(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MapdDraw"] = factory();
	else
		root["MapdDraw"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* eslint-disable object-curly-spacing*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleHull_2D = exports.Math = exports.Point = exports.PolyLine = exports.Poly = exports.Rect = exports.Circle = exports.Vec2d = exports.BasicStyle = exports.Mat2 = exports.Point2d = exports.Mat2d = exports.AABox2d = exports.DrawEngine = exports.ShapeBuilder = exports.version = undefined;\n\nvar _package = __webpack_require__(39);\n\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function get() {\n    return _package.version;\n  }\n});\n\nvar _glMatrix = __webpack_require__(1);\n\nObject.defineProperty(exports, \"Mat2\", {\n  enumerable: true,\n  get: function get() {\n    return _glMatrix.mat2;\n  }\n});\n\nvar _convexHull = __webpack_require__(15);\n\nObject.defineProperty(exports, \"simpleHull_2D\", {\n  enumerable: true,\n  get: function get() {\n    return _convexHull.simpleHull_2D;\n  }\n});\n\nvar _shapeBuilder = __webpack_require__(23);\n\nvar _shapeBuilder2 = _interopRequireDefault(_shapeBuilder);\n\nvar _drawEngine = __webpack_require__(14);\n\nvar _drawEngine2 = _interopRequireDefault(_drawEngine);\n\nvar _aabox2d = __webpack_require__(2);\n\nvar _AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _mat2d = __webpack_require__(5);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _point2d = __webpack_require__(4);\n\nvar _Point2d = _interopRequireWildcard(_point2d);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _vec2d = __webpack_require__(10);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nvar _circle = __webpack_require__(27);\n\nvar _circle2 = _interopRequireDefault(_circle);\n\nvar _rect = __webpack_require__(16);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _poly = __webpack_require__(29);\n\nvar _poly2 = _interopRequireDefault(_poly);\n\nvar _polyLine = __webpack_require__(11);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nvar _point = __webpack_require__(28);\n\nvar _point2 = _interopRequireDefault(_point);\n\nvar _math = __webpack_require__(6);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.ShapeBuilder = _shapeBuilder2.default;\nexports.DrawEngine = _drawEngine2.default;\nexports.AABox2d = _AABox2d;\nexports.Mat2d = _mat2d2.default;\nexports.Point2d = _Point2d;\nexports.BasicStyle = _basicStyle2.default;\nexports.Vec2d = _vec2d2.default;\nexports.Circle = _circle2.default;\nexports.Rect = _rect2.default;\nexports.Poly = _poly2.default;\nexports.PolyLine = _polyLine2.default;\nexports.Point = _point2.default;\nexports.Math = _math2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXBkLWRyYXcuanM/NGY3OSJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwibWF0MiIsInNpbXBsZUh1bGxfMkQiLCJTaGFwZUJ1aWxkZXIiLCJEcmF3RW5naW5lIiwiQUFCb3gyZCIsIk1hdDJkIiwiUG9pbnQyZCIsIkJhc2ljU3R5bGUiLCJWZWMyZCIsIkNpcmNsZSIsIlJlY3QiLCJQb2x5IiwiUG9seUxpbmUiLCJQb2ludCIsIk1hdGgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFFUUEsTzs7Ozs7Ozs7O3FCQU9BQyxJOzs7Ozs7Ozs7dUJBU0FDLGE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWREQyxZO1FBQ0FDLFU7UUFDS0MsTztRQUNMQyxLO1FBQ0tDLE87UUFFTEMsVTtRQUNBQyxLO1FBQ0FDLE07UUFDQUMsSTtRQUNBQyxJO1FBQ0FDLFE7UUFDQUMsSztRQUNBQyxJIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBvYmplY3QtY3VybHktc3BhY2luZyovXG5cInVzZSBzdHJpY3RcIlxuXG5leHBvcnQge3ZlcnNpb259IGZyb20gXCIuLi9wYWNrYWdlLmpzb25cIlxuXG5leHBvcnQgU2hhcGVCdWlsZGVyIGZyb20gXCIuL2VuZ2luZS9zaGFwZS1idWlsZGVyXCJcbmV4cG9ydCBEcmF3RW5naW5lIGZyb20gXCIuL2VuZ2luZS9kcmF3LWVuZ2luZVwiXG5leHBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuL2NvcmUvYWFib3gyZFwiXG5leHBvcnQgTWF0MmQgZnJvbSBcIi4vY29yZS9tYXQyZFwiXG5leHBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuL2NvcmUvcG9pbnQyZFwiXG5leHBvcnQge21hdDIgYXMgTWF0Mn0gZnJvbSBcImdsLW1hdHJpeFwiXG5leHBvcnQgQmFzaWNTdHlsZSBmcm9tIFwiLi9zdHlsZS9iYXNpYy1zdHlsZVwiXG5leHBvcnQgVmVjMmQgZnJvbSBcIi4vY29yZS92ZWMyZFwiXG5leHBvcnQgQ2lyY2xlIGZyb20gXCIuL3NoYXBlcy9jaXJjbGVcIlxuZXhwb3J0IFJlY3QgZnJvbSBcIi4vc2hhcGVzL3JlY3RcIlxuZXhwb3J0IFBvbHkgZnJvbSBcIi4vc2hhcGVzL3BvbHlcIlxuZXhwb3J0IFBvbHlMaW5lIGZyb20gXCIuL3NoYXBlcy9wb2x5LWxpbmVcIlxuZXhwb3J0IFBvaW50IGZyb20gXCIuL3NoYXBlcy9wb2ludFwiXG5leHBvcnQgTWF0aCBmcm9tIFwiLi9tYXRoL21hdGhcIlxuZXhwb3J0IHtzaW1wbGVIdWxsXzJEfSBmcm9tIFwiLi9tYXRoL2NvbnZleC1odWxsXCJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21hcGQtZHJhdy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * @fileoverview gl-matrix - High performance matrix and vector operations\n * @author Brandon Jones\n * @author Colin MacKenzie IV\n * @version 2.3.2\n */\n\n/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n// END HEADER\n\nexports.glMatrix = __webpack_require__(3);\nexports.mat2 = __webpack_require__(34);\nexports.mat2d = __webpack_require__(35);\nexports.mat3 = __webpack_require__(20);\nexports.mat4 = __webpack_require__(36);\nexports.quat = __webpack_require__(37);\nexports.vec2 = __webpack_require__(38);\nexports.vec3 = __webpack_require__(21);\nexports.vec4 = __webpack_require__(22);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcz9jNzBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4zLjJcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuLy8gRU5EIEhFQURFUlxuXG5leHBvcnRzLmdsTWF0cml4ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L2NvbW1vbi5qc1wiKTtcbmV4cG9ydHMubWF0MiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyLmpzXCIpO1xuZXhwb3J0cy5tYXQyZCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyZC5qc1wiKTtcbmV4cG9ydHMubWF0MyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQzLmpzXCIpO1xuZXhwb3J0cy5tYXQ0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDQuanNcIik7XG5leHBvcnRzLnF1YXQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvcXVhdC5qc1wiKTtcbmV4cG9ydHMudmVjMiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMyLmpzXCIpO1xuZXhwb3J0cy52ZWMzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzMuanNcIik7XG5leHBvcnRzLnZlYzQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjNC5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MAXY = exports.MAXX = exports.MINY = exports.MINX = undefined;\nexports.set = set;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.initEmpty = initEmpty;\nexports.initInfinity = initInfinity;\nexports.initSizeFromOrigin = initSizeFromOrigin;\nexports.initSizeFromLocation = initSizeFromLocation;\nexports.initCenterExtents = initCenterExtents;\nexports.isEmpty = isEmpty;\nexports.isInfinite = isInfinite;\nexports.equals = equals;\nexports.getSize = getSize;\nexports.getExtents = getExtents;\nexports.getCenter = getCenter;\nexports.expand = expand;\nexports.area = area;\nexports.hull = hull;\nexports.intersection = intersection;\nexports.overlaps = overlaps;\nexports.contains = contains;\nexports.containsPt = containsPt;\nexports.encapsulatePt = encapsulatePt;\nexports.translate = translate;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\n\nvar _glMatrix = __webpack_require__(1);\n\nvar MINX = exports.MINX = 0;\nvar MINY = exports.MINY = 1;\nvar MAXX = exports.MAXX = 2;\nvar MAXY = exports.MAXY = 3;\n\nvar Constants = {\n  BOX_SIDES: 4\n};\n\n/**\n * Sets the boundaries of an existing 2d axis-aligned bounding box\n * If arguments are not supplied, the aabox is initialized as empty.\n * @param {AABox2d} out  AAbox2d to set\n * @param {Number} [minx = Infinity] Minimum x-axis value\n * @param {Number} [miny = Infinity] Minimum y-axis value\n * @param {Number} [maxx = -Infinity] Maximum x-axis value\n * @param {Number} [maxy = -Infinity] Maximum y-axis value\n * @return {AABox2d}    bounds referenced by out arg\n */\nfunction set(out, minx, miny, maxx, maxy) {\n  out[MINX] = typeof minx === \"number\" ? minx : Infinity;\n  out[MINY] = typeof miny === \"number\" ? miny : Infinity;\n  out[MAXX] = typeof maxx === \"number\" ? maxx : -Infinity;\n  out[MAXY] = typeof maxy === \"number\" ? maxy : -Infinity;\n  return out;\n}\n\n/**\n * Creates a new 2d axis-aligned bounding box object\n * with optional boundaries. If boundaries are not supplied,\n * the aabox is initialized as empty.\n * @param  {Number} [minx = Infinity] Minimum x-axis value\n * @param  {Number} [miny = Infinity] Minimum y-axis value\n * @param  {Number} [maxx = -Infinity] Maximum x-axis value\n * @param  {Number} [maxy = -Infinity] Maximum y-axis value\n * @return {AABox2d}      New AABox2d object\n */\nfunction create(minx, miny, maxx, maxy) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(Constants.BOX_SIDES);\n  return set(out, minx, miny, maxx, maxy);\n}\n\n/**\n * Creates a new 2d axis-aligned bounding box with boundaries copied\n * from an existing aabox.\n * @param  {AABox2d} box existing bounds to copy boundaries from\n * @return {AABox2d}     new AABox2d object\n */\nfunction clone(box) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(Constants.BOX_SIDES);\n  out[MINX] = box[MINX];\n  out[MINY] = box[MINY];\n  out[MAXX] = box[MAXX];\n  out[MAXY] = box[MAXY];\n  return out;\n}\n\n/**\n * Copies the boundaries from one existing aabox to another.\n * @param  {AABox2d} out bounds to copy to\n * @param  {AABox2d} box bounds to copy from\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction copy(out, box) {\n  out[MINX] = box[MINX];\n  out[MINY] = box[MINY];\n  out[MAXX] = box[MAXX];\n  out[MAXY] = box[MAXY];\n  return out;\n}\n\n/**\n * Re-initializes an existing aabox as empty.\n * An aabox is empty if the minimum value in either of\n * its dimensions exceeds its respective max value.\n * In this case, the minumums will be set to +Infinity\n * and the maximums to -Infinity\n * @param  {AABox2d} out existing bounds to re-initialize as empty\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction initEmpty(out) {\n  out[MINX] = Infinity;\n  out[MINY] = Infinity;\n  out[MAXX] = -Infinity;\n  out[MAXY] = -Infinity;\n  return out;\n}\n\n/**\n * Re-initializes an existing aabox to infinity, ultimately encompassing\n * all numeric values.\n * @param  {AABox2d} out existing bounds to initialize to infinity\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction initInfinity(out) {\n  out[MINX] = -Infinity;\n  out[MINY] = -Infinity;\n  out[MAXX] = Infinity;\n  out[MAXY] = Infinity;\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its top-left corner set to be the origin ([0, 0]),\n * an extends outwards in each dimension by its respective size.\n *   minx: 0\n *   miny: 0\n *   maxx: sizes[x]\n *   maxy: sizes[y]\n * @param  {AABox2d} out   existing bounds to re-initialize\n * @param  {Vec2d} sizes   new width/height of the bounds\n * @return {AABox2d}       bounds referenced by out arg\n */\nfunction initSizeFromOrigin(out, sizes) {\n  if (sizes[0] < 0) {\n    out[MINX] = -sizes[0];\n    out[MAXX] = 0;\n  } else {\n    out[MINX] = 0;\n    out[MAXX] = sizes[0];\n  }\n  if (sizes[1] < 0) {\n    out[MINY] = -sizes[1];\n    out[MAXY] = 0;\n  } else {\n    out[MINY] = 0;\n    out[MAXY] = sizes[1];\n  }\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its top-left corner set to be an existing pt and with\n * bounds extending outwards in each dimension by its respective size.\n *   minx: pt[x]\n *   miny: pt[y]\n *   maxx: pt[x] + sizes[x]\n *   maxy: pt[y] + sizes[y]\n * @param  {AABox2d} out   existing bounds to re-initialize\n * @param  {Point2d} pt    new position of the top-left corner of the bounds\n * @param  {Vec2d} sizes   new width/height of the bounds\n * @return {AABox2d}       bounds referenced by out arg\n */\nfunction initSizeFromLocation(out, pt, sizes) {\n  for (var i = 0; i < 2; i += 1) {\n    if (sizes[i] < 0) {\n      out[i] = pt[i] - sizes[i];\n      out[i + 2] = pt[i];\n    } else {\n      out[i] = pt[i];\n      out[i + 2] = pt[i] + sizes[i];\n    }\n  }\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its center set to a specific pt and with bounds\n * extending outward in each dimension so that the aabox's width and height are a\n * specific size\n * @param  {AABox2d} out    existing bounds to re-initialize\n * @param  {Point2d} center new center of the bounds\n * @param  {Vec2d} sizes  new width/height of the bounds\n * @return {AABox2d}        bounds referenced by out arg\n */\nfunction initCenterExtents(out, center, sizes) {\n  for (var i = 0; i < 2; i += 1) {\n    if (sizes[i] < 0) {\n      out[i] = center[i] + sizes[i];\n      out[i + 2] = center[i] - sizes[i];\n    } else {\n      out[i] = center[i] - sizes[i];\n      out[i + 2] = center[i] + sizes[i];\n    }\n  }\n  return out;\n}\n\n/**\n * Returns true if the aabox is empty\n * @param  {AABox2d}  box\n * @return {Boolean}     true if box is empty, false otherwise\n */\nfunction isEmpty(box) {\n  return box[MINX] > box[MAXX] || box[MINY] > box[MAXY];\n}\n\n/**\n * Returns true if an aabox is infinite in either dimension\n * @param  {AABox2d}  box Existing aabox to check\n * @return {Boolean}     True if box extends to +/- inifinity in either dimension, false otherwise\n */\nfunction isInfinite(box) {\n  return !isFinite(box[MINX]) || !isFinite(box[MINY]) || !isFinite(box[MAXX]) || !isFinite(box[MAXY]);\n}\n\n/**\n * Returns true if one aabox approximately equals another\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   true if a ~= b\n */\nfunction equals(a, b) {\n  var a0 = a[0];\n  var a1 = a[1];\n  var a2 = a[2];\n  var a3 = a[3];\n  var b0 = b[0];\n  var b1 = b[1];\n  var b2 = b[2];\n  var b3 = b[3];\n  return Math.abs(a0 - b0) <= _glMatrix.glMatrix.EPSILON && Math.abs(a1 - b1) <= _glMatrix.glMatrix.EPSILON && Math.abs(a2 - b2) <= _glMatrix.glMatrix.EPSILON && Math.abs(a3 - b3) <= _glMatrix.glMatrix.EPSILON;\n}\n\n/**\n * Returns the width/height of an existing aabox\n * @param  {Vec2d} out 2d vector to store the width/height of an existing aabox\n * @param  {AABox2d} box bounds to extract the width/height from\n * @return {Vec2d}     vector referenced by the out arg\n */\nfunction getSize(out, box) {\n  return _glMatrix.vec2.set(out, box[MAXX] - box[MINX], box[MAXY] - box[MINY]);\n}\n\n/**\n * Returns the extents of an existing aabox.\n * Extents is the size of a bounds in each dimension starting at the center\n * of the bounds. (i.e. extents = [width / 2, height / 2])\n * @param  {Vec2d} out 2d vector to store the extents of an existing aabox\n * @param  {AABox2d} box bounds to extract the extents from\n * @return {Vec2d}     vector referenced by the out arg\n */\nfunction getExtents(out, box) {\n  getSize(out, box);\n  return _glMatrix.vec2.scale(out, out, 0.5); // eslint-disable-line no-magic-numbers\n}\n\n/**\n * Returns the center of an existing aabox\n * @param  {Point2d} out point to store the center of an existing bounds\n * @param  {AABox2d} box bounds to extract the center from\n * @return {Point2d}     point referenced by the out arg\n */\nfunction getCenter(out, box) {\n  getExtents(out, box);\n  out[MINX] += box[MINX];\n  out[MINY] += box[MINY];\n  return out;\n}\n\n/**\n * Expands an existing aabox by a specified size in each dimension.\n * @param  {AABox2d} out        bounds to store the resulting operation in\n * @param  {AABox2d} box        starting bounds to expand\n * @param  {Vec2d} expandSize   size to expand in each dimension\n * @return {AABox2d}            bounds referenced by the out arg\n */\nfunction expand(out, box, expandSize) {\n  out[MINX] = box[MINX] - expandSize[0];\n  out[MAXX] = box[MAXX] + expandSize[0];\n  out[MINY] = box[MINY] - expandSize[1];\n  out[MAXY] = box[MAXY] + expandSize[1];\n}\n\n/**\n * Computes the area of an existing aabox\n * @param  {AABox2d} box\n * @return {Number}     area of the bounds\n */\nfunction area(box) {\n  return (box[MAXX] - box[MINX]) * (box[MAXY] - box[MINY]);\n}\n\n/**\n * Calculates the hull of two aaboxes. The hull is the smallest bounds that contains\n * both of the aaboxes\n * @param  {AABox2d} out bounds to store the resulting operation in\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction hull(out, a, b) {\n  return create(Math.min(a[MINX], b[MINX]), Math.min(a[MINY], b[MINY]), Math.max(a[MAXX], b[MAXX]), Math.max(a[MAXY], b[MAXY]));\n}\n\n/**\n * Calculates the intersection of two existing bounds.\n * @param  {AABox2d} out bounds to store the resulting operation in\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction intersection(out, a, b) {\n  var boxToUse = out;\n  if (out === a) {\n    boxToUse = create();\n  }\n\n  var minindex = MINX;\n  var maxindex = MAXX;\n  for (; minindex <= MINY; minindex += 1, maxindex += 1) {\n    if (a[maxindex] < b[minindex] || a[minindex] > b[maxindex]) {\n      break;\n    }\n\n    boxToUse[minindex] = Math.max(a[minindex], b[minindex]);\n    boxToUse[maxindex] = Math.min(a[maxindex], b[maxindex]);\n  }\n\n  if (minindex !== MINY + 1) {\n    initEmpty(boxToUse);\n  }\n\n  if (out === a) {\n    copy(out, boxToUse);\n  }\n\n  return out;\n}\n\n/**\n * Returns true if one bounds overlaps another in any way (non-inclusive).\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   Returns true if a overlaps b, false otherwise\n */\nfunction overlaps(a, b) {\n  return !(a[MAXX] <= b[MINX] || a[MINX] >= b[MAXX] || a[MAXY] <= b[MINY] || a[MINY] >= b[MAXY]);\n}\n\n/**\n * Returns true if one bounds full contains another (inclusive).\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   true if a fully contains b.\n */\nfunction contains(a, b) {\n  return !(b[MINX] < a[MINX] || b[MAXX] > a[MAXX] || b[MINY] < a[MINY] || b[MAXY] > a[MAXY]);\n}\n\n/**\n * Returns true if an existing bounds contains a specific point (inclusive)\n * @param  {AABox2d} box\n * @param  {Point2d} pt\n * @return {Boolean}     Returns true if pt is inside of box, false otherwise\n */\nfunction containsPt(box, pt) {\n  return pt[MINX] >= box[MINX] && pt[MINX] <= box[MAXX] && pt[MINY] >= box[MINY] && pt[MINY] <= box[MAXY];\n}\n\n/**\n * Extends an existing bounds so that it would contain a specific point\n * @param  {AABox2d} out Bounds containing the operation result\n * @param  {AABox2d} box Starting bounds to possibly extend\n * @param  {Point2d} pt  Point to encapsulate in box\n * @return {AAbox2d}     bounds referenced by out arg\n */\nfunction encapsulatePt(out, box, pt) {\n  if (out !== box) {\n    copy(out, box);\n  }\n  if (isEmpty(box)) {\n    out[MINX] = pt[MINX];\n    out[MAXX] = pt[MINX];\n    out[MINY] = pt[MINY];\n    out[MAXY] = pt[MINY];\n  } else {\n    if (pt[MINX] < out[MINX]) {\n      out[MINX] = pt[MINX];\n    } else if (pt[MINX] > out[MAXX]) {\n      out[MAXX] = pt[MINX];\n    }\n\n    if (pt[MINY] < out[MINY]) {\n      out[MINY] = pt[MINY];\n    } else if (pt[MINY] > out[MAXY]) {\n      out[MAXY] = pt[MINY];\n    }\n  }\n  return out;\n}\n\n/**\n * Translates an existing bounds by a specified offset it each dimension\n * @param  {AABox2d} out bounds resulting from the operation\n * @param  {AABox2d} box starting bounds\n * @param  {Vec2d} pos   translation in each dimension\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction translate(out, box, pos) {\n  out[MINX] = box[MINX] + pos[0];\n  out[MINY] = box[MINY] + pos[1];\n  out[MAXX] = box[MAXX] + pos[0];\n  out[MAXY] = box[MAXY] + pos[1];\n}\n\nfunction transform(out, box, mat, xformFunc) {\n  var boxToUse = out;\n  if (out === box) {\n    boxToUse = create();\n  }\n  initEmpty(boxToUse);\n\n  var pt1 = _glMatrix.vec2.set(_glMatrix.vec2.create(), box[MINX], box[MINY]);\n  var pt2 = _glMatrix.vec2.create();\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINX] = box[MAXX];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINY] = box[MAXY];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINX] = box[MINX];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  if (out === box) {\n    copy(out, boxToUse);\n  }\n  return out;\n}\n\n/**\n * Transforms an existing bounds by a 2x2 matrix\n * @param  {AABox2d} out bounds to contain the operation result\n * @param  {AABox2d} box bounds to transform\n * @param  {Mat2} mat 2x2 matrix transformation\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction transformMat2(out, box, mat) {\n  return transform(out, box, mat, _glMatrix.vec2.transformMat2);\n}\n\n/**\n * Transforms an existing bounds by a 2x3 matrix.\n * A 2x3 matrix is a 2x2 matrix with a translation component.\n * @param  {AABox2d} out bounds to hold the operation result\n * @param  {AABox2d} box bounds to transform\n * @param  {Mat2d} mat   2x3 matrix\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction transformMat2d(out, box, mat) {\n  return transform(out, box, mat, _glMatrix.vec2.transformMat2d);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL2FhYm94MmQuanM/MDZlMCJdLCJuYW1lcyI6WyJzZXQiLCJjcmVhdGUiLCJjbG9uZSIsImNvcHkiLCJpbml0RW1wdHkiLCJpbml0SW5maW5pdHkiLCJpbml0U2l6ZUZyb21PcmlnaW4iLCJpbml0U2l6ZUZyb21Mb2NhdGlvbiIsImluaXRDZW50ZXJFeHRlbnRzIiwiaXNFbXB0eSIsImlzSW5maW5pdGUiLCJlcXVhbHMiLCJnZXRTaXplIiwiZ2V0RXh0ZW50cyIsImdldENlbnRlciIsImV4cGFuZCIsImFyZWEiLCJodWxsIiwiaW50ZXJzZWN0aW9uIiwib3ZlcmxhcHMiLCJjb250YWlucyIsImNvbnRhaW5zUHQiLCJlbmNhcHN1bGF0ZVB0IiwidHJhbnNsYXRlIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwiTUlOWCIsIk1JTlkiLCJNQVhYIiwiTUFYWSIsIkNvbnN0YW50cyIsIkJPWF9TSURFUyIsIm91dCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJJbmZpbml0eSIsIkFSUkFZX1RZUEUiLCJib3giLCJzaXplcyIsInB0IiwiaSIsImNlbnRlciIsImlzRmluaXRlIiwiYSIsImIiLCJhMCIsImExIiwiYTIiLCJhMyIsImIwIiwiYjEiLCJiMiIsImIzIiwiTWF0aCIsImFicyIsIkVQU0lMT04iLCJzY2FsZSIsImV4cGFuZFNpemUiLCJtaW4iLCJtYXgiLCJib3hUb1VzZSIsIm1pbmluZGV4IiwibWF4aW5kZXgiLCJwb3MiLCJ0cmFuc2Zvcm0iLCJtYXQiLCJ4Zm9ybUZ1bmMiLCJwdDEiLCJwdDIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7UUF1QmdCQSxHLEdBQUFBLEc7UUFrQkFDLE0sR0FBQUEsTTtRQVdBQyxLLEdBQUFBLEs7UUFlQUMsSSxHQUFBQSxJO1FBaUJBQyxTLEdBQUFBLFM7UUFjQUMsWSxHQUFBQSxZO1FBbUJBQyxrQixHQUFBQSxrQjtRQThCQUMsb0IsR0FBQUEsb0I7UUFzQkFDLGlC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QUFaLEVBQWlCO0FBQ2ZwQyxTQUFLNkIsR0FBTCxFQUFVOEIsUUFBVjtBQUNEO0FBQ0QsU0FBTzlCLEdBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9PLFNBQVNSLGFBQVQsQ0FBdUJRLEdBQXZCLEVBQTRCTyxHQUE1QixFQUFpQzRCLEdBQWpDLEVBQXNDO0FBQzNDLFNBQU9ELFVBQVVsQyxHQUFWLEVBQWVPLEdBQWYsRUFBb0I0QixHQUFwQixFQUF5QixlQUFNM0MsYUFBL0IsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNDLGNBQVQsQ0FBd0JPLEdBQXhCLEVBQTZCTyxHQUE3QixFQUFrQzRCLEdBQWxDLEVBQXVDO0FBQzVDLFNBQU9ELFVBQVVsQyxHQUFWLEVBQWVPLEdBQWYsRUFBb0I0QixHQUFwQixFQUF5QixlQUFNMUMsY0FBL0IsQ0FBUDtBQUNEIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQge2dsTWF0cml4LCB2ZWMyIGFzIFZlYzJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuZXhwb3J0IGNvbnN0IE1JTlggPSAwXG5leHBvcnQgY29uc3QgTUlOWSA9IDFcbmV4cG9ydCBjb25zdCBNQVhYID0gMlxuZXhwb3J0IGNvbnN0IE1BWFkgPSAzXG5cbmNvbnN0IENvbnN0YW50cyA9IHtcbiAgQk9YX1NJREVTOiA0XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYm91bmRhcmllcyBvZiBhbiBleGlzdGluZyAyZCBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94XG4gKiBJZiBhcmd1bWVudHMgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFhYm94IGlzIGluaXRpYWxpemVkIGFzIGVtcHR5LlxuICogQHBhcmFtIHtBQUJveDJkfSBvdXQgIEFBYm94MmQgdG8gc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gW21pbnggPSBJbmZpbml0eV0gTWluaW11bSB4LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWlueSA9IEluZmluaXR5XSBNaW5pbXVtIHktYXhpcyB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXh4ID0gLUluZmluaXR5XSBNYXhpbXVtIHgtYXhpcyB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXh5ID0gLUluZmluaXR5XSBNYXhpbXVtIHktYXhpcyB2YWx1ZVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbWlueCwgbWlueSwgbWF4eCwgbWF4eSkge1xuICBvdXRbTUlOWF0gPSB0eXBlb2YgbWlueCA9PT0gXCJudW1iZXJcIiA/IG1pbnggOiBJbmZpbml0eVxuICBvdXRbTUlOWV0gPSB0eXBlb2YgbWlueSA9PT0gXCJudW1iZXJcIiA/IG1pbnkgOiBJbmZpbml0eVxuICBvdXRbTUFYWF0gPSB0eXBlb2YgbWF4eCA9PT0gXCJudW1iZXJcIiA/IG1heHggOiAtSW5maW5pdHlcbiAgb3V0W01BWFldID0gdHlwZW9mIG1heHkgPT09IFwibnVtYmVyXCIgPyBtYXh5IDogLUluZmluaXR5XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IDJkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2JqZWN0XG4gKiB3aXRoIG9wdGlvbmFsIGJvdW5kYXJpZXMuIElmIGJvdW5kYXJpZXMgYXJlIG5vdCBzdXBwbGllZCxcbiAqIHRoZSBhYWJveCBpcyBpbml0aWFsaXplZCBhcyBlbXB0eS5cbiAqIEBwYXJhbSAge051bWJlcn0gW21pbnggPSBJbmZpbml0eV0gTWluaW11bSB4LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gW21pbnkgPSBJbmZpbml0eV0gTWluaW11bSB5LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gW21heHggPSAtSW5maW5pdHldIE1heGltdW0geC1heGlzIHZhbHVlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXh5ID0gLUluZmluaXR5XSBNYXhpbXVtIHktYXhpcyB2YWx1ZVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgICBOZXcgQUFCb3gyZCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShtaW54LCBtaW55LCBtYXh4LCBtYXh5KSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKENvbnN0YW50cy5CT1hfU0lERVMpXG4gIHJldHVybiBzZXQob3V0LCBtaW54LCBtaW55LCBtYXh4LCBtYXh5KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgMmQgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCB3aXRoIGJvdW5kYXJpZXMgY29waWVkXG4gKiBmcm9tIGFuIGV4aXN0aW5nIGFhYm94LlxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGV4aXN0aW5nIGJvdW5kcyB0byBjb3B5IGJvdW5kYXJpZXMgZnJvbVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIG5ldyBBQUJveDJkIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYm94KSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKENvbnN0YW50cy5CT1hfU0lERVMpXG4gIG91dFtNSU5YXSA9IGJveFtNSU5YXVxuICBvdXRbTUlOWV0gPSBib3hbTUlOWV1cbiAgb3V0W01BWFhdID0gYm94W01BWFhdXG4gIG91dFtNQVhZXSA9IGJveFtNQVhZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBib3VuZGFyaWVzIGZyb20gb25lIGV4aXN0aW5nIGFhYm94IHRvIGFub3RoZXIuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHRvIGNvcHkgdG9cbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBib3VuZHMgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGJveCkge1xuICBvdXRbTUlOWF0gPSBib3hbTUlOWF1cbiAgb3V0W01JTlldID0gYm94W01JTlldXG4gIG91dFtNQVhYXSA9IGJveFtNQVhYXVxuICBvdXRbTUFYWV0gPSBib3hbTUFYWV1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJlLWluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IGFzIGVtcHR5LlxuICogQW4gYWFib3ggaXMgZW1wdHkgaWYgdGhlIG1pbmltdW0gdmFsdWUgaW4gZWl0aGVyIG9mXG4gKiBpdHMgZGltZW5zaW9ucyBleGNlZWRzIGl0cyByZXNwZWN0aXZlIG1heCB2YWx1ZS5cbiAqIEluIHRoaXMgY2FzZSwgdGhlIG1pbnVtdW1zIHdpbGwgYmUgc2V0IHRvICtJbmZpbml0eVxuICogYW5kIHRoZSBtYXhpbXVtcyB0byAtSW5maW5pdHlcbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZSBhcyBlbXB0eVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRFbXB0eShvdXQpIHtcbiAgb3V0W01JTlhdID0gSW5maW5pdHlcbiAgb3V0W01JTlldID0gSW5maW5pdHlcbiAgb3V0W01BWFhdID0gLUluZmluaXR5XG4gIG91dFtNQVhZXSA9IC1JbmZpbml0eVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUmUtaW5pdGlhbGl6ZXMgYW4gZXhpc3RpbmcgYWFib3ggdG8gaW5maW5pdHksIHVsdGltYXRlbHkgZW5jb21wYXNzaW5nXG4gKiBhbGwgbnVtZXJpYyB2YWx1ZXMuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgZXhpc3RpbmcgYm91bmRzIHRvIGluaXRpYWxpemUgdG8gaW5maW5pdHlcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0SW5maW5pdHkob3V0KSB7XG4gIG91dFtNSU5YXSA9IC1JbmZpbml0eVxuICBvdXRbTUlOWV0gPSAtSW5maW5pdHlcbiAgb3V0W01BWFhdID0gSW5maW5pdHlcbiAgb3V0W01BWFldID0gSW5maW5pdHlcbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHdpdGggaXRzIHRvcC1sZWZ0IGNvcm5lciBzZXQgdG8gYmUgdGhlIG9yaWdpbiAoWzAsIDBdKSxcbiAqIGFuIGV4dGVuZHMgb3V0d2FyZHMgaW4gZWFjaCBkaW1lbnNpb24gYnkgaXRzIHJlc3BlY3RpdmUgc2l6ZS5cbiAqICAgbWlueDogMFxuICogICBtaW55OiAwXG4gKiAgIG1heHg6IHNpemVzW3hdXG4gKiAgIG1heHk6IHNpemVzW3ldXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgICBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZVxuICogQHBhcmFtICB7VmVjMmR9IHNpemVzICAgbmV3IHdpZHRoL2hlaWdodCBvZiB0aGUgYm91bmRzXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2l6ZUZyb21PcmlnaW4ob3V0LCBzaXplcykge1xuICBpZiAoc2l6ZXNbMF0gPCAwKSB7XG4gICAgb3V0W01JTlhdID0gLXNpemVzWzBdXG4gICAgb3V0W01BWFhdID0gMFxuICB9IGVsc2Uge1xuICAgIG91dFtNSU5YXSA9IDBcbiAgICBvdXRbTUFYWF0gPSBzaXplc1swXVxuICB9XG4gIGlmIChzaXplc1sxXSA8IDApIHtcbiAgICBvdXRbTUlOWV0gPSAtc2l6ZXNbMV1cbiAgICBvdXRbTUFYWV0gPSAwXG4gIH0gZWxzZSB7XG4gICAgb3V0W01JTlldID0gMFxuICAgIG91dFtNQVhZXSA9IHNpemVzWzFdXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHdpdGggaXRzIHRvcC1sZWZ0IGNvcm5lciBzZXQgdG8gYmUgYW4gZXhpc3RpbmcgcHQgYW5kIHdpdGhcbiAqIGJvdW5kcyBleHRlbmRpbmcgb3V0d2FyZHMgaW4gZWFjaCBkaW1lbnNpb24gYnkgaXRzIHJlc3BlY3RpdmUgc2l6ZS5cbiAqICAgbWlueDogcHRbeF1cbiAqICAgbWlueTogcHRbeV1cbiAqICAgbWF4eDogcHRbeF0gKyBzaXplc1t4XVxuICogICBtYXh5OiBwdFt5XSArIHNpemVzW3ldXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgICBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZVxuICogQHBhcmFtICB7UG9pbnQyZH0gcHQgICAgbmV3IHBvc2l0aW9uIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGJvdW5kc1xuICogQHBhcmFtICB7VmVjMmR9IHNpemVzICAgbmV3IHdpZHRoL2hlaWdodCBvZiB0aGUgYm91bmRzXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2l6ZUZyb21Mb2NhdGlvbihvdXQsIHB0LCBzaXplcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkgKz0gMSkge1xuICAgIGlmIChzaXplc1tpXSA8IDApIHtcbiAgICAgIG91dFtpXSA9IHB0W2ldIC0gc2l6ZXNbaV1cbiAgICAgIG91dFtpICsgMl0gPSBwdFtpXVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbaV0gPSBwdFtpXVxuICAgICAgb3V0W2kgKyAyXSA9IHB0W2ldICsgc2l6ZXNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHdpdGggaXRzIGNlbnRlciBzZXQgdG8gYSBzcGVjaWZpYyBwdCBhbmQgd2l0aCBib3VuZHNcbiAqIGV4dGVuZGluZyBvdXR3YXJkIGluIGVhY2ggZGltZW5zaW9uIHNvIHRoYXQgdGhlIGFhYm94J3Mgd2lkdGggYW5kIGhlaWdodCBhcmUgYVxuICogc3BlY2lmaWMgc2l6ZVxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0ICAgIGV4aXN0aW5nIGJvdW5kcyB0byByZS1pbml0aWFsaXplXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBjZW50ZXIgbmV3IGNlbnRlciBvZiB0aGUgYm91bmRzXG4gKiBAcGFyYW0gIHtWZWMyZH0gc2l6ZXMgIG5ldyB3aWR0aC9oZWlnaHQgb2YgdGhlIGJvdW5kc1xuICogQHJldHVybiB7QUFCb3gyZH0gICAgICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRDZW50ZXJFeHRlbnRzKG91dCwgY2VudGVyLCBzaXplcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkgKz0gMSkge1xuICAgIGlmIChzaXplc1tpXSA8IDApIHtcbiAgICAgIG91dFtpXSA9IGNlbnRlcltpXSArIHNpemVzW2ldXG4gICAgICBvdXRbaSArIDJdID0gY2VudGVyW2ldIC0gc2l6ZXNbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0W2ldID0gY2VudGVyW2ldIC0gc2l6ZXNbaV1cbiAgICAgIG91dFtpICsgMl0gPSBjZW50ZXJbaV0gKyBzaXplc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhYWJveCBpcyBlbXB0eVxuICogQHBhcmFtICB7QUFCb3gyZH0gIGJveFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIHRydWUgaWYgYm94IGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoYm94KSB7XG4gIHJldHVybiAoYm94W01JTlhdID4gYm94W01BWFhdIHx8IGJveFtNSU5ZXSA+IGJveFtNQVhZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gYWFib3ggaXMgaW5maW5pdGUgaW4gZWl0aGVyIGRpbWVuc2lvblxuICogQHBhcmFtICB7QUFCb3gyZH0gIGJveCBFeGlzdGluZyBhYWJveCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgYm94IGV4dGVuZHMgdG8gKy8tIGluaWZpbml0eSBpbiBlaXRoZXIgZGltZW5zaW9uLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5maW5pdGUoYm94KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoYm94W01JTlhdKSB8fCAhaXNGaW5pdGUoYm94W01JTlldKSB8fCAhaXNGaW5pdGUoYm94W01BWFhdKSB8fCAhaXNGaW5pdGUoYm94W01BWFldKVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvbmUgYWFib3ggYXBwcm94aW1hdGVseSBlcXVhbHMgYW5vdGhlclxuICogQHBhcmFtICB7QUFCb3gyZH0gYVxuICogQHBhcmFtICB7QUFCb3gyZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIGlmIGEgfj0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgY29uc3QgYTAgPSBhWzBdXG4gIGNvbnN0IGExID0gYVsxXVxuICBjb25zdCBhMiA9IGFbMl1cbiAgY29uc3QgYTMgPSBhWzNdXG4gIGNvbnN0IGIwID0gYlswXVxuICBjb25zdCBiMSA9IGJbMV1cbiAgY29uc3QgYjIgPSBiWzJdXG4gIGNvbnN0IGIzID0gYlszXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04pXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgd2lkdGgvaGVpZ2h0IG9mIGFuIGV4aXN0aW5nIGFhYm94XG4gKiBAcGFyYW0gIHtWZWMyZH0gb3V0IDJkIHZlY3RvciB0byBzdG9yZSB0aGUgd2lkdGgvaGVpZ2h0IG9mIGFuIGV4aXN0aW5nIGFhYm94XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggYm91bmRzIHRvIGV4dHJhY3QgdGhlIHdpZHRoL2hlaWdodCBmcm9tXG4gKiBAcmV0dXJuIHtWZWMyZH0gICAgIHZlY3RvciByZWZlcmVuY2VkIGJ5IHRoZSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKG91dCwgYm94KSB7XG4gIHJldHVybiBWZWMyZC5zZXQob3V0LCBib3hbTUFYWF0gLSBib3hbTUlOWF0sIGJveFtNQVhZXSAtIGJveFtNSU5ZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnRzIG9mIGFuIGV4aXN0aW5nIGFhYm94LlxuICogRXh0ZW50cyBpcyB0aGUgc2l6ZSBvZiBhIGJvdW5kcyBpbiBlYWNoIGRpbWVuc2lvbiBzdGFydGluZyBhdCB0aGUgY2VudGVyXG4gKiBvZiB0aGUgYm91bmRzLiAoaS5lLiBleHRlbnRzID0gW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl0pXG4gKiBAcGFyYW0gIHtWZWMyZH0gb3V0IDJkIHZlY3RvciB0byBzdG9yZSB0aGUgZXh0ZW50cyBvZiBhbiBleGlzdGluZyBhYWJveFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGJvdW5kcyB0byBleHRyYWN0IHRoZSBleHRlbnRzIGZyb21cbiAqIEByZXR1cm4ge1ZlYzJkfSAgICAgdmVjdG9yIHJlZmVyZW5jZWQgYnkgdGhlIG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVudHMob3V0LCBib3gpIHtcbiAgZ2V0U2l6ZShvdXQsIGJveClcbiAgcmV0dXJuIFZlYzJkLnNjYWxlKG91dCwgb3V0LCAwLjUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGNlbnRlciBvZiBhbiBleGlzdGluZyBhYWJveFxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IHBvaW50IHRvIHN0b3JlIHRoZSBjZW50ZXIgb2YgYW4gZXhpc3RpbmcgYm91bmRzXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggYm91bmRzIHRvIGV4dHJhY3QgdGhlIGNlbnRlciBmcm9tXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgcG9pbnQgcmVmZXJlbmNlZCBieSB0aGUgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2VudGVyKG91dCwgYm94KSB7XG4gIGdldEV4dGVudHMob3V0LCBib3gpXG4gIG91dFtNSU5YXSArPSBib3hbTUlOWF1cbiAgb3V0W01JTlldICs9IGJveFtNSU5ZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogRXhwYW5kcyBhbiBleGlzdGluZyBhYWJveCBieSBhIHNwZWNpZmllZCBzaXplIGluIGVhY2ggZGltZW5zaW9uLlxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0ICAgICAgICBib3VuZHMgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBvcGVyYXRpb24gaW5cbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCAgICAgICAgc3RhcnRpbmcgYm91bmRzIHRvIGV4cGFuZFxuICogQHBhcmFtICB7VmVjMmR9IGV4cGFuZFNpemUgICBzaXplIHRvIGV4cGFuZCBpbiBlYWNoIGRpbWVuc2lvblxuICogQHJldHVybiB7QUFCb3gyZH0gICAgICAgICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSB0aGUgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kKG91dCwgYm94LCBleHBhbmRTaXplKSB7XG4gIG91dFtNSU5YXSA9IGJveFtNSU5YXSAtIGV4cGFuZFNpemVbMF1cbiAgb3V0W01BWFhdID0gYm94W01BWFhdICsgZXhwYW5kU2l6ZVswXVxuICBvdXRbTUlOWV0gPSBib3hbTUlOWV0gLSBleHBhbmRTaXplWzFdXG4gIG91dFtNQVhZXSA9IGJveFtNQVhZXSArIGV4cGFuZFNpemVbMV1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgYXJlYSBvZiBhbiBleGlzdGluZyBhYWJveFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94XG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBhcmVhIG9mIHRoZSBib3VuZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFyZWEoYm94KSB7XG4gIHJldHVybiAoYm94W01BWFhdIC0gYm94W01JTlhdKSAqIChib3hbTUFYWV0gLSBib3hbTUlOWV0pXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaHVsbCBvZiB0d28gYWFib3hlcy4gVGhlIGh1bGwgaXMgdGhlIHNtYWxsZXN0IGJvdW5kcyB0aGF0IGNvbnRhaW5zXG4gKiBib3RoIG9mIHRoZSBhYWJveGVzXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgb3BlcmF0aW9uIGluXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBhXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBiXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaHVsbChvdXQsIGEsIGIpIHtcbiAgcmV0dXJuIGNyZWF0ZShNYXRoLm1pbihhW01JTlhdLCBiW01JTlhdKSwgTWF0aC5taW4oYVtNSU5ZXSwgYltNSU5ZXSksIE1hdGgubWF4KGFbTUFYWF0sIGJbTUFYWF0pLCBNYXRoLm1heChhW01BWFldLCBiW01BWFldKSlcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdHdvIGV4aXN0aW5nIGJvdW5kcy5cbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBib3VuZHMgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBvcGVyYXRpb24gaW5cbiAqIEBwYXJhbSAge0FBQm94MmR9IGFcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ob3V0LCBhLCBiKSB7XG4gIGxldCBib3hUb1VzZSA9IG91dFxuICBpZiAob3V0ID09PSBhKSB7XG4gICAgYm94VG9Vc2UgPSBjcmVhdGUoKVxuICB9XG5cbiAgbGV0IG1pbmluZGV4ID0gTUlOWFxuICBsZXQgbWF4aW5kZXggPSBNQVhYXG4gIGZvciAoOyBtaW5pbmRleCA8PSBNSU5ZOyBtaW5pbmRleCArPSAxLCBtYXhpbmRleCArPSAxKSB7XG4gICAgaWYgKGFbbWF4aW5kZXhdIDwgYlttaW5pbmRleF0gfHwgYVttaW5pbmRleF0gPiBiW21heGluZGV4XSkge1xuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBib3hUb1VzZVttaW5pbmRleF0gPSBNYXRoLm1heChhW21pbmluZGV4XSwgYlttaW5pbmRleF0pXG4gICAgYm94VG9Vc2VbbWF4aW5kZXhdID0gTWF0aC5taW4oYVttYXhpbmRleF0sIGJbbWF4aW5kZXhdKVxuICB9XG5cbiAgaWYgKG1pbmluZGV4ICE9PSBNSU5ZICsgMSkge1xuICAgIGluaXRFbXB0eShib3hUb1VzZSlcbiAgfVxuXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBjb3B5KG91dCwgYm94VG9Vc2UpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9uZSBib3VuZHMgb3ZlcmxhcHMgYW5vdGhlciBpbiBhbnkgd2F5IChub24taW5jbHVzaXZlKS5cbiAqIEBwYXJhbSAge0FBQm94MmR9IGFcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIGEgb3ZlcmxhcHMgYiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvdmVybGFwcyhhLCBiKSB7XG4gIHJldHVybiAhKGFbTUFYWF0gPD0gYltNSU5YXSB8fCBhW01JTlhdID49IGJbTUFYWF0gfHwgYVtNQVhZXSA8PSBiW01JTlldIHx8IGFbTUlOWV0gPj0gYltNQVhZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb25lIGJvdW5kcyBmdWxsIGNvbnRhaW5zIGFub3RoZXIgKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBhXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgIHRydWUgaWYgYSBmdWxseSBjb250YWlucyBiLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICByZXR1cm4gIShiW01JTlhdIDwgYVtNSU5YXSB8fCBiW01BWFhdID4gYVtNQVhYXSB8fCBiW01JTlldIDwgYVtNSU5ZXSB8fCBiW01BWFldID4gYVtNQVhZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gZXhpc3RpbmcgYm91bmRzIGNvbnRhaW5zIGEgc3BlY2lmaWMgcG9pbnQgKGluY2x1c2l2ZSlcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveFxuICogQHBhcmFtICB7UG9pbnQyZH0gcHRcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBSZXR1cm5zIHRydWUgaWYgcHQgaXMgaW5zaWRlIG9mIGJveCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1B0KGJveCwgcHQpIHtcbiAgcmV0dXJuIChwdFtNSU5YXSA+PSBib3hbTUlOWF0gJiYgcHRbTUlOWF0gPD0gYm94W01BWFhdICYmIHB0W01JTlldID49IGJveFtNSU5ZXSAmJiBwdFtNSU5ZXSA8PSBib3hbTUFYWV0pXG59XG5cbi8qKlxuICogRXh0ZW5kcyBhbiBleGlzdGluZyBib3VuZHMgc28gdGhhdCBpdCB3b3VsZCBjb250YWluIGEgc3BlY2lmaWMgcG9pbnRcbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBCb3VuZHMgY29udGFpbmluZyB0aGUgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IFN0YXJ0aW5nIGJvdW5kcyB0byBwb3NzaWJseSBleHRlbmRcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0ICBQb2ludCB0byBlbmNhcHN1bGF0ZSBpbiBib3hcbiAqIEByZXR1cm4ge0FBYm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNhcHN1bGF0ZVB0KG91dCwgYm94LCBwdCkge1xuICBpZiAob3V0ICE9PSBib3gpIHtcbiAgICBjb3B5KG91dCwgYm94KVxuICB9XG4gIGlmIChpc0VtcHR5KGJveCkpIHtcbiAgICBvdXRbTUlOWF0gPSBwdFtNSU5YXVxuICAgIG91dFtNQVhYXSA9IHB0W01JTlhdXG4gICAgb3V0W01JTlldID0gcHRbTUlOWV1cbiAgICBvdXRbTUFYWV0gPSBwdFtNSU5ZXVxuICB9IGVsc2Uge1xuICAgIGlmIChwdFtNSU5YXSA8IG91dFtNSU5YXSkge1xuICAgICAgb3V0W01JTlhdID0gcHRbTUlOWF1cbiAgICB9IGVsc2UgaWYgKHB0W01JTlhdID4gb3V0W01BWFhdKSB7XG4gICAgICBvdXRbTUFYWF0gPSBwdFtNSU5YXVxuICAgIH1cblxuICAgIGlmIChwdFtNSU5ZXSA8IG91dFtNSU5ZXSkge1xuICAgICAgb3V0W01JTlldID0gcHRbTUlOWV1cbiAgICB9IGVsc2UgaWYgKHB0W01JTlldID4gb3V0W01BWFldKSB7XG4gICAgICBvdXRbTUFYWV0gPSBwdFtNSU5ZXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogVHJhbnNsYXRlcyBhbiBleGlzdGluZyBib3VuZHMgYnkgYSBzcGVjaWZpZWQgb2Zmc2V0IGl0IGVhY2ggZGltZW5zaW9uXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHJlc3VsdGluZyBmcm9tIHRoZSBvcGVyYXRpb25cbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBzdGFydGluZyBib3VuZHNcbiAqIEBwYXJhbSAge1ZlYzJkfSBwb3MgICB0cmFuc2xhdGlvbiBpbiBlYWNoIGRpbWVuc2lvblxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGJveCwgcG9zKSB7XG4gIG91dFtNSU5YXSA9IGJveFtNSU5YXSArIHBvc1swXVxuICBvdXRbTUlOWV0gPSBib3hbTUlOWV0gKyBwb3NbMV1cbiAgb3V0W01BWFhdID0gYm94W01BWFhdICsgcG9zWzBdXG4gIG91dFtNQVhZXSA9IGJveFtNQVhZXSArIHBvc1sxXVxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm0ob3V0LCBib3gsIG1hdCwgeGZvcm1GdW5jKSB7XG4gIGxldCBib3hUb1VzZSA9IG91dFxuICBpZiAob3V0ID09PSBib3gpIHtcbiAgICBib3hUb1VzZSA9IGNyZWF0ZSgpXG4gIH1cbiAgaW5pdEVtcHR5KGJveFRvVXNlKVxuXG4gIGNvbnN0IHB0MSA9IFZlYzJkLnNldChWZWMyZC5jcmVhdGUoKSwgYm94W01JTlhdLCBib3hbTUlOWV0pXG4gIGNvbnN0IHB0MiA9IFZlYzJkLmNyZWF0ZSgpXG4gIHhmb3JtRnVuYyhwdDIsIHB0MSwgbWF0KVxuICBlbmNhcHN1bGF0ZVB0KGJveFRvVXNlLCBib3hUb1VzZSwgcHQyKVxuICBwdDFbTUlOWF0gPSBib3hbTUFYWF1cbiAgeGZvcm1GdW5jKHB0MiwgcHQxLCBtYXQpXG4gIGVuY2Fwc3VsYXRlUHQoYm94VG9Vc2UsIGJveFRvVXNlLCBwdDIpXG4gIHB0MVtNSU5ZXSA9IGJveFtNQVhZXVxuICB4Zm9ybUZ1bmMocHQyLCBwdDEsIG1hdClcbiAgZW5jYXBzdWxhdGVQdChib3hUb1VzZSwgYm94VG9Vc2UsIHB0MilcbiAgcHQxW01JTlhdID0gYm94W01JTlhdXG4gIHhmb3JtRnVuYyhwdDIsIHB0MSwgbWF0KVxuICBlbmNhcHN1bGF0ZVB0KGJveFRvVXNlLCBib3hUb1VzZSwgcHQyKVxuICBpZiAob3V0ID09PSBib3gpIHtcbiAgICBjb3B5KG91dCwgYm94VG9Vc2UpXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXhpc3RpbmcgYm91bmRzIGJ5IGEgMngyIG1hdHJpeFxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGJvdW5kcyB0byBjb250YWluIHRoZSBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggYm91bmRzIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtICB7TWF0Mn0gbWF0IDJ4MiBtYXRyaXggdHJhbnNmb3JtYXRpb25cbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYm94LCBtYXQpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybShvdXQsIGJveCwgbWF0LCBWZWMyZC50cmFuc2Zvcm1NYXQyKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gZXhpc3RpbmcgYm91bmRzIGJ5IGEgMngzIG1hdHJpeC5cbiAqIEEgMngzIG1hdHJpeCBpcyBhIDJ4MiBtYXRyaXggd2l0aCBhIHRyYW5zbGF0aW9uIGNvbXBvbmVudC5cbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBib3VuZHMgdG8gaG9sZCB0aGUgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGJvdW5kcyB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSAge01hdDJkfSBtYXQgICAyeDMgbWF0cml4XG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MmQob3V0LCBib3gsIG1hdCkge1xuICByZXR1cm4gdHJhbnNmb3JtKG91dCwgYm94LCBtYXQsIFZlYzJkLnRyYW5zZm9ybU1hdDJkKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29yZS9hYWJveDJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\n/**\n * @class Common utilities\n * @name glMatrix\n */\nvar glMatrix = {};\n\n// Configuration Constants\nglMatrix.EPSILON = 0.000001;\nglMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\nglMatrix.RANDOM = Math.random;\nglMatrix.ENABLE_SIMD = false;\n\n// Capability detection\nglMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);\nglMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nglMatrix.setMatrixArrayType = function(type) {\n    glMatrix.ARRAY_TYPE = type;\n}\n\nvar degree = Math.PI / 180;\n\n/**\n* Convert Degree To Radian\n*\n* @param {Number} Angle in Degrees\n*/\nglMatrix.toRadian = function(a){\n     return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less \n * than or equal to 1.0, and a relative tolerance is used for larger values)\n * \n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nglMatrix.equals = function(a, b) {\n\treturn Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nmodule.exports = glMatrix;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9jb21tb24uanM/N2NhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDb21tb24gdXRpbGl0aWVzXG4gKiBAbmFtZSBnbE1hdHJpeFxuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDAwMTtcbmdsTWF0cml4LkFSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5nbE1hdHJpeC5SQU5ET00gPSBNYXRoLnJhbmRvbTtcbmdsTWF0cml4LkVOQUJMRV9TSU1EID0gZmFsc2U7XG5cbi8vIENhcGFiaWxpdHkgZGV0ZWN0aW9uXG5nbE1hdHJpeC5TSU1EX0FWQUlMQUJMRSA9IChnbE1hdHJpeC5BUlJBWV9UWVBFID09PSBGbG9hdDMyQXJyYXkpICYmICgnU0lNRCcgaW4gdGhpcyk7XG5nbE1hdHJpeC5VU0VfU0lNRCA9IGdsTWF0cml4LkVOQUJMRV9TSU1EICYmIGdsTWF0cml4LlNJTURfQVZBSUxBQkxFO1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgZ2xNYXRyaXguQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBBbmdsZSBpbiBEZWdyZWVzXG4qL1xuZ2xNYXRyaXgudG9SYWRpYW4gPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzcyBcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmdsTWF0cml4LmVxdWFscyA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0cmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbE1hdHJpeDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqrDist = exports.dist = undefined;\nexports.set = set;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.initFromValues = initFromValues;\nexports.addVec2 = addVec2;\nexports.sub = sub;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\nexports.str = str;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.lerp = lerp;\nexports.equals = equals;\nexports.exactEquals = exactEquals;\n\nvar _glMatrix = __webpack_require__(1);\n\nvar X = 0;\nvar Y = 1;\n\n/**\n * Sets the coordinates of a 2D point\n * @param {Point2d} out Point to set\n * @param {Number} [x = 0]   X coordinate\n * @param {Number} [y = 0]   Y coordinate\n * @return {Point2d}    Point referenced by out arg\n */\nfunction set(out) {\n  var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  out[X] = x;\n  out[Y] = y;\n  return out;\n}\n\n/**\n * Creates a new Point2d object\n * @param  {Number} [x = 0] X coordinate\n * @param  {Number} [y = 0] Y coordinate\n * @return {Point2d}\n */\nfunction create() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(2);\n  return set(out, x, y);\n}\n\n/**\n * Creates a new Point2d object with coordinates initialized from an existing point.\n * @param  {Point2d} p\n * @return {Point2d}\n */\nfunction clone(p) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(2);\n  out[X] = p[X];\n  out[Y] = p[Y];\n  return out;\n}\n\n/**\n * Copies the coordinates of one point to another.\n * @param  {Point2d} out The point to copy to\n * @param  {Point2d} p   The point to copy from\n * @return {Point2d}     Point referenced by out arg\n */\nfunction copy(out, p) {\n  out[X] = p[X];\n  out[Y] = p[Y];\n  return out;\n}\n\n/**\n * Creates a new point from coordinates\n * @param  {Number} x X coordinate\n * @param  {Number} y Y coordinate\n * @return {Point2d}   New point\n */\nfunction initFromValues(x, y) {\n  return create(x, y);\n}\n\n/**\n * Adds a 2d offset to an existing point\n * @param {Point2d} out Point receiving the operation result\n * @param {Point2d} pt  Existing point\n * @param {Vec2d} v   Vector describing the offset\n * @return {Point2d}   Point referenced by out arg\n */\nfunction addVec2(out, pt, v) {\n  return _glMatrix.vec2.add(out, pt, v);\n}\n\n/**\n * Calculates the difference between two points\n * @param  {Vec2d} out Vector receiving operation result\n * @param  {Point2d} pt1\n * @param  {Point2d} pt2\n * @return {Vec2d}     Vector referenced by out arg\n */\nfunction sub(out, pt1, pt2) {\n  return _glMatrix.vec2.sub(out, pt1, pt2);\n}\n\n/**\n * Performs an 2x2 matrix multiplication on a point\n * @param  {Point2d} out Point receiving operation result\n * @param  {Point2d} p\n * @param  {Mat2} m 2x2 matrix\n * @return {Point2d}     Point referenced by out arg\n */\nfunction transformMat2(out, p, m) {\n  return _glMatrix.vec2.transformMat2(out, p, m);\n}\n\n/**\n * Performs a 2x3 matrix multiplication on a point.\n * A 2x3 matrix is ultimately a 2x2 matrix with a\n * translation component\n * @param  {Point2d} out Point receiving operation result\n * @param  {Point2d} p\n * @param  {Mat2d} m   2x3 matrix\n * @return {Point2d}     Point referenced by out arg\n */\nfunction transformMat2d(out, p, m) {\n  return _glMatrix.vec2.transformMat2d(out, p, m);\n}\n\n/**\n * Creates a string representation of a point\n * @param  {Point2d} p\n * @return {string}\n */\nfunction str(p) {\n  return \"point2d(\" + p[0] + \" , \" + p[1] + \")\";\n}\n\n/**\n * Computes the distance between two 2d points\n * @param  {Point2d} p1\n * @param  {Point2d} p2\n * @return {Number}\n */\nfunction distance(p1, p2) {\n  return _glMatrix.vec2.distance(p1, p2);\n}\n\nvar dist = exports.dist = distance;\n\n/**\n * Returns the squared distance between two points.\n * This is a cheaper operation than the true distance\n * calculation.\n * @param  {Point2d} p1\n * @param  {Point2d} p2\n * @return {Number}    distance^2\n */\nfunction squaredDistance(p1, p2) {\n  return _glMatrix.vec2.squaredDistance(p1, p2);\n}\n\nvar sqrDist = exports.sqrDist = squaredDistance;\n\n/**\n * Calculates the point linearly interpolated\n * between two points according to the relative operator t\n * [t == 0 = p1 & t == 1 = p2]\n * @param  {Point2d} out Point receiving result of operation\n * @param  {Point2d} p1  Start point (t = 0)\n * @param  {Point2d} p2  End point (t = 1)\n * @param  {[type]} t   Interpolate parameter [0, 1]\n * @return {Point2d}     Point referenced by out arg\n */\nfunction lerp(out, p1, p2, t) {\n  return _glMatrix.vec2.lerp(out, p1, p2, t);\n}\n\n/**\n * Returns whether two points are relatively equal\n * @param  {Point2d} a\n * @param  {Point2d} b\n * @return {Boolean}   Returns true if two point are relatively equal, false otherwise\n */\nfunction equals(a, b) {\n  return _glMatrix.vec2.equals(a, b);\n}\n\n/**\n * Returns whether two points are exactly equal.\n * @param  {Point2d} a\n * @param  {Point2d} b\n * @return {Boolean}   Returns true if the two points are exactly equal, false otherwise\n */\nfunction exactEquals(a, b) {\n  return _glMatrix.vec2.exactEquals(a, b);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL3BvaW50MmQuanM/NzNlMyJdLCJuYW1lcyI6WyJzZXQiLCJjcmVhdGUiLCJjbG9uZSIsImNvcHkiLCJpbml0RnJvbVZhbHVlcyIsImFkZFZlYzIiLCJzdWIiLCJ0cmFuc2Zvcm1NYXQyIiwidHJhbnNmb3JtTWF0MmQiLCJzdHIiLCJkaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZSIsImxlcnAiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsIlgiLCJZIiwib3V0IiwieCIsInkiLCJBUlJBWV9UWVBFIiwicCIsInB0IiwidiIsImFkZCIsInB0MSIsInB0MiIsIm0iLCJwMSIsInAyIiwiZGlzdCIsInNxckRpc3QiLCJ0IiwiYSIsImIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7UUFjZ0JBLEcsR0FBQUEsRztRQVlBQyxNLEdBQUFBLE07UUFVQUMsSyxHQUFBQSxLO1FBYUFDLEksR0FBQUEsSTtRQVlBQyxjLEdBQUFBLGM7UUFXQUMsTyxHQUFBQSxPO1FBV0FDLEcsR0FBQUEsRztRQVdBQyxhLEdBQUFBLGE7UUFhQUMsYyxHQUFBQSxjO1FBU0FDLEcsR0FBQUEsRztRQVVBQyxRLEdBQUFBLFE7UUFjQUMsZSxHQUFBQSxlO1FBZ0JBQyxJLEdBQUFBLEk7UUFVQUMsTSxHQUFBQSxNO1FBVUFDLFcsR0FBQUEsVzs7QUE5S2hCOztBQUVBLElBQU1DLElBQUksQ0FBVjtBQUNBLElBQU1DLElBQUksQ0FBVjs7QUFFQTs7Ozs7OztBQU9PLFNBQVNoQixHQUFULENBQWFpQixHQUFiLEVBQWdDO0FBQUEsTUFBZEMsQ0FBYyx1RUFBVixDQUFVO0FBQUEsTUFBUEMsQ0FBTyx1RUFBSCxDQUFHOztBQUNyQ0YsTUFBSUYsQ0FBSixJQUFTRyxDQUFUO0FBQ0FELE1BQUlELENBQUosSUFBU0csQ0FBVDtBQUNBLFNBQU9GLEdBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTU8sU0FBU2hCLE1BQVQsR0FBOEI7QUFBQSxNQUFkaUIsQ0FBYyx1RUFBVixDQUFVO0FB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S3JCLE1BQUwsQ0FBWW9CLENBQVosRUFBZUMsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1PLFNBQVNwQixXQUFULENBQXFCbUIsQ0FBckIsRUFBd0JDLENBQXhCLEVBQTJCO0FBQ2hDLFNBQU8sZUFBS3BCLFdBQUwsQ0FBaUJtQixDQUFqQixFQUFvQkMsQ0FBcEIsQ0FBUDtBQUNEIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQge2dsTWF0cml4LCB2ZWMyIGFzIFZlYzJ9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5jb25zdCBYID0gMFxuY29uc3QgWSA9IDFcblxuLyoqXG4gKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiBhIDJEIHBvaW50XG4gKiBAcGFyYW0ge1BvaW50MmR9IG91dCBQb2ludCB0byBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbeCA9IDBdICAgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3kgPSAwXSAgIFkgY29vcmRpbmF0ZVxuICogQHJldHVybiB7UG9pbnQyZH0gICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4ID0gMCwgeSA9IDApIHtcbiAgb3V0W1hdID0geFxuICBvdXRbWV0gPSB5XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBvaW50MmQgb2JqZWN0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt4ID0gMF0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt5ID0gMF0gWSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludDJkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHggPSAwLCB5ID0gMCkge1xuICBjb25zdCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKVxuICByZXR1cm4gc2V0KG91dCwgeCwgeSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBvaW50MmQgb2JqZWN0IHdpdGggY29vcmRpbmF0ZXMgaW5pdGlhbGl6ZWQgZnJvbSBhbiBleGlzdGluZyBwb2ludC5cbiAqIEBwYXJhbSAge1BvaW50MmR9IHBcbiAqIEByZXR1cm4ge1BvaW50MmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShwKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpXG4gIG91dFtYXSA9IHBbWF1cbiAgb3V0W1ldID0gcFtZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjb29yZGluYXRlcyBvZiBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBUaGUgcG9pbnQgdG8gY29weSB0b1xuICogQHBhcmFtICB7UG9pbnQyZH0gcCAgIFRoZSBwb2ludCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBQb2ludCByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBwKSB7XG4gIG91dFtYXSA9IHBbWF1cbiAgb3V0W1ldID0gcFtZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwb2ludCBmcm9tIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggWCBjb29yZGluYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgWSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgIE5ldyBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEZyb21WYWx1ZXMoeCwgeSkge1xuICByZXR1cm4gY3JlYXRlKHgsIHkpXG59XG5cbi8qKlxuICogQWRkcyBhIDJkIG9mZnNldCB0byBhbiBleGlzdGluZyBwb2ludFxuICogQHBhcmFtIHtQb2ludDJkfSBvdXQgUG9pbnQgcmVjZWl2aW5nIHRoZSBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1BvaW50MmR9IHB0ICBFeGlzdGluZyBwb2ludFxuICogQHBhcmFtIHtWZWMyZH0gdiAgIFZlY3RvciBkZXNjcmliaW5nIHRoZSBvZmZzZXRcbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRWZWMyKG91dCwgcHQsIHYpIHtcbiAgcmV0dXJuIFZlYzIuYWRkKG91dCwgcHQsIHYpXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSAge1ZlYzJkfSBvdXQgVmVjdG9yIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdDFcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0MlxuICogQHJldHVybiB7VmVjMmR9ICAgICBWZWN0b3IgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWIob3V0LCBwdDEsIHB0Mikge1xuICByZXR1cm4gVmVjMi5zdWIob3V0LCBwdDEsIHB0Milcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhbiAyeDIgbWF0cml4IG11bHRpcGxpY2F0aW9uIG9uIGEgcG9pbnRcbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBQb2ludCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtICB7UG9pbnQyZH0gcFxuICogQHBhcmFtICB7TWF0Mn0gbSAyeDIgbWF0cml4XG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgcCwgbSkge1xuICByZXR1cm4gVmVjMi50cmFuc2Zvcm1NYXQyKG91dCwgcCwgbSlcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIDJ4MyBtYXRyaXggbXVsdGlwbGljYXRpb24gb24gYSBwb2ludC5cbiAqIEEgMngzIG1hdHJpeCBpcyB1bHRpbWF0ZWx5IGEgMngyIG1hdHJpeCB3aXRoIGFcbiAqIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IFBvaW50IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwXG4gKiBAcGFyYW0gIHtNYXQyZH0gbSAgIDJ4MyBtYXRyaXhcbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBQb2ludCByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgcCwgbSkge1xuICByZXR1cm4gVmVjMi50cmFuc2Zvcm1NYXQyZChvdXQsIHAsIG0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHBvaW50XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIocCkge1xuICByZXR1cm4gYHBvaW50MmQoJHtwWzBdfSAsICR7cFsxXX0pYFxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byAyZCBwb2ludHNcbiAqIEBwYXJhbSAge1BvaW50MmR9IHAxXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBWZWMyLmRpc3RhbmNlKHAxLCBwMilcbn1cblxuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICogVGhpcyBpcyBhIGNoZWFwZXIgb3BlcmF0aW9uIHRoYW4gdGhlIHRydWUgZGlzdGFuY2VcbiAqIGNhbGN1bGF0aW9uLlxuICogQHBhcmFtICB7UG9pbnQyZH0gcDFcbiAqIEBwYXJhbSAge1BvaW50MmR9IHAyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIGRpc3RhbmNlXjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIFZlYzIuc3F1YXJlZERpc3RhbmNlKHAxLCBwMilcbn1cblxuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBsaW5lYXJseSBpbnRlcnBvbGF0ZWRcbiAqIGJldHdlZW4gdHdvIHBvaW50cyBhY2NvcmRpbmcgdG8gdGhlIHJlbGF0aXZlIG9wZXJhdG9yIHRcbiAqIFt0ID09IDAgPSBwMSAmIHQgPT0gMSA9IHAyXVxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IFBvaW50IHJlY2VpdmluZyByZXN1bHQgb2Ygb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwMSAgU3RhcnQgcG9pbnQgKHQgPSAwKVxuICogQHBhcmFtICB7UG9pbnQyZH0gcDIgIEVuZCBwb2ludCAodCA9IDEpXG4gKiBAcGFyYW0gIHtbdHlwZV19IHQgICBJbnRlcnBvbGF0ZSBwYXJhbWV0ZXIgWzAsIDFdXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiBWZWMyLmxlcnAob3V0LCBwMSwgcDIsIHQpXG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHR3byBwb2ludHMgYXJlIHJlbGF0aXZlbHkgZXF1YWxcbiAqIEBwYXJhbSAge1BvaW50MmR9IGFcbiAqIEBwYXJhbSAge1BvaW50MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIHR3byBwb2ludCBhcmUgcmVsYXRpdmVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gVmVjMi5lcXVhbHMoYSwgYilcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdHdvIHBvaW50cyBhcmUgZXhhY3RseSBlcXVhbC5cbiAqIEBwYXJhbSAge1BvaW50MmR9IGFcbiAqIEBwYXJhbSAge1BvaW50MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcG9pbnRzIGFyZSBleGFjdGx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIFZlYzIuZXhhY3RFcXVhbHMoYSwgYilcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvcG9pbnQyZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _glMatrix = __webpack_require__(1);\n\n/**\n * Singular value decomposition\n * See: http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation\n */\n\n/**\n * Calculates the singular value decomposition to extract the\n * scale, rotation, and translation from a 2x3 matrix.\n * Any matrix built by affine transformations can be decomposed\n * into a rotation*scale*rotation*translation\n * See: http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation\n * @param  {Vec2d} outTranslate Vector to hold the translation components\n * @param  {Vec2d} outScale     Vector to hold the x,y scale components\n * @param  {Vec2d} outRotate    Vector to hold the rotation components\n * @param  {Mat2d} mat          Matrix to decompose\n */\n_glMatrix.mat2d.svd = function (outTranslate, outScale, outRotate, mat) {\n  if (outTranslate) {\n    outTranslate[0] = mat[4];\n    outTranslate[1] = mat[5];\n  }\n  if (outScale || outRotate) {\n    var E = (mat[0] + mat[3]) / 2.0;\n    var F = (mat[0] - mat[3]) / 2.0;\n    var G = (mat[1] + mat[2]) / 2.0;\n    var H = (mat[1] - mat[2]) / 2.0;\n    if (outScale) {\n      var Q = Math.sqrt(E * E + H * H);\n      var R = Math.sqrt(F * F + G * G);\n      outScale[0] = Q + R;\n      outScale[1] = Q - R;\n    }\n    if (outRotate) {\n      var a1 = Math.atan2(G, F);\n      var a2 = Math.atan2(H, E);\n      outRotate[0] = (a2 - a1) / 2.0;\n      outRotate[1] = (a2 + a1) / 2.0;\n    }\n  }\n};\n\nexports.default = _glMatrix.mat2d;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL21hdDJkLmpzPzY0YTUiXSwibmFtZXMiOlsic3ZkIiwib3V0VHJhbnNsYXRlIiwib3V0U2NhbGUiLCJvdXRSb3RhdGUiLCJtYXQiLCJFIiwiRiIsIkciLCJIIiwiUSIsIk1hdGgiLCJzcXJ0IiwiUiIsImExIiwiYXRhbjIiLCJhMiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOztBQUVBOzs7OztBQUtDOzs7Ozs7Ozs7OztBQVdELGdCQUFNQSxHQUFOLEdBQVksVUFBQ0MsWUFBRCxFQUFlQyxRQUFmLEVBQXlCQyxTQUF6QixFQUFvQ0MsR0FBcEMsRUFBNEM7QUFDdEQsTUFBSUgsWUFBSixFQUFrQjtBQUNoQkEsaUJBQWEsQ0FBYixJQUFrQkcsSUFBSSxDQUFKLENBQWxCO0FBQ0FILGlCQUFhLENBQWIsSUFBa0JHLElBQUksQ0FBSixDQUFsQjtBQUNEO0FBQ0QsTUFBSUYsWUFBWUMsU0FBaEIsRUFBMkI7QUFDekIsUUFBTUUsSUFBSSxDQUFDRCxJQUFJLENBQUosSUFBU0EsSUFBSSxDQUFKLENBQVYsSUFBb0IsR0FBOUI7QUFDQSxRQUFNRSxJQUFJLENBQUNGLElBQUksQ0FBSixJQUFTQSxJQUFJLENBQUosQ0FBVixJQUFvQixHQUE5QjtBQUNBLFFBQU1HLElBQUksQ0FBQ0gsSUFBSSxDQUFKLElBQVNBLElBQUksQ0FBSixDQUFWLElBQW9CLEdBQTlCO0FBQ0EsUUFBTUksSUFBSSxDQUFDSixJQUFJLENBQUosSUFBU0EsSUFBSSxDQUFKLENBQVYsSUFBb0IsR0FBOUI7QUFDQSxRQUFJRixRQUFKLEVBQWM7QUFDWixVQUFNTyxJQUFJQyxLQUFLQyxJQUFMLENBQVVOLElBQUlBLENBQUosR0FBUUcsSUFBSUEsQ0FBdEIsQ0FBVjtBQUNBLFVBQU1JLElBQUlGLEtBQUtDLElBQUwsQ0FBVUwsSUFBSUEsQ0FBSixHQUFRQyxJQUFJQSxDQUF0QixDQUFWO0FBQ0FMLGVBQVMsQ0FBVCxJQUFjTyxJQUFJRyxDQUFsQjtBQUNBVixlQUFTLENBQVQsSUFBY08sSUFBSUcsQ0FBbEI7QUFDRDtBQUNELFFBQUlULFNBQUosRUFBZTtBQUNiLFVBQU1VLEtBQUtILEtBQUtJLEtBQUwsQ0FBV1AsQ0FBWCxFQUFjRCxDQUFkLENBQVg7QUFDQSxVQUFNUyxLQUFLTCxLQUFLSSxLQUFMLENBQVdOLENBQVgsRUFBY0gsQ0FBZCxDQUFYO0FBQ0FGLGdCQUFVLENBQVYsSUFBZSxDQUFDWSxLQUFLRixFQUFOLElBQVksR0FBM0I7QUFDQVYsZ0JBQVUsQ0FBVixJQUFlLENBQUNZLEtBQUtGLEVBQU4sSUFBWSxHQUEzQjtBQUNEO0FBQ0Y7QUFDRixDQXZCRCIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IHttYXQyZCBhcyBNYXQyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbi8qKlxuICogU2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvblxuICogU2VlOiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvODYxNjc0L2RlY29tcG9zZS1hLTJkLWFyYml0cmFyeS10cmFuc2Zvcm0taW50by1vbmx5LXNjYWxpbmctYW5kLXJvdGF0aW9uXG4gKi9cblxuIC8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gdG8gZXh0cmFjdCB0aGVcbiAgKiBzY2FsZSwgcm90YXRpb24sIGFuZCB0cmFuc2xhdGlvbiBmcm9tIGEgMngzIG1hdHJpeC5cbiAgKiBBbnkgbWF0cml4IGJ1aWx0IGJ5IGFmZmluZSB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRlY29tcG9zZWRcbiAgKiBpbnRvIGEgcm90YXRpb24qc2NhbGUqcm90YXRpb24qdHJhbnNsYXRpb25cbiAgKiBTZWU6IGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NjE2NzQvZGVjb21wb3NlLWEtMmQtYXJiaXRyYXJ5LXRyYW5zZm9ybS1pbnRvLW9ubHktc2NhbGluZy1hbmQtcm90YXRpb25cbiAgKiBAcGFyYW0gIHtWZWMyZH0gb3V0VHJhbnNsYXRlIFZlY3RvciB0byBob2xkIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnRzXG4gICogQHBhcmFtICB7VmVjMmR9IG91dFNjYWxlICAgICBWZWN0b3IgdG8gaG9sZCB0aGUgeCx5IHNjYWxlIGNvbXBvbmVudHNcbiAgKiBAcGFyYW0gIHtWZWMyZH0gb3V0Um90YXRlICAgIFZlY3RvciB0byBob2xkIHRoZSByb3RhdGlvbiBjb21wb25lbnRzXG4gICogQHBhcmFtICB7TWF0MmR9IG1hdCAgICAgICAgICBNYXRyaXggdG8gZGVjb21wb3NlXG4gICovXG5NYXQyZC5zdmQgPSAob3V0VHJhbnNsYXRlLCBvdXRTY2FsZSwgb3V0Um90YXRlLCBtYXQpID0+IHtcbiAgaWYgKG91dFRyYW5zbGF0ZSkge1xuICAgIG91dFRyYW5zbGF0ZVswXSA9IG1hdFs0XVxuICAgIG91dFRyYW5zbGF0ZVsxXSA9IG1hdFs1XVxuICB9XG4gIGlmIChvdXRTY2FsZSB8fCBvdXRSb3RhdGUpIHtcbiAgICBjb25zdCBFID0gKG1hdFswXSArIG1hdFszXSkgLyAyLjBcbiAgICBjb25zdCBGID0gKG1hdFswXSAtIG1hdFszXSkgLyAyLjBcbiAgICBjb25zdCBHID0gKG1hdFsxXSArIG1hdFsyXSkgLyAyLjBcbiAgICBjb25zdCBIID0gKG1hdFsxXSAtIG1hdFsyXSkgLyAyLjBcbiAgICBpZiAob3V0U2NhbGUpIHtcbiAgICAgIGNvbnN0IFEgPSBNYXRoLnNxcnQoRSAqIEUgKyBIICogSClcbiAgICAgIGNvbnN0IFIgPSBNYXRoLnNxcnQoRiAqIEYgKyBHICogRylcbiAgICAgIG91dFNjYWxlWzBdID0gUSArIFJcbiAgICAgIG91dFNjYWxlWzFdID0gUSAtIFJcbiAgICB9XG4gICAgaWYgKG91dFJvdGF0ZSkge1xuICAgICAgY29uc3QgYTEgPSBNYXRoLmF0YW4yKEcsIEYpXG4gICAgICBjb25zdCBhMiA9IE1hdGguYXRhbjIoSCwgRSlcbiAgICAgIG91dFJvdGF0ZVswXSA9IChhMiAtIGExKSAvIDIuMFxuICAgICAgb3V0Um90YXRlWzFdID0gKGEyICsgYTEpIC8gMi4wXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hdDJkXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb3JlL21hdDJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar EPS = 1e-5;\nvar quarter = 0.25;\nvar half = 0.5;\nvar two = 2;\n\nMath.QUATER_PI = quarter * Math.PI;\nMath.HALF_PI = half * Math.PI;\nMath.HALF_NPI = -half * Math.PI;\nMath.TWO_PI = two * Math.PI;\nMath.NPI = -Math.PI;\nMath.NQUATER_PI = quarter * Math.NPI;\nMath.NHALF_PI = half * Math.NPI;\nMath.NTWO_PI = two * Math.NPI;\nMath.INV_PI = 1 / Math.PI;\nMath.RAD_TO_DEG = 180 / Math.PI;\nMath.DEG_TO_RAD = Math.PI / 180;\n\n// this could be useful to tweak in your app, depends on your world resolution\nMath.EPS = EPS;\n\n/**\n * Clamp f to be between a min and max.\n * @param {Number} f\n * @param {Number} minv\n * @param {Number} maxv\n * @return {Number}\n */\nfunction clamp(f, minv, maxv) {\n  return f < minv ? minv : f > maxv ? maxv : f;\n}\n\n/**\n * Clamp f to be between 0 and 1.\n * @param {Number} f\n * @return {Number}\n */\nfunction clamp01(f) {\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\n/**\n * Linearly interpolate (or extrapolate) between @c f1 and @c f2 by @c t percent.\n * @param {Number} f1\n * @param {Number} f2\n * @param {Number} t\n * @return {Number}\n */\nfunction lerp(f1, f2, t) {\n  return f1 * (1 - t) + f2 * t;\n}\n\nMath.clamp = clamp;\nMath.clamp01 = clamp01;\nMath.lerp = lerp;\n\nexports.default = Math;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRoL21hdGguanM/MDU5NiJdLCJuYW1lcyI6WyJFUFMiLCJxdWFydGVyIiwiaGFsZiIsInR3byIsIk1hdGgiLCJRVUFURVJfUEkiLCJQSSIsIkhBTEZfUEkiLCJIQUxGX05QSSIsIlRXT19QSSIsIk5QSSIsIk5RVUFURVJfUEkiLCJOSEFMRl9QSSIsIk5UV09fUEkiLCJJTlZfUEkiLCJSQURfVE9fREVHIiwiREVHX1RPX1JBRCIsImNsYW1wIiwiZiIsIm1pbnYiLCJtYXh2IiwiY2xhbXAwMSIsImxlcnAiLCJmMSIsImYyIiwidCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFNQSxNQUFNLElBQVo7QUFDQSxJQUFNQyxVQUFVLElBQWhCO0FBQ0EsSUFBTUMsT0FBTyxHQUFiO0FBQ0EsSUFBTUMsTUFBTSxDQUFaOztBQUVBQyxLQUFLQyxTQUFMLEdBQWlCSixVQUFVRyxLQUFLRSxFQUFoQztBQUNBRixLQUFLRyxPQUFMLEdBQWVMLE9BQU9FLEtBQUtFLEVBQTNCO0FBQ0FGLEtBQUtJLFFBQUwsR0FBZ0IsQ0FBQ04sSUFBRCxHQUFRRSxLQUFLRSxFQUE3QjtBQUNBRixLQUFLSyxNQUFMLEdBQWNOLE1BQU1DLEtBQUtFLEVBQXpCO0FBQ0FGLEtBQUtNLEdBQUwsR0FBVyxDQUFDTixLQUFLRSxFQUFqQjtBQUNBRixLQUFLTyxVQUFMLEdBQWtCVixVQUFVRyxLQUFLTSxHQUFqQztBQUNBTixLQUFLUSxRQUFMLEdBQWdCVixPQUFPRSxLQUFLTSxHQUE1QjtBQUNBTixLQUFLUyxPQUFMLEdBQWVWLE1BQU1DLEtBQUtNLEdBQTFCO0FBQ0FOLEtBQUtVLE1BQUwsR0FBYyxJQUFJVixLQUFLRSxFQUF2QjtBQUNBRixLQUFLVyxVQUFMLEdBQWtCLE1BQU1YLEtBQUtFLEVBQTdCO0FBQ0FGLEtBQUtZLFVBQUwsR0FBa0JaLEtBQUtFLEVBQUwsR0FBVSxHQUE1Qjs7QUFFQTtBQUNBRixLQUFLSixHQUFMLEdBQVdBLEdBQVg7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTaUIsS0FBVCxDQUFlQyxDQUFmLEVBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEI7QUFDNUIsU0FBT0YsSUFBSUMsSUFBSixHQUFXQSxJQUFYLEdBQW1CRCxJQUFJRSxJQUFKLEdBQVdBLElBQVgsR0FBa0JGLENBQTVDO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsU0FBU0csT0FBVCxDQUFpQkgsQ0FBakIsRUFBb0I7QUFDbEIsU0FBT0EsSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFhQSxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVlBLENBQWhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTSSxJQUFULENBQWNDLEVBQWQsRUFBa0JDLEVBQWxCLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QixTQUFPRixNQUFNLElBQUlFLENBQVYsSUFBZUQsS0FBS0MsQ0FBM0I7QUFDRDs7QUFFRHJCLEtBQUthLEtBQUwsR0FBYUEsS0FBYjtBQUNBYixLQUFLaUIsT0FBTCxHQUFlQSxPQUFmO0FBQ0FqQixLQUFLa0IsSUFBTCxHQUFZQSxJQUFaOztrQkFFZWxCLEkiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVQUyA9IDFlLTVcbmNvbnN0IHF1YXJ0ZXIgPSAwLjI1XG5jb25zdCBoYWxmID0gMC41XG5jb25zdCB0d28gPSAyXG5cbk1hdGguUVVBVEVSX1BJID0gcXVhcnRlciAqIE1hdGguUElcbk1hdGguSEFMRl9QSSA9IGhhbGYgKiBNYXRoLlBJXG5NYXRoLkhBTEZfTlBJID0gLWhhbGYgKiBNYXRoLlBJXG5NYXRoLlRXT19QSSA9IHR3byAqIE1hdGguUElcbk1hdGguTlBJID0gLU1hdGguUElcbk1hdGguTlFVQVRFUl9QSSA9IHF1YXJ0ZXIgKiBNYXRoLk5QSVxuTWF0aC5OSEFMRl9QSSA9IGhhbGYgKiBNYXRoLk5QSVxuTWF0aC5OVFdPX1BJID0gdHdvICogTWF0aC5OUElcbk1hdGguSU5WX1BJID0gMSAvIE1hdGguUElcbk1hdGguUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUElcbk1hdGguREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODBcblxuLy8gdGhpcyBjb3VsZCBiZSB1c2VmdWwgdG8gdHdlYWsgaW4geW91ciBhcHAsIGRlcGVuZHMgb24geW91ciB3b3JsZCByZXNvbHV0aW9uXG5NYXRoLkVQUyA9IEVQU1xuXG4vKipcbiAqIENsYW1wIGYgdG8gYmUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4LlxuICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW52XG4gKiBAcGFyYW0ge051bWJlcn0gbWF4dlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcChmLCBtaW52LCBtYXh2KSB7XG4gIHJldHVybiBmIDwgbWludiA/IG1pbnYgOiAoZiA+IG1heHYgPyBtYXh2IDogZilcbn1cblxuLyoqXG4gKiBDbGFtcCBmIHRvIGJlIGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wMDEoZikge1xuICByZXR1cm4gZiA8IDAgPyAwIDogKGYgPiAxID8gMSA6IGYpXG59XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGUgKG9yIGV4dHJhcG9sYXRlKSBiZXR3ZWVuIEBjIGYxIGFuZCBAYyBmMiBieSBAYyB0IHBlcmNlbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gZjFcbiAqIEBwYXJhbSB7TnVtYmVyfSBmMlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbGVycChmMSwgZjIsIHQpIHtcbiAgcmV0dXJuIGYxICogKDEgLSB0KSArIGYyICogdFxufVxuXG5NYXRoLmNsYW1wID0gY2xhbXBcbk1hdGguY2xhbXAwMSA9IGNsYW1wMDFcbk1hdGgubGVycCA9IGxlcnBcblxuZXhwb3J0IGRlZmF1bHQgTWF0aFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbWF0aC9tYXRoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _fillStyle = __webpack_require__(18);\n\nvar _fillStyle2 = _interopRequireDefault(_fillStyle);\n\nvar _strokeStyle = __webpack_require__(19);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nvar _transform2d = __webpack_require__(12);\n\nvar _transform2d2 = _interopRequireDefault(_transform2d);\n\nvar _aggregation2 = __webpack_require__(8);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _eventHandler = __webpack_require__(13);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} CoreShapeOptions\n * @property {number} [zIndex=0] Z index draw order of the shape. Lower numbers get drawn before larger numbers\n */\n\n/**\n * Shape geom modification event\n * @event Shape#geomChanged\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * Shape modification event\n * @event EventedShape#changed\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * @class Defines the core functionality for all shapes\n * @extends {EventHandler}\n */\nvar CoreBaseShape = function (_EventHandler) {\n  _inherits(CoreBaseShape, _EventHandler);\n\n  /**\n   * Creates new core functionality for a shape\n   * @param  {CoreShapeOptions} [opts]\n   * @return {CoreBaseShape}\n   */\n  function CoreBaseShape(opts) {\n    _classCallCheck(this, CoreBaseShape);\n\n    var _this = _possibleConstructorReturn(this, (CoreBaseShape.__proto__ || Object.getPrototypeOf(CoreBaseShape)).call(this, [\"changed:xform\", \"changed:style\", \"changed:order\", \"changed:visibility\", \"changed:geom\"]));\n\n    _this._aabox = AABox2d.create();\n    _this._zIndex = opts && opts.zIndex ? opts.zIndex : 0;\n    _this._visible = true;\n    _this._geomDirty = false;\n\n    _this._fullXform = _glMatrix.mat2d.create();\n    return _this;\n  }\n\n  /**\n   * Sets the z index (back to front draw order) of the shape\n   * @param  {number} zIndex\n   * @fires  EventedShape#changed\n   * @return {CoreBaseShape}        this\n   */\n\n\n  _createClass(CoreBaseShape, [{\n    key: \"zIndex\",\n    set: function set(zIndex) {\n      if (!Number.isInteger(zIndex)) {\n        throw new Error(\"zIndex must be an integer\");\n      }\n      if (zIndex !== this._zIndex) {\n        var prev = this._zIndex;\n        this._zIndex = zIndex;\n        this.fire(\"changed:order\", {\n          attr: \"zIndex\",\n          prevVal: prev,\n          currVal: this._zIndex\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current z index (i.e. draw/layer order) of the shape\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._zIndex;\n    }\n\n    /**\n     * Gets a reference to the current axis-aligned bounding box of the\n     * shape\n     * @return {AABox2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"aabox\",\n    get: function get() {\n      this._updateAABox();\n      return this._aabox;\n    }\n\n    /**\n     * Sets the visibility of the shape\n     * @param  {Boolean} visible If true, the shape is considered visible\n     * @fires  EventedShape#changed\n     * @return {CoreBaseShape}         this\n     * @throws {Error} If argument is not a boolean type\n     */\n\n  }, {\n    key: \"visible\",\n    set: function set(visible) {\n      if (typeof visible !== \"boolean\") {\n        throw new Error(\"visible must be a boolean\");\n      }\n\n      if (visible !== this._visible) {\n        this._visible = visible;\n        this.fire(\"changed:visibility\", {\n          attr: \"visible\",\n          prevVal: !this._visible,\n          currVal: this._visible\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets the current visibility of the shape\n     * @return {boolean}\n     */\n    ,\n    get: function get() {\n      return this._visible;\n    }\n  }]);\n\n  return CoreBaseShape;\n}(_eventHandler2.default);\n\n/**\n * @class Defines the basic functionality of all shapes. This includes\n *        mixing in from EventedTransform2d so that affine transformations\n *        can be applied to the shape. Also includes mixing in fill and stroke\n *        properties so that the shape's renderable properties can be modified.\n * @extends {CoreBaseShape}\n * @mixin {EventedTransform2d}\n * @mixin {EventedFillStyle}\n * @mixin {EventedStrokeStyle}\n */\n\n\nvar BaseShape = function (_aggregation) {\n  _inherits(BaseShape, _aggregation);\n\n  /**\n   * Creates new basic functionality (including transform, fill style, and stroke style properties)\n   * for a shape\n   * @param  {object} opts\n   * @return {BaseShape}\n   */\n  function BaseShape(opts) {\n    _classCallCheck(this, BaseShape);\n\n    var _this2 = _possibleConstructorReturn(this, (BaseShape.__proto__ || Object.getPrototypeOf(BaseShape)).call(this, opts));\n\n    _this2._stateStack = [];\n    return _this2;\n  }\n\n  /**\n   * Saves the current state of the shape so that it can be restored later.\n   * @return {BaseShape} this\n   */\n\n\n  _createClass(BaseShape, [{\n    key: \"save\",\n    value: function save() {\n      // Currently only the state of the fill/stroke style properties\n      // and the z index are saved. May want to expand this to include\n      // all modifiable properties (i.e. transform props and visibility prop)\n      var state = new _basicStyle2.default();\n      _basicStyle2.default.copyBasicStyle(this, state);\n      state.zIndex = this.zIndex;\n      this._stateStack.push(state);\n      return this;\n    }\n\n    /**\n     * Pops a saved state from the top of the saved state stack\n     * @return {BaseShape} this\n     */\n\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      // Currently only restores the state of the fill/stroke style properties\n      // and the z index. May want to expand this to include\n      // all modifiable properties (i.e. transform props and visibility prop)\n      var state = this._stateStack.pop();\n      if (state) {\n        _basicStyle2.default.copyBasicStyle(state, this);\n        this.zIndex = state.zIndex;\n      }\n      return this;\n    }\n\n    /**\n     * Gets the visibility of the shape\n     * @return {boolean}\n     * @override\n     */\n\n  }, {\n    key: \"getGlobalDimensions\",\n\n\n    /**\n     * Gets the width/height of the shape after the parent transforms are applied\n     * @return {Vec2d} Width/Height of the shape after all parent transforms applied\n     */\n    value: function getGlobalDimensions() {\n      var scale = [0, 0];\n      _glMatrix.mat2d.svd(null, scale, null, this.globalXform);\n      scale[0] *= this.width;\n      scale[1] *= this.height;\n      return scale;\n    }\n\n    /**\n     * Returns true the shape contains a screen/world space point\n     * @param  {Point2d} screenPt           The point to check in screen/pixel space\n     * @param  {Poitn2d} worldPt            The point to check in world space\n     * @param  {Mat2d} worldToScreenMatrix  The transform matrix from world to screen space\n     * @param  {CanvasRenderingContext2D} ctx The 2d rendering context\n     * @return {boolean}                    True if the shape contains the point, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtn = false;\n      var aabox = this.aabox;\n\n      // Check if the point is contained by the shape's bounds first\n      if (this.visible && AABox2d.containsPt(aabox, worldPt)) {\n        // re-draw the shape (invisible) so that we can use canvas's\n        // isPointInPath/isPointInStroke api calls. Doing that\n        // as this should be compatible across all browsers\n        ctx.save();\n        ctx.setTransform(this._fullXform[0], this._fullXform[1], this._fullXform[2], this._fullXform[3], this._fullXform[4], this._fullXform[5]);\n        ctx.beginPath();\n        this._draw(ctx);\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineWidth = this.strokeWidth + 5; // eslint-disable-line no-magic-numbers\n        ctx.dashPattern = [];\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n        if (this.isFillVisible() && ctx.isPointInPath(screenPt[0], screenPt[1]) || this.isStrokeVisible() && ctx.isPointInStroke(screenPt[0], screenPt[1])) {\n          rtn = true;\n        }\n        ctx.restore();\n      }\n      return rtn;\n    }\n\n    /**\n     * Debug function to draw the bounds of the shape\n     * @param  {CanvasRenderingContext2D} ctx                 2d rendering context\n     * @param  {Mat2d} worldToScreenMatrix Transform from world to screen space\n     * @param  {StrokeStyle} boundsStrokeStyle   The stroke style to use to render the bounds\n     */\n\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      ctx.save();\n      ctx.setTransform(worldToScreenMatrix[0], worldToScreenMatrix[1], worldToScreenMatrix[2], worldToScreenMatrix[3], worldToScreenMatrix[4], worldToScreenMatrix[5]);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      var aabox = this.aabox;\n      AABox2d.getCenter(center, aabox);\n      AABox2d.getExtents(extents, aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    /**\n     * Called when the local transform (does not include parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the shape's bounds needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_localXformUpdated\",\n    value: function _localXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Called when the global transform (includes parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the shape's bounds needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_globalXformUpdated\",\n    value: function _globalXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Renders the shape using a 2d rendering context\n     * @param  {CanvasRenderingContext2d} ctx                 2d rendering context\n     * @param  {Mat2d} worldToScreenMatrix Transform from world to screen space,\n     *                                     usually provided by a camera\n     * @param  {DrawStyleState} styleState Manages the current state of the fill/stroke style attrs\n     *                                     of the 2d rendering context. This is self-managed to minimize\n     *                                     context state switches\n     * @param  {boolean} [doFill=null]     If provided, used to manually override whether to fill the\n     *                                     shape.\n     * @param  {boolean} [doStroke=null]   If provided, used to manually override whether to stroke the\n     *                                     shape.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      var doFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var doStroke = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n      this.transformCtx(ctx, this._fullXform, worldToScreenMatrix);\n\n      ctx.beginPath();\n\n      var rtn = this._draw(ctx);\n      if (rtn || typeof rtn === \"undefined\") {\n        if (this.isFillVisible() && (doFill === null || Boolean(doFill))) {\n          styleState.setFillStyle(ctx, this);\n          ctx.fill();\n        }\n\n        if (this.isStrokeVisible() && (doStroke === null || Boolean(doStroke))) {\n          styleState.setStrokeStyle(ctx, this);\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * Copies the fill/stroke style from one BasicStyle object to this shape\n     * @param {BasicStyle} newStyle The style to copy from.\n     * @return {BaseShape} this\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(newStyle) {\n      _basicStyle2.default.copyBasicStyle(newStyle, this);\n      return this;\n    }\n\n    /**\n     * Returns a JSON object containing the properties of this shape\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var state = this; // eslint-disable-line consistent-this\n      if (this._stateStack && this._stateStack.length) {\n        state = this._stateStack[0];\n      }\n      return Object.assign({\n        // type: this.constructor.name,\n        // NOTE: I wanted to use the above call, which would keep the type\n        // consistent with the name of the class, but this isn't always\n        // the case, as was found out a few times when trying to add\n        // this to immerse\n        visible: this.visible,\n        zIndex: state.zIndex\n      }, _basicStyle2.default.toJSON(state), _transform2d2.default.toJSON(this));\n    }\n\n    /**\n     * Compares two shapes, usually used to sort the shapes for drawing\n     * @param  {BaseShape} shape1\n     * @param  {BaseShape} shape2\n     * @return {number}        Returns < 0 if shape1 < shape2, > 0 if shape1 > shape2, 0 if shape1 === shape2\n     */\n\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return this._visible && (this.isFillVisible() || this.isStrokeVisible());\n    }\n  }], [{\n    key: \"shapeCompare\",\n    value: function shapeCompare(shape1, shape2) {\n      var zIndex1 = shape1.zIndex;\n      var zIndex2 = shape2.zIndex;\n      if (zIndex1 < zIndex2) {\n        return -1;\n      } else if (zIndex1 > zIndex2) {\n        return 1;\n      }\n\n      var rtn = _fillStyle2.default.compareFillStyle(shape1, shape2);\n      if (!rtn) {\n        rtn = _strokeStyle2.default.compareStrokeStyle(shape1, shape2);\n      }\n\n      return rtn;\n    }\n  }]);\n\n  return BaseShape;\n}((0, _aggregation3.default)(CoreBaseShape, (0, _transform2d.createEventedTransform2dMixin)(\"changed:xform\"), (0, _fillStyle.createEventedFillStyleMixin)(\"changed:style\"), (0, _strokeStyle.createEventedStrokeStyleMixin)(\"changed:style\")));\n\nexports.default = BaseShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvYmFzZS1zaGFwZS5qcz9iYmVhIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJDb3JlQmFzZVNoYXBlIiwib3B0cyIsIl9hYWJveCIsImNyZWF0ZSIsIl96SW5kZXgiLCJ6SW5kZXgiLCJfdmlzaWJsZSIsIl9nZW9tRGlydHkiLCJfZnVsbFhmb3JtIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJwcmV2IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsIl91cGRhdGVBQUJveCIsInZpc2libGUiLCJCYXNlU2hhcGUiLCJfc3RhdGVTdGFjayIsInN0YXRlIiwiY29weUJhc2ljU3R5bGUiLCJwdXNoIiwicG9wIiwic2NhbGUiLCJzdmQiLCJnbG9iYWxYZm9ybSIsIndpZHRoIiwiaGVpZ2h0Iiwic2NyZWVuUHQiLCJ3b3JsZFB0Iiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImN0eCIsInJ0biIsImFhYm94IiwiY29udGFpbnNQdCIsInNhdmUiLCJzZXRUcmFuc2Zvcm0iLCJiZWdpblBhdGgiLCJfZHJhdyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlV2lkdGgiLCJkYXNoUGF0dGVybiIsInN0cm9rZSIsImlzRmlsbFZpc2libGUiLCJpc1BvaW50SW5QYXRoIiwiaXNTdHJva2VWaXNpYmxlIiwiaXNQb2ludEluU3Ryb2tlIiwicmVzdG9yZSIsImJvdW5kc1N0cm9rZVN0eWxlIiwic2V0U3Ryb2tlQ3R4IiwiY2VudGVyIiwiZXh0ZW50cyIsImdldENlbnRlciIsImdldEV4dGVudHMiLCJyZWN0IiwiX2JvdW5kc091dE9mRGF0ZSIsInN0eWxlU3RhdGUiLCJkb0ZpbGwiLCJkb1N0cm9rZSIsInRyYW5zZm9ybUN0eCIsIkJvb2xlYW4iLCJzZXRGaWxsU3R5bGUiLCJmaWxsIiwic2V0U3Ryb2tlU3R5bGUiLCJuZXdTdHlsZSIsImxlbmd0aCIsIk9iamVjdCIsImFzc2lnbiIsInRvSlNPTiIsInNoYXBlMSIsInNoYXBlMiIsInpJbmRleDEiLCJ6SW5kZXgyIiwiY29tcGFyZUZpbGxTdHlsZSIsImNvbXBhcmVTdHJva2VTdHlsZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7OztBQUtBOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7O0FBU0E7Ozs7SUFJTUMsYTs7O0FBQ0o7Ozs7O0FBS0EseUJBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFBQSw4SEFDVixDQUFDLGVBQUQsRUFBa0IsZUFBbEIsRUFBbUMsZUFBbkMsRUFBb0Qsb0JBQXBELEVBQTBFLGNBQTFFLENBRFU7O0FBRWhCLFVBQUtDLE1BQUwsR0FBY0gsUUFBUUksTUFBUixFQUFkO0FBQ0EsVUFBS0MsT0FBTCxHQUFnQkgsUUFBUUEsS0FBS0ksTUFBZCxHQUF3QkosS0FBS0ksTUFBN0IsR0FBc0MsQ0FBckQ7QUFDQSxVQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsVUFBS0MsVUFBTCxHQUFrQixLQUFsQjs7QUFFQSxVQUFLQyxVQUFMLEdBQWtCLGdCQUFNTCxNQUFOLEVBQWxCO0FBUGdCO0FBUWpCOztBQUVEOzs7Ozs7Ozs7O3NCQU1XRSxNLEVBQVE7QUFDakIsVUFBSSxDQUFDSSxPQUFPQyxTQUFQLENBQWlCTCxNQUFqQixDQUFMLEVBQStCO0FBQzdCLGNBQU0sSUFBSU0sS0FBSixDQUFVLDJCQUFWLENBQU47QUFDRDtBQUNELFVBQUlOLFdBQVcsS0FBS0QsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTVEsT0FBTyxLQUFLUixPQUFsQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUMsTUFBZjtBQUNBLGFBQUtRLElBQUwsQ0FBVSxlQUFWLEVBQTJCO0FBQ3pCQyxnQkFBTSxRQURtQjtBQUV6QkMsbUJBQVNILElBRmdCO0FBR3pCSSxtQkFBUyxLQUFLWjtBQUhXLFNBQTNCO0FBS0Q7QUFDRCxhQUFPLElBQVA7QUFD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LGVBQU8sQ0FBUDtBQUNEOztBQUVELFVBQUl6QyxNQUFNLG9CQUFVMEMsZ0JBQVYsQ0FBMkJKLE1BQTNCLEVBQW1DQyxNQUFuQyxDQUFWO0FBQ0EsVUFBSSxDQUFDdkMsR0FBTCxFQUFVO0FBQ1JBLGNBQU0sc0JBQVkyQyxrQkFBWixDQUErQkwsTUFBL0IsRUFBdUNDLE1BQXZDLENBQU47QUFDRDs7QUFFRCxhQUFPdkMsR0FBUDtBQUNEOzs7O0VBdE9vQywyQkFBWWxDLGFBQVosRUFDckMsZ0RBQThCLGVBQTlCLENBRHFDLEVBQ1csNENBQTRCLGVBQTVCLENBRFgsRUFFckMsZ0RBQThCLGVBQTlCLENBRnFDLEM7O2tCQUFsQm1CLFMiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgRmlsbFN0eWxlLCB7Y3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGlufSBmcm9tIFwiLi4vc3R5bGUvZmlsbC1zdHlsZVwiXG5pbXBvcnQgU3Ryb2tlU3R5bGUsIHtjcmVhdGVFdmVudGVkU3Ryb2tlU3R5bGVNaXhpbn0gZnJvbSBcIi4uL3N0eWxlL3N0cm9rZS1zdHlsZVwiXG5pbXBvcnQgVHJhbnNmb3JtMmQsIHtjcmVhdGVFdmVudGVkVHJhbnNmb3JtMmRNaXhpbn0gZnJvbSBcIi4vdHJhbnNmb3JtMmRcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCBCYXNpY1N0eWxlIGZyb20gXCIuLi9zdHlsZS9iYXNpYy1zdHlsZVwiXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gXCIuLi91dGlsL2V2ZW50LWhhbmRsZXJcIlxuaW1wb3J0IHttYXQyZCBhcyBNYXQyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ29yZVNoYXBlT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gWiBpbmRleCBkcmF3IG9yZGVyIG9mIHRoZSBzaGFwZS4gTG93ZXIgbnVtYmVycyBnZXQgZHJhd24gYmVmb3JlIGxhcmdlciBudW1iZXJzXG4gKi9cblxuLyoqXG4gKiBTaGFwZSBnZW9tIG1vZGlmaWNhdGlvbiBldmVudFxuICogQGV2ZW50IFNoYXBlI2dlb21DaGFuZ2VkXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICogQHByb3BlcnR5IHt9IGN1cnJWYWwgVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwb3N0IG1vZGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogU2hhcGUgbW9kaWZpY2F0aW9uIGV2ZW50XG4gKiBAZXZlbnQgRXZlbnRlZFNoYXBlI2NoYW5nZWRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXR0ciBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgbW9kaWZpZWRcbiAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRGVmaW5lcyB0aGUgY29yZSBmdW5jdGlvbmFsaXR5IGZvciBhbGwgc2hhcGVzXG4gKiBAZXh0ZW5kcyB7RXZlbnRIYW5kbGVyfVxuICovXG5jbGFzcyBDb3JlQmFzZVNoYXBlIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IGNvcmUgZnVuY3Rpb25hbGl0eSBmb3IgYSBzaGFwZVxuICAgKiBAcGFyYW0gIHtDb3JlU2hhcGVPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7Q29yZUJhc2VTaGFwZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihbXCJjaGFuZ2VkOnhmb3JtXCIsIFwiY2hhbmdlZDpzdHlsZVwiLCBcImNoYW5nZWQ6b3JkZXJcIiwgXCJjaGFuZ2VkOnZpc2liaWxpdHlcIiwgXCJjaGFuZ2VkOmdlb21cIl0pXG4gICAgdGhpcy5fYWFib3ggPSBBQUJveDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fekluZGV4ID0gKG9wdHMgJiYgb3B0cy56SW5kZXgpID8gb3B0cy56SW5kZXggOiAwXG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWVcbiAgICB0aGlzLl9nZW9tRGlydHkgPSBmYWxzZVxuXG4gICAgdGhpcy5fZnVsbFhmb3JtID0gTWF0MmQuY3JlYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB6IGluZGV4IChiYWNrIHRvIGZyb250IGRyYXcgb3JkZXIpIG9mIHRoZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHpJbmRleFxuICAgKiBAZmlyZXMgIEV2ZW50ZWRTaGFwZSNjaGFuZ2VkXG4gICAqIEByZXR1cm4ge0NvcmVCYXNlU2hhcGV9ICAgICAgICB0aGlzXG4gICAqL1xuICBzZXQgekluZGV4KHpJbmRleCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih6SW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6SW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyXCIpXG4gICAgfVxuICAgIGlmICh6SW5kZXggIT09IHRoaXMuX3pJbmRleCkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3pJbmRleFxuICAgICAgdGhpcy5fekluZGV4ID0gekluZGV4XG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOm9yZGVyXCIsIHtcbiAgICAgICAgYXR0cjogXCJ6SW5kZXhcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogdGhpcy5fekluZGV4XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgeiBpbmRleCAoaS5lLiBkcmF3L2xheWVyIG9yZGVyKSBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fekluZGV4XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIHRoZVxuICAgKiBzaGFwZVxuICAgKiBAcmV0dXJuIHtBQUJveDJkfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCBhYWJveCgpIHtcbiAgICB0aGlzLl91cGRhdGVBQUJveCgpXG4gICAgcmV0dXJuIHRoaXMuX2FhYm94XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc2hhcGVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdmlzaWJsZSBJZiB0cnVlLCB0aGUgc2hhcGUgaXMgY29uc2lkZXJlZCB2aXNpYmxlXG4gICAqIEBmaXJlcyAgRXZlbnRlZFNoYXBlI2NoYW5nZWRcbiAgICogQHJldHVybiB7Q29yZUJhc2VTaGFwZX0gICAgICAgICB0aGlzXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhcmd1bWVudCBpcyBub3QgYSBib29sZWFuIHR5cGVcbiAgICovXG4gIHNldCB2aXNpYmxlKHZpc2libGUpIHtcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aXNpYmxlIG11c3QgYmUgYSBib29sZWFuXCIpXG4gICAgfVxuXG4gICAgaWYgKHZpc2libGUgIT09IHRoaXMuX3Zpc2libGUpIHtcbiAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlXG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOnZpc2liaWxpdHlcIiwge1xuICAgICAgICBhdHRyOiBcInZpc2libGVcIixcbiAgICAgICAgcHJldlZhbDogIXRoaXMuX3Zpc2libGUsXG4gICAgICAgIGN1cnJWYWw6IHRoaXMuX3Zpc2libGVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZpc2liaWxpdHkgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVxuICB9XG59XG5cbi8qKlxuICogQGNsYXNzIERlZmluZXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgYWxsIHNoYXBlcy4gVGhpcyBpbmNsdWRlc1xuICogICAgICAgIG1peGluZyBpbiBmcm9tIEV2ZW50ZWRUcmFuc2Zvcm0yZCBzbyB0aGF0IGFmZmluZSB0cmFuc2Zvcm1hdGlvbnNcbiAqICAgICAgICBjYW4gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuIEFsc28gaW5jbHVkZXMgbWl4aW5nIGluIGZpbGwgYW5kIHN0cm9rZVxuICogICAgICAgIHByb3BlcnRpZXMgc28gdGhhdCB0aGUgc2hhcGUncyByZW5kZXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIG1vZGlmaWVkLlxuICogQGV4dGVuZHMge0NvcmVCYXNlU2hhcGV9XG4gKiBAbWl4aW4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAqIEBtaXhpbiB7RXZlbnRlZEZpbGxTdHlsZX1cbiAqIEBtaXhpbiB7RXZlbnRlZFN0cm9rZVN0eWxlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlU2hhcGUgZXh0ZW5kcyBhZ2dyZWdhdGlvbihDb3JlQmFzZVNoYXBlLFxuICBjcmVhdGVFdmVudGVkVHJhbnNmb3JtMmRNaXhpbihcImNoYW5nZWQ6eGZvcm1cIiksIGNyZWF0ZUV2ZW50ZWRGaWxsU3R5bGVNaXhpbihcImNoYW5nZWQ6c3R5bGVcIiksXG4gIGNyZWF0ZUV2ZW50ZWRTdHJva2VTdHlsZU1peGluKFwiY2hhbmdlZDpzdHlsZVwiKSkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyBiYXNpYyBmdW5jdGlvbmFsaXR5IChpbmNsdWRpbmcgdHJhbnNmb3JtLCBmaWxsIHN0eWxlLCBhbmQgc3Ryb2tlIHN0eWxlIHByb3BlcnRpZXMpXG4gICAqIGZvciBhIHNoYXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0c1xuICAgKiBAcmV0dXJuIHtCYXNlU2hhcGV9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9zdGF0ZVN0YWNrID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2hhcGUgc28gdGhhdCBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXIuXG4gICAqIEByZXR1cm4ge0Jhc2VTaGFwZX0gdGhpc1xuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICAvLyBDdXJyZW50bHkgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAvLyBhbmQgdGhlIHogaW5kZXggYXJlIHNhdmVkLiBNYXkgd2FudCB0byBleHBhbmQgdGhpcyB0byBpbmNsdWRlXG4gICAgLy8gYWxsIG1vZGlmaWFibGUgcHJvcGVydGllcyAoaS5lLiB0cmFuc2Zvcm0gcHJvcHMgYW5kIHZpc2liaWxpdHkgcHJvcClcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBCYXNpY1N0eWxlKClcbiAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHRoaXMsIHN0YXRlKVxuICAgIHN0YXRlLnpJbmRleCA9IHRoaXMuekluZGV4XG4gICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKHN0YXRlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUG9wcyBhIHNhdmVkIHN0YXRlIGZyb20gdGhlIHRvcCBvZiB0aGUgc2F2ZWQgc3RhdGUgc3RhY2tcbiAgICogQHJldHVybiB7QmFzZVNoYXBlfSB0aGlzXG4gICAqL1xuICByZXN0b3JlKCkge1xuICAgIC8vIEN1cnJlbnRseSBvbmx5IHJlc3RvcmVzIHRoZSBzdGF0ZSBvZiB0aGUgZmlsbC9zdHJva2Ugc3R5bGUgcHJvcGVydGllc1xuICAgIC8vIGFuZCB0aGUgeiBpbmRleC4gTWF5IHdhbnQgdG8gZXhwYW5kIHRoaXMgdG8gaW5jbHVkZVxuICAgIC8vIGFsbCBtb2RpZmlhYmxlIHByb3BlcnRpZXMgKGkuZS4gdHJhbnNmb3JtIHByb3BzIGFuZCB2aXNpYmlsaXR5IHByb3ApXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHN0YXRlLCB0aGlzKVxuICAgICAgdGhpcy56SW5kZXggPSBzdGF0ZS56SW5kZXhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzaGFwZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlICYmICh0aGlzLmlzRmlsbFZpc2libGUoKSB8fCB0aGlzLmlzU3Ryb2tlVmlzaWJsZSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgc2hhcGUgYWZ0ZXIgdGhlIHBhcmVudCB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkXG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9IZWlnaHQgb2YgdGhlIHNoYXBlIGFmdGVyIGFsbCBwYXJlbnQgdHJhbnNmb3JtcyBhcHBsaWVkXG4gICAqL1xuICBnZXRHbG9iYWxEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHNjYWxlID0gWzAsIDBdXG4gICAgTWF0MmQuc3ZkKG51bGwsIHNjYWxlLCBudWxsLCB0aGlzLmdsb2JhbFhmb3JtKVxuICAgIHNjYWxlWzBdICo9IHRoaXMud2lkdGhcbiAgICBzY2FsZVsxXSAqPSB0aGlzLmhlaWdodFxuICAgIHJldHVybiBzY2FsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB0aGUgc2hhcGUgY29udGFpbnMgYSBzY3JlZW4vd29ybGQgc3BhY2UgcG9pbnRcbiAgICogQHBhcmFtICB7UG9pbnQyZH0gc2NyZWVuUHQgICAgICAgICAgIFRoZSBwb2ludCB0byBjaGVjayBpbiBzY3JlZW4vcGl4ZWwgc3BhY2VcbiAgICogQHBhcmFtICB7UG9pdG4yZH0gd29ybGRQdCAgICAgICAgICAgIFRoZSBwb2ludCB0byBjaGVjayBpbiB3b3JsZCBzcGFjZVxuICAgKiBAcGFyYW0gIHtNYXQyZH0gd29ybGRUb1NjcmVlbk1hdHJpeCAgVGhlIHRyYW5zZm9ybSBtYXRyaXggZnJvbSB3b3JsZCB0byBzY3JlZW4gc3BhY2VcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJkIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICBUcnVlIGlmIHRoZSBzaGFwZSBjb250YWlucyB0aGUgcG9pbnQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgY29udGFpbnNQb2ludChzY3JlZW5QdCwgd29ybGRQdCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgY3R4KSB7XG4gICAgLy8gU2hvdWxkIHdlIHVwZGF0ZSBoZXJlLCBvciBpcyBpdCBzYWZlIHRvXG4gICAgLy8gc2F5IHRoYXQgdGhpcyBpcyBzdGF0ZWZ1bCwgbWVhbmluZyBhIHJlbmRlclxuICAgIC8vIHNob3VsZCBoYXZlIGJlZW4gcGVyZm9ybWVkIGJlZm9yZWhhbmQgd2hpY2hcbiAgICAvLyB3b3VsZCd2ZSB1cGRhdGVkIGl0cyBzdGF0ZVxuICAgIGxldCBydG4gPSBmYWxzZVxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGlzIGNvbnRhaW5lZCBieSB0aGUgc2hhcGUncyBib3VuZHMgZmlyc3RcbiAgICBpZiAodGhpcy52aXNpYmxlICYmIEFBQm94MmQuY29udGFpbnNQdChhYWJveCwgd29ybGRQdCkpIHtcbiAgICAgIC8vIHJlLWRyYXcgdGhlIHNoYXBlIChpbnZpc2libGUpIHNvIHRoYXQgd2UgY2FuIHVzZSBjYW52YXMnc1xuICAgICAgLy8gaXNQb2ludEluUGF0aC9pc1BvaW50SW5TdHJva2UgYXBpIGNhbGxzLiBEb2luZyB0aGF0XG4gICAgICAvLyBhcyB0aGlzIHNob3VsZCBiZSBjb21wYXRpYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnNcbiAgICAgIGN0eC5zYXZlKClcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5fZnVsbFhmb3JtWzBdLCB0aGlzLl9mdWxsWGZvcm1bMV0sIHRoaXMuX2Z1bGxYZm9ybVsyXSwgdGhpcy5fZnVsbFhmb3JtWzNdLCB0aGlzLl9mdWxsWGZvcm1bNF0sIHRoaXMuX2Z1bGxYZm9ybVs1XSlcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgdGhpcy5fZHJhdyhjdHgpXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMClcIlxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggKyA1IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgY3R4LmRhc2hQYXR0ZXJuID0gW11cbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgaWYgKCh0aGlzLmlzRmlsbFZpc2libGUoKSAmJiBjdHguaXNQb2ludEluUGF0aChzY3JlZW5QdFswXSwgc2NyZWVuUHRbMV0pKSB8fFxuICAgICAgICAodGhpcy5pc1N0cm9rZVZpc2libGUoKSAmJiBjdHguaXNQb2ludEluU3Ryb2tlKHNjcmVlblB0WzBdLCBzY3JlZW5QdFsxXSkpKSB7XG4gICAgICAgIHJ0biA9IHRydWVcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKClcbiAgICB9XG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbiAgLyoqXG4gICAqIERlYnVnIGZ1bmN0aW9uIHRvIGRyYXcgdGhlIGJvdW5kcyBvZiB0aGUgc2hhcGVcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggICAgICAgICAgICAgICAgIDJkIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEBwYXJhbSAge01hdDJkfSB3b3JsZFRvU2NyZWVuTWF0cml4IFRyYW5zZm9ybSBmcm9tIHdvcmxkIHRvIHNjcmVlbiBzcGFjZVxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gYm91bmRzU3Ryb2tlU3R5bGUgICBUaGUgc3Ryb2tlIHN0eWxlIHRvIHVzZSB0byByZW5kZXIgdGhlIGJvdW5kc1xuICAgKi9cbiAgcmVuZGVyQm91bmRzKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgYm91bmRzU3Ryb2tlU3R5bGUpIHtcbiAgICBjdHguc2F2ZSgpXG4gICAgY3R4LnNldFRyYW5zZm9ybSh3b3JsZFRvU2NyZWVuTWF0cml4WzBdLCB3b3JsZFRvU2NyZWVuTWF0cml4WzFdLCB3b3JsZFRvU2NyZWVuTWF0cml4WzJdLCB3b3JsZFRvU2NyZWVuTWF0cml4WzNdLCB3b3JsZFRvU2NyZWVuTWF0cml4WzRdLCB3b3JsZFRvU2NyZWVuTWF0cml4WzVdKVxuICAgIGJvdW5kc1N0cm9rZVN0eWxlLnNldFN0cm9rZUN0eChjdHgpXG4gICAgY29uc3QgY2VudGVyID0gWzAsIDBdXG4gICAgY29uc3QgZXh0ZW50cyA9IFswLCAwXVxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuICAgIEFBQm94MmQuZ2V0Q2VudGVyKGNlbnRlciwgYWFib3gpXG4gICAgQUFCb3gyZC5nZXRFeHRlbnRzKGV4dGVudHMsIGFhYm94KVxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5yZWN0KGNlbnRlclswXSAtIGV4dGVudHNbMF0sIGNlbnRlclsxXSAtIGV4dGVudHNbMV0sIGV4dGVudHNbMF0gKiAyLCBleHRlbnRzWzFdICogMilcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBsb2NhbCB0cmFuc2Zvcm0gKGRvZXMgbm90IGluY2x1ZGUgcGFyZW50IHRyYW5zZm9ybXMpIG9mIHRoZSBUcmFuc2Zvcm0yZFxuICAgKiBtaXhpbiBpcyBtb2RpZmllZC4gVXNlZCB0byBiZSBub3RpZmllZCBpbnRlcm5hbGx5IHRoYXQgdGhlIHNoYXBlJ3MgYm91bmRzIG5lZWRzIHVwZGF0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9jYWxYZm9ybVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBnbG9iYWwgdHJhbnNmb3JtIChpbmNsdWRlcyBwYXJlbnQgdHJhbnNmb3Jtcykgb2YgdGhlIFRyYW5zZm9ybTJkXG4gICAqIG1peGluIGlzIG1vZGlmaWVkLiBVc2VkIHRvIGJlIG5vdGlmaWVkIGludGVybmFsbHkgdGhhdCB0aGUgc2hhcGUncyBib3VuZHMgbmVlZHMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nbG9iYWxYZm9ybVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHNoYXBlIHVzaW5nIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJkfSBjdHggICAgICAgICAgICAgICAgIDJkIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEBwYXJhbSAge01hdDJkfSB3b3JsZFRvU2NyZWVuTWF0cml4IFRyYW5zZm9ybSBmcm9tIHdvcmxkIHRvIHNjcmVlbiBzcGFjZSxcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXN1YWxseSBwcm92aWRlZCBieSBhIGNhbWVyYVxuICAgKiBAcGFyYW0gIHtEcmF3U3R5bGVTdGF0ZX0gc3R5bGVTdGF0ZSBNYW5hZ2VzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmaWxsL3N0cm9rZSBzdHlsZSBhdHRyc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZiB0aGUgMmQgcmVuZGVyaW5nIGNvbnRleHQuIFRoaXMgaXMgc2VsZi1tYW5hZ2VkIHRvIG1pbmltaXplXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgc3RhdGUgc3dpdGNoZXNcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2RvRmlsbD1udWxsXSAgICAgSWYgcHJvdmlkZWQsIHVzZWQgdG8gbWFudWFsbHkgb3ZlcnJpZGUgd2hldGhlciB0byBmaWxsIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gW2RvU3Ryb2tlPW51bGxdICAgSWYgcHJvdmlkZWQsIHVzZWQgdG8gbWFudWFsbHkgb3ZlcnJpZGUgd2hldGhlciB0byBzdHJva2UgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLlxuICAgKi9cbiAgcmVuZGVyKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgc3R5bGVTdGF0ZSwgZG9GaWxsID0gbnVsbCwgZG9TdHJva2UgPSBudWxsKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1DdHgoY3R4LCB0aGlzLl9mdWxsWGZvcm0sIHdvcmxkVG9TY3JlZW5NYXRyaXgpXG5cbiAgICBjdHguYmVnaW5QYXRoKClcblxuICAgIGNvbnN0IHJ0biA9IHRoaXMuX2RyYXcoY3R4KVxuICAgIGlmIChydG4gfHwgdHlwZW9mIHJ0biA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHRoaXMuaXNGaWxsVmlzaWJsZSgpICYmIChkb0ZpbGwgPT09IG51bGwgfHwgQm9vbGVhbihkb0ZpbGwpKSkge1xuICAgICAgICBzdHlsZVN0YXRlLnNldEZpbGxTdHlsZShjdHgsIHRoaXMpXG4gICAgICAgIGN0eC5maWxsKClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNTdHJva2VWaXNpYmxlKCkgJiYgKGRvU3Ryb2tlID09PSBudWxsIHx8IEJvb2xlYW4oZG9TdHJva2UpKSkge1xuICAgICAgICBzdHlsZVN0YXRlLnNldFN0cm9rZVN0eWxlKGN0eCwgdGhpcylcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgICAgICBjdHguc3Ryb2tlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSBmaWxsL3N0cm9rZSBzdHlsZSBmcm9tIG9uZSBCYXNpY1N0eWxlIG9iamVjdCB0byB0aGlzIHNoYXBlXG4gICAqIEBwYXJhbSB7QmFzaWNTdHlsZX0gbmV3U3R5bGUgVGhlIHN0eWxlIHRvIGNvcHkgZnJvbS5cbiAgICogQHJldHVybiB7QmFzZVNoYXBlfSB0aGlzXG4gICAqL1xuICBzZXRTdHlsZShuZXdTdHlsZSkge1xuICAgIEJhc2ljU3R5bGUuY29weUJhc2ljU3R5bGUobmV3U3R5bGUsIHRoaXMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHNoYXBlXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gICAgaWYgKHRoaXMuX3N0YXRlU3RhY2sgJiYgdGhpcy5fc3RhdGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5fc3RhdGVTdGFja1swXVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICAvLyB0eXBlOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsXG4gICAgICAvLyBOT1RFOiBJIHdhbnRlZCB0byB1c2UgdGhlIGFib3ZlIGNhbGwsIHdoaWNoIHdvdWxkIGtlZXAgdGhlIHR5cGVcbiAgICAgIC8vIGNvbnNpc3RlbnQgd2l0aCB0aGUgbmFtZSBvZiB0aGUgY2xhc3MsIGJ1dCB0aGlzIGlzbid0IGFsd2F5c1xuICAgICAgLy8gdGhlIGNhc2UsIGFzIHdhcyBmb3VuZCBvdXQgYSBmZXcgdGltZXMgd2hlbiB0cnlpbmcgdG8gYWRkXG4gICAgICAvLyB0aGlzIHRvIGltbWVyc2VcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSxcbiAgICAgIHpJbmRleDogc3RhdGUuekluZGV4XG4gICAgfSwgQmFzaWNTdHlsZS50b0pTT04oc3RhdGUpLCBUcmFuc2Zvcm0yZC50b0pTT04odGhpcykpXG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyZXMgdHdvIHNoYXBlcywgdXN1YWxseSB1c2VkIHRvIHNvcnQgdGhlIHNoYXBlcyBmb3IgZHJhd2luZ1xuICAgKiBAcGFyYW0gIHtCYXNlU2hhcGV9IHNoYXBlMVxuICAgKiBAcGFyYW0gIHtCYXNlU2hhcGV9IHNoYXBlMlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICBSZXR1cm5zIDwgMCBpZiBzaGFwZTEgPCBzaGFwZTIsID4gMCBpZiBzaGFwZTEgPiBzaGFwZTIsIDAgaWYgc2hhcGUxID09PSBzaGFwZTJcbiAgICovXG4gIHN0YXRpYyBzaGFwZUNvbXBhcmUoc2hhcGUxLCBzaGFwZTIpIHtcbiAgICBjb25zdCB6SW5kZXgxID0gc2hhcGUxLnpJbmRleFxuICAgIGNvbnN0IHpJbmRleDIgPSBzaGFwZTIuekluZGV4XG4gICAgaWYgKHpJbmRleDEgPCB6SW5kZXgyKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9IGVsc2UgaWYgKHpJbmRleDEgPiB6SW5kZXgyKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGxldCBydG4gPSBGaWxsU3R5bGUuY29tcGFyZUZpbGxTdHlsZShzaGFwZTEsIHNoYXBlMilcbiAgICBpZiAoIXJ0bikge1xuICAgICAgcnRuID0gU3Ryb2tlU3R5bGUuY29tcGFyZVN0cm9rZVN0eWxlKHNoYXBlMSwgc2hhcGUyKVxuICAgIH1cblxuICAgIHJldHVybiBydG5cbiAgfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaGFwZXMvYmFzZS1zaGFwZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/*\n **  Aggregation -- Aggregation of Base Class and Mixin Classes\n **  Copyright (c) 2015 Ralf S. Engelschall <rse@engelschall.com>\n **\n **  Permission is hereby granted, free of charge, to any person obtaining\n **  a copy of this software and associated documentation files (the\n **  \"Software\"), to deal in the Software without restriction, including\n **  without limitation the rights to use, copy, modify, merge, publish,\n **  distribute, sublicense, and/or sell copies of the Software, and to\n **  permit persons to whom the Software is furnished to do so, subject to\n **  the following conditions:\n **\n **  The above copyright notice and this permission notice shall be included\n **  in all copies or substantial portions of the Software.\n **\n **  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n **  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n **  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n **  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n **  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n **  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n **  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*  ==== ECMAScript 6 variant ====  */\n\n/**\n * Creates a new class constructor function using an optional base class\n * and an optional list of mixins. If mixins need initializing, then\n * they should contain an 'initializer' member function\n * @param  {function}    base   base class construct function, if null, a bare-bones\n *                              base class is used by default\n * @param  {...[function]} mixins mixin classes\n * @return {function}           new class constructor function\n */\nvar aggregation = function aggregation(base) {\n  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n\n  /*  create aggregation class  */\n  var aggregate = base ? function (_base) {\n    _inherits(__Aggregate, _base);\n\n    function __Aggregate() {\n      var _ref;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _classCallCheck(this, __Aggregate);\n\n      /*  call mixin's initializer  */\n      var _this = _possibleConstructorReturn(this, (_ref = __Aggregate.__proto__ || Object.getPrototypeOf(__Aggregate)).call.apply(_ref, [this].concat(args)));\n      /*  call base class constructor  */\n\n\n      mixins.forEach(function (mixin) {\n        if (typeof mixin.prototype.initializer === \"function\") {\n          var _mixin$prototype$init;\n\n          (_mixin$prototype$init = mixin.prototype.initializer).call.apply(_mixin$prototype$init, [_this].concat(args));\n        }\n      });\n      return _this;\n    }\n\n    return __Aggregate;\n  }(base) : function () {/* do nothing */};\n\n  /*  copy properties  */\n  var copyProps = function copyProps(target, source) {\n    Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source)).forEach(function (prop) {\n      if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)) {\n        return;\n      }\n      if (base && prop.match(/^(?:initializer)$/)) {\n        return;\n      }\n      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n    });\n  };\n\n  /*  copy all properties of all mixins into aggregation class  */\n  mixins.forEach(function (mixin) {\n    copyProps(aggregate.prototype, mixin.prototype);\n    copyProps(aggregate, mixin);\n  });\n\n  return aggregate;\n};\n\nexports.default = aggregation;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2FnZ3JlZ2F0aW9uLmpzP2I4ODAiXSwibmFtZXMiOlsiYWdncmVnYXRpb24iLCJiYXNlIiwibWl4aW5zIiwiYWdncmVnYXRlIiwiYXJncyIsImZvckVhY2giLCJtaXhpbiIsInByb3RvdHlwZSIsImluaXRpYWxpemVyIiwiY2FsbCIsImNvcHlQcm9wcyIsInRhcmdldCIsInNvdXJjZSIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wIiwibWF0Y2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7QUFFQTs7Ozs7Ozs7O0FBU0EsSUFBTUEsY0FBYyxTQUFkQSxXQUFjLENBQUNDLElBQUQsRUFBcUI7QUFBQSxvQ0FBWEMsTUFBVztBQUFYQSxVQUFXO0FBQUE7O0FBRXZDO0FBQ0EsTUFBTUMsWUFBYUY7QUFBQTs7QUFDakIsMkJBQXFCO0FBQUE7O0FBQUEseUNBQU5HLElBQU07QUFBTkEsWUFBTTtBQUFBOztBQUFBOztBQUluQjtBQUptQix1SkFFVkEsSUFGVTtBQUNuQjs7O0FBSUFGLGFBQU9HLE9BQVAsQ0FBZSxVQUFDQyxLQUFELEVBQVc7QUFDeEIsWUFBSSxPQUFPQSxNQUFNQyxTQUFOLENBQWdCQyxXQUF2QixLQUF1QyxVQUEzQyxFQUF1RDtBQUFBOztBQUFFLHlDQUFNRCxTQUFOLENBQWdCQyxXQUFoQixFQUE0QkMsSUFBNUIsNkNBQTBDTCxJQUExQztBQUFpRDtBQUMzRyxPQUZEO0FBTG1CO0FBUXBCOztBQVRnQjtBQUFBLElBQWlDSCxJQUFqQyxJQVVmLFlBQU0sQ0FBRSxnQkFBa0IsQ0FWOUI7O0FBWUE7QUFDQSxNQUFNUyxZQUFZLFNBQVpBLFNBQVksQ0FBQ0MsTUFBRCxFQUFTQyxNQUFULEVBQW9CO0FBQ3BDQyxXQUFPQyxtQkFBUCxDQUEyQkYsTUFBM0IsRUFDR0csTUFESCxDQUNVRixPQUFPRyxxQkFBUCxDQUE2QkosTUFBN0IsQ0FEVixFQUVHUCxPQUZILENBRVcsVUFBQ1ksSUFBRCxFQUFVO0FBQ2pCLFVBQUlBLEtBQUtDLEtBQUwsQ0FBVyxtRkFBWCxDQUFKLEVBQXFHO0FBQUU7QUFBUTtBQUMvRyxVQUFJakIsUUFBUWdCLEtBQUtDLEtBQUwsQ0FBVyxtQkFBWCxDQUFaLEVBQTZDO0FBQUU7QUFBUTtBQUN2REwsYUFBT00sY0FBUCxDQUFzQlIsTUFBdEIsRUFBOEJNLElBQTlCLEVBQW9DSixPQUFPTyx3QkFBUCxDQUFnQ1IsTUFBaEMsRUFBd0NLLElBQXhDLENBQXBDO0FBQ0QsS0FOSDtBQU9ELEdBUkQ7O0FBVUE7QUFDQWYsU0FBT0csT0FBUCxDQUFlLFVBQUNDLEtBQUQsRUFBVztBQUN4QkksY0FBVVAsVUFBVUksU0FBcEIsRUFBK0JELE1BQU1DLFNBQXJDO0FBQ0FHLGNBQVVQLFNBQVYsRUFBcUJHLEtBQXJCO0FBQ0QsR0FIRDs7QUFLQSxTQUFPSCxTQUFQO0FBQ0QsQ0FqQ0Q7O2tCQW1DZUgsVyIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqKiAgQWdncmVnYXRpb24gLS0gQWdncmVnYXRpb24gb2YgQmFzZSBDbGFzcyBhbmQgTWl4aW4gQ2xhc3Nlc1xuICoqICBDb3B5cmlnaHQgKGMpIDIwMTUgUmFsZiBTLiBFbmdlbHNjaGFsbCA8cnNlQGVuZ2Vsc2NoYWxsLmNvbT5cbiAqKlxuICoqICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqKiAgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiogIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICoqICB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiogIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICoqICBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqKiAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICoqXG4gKiogIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiogIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICoqXG4gKiogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiogIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICoqICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG4gKiogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiogIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiogIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG4gKiogIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qICA9PT09IEVDTUFTY3JpcHQgNiB2YXJpYW50ID09PT0gICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2luZyBhbiBvcHRpb25hbCBiYXNlIGNsYXNzXG4gKiBhbmQgYW4gb3B0aW9uYWwgbGlzdCBvZiBtaXhpbnMuIElmIG1peGlucyBuZWVkIGluaXRpYWxpemluZywgdGhlblxuICogdGhleSBzaG91bGQgY29udGFpbiBhbiAnaW5pdGlhbGl6ZXInIG1lbWJlciBmdW5jdGlvblxuICogQHBhcmFtICB7ZnVuY3Rpb259ICAgIGJhc2UgICBiYXNlIGNsYXNzIGNvbnN0cnVjdCBmdW5jdGlvbiwgaWYgbnVsbCwgYSBiYXJlLWJvbmVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgY2xhc3MgaXMgdXNlZCBieSBkZWZhdWx0XG4gKiBAcGFyYW0gIHsuLi5bZnVuY3Rpb25dfSBtaXhpbnMgbWl4aW4gY2xhc3Nlc1xuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICBuZXcgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqL1xuY29uc3QgYWdncmVnYXRpb24gPSAoYmFzZSwgLi4ubWl4aW5zKSA9PiB7XG5cbiAgLyogIGNyZWF0ZSBhZ2dyZWdhdGlvbiBjbGFzcyAgKi9cbiAgY29uc3QgYWdncmVnYXRlID0gKGJhc2UgPyBjbGFzcyBfX0FnZ3JlZ2F0ZSBleHRlbmRzIGJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIC8qICBjYWxsIGJhc2UgY2xhc3MgY29uc3RydWN0b3IgICovXG4gICAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgICAvKiAgY2FsbCBtaXhpbidzIGluaXRpYWxpemVyICAqL1xuICAgICAgbWl4aW5zLmZvckVhY2goKG1peGluKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbWl4aW4ucHJvdG90eXBlLmluaXRpYWxpemVyID09PSBcImZ1bmN0aW9uXCIpIHsgbWl4aW4ucHJvdG90eXBlLmluaXRpYWxpemVyLmNhbGwodGhpcywgLi4uYXJncykgfVxuICAgICAgfSlcbiAgICB9XG4gIH0gOiAoKSA9PiB7IC8qIGRvIG5vdGhpbmcgKi8gfSlcblxuICAvKiAgY29weSBwcm9wZXJ0aWVzICAqL1xuICBjb25zdCBjb3B5UHJvcHMgPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKSlcbiAgICAgIC5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wLm1hdGNoKC9eKD86Y29uc3RydWN0b3J8cHJvdG90eXBlfGFyZ3VtZW50c3xjYWxsZXJ8bmFtZXxiaW5kfGNhbGx8YXBwbHl8dG9TdHJpbmd8bGVuZ3RoKSQvKSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAoYmFzZSAmJiBwcm9wLm1hdGNoKC9eKD86aW5pdGlhbGl6ZXIpJC8pKSB7IHJldHVybiB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wKSlcbiAgICAgIH0pXG4gIH1cblxuICAvKiAgY29weSBhbGwgcHJvcGVydGllcyBvZiBhbGwgbWl4aW5zIGludG8gYWdncmVnYXRpb24gY2xhc3MgICovXG4gIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xuICAgIGNvcHlQcm9wcyhhZ2dyZWdhdGUucHJvdG90eXBlLCBtaXhpbi5wcm90b3R5cGUpXG4gICAgY29weVByb3BzKGFnZ3JlZ2F0ZSwgbWl4aW4pXG4gIH0pXG5cbiAgcmV0dXJuIGFnZ3JlZ2F0ZVxufVxuXG5leHBvcnQgZGVmYXVsdCBhZ2dyZWdhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdXRpbC9hZ2dyZWdhdGlvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aggregation2 = __webpack_require__(8);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _fillStyle = __webpack_require__(18);\n\nvar _fillStyle2 = _interopRequireDefault(_fillStyle);\n\nvar _strokeStyle = __webpack_require__(19);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @class  Basic shape style for a 2d rendering context\n * @extends {FillStyle}\n * @extends {StrokeStyle}\n */\nvar BasicStyle = function (_aggregation) {\n  _inherits(BasicStyle, _aggregation);\n\n  function BasicStyle() {\n    _classCallCheck(this, BasicStyle);\n\n    return _possibleConstructorReturn(this, (BasicStyle.__proto__ || Object.getPrototypeOf(BasicStyle)).apply(this, arguments));\n  }\n\n  _createClass(BasicStyle, null, [{\n    key: \"copyBasicStyle\",\n\n    /**\n     * Copies the properties from one BasicStyle to another\n     * @param  {BasicStyle} srcBasicStyle The style to copy from\n     * @param  {BasicStyle} dstBasicStyle The style to copy to\n     */\n    value: function copyBasicStyle(srcBasicStyle, dstBasicStyle) {\n      _fillStyle2.default.copyFillStyle(srcBasicStyle, dstBasicStyle);\n      _strokeStyle2.default.copyStrokeStyle(srcBasicStyle, dstBasicStyle);\n    }\n\n    /**\n     * Converts a BasicStyle instance to a JSON object\n     * @param  {BasicStyle} basicStyleObj\n     * @return {{fillColor   : string,\n     *           strokeColor : string,\n     *           strokeWidth : number,\n     *           lineJoin    : string,\n     *           lineCap     : string,\n     *           dashPattern : number[],\n     *           dashOffset  : number\n     *          }}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(basicStyleObj) {\n      return Object.assign(_fillStyle2.default.toJSON(basicStyleObj), _strokeStyle2.default.toJSON(basicStyleObj));\n    }\n  }]);\n\n  return BasicStyle;\n}((0, _aggregation3.default)(function BaseBasicStyle() {\n  _classCallCheck(this, BaseBasicStyle);\n}, _fillStyle2.default, _strokeStyle2.default));\n\nexports.default = BasicStyle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9iYXNpYy1zdHlsZS5qcz9kNTU5Il0sIm5hbWVzIjpbIkJhc2ljU3R5bGUiLCJzcmNCYXNpY1N0eWxlIiwiZHN0QmFzaWNTdHlsZSIsImNvcHlGaWxsU3R5bGUiLCJjb3B5U3Ryb2tlU3R5bGUiLCJiYXNpY1N0eWxlT2JqIiwiT2JqZWN0IiwiYXNzaWduIiwidG9KU09OIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7QUFFQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7OztJQUtxQkEsVTs7Ozs7Ozs7Ozs7O0FBQ25COzs7OzttQ0FLc0JDLGEsRUFBZUMsYSxFQUFlO0FBQ2xELDBCQUFVQyxhQUFWLENBQXdCRixhQUF4QixFQUF1Q0MsYUFBdkM7QUFDQSw0QkFBWUUsZUFBWixDQUE0QkgsYUFBNUIsRUFBMkNDLGFBQTNDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OzsyQkFZY0csYSxFQUFlO0FBQzNCLGFBQU9DLE9BQU9DLE1BQVAsQ0FBYyxvQkFBVUMsTUFBVixDQUFpQkgsYUFBakIsQ0FBZCxFQUErQyxzQkFBWUcsTUFBWixDQUFtQkgsYUFBbkIsQ0FBL0MsQ0FBUDtBQUNEOzs7O0VBekJxQztBQUFBO0FBQUEsOEM7O2tCQUFuQkwsVSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCBGaWxsU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2ZpbGwtc3R5bGVcIlxuaW1wb3J0IFN0cm9rZVN0eWxlIGZyb20gXCIuLi9zdHlsZS9zdHJva2Utc3R5bGVcIlxuXG4vKipcbiAqIEBjbGFzcyAgQmFzaWMgc2hhcGUgc3R5bGUgZm9yIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBleHRlbmRzIHtGaWxsU3R5bGV9XG4gKiBAZXh0ZW5kcyB7U3Ryb2tlU3R5bGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljU3R5bGUgZXh0ZW5kcyBhZ2dyZWdhdGlvbihjbGFzcyBCYXNlQmFzaWNTdHlsZSB7fSwgRmlsbFN0eWxlLCBTdHJva2VTdHlsZSkge1xuICAvKipcbiAgICogQ29waWVzIHRoZSBwcm9wZXJ0aWVzIGZyb20gb25lIEJhc2ljU3R5bGUgdG8gYW5vdGhlclxuICAgKiBAcGFyYW0gIHtCYXNpY1N0eWxlfSBzcmNCYXNpY1N0eWxlIFRoZSBzdHlsZSB0byBjb3B5IGZyb21cbiAgICogQHBhcmFtICB7QmFzaWNTdHlsZX0gZHN0QmFzaWNTdHlsZSBUaGUgc3R5bGUgdG8gY29weSB0b1xuICAgKi9cbiAgc3RhdGljIGNvcHlCYXNpY1N0eWxlKHNyY0Jhc2ljU3R5bGUsIGRzdEJhc2ljU3R5bGUpIHtcbiAgICBGaWxsU3R5bGUuY29weUZpbGxTdHlsZShzcmNCYXNpY1N0eWxlLCBkc3RCYXNpY1N0eWxlKVxuICAgIFN0cm9rZVN0eWxlLmNvcHlTdHJva2VTdHlsZShzcmNCYXNpY1N0eWxlLCBkc3RCYXNpY1N0eWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQmFzaWNTdHlsZSBpbnN0YW5jZSB0byBhIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSAge0Jhc2ljU3R5bGV9IGJhc2ljU3R5bGVPYmpcbiAgICogQHJldHVybiB7e2ZpbGxDb2xvciAgIDogc3RyaW5nLFxuICAgKiAgICAgICAgICAgc3Ryb2tlQ29sb3IgOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBzdHJva2VXaWR0aCA6IG51bWJlcixcbiAgICogICAgICAgICAgIGxpbmVKb2luICAgIDogc3RyaW5nLFxuICAgKiAgICAgICAgICAgbGluZUNhcCAgICAgOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBkYXNoUGF0dGVybiA6IG51bWJlcltdLFxuICAgKiAgICAgICAgICAgZGFzaE9mZnNldCAgOiBudW1iZXJcbiAgICogICAgICAgICAgfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oYmFzaWNTdHlsZU9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKEZpbGxTdHlsZS50b0pTT04oYmFzaWNTdHlsZU9iaiksIFN0cm9rZVN0eWxlLnRvSlNPTihiYXNpY1N0eWxlT2JqKSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvYmFzaWMtc3R5bGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _glMatrix = __webpack_require__(1);\n\n/**\n * Returns the Z coordinate of a 2D crossproduct\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    z coord of the 2D crossproduct\n */\n_glMatrix.vec2.cross2d = function (v1, v2) {\n  return v1[0] * v2[1] - v1[1] * v2[0];\n};\n\n/**\n * Calculates the angle between two vectors when directionality\n * is unnecessary (only returns an angle between 0 and PI, inclusive)\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    The angle between two vectors in radians [0, PI]\n */\n_glMatrix.vec2.angleFast = function (v1, v2) {\n  return Math.acos(_glMatrix.vec2.dot(v1, v2));\n};\n\n/**\n * Returns the true angle between two vectors\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    The angle between two vectors in radians [-PI, PI]\n */\n_glMatrix.vec2.angle = function (v1, v2) {\n  var c = _glMatrix.vec2.dot(v1, v2);\n  var s = _glMatrix.vec2.cross2d(v1, v2);\n  var angle = Math.atan2(s, c);\n  return angle;\n};\n\n/**\n * Returns the angle of a vector from the positive X direction\n * in a cartesian coordinate system\n * @param  {Vec2d} v1\n * @return {Number}    The angle in radians [-PI, PI]\n */\n_glMatrix.vec2.anglePosX = function (v) {\n  var angle = Math.atan2(v[1], v[0]);\n  if (angle < 0) {\n    angle *= -1;\n  }\n  return angle;\n};\n\nexports.default = _glMatrix.vec2;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL3ZlYzJkLmpzPzhkZDMiXSwibmFtZXMiOlsiY3Jvc3MyZCIsInYxIiwidjIiLCJhbmdsZUZhc3QiLCJNYXRoIiwiYWNvcyIsImRvdCIsImFuZ2xlIiwiYyIsInMiLCJhdGFuMiIsImFuZ2xlUG9zWCIsInYiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQTs7QUFFQTs7Ozs7O0FBTUEsZUFBTUEsT0FBTixHQUFnQixVQUFDQyxFQUFELEVBQUtDLEVBQUw7QUFBQSxTQUFZRCxHQUFHLENBQUgsSUFBUUMsR0FBRyxDQUFILENBQVIsR0FBZ0JELEdBQUcsQ0FBSCxJQUFRQyxHQUFHLENBQUgsQ0FBcEM7QUFBQSxDQUFoQjs7QUFFQTs7Ozs7OztBQU9BLGVBQU1DLFNBQU4sR0FBa0IsVUFBQ0YsRUFBRCxFQUFLQyxFQUFMO0FBQUEsU0FBWUUsS0FBS0MsSUFBTCxDQUFVLGVBQU1DLEdBQU4sQ0FBVUwsRUFBVixFQUFjQyxFQUFkLENBQVYsQ0FBWjtBQUFBLENBQWxCOztBQUVBOzs7Ozs7QUFNQSxlQUFNSyxLQUFOLEdBQWMsVUFBQ04sRUFBRCxFQUFLQyxFQUFMLEVBQVk7QUFDeEIsTUFBTU0sSUFBSSxlQUFNRixHQUFOLENBQVVMLEVBQVYsRUFBY0MsRUFBZCxDQUFWO0FBQ0EsTUFBTU8sSUFBSSxlQUFNVCxPQUFOLENBQWNDLEVBQWQsRUFBa0JDLEVBQWxCLENBQVY7QUFDQSxNQUFNSyxRQUFRSCxLQUFLTSxLQUFMLENBQVdELENBQVgsRUFBY0QsQ0FBZCxDQUFkO0FBQ0EsU0FBT0QsS0FBUDtBQUNELENBTEQ7O0FBT0E7Ozs7OztBQU1BLGVBQU1JLFNBQU4sR0FBa0IsYUFBSztBQUNyQixNQUFJSixRQUFRSCxLQUFLTSxLQUFMLENBQVdFLEVBQUUsQ0FBRixDQUFYLEVBQWlCQSxFQUFFLENBQUYsQ0FBakIsQ0FBWjtBQUNBLE1BQUlMLFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGFBQVMsQ0FBQyxDQUFWO0FBQ0Q7QUFDRCxTQUFPQSxLQUFQO0FBQ0QsQ0FORCIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCB7dmVjMiBhcyBWZWMyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbi8qKlxuICogUmV0dXJucyB0aGUgWiBjb29yZGluYXRlIG9mIGEgMkQgY3Jvc3Nwcm9kdWN0XG4gKiBAcGFyYW0gIHtWZWMyZH0gdjFcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MlxuICogQHJldHVybiB7TnVtYmVyfSAgICB6IGNvb3JkIG9mIHRoZSAyRCBjcm9zc3Byb2R1Y3RcbiAqL1xuVmVjMmQuY3Jvc3MyZCA9ICh2MSwgdjIpID0+IHYxWzBdICogdjJbMV0gLSB2MVsxXSAqIHYyWzBdXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyB3aGVuIGRpcmVjdGlvbmFsaXR5XG4gKiBpcyB1bm5lY2Vzc2FyeSAob25seSByZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gMCBhbmQgUEksIGluY2x1c2l2ZSlcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MVxuICogQHBhcmFtICB7VmVjMmR9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGluIHJhZGlhbnMgWzAsIFBJXVxuICovXG5WZWMyZC5hbmdsZUZhc3QgPSAodjEsIHYyKSA9PiBNYXRoLmFjb3MoVmVjMmQuZG90KHYxLCB2MikpXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJ1ZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzXG4gKiBAcGFyYW0gIHtWZWMyZH0gdjFcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MlxuICogQHJldHVybiB7TnVtYmVyfSAgICBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyBpbiByYWRpYW5zIFstUEksIFBJXVxuICovXG5WZWMyZC5hbmdsZSA9ICh2MSwgdjIpID0+IHtcbiAgY29uc3QgYyA9IFZlYzJkLmRvdCh2MSwgdjIpXG4gIGNvbnN0IHMgPSBWZWMyZC5jcm9zczJkKHYxLCB2MilcbiAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHMsIGMpXG4gIHJldHVybiBhbmdsZVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHBvc2l0aXZlIFggZGlyZWN0aW9uXG4gKiBpbiBhIGNhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICogQHBhcmFtICB7VmVjMmR9IHYxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBpbiByYWRpYW5zIFstUEksIFBJXVxuICovXG5WZWMyZC5hbmdsZVBvc1ggPSB2ID0+IHtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih2WzFdLCB2WzBdKVxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKj0gLTFcbiAgfVxuICByZXR1cm4gYW5nbGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVjMmRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvdmVjMmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(7);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _math = __webpack_require__(6);\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _convexHull = __webpack_require__(15);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar identityMatrix = _glMatrix.mat2d.create();\n\n/**\n * Expands an axis-aligned bounding box to encapsulate a 2d vertex\n * defined in an array of vertices, and updates a struct used to\n * store the indices of the vertices that define the final bounds\n * of the vertices\n * @param  {AABox2d} box          Bounds to expand\n * @param  {Point2d} pt           2d vertex to encapsulate\n * @param  {number} ptIdx         Index of the vertex in its list of vertices\n * @param  {number[]} extentIndices Struct to store the indices of the bounding vertices\n * @private\n */\nfunction aaboxEncapsulatePt(box, pt, ptIdx, extentIndices) {\n  if (AABox2d.isEmpty(box)) {\n    box[0] = pt[0];\n    box[2] = pt[0];\n    extentIndices[0] = extentIndices[2] = ptIdx;\n    box[1] = pt[1];\n    box[3] = pt[1];\n    extentIndices[1] = extentIndices[3] = ptIdx;\n  } else {\n    if (pt[0] < box[0]) {\n      box[0] = pt[0];\n      extentIndices[0] = ptIdx;\n    } else if (pt[0] > box[2]) {\n      box[2] = pt[0];\n      extentIndices[2] = ptIdx;\n    }\n\n    if (pt[1] < box[1]) {\n      box[1] = pt[1];\n      extentIndices[1] = ptIdx;\n    } else if (pt[1] > box[3]) {\n      box[3] = pt[1];\n      extentIndices[3] = ptIdx;\n    }\n  }\n}\n\n/**\n * Function called sequentially to calculate the centroid of a polygon\n * @param  {Point2d} centroidPt Current centroid point\n * @param  {Point2d} pt1        Point describing one end of an edge of a polygon\n * @param  {Point2d} pt2        Point describing other end of an edge of a polygon\n * @private\n */\nfunction buildCentroid(centroidPt, pt1, pt2) {\n  var a = pt1[0] * pt2[1] - pt2[0] * pt1[1];\n  centroidPt[0] += (pt1[0] + pt2[0]) * a;\n  centroidPt[1] += (pt1[1] + pt2[1]) * a;\n  return a;\n}\n\n/**\n * Utility function used to check whether an argument is an array\n * of an arraybuffer\n * @param  {}  obj\n * @return {Boolean}     Returns true if object is array-like\n */\nfunction isArray(obj) {\n  return Array.isArray(obj) || ArrayBuffer && ArrayBuffer.isView(obj);\n}\n\n/**\n * @typedef {object} PolyLineOptions\n * @property {number[]|Point2d[]} [verts=[]] Initial vertices of the polyline\n */\n\n/**\n * @class Class defining a poly line\n * @extends {BaseShape}\n */\n\nvar PolyLine = function (_BaseShape) {\n  _inherits(PolyLine, _BaseShape);\n\n  /**\n   * Creates a new poly line shape\n   * @param  {PolyLineOptions} [opts] [description]\n   * @return {PolyLine}\n   */\n  function PolyLine(opts) {\n    _classCallCheck(this, PolyLine);\n\n    var verts = opts.verts || [];\n\n    var _this = _possibleConstructorReturn(this, (PolyLine.__proto__ || Object.getPrototypeOf(PolyLine)).call(this, opts));\n\n    if (!isArray(verts) || verts.length === 0 || isArray(verts[0]) && verts.length < 1 || !isArray(verts[0]) && (verts.length < 2 || verts.length % 2 !== 0)) {\n      throw new Error(\"PolyLine shapes must be initialized with an array of 2d points and contain at least 1 points\");\n    }\n\n    // going to build the aabox and store the indices for each vertex\n    // that defines the bounds\n    _this._extentIndices = [-1, -1, -1, -1];\n    _this._localaabox = AABox2d.create();\n    _this._verts = [];\n    _this._centroid = [0, 0];\n    AABox2d.initEmpty(_this._aabox);\n    var signedArea = 0;\n    var i = 0;\n    if (isArray(verts[0])) {\n      for (i = 0; i < verts.length - 1; i += 1) {\n        _this._verts.push(Point2d.clone(verts[i]));\n        aaboxEncapsulatePt(_this._aabox, verts[i], i, _this._extentIndices);\n        signedArea += buildCentroid(_this._centroid, verts[i], verts[i + 1]);\n      }\n      _this._verts.push(Point2d.clone(verts[i]));\n      aaboxEncapsulatePt(_this._aabox, verts[i], i, _this._extentIndices);\n      signedArea += buildCentroid(_this._centroid, verts[i], verts[0]);\n    } else {\n      _this._verts.push(Point2d.create(verts[0], verts[1]));\n      aaboxEncapsulatePt(_this._aabox, _this._verts[0], 0, _this._extentIndices);\n      var idx = 1;\n      for (i = 2; i < verts.length - 2; i += 2, idx += 1) {\n        _this._verts.push(Point2d.create(verts[i], verts[i + 1]));\n        aaboxEncapsulatePt(_this._aabox, _this._verts[idx], idx, _this._extentIndices);\n        signedArea += buildCentroid(_this._centroid, _this._verts[idx - 1], _this._verts[idx]);\n      }\n      _this._verts.push(Point2d.create(verts[i], verts[i + 1]));\n      aaboxEncapsulatePt(_this._aabox, _this._verts[idx], idx, _this._extentIndices);\n      signedArea += buildCentroid(_this._centroid, _this._verts[idx], _this._verts[0]);\n    }\n    signedArea *= 0.5;\n    _this._centroid[0] /= 6.0 * signedArea;\n    _this._centroid[1] /= 6.0 * signedArea;\n\n    // extract the center of the aabox. We are going to use this as the\n    // shape's pivot, so all rotation/scale transformations will be sourced\n    // at this location\n    var pivot = Point2d.create();\n    AABox2d.getCenter(pivot, _this._aabox);\n    _this.pivot = pivot;\n\n    // now build the convex hull of the vertices.\n    // When rebuilding the axis aligned box (a transform is applied for example),\n    // there's no need to traverse all the points. All we need to do is traverse\n    // the points that define the convex hull to rebuild the bounds\n    if (_this._verts.length < 3) {\n      _this._convexHull = _this._verts.map(function (val, idx) {\n        return idx;\n      });\n    } else {\n      _this._convexHull = (0, _convexHull.simpleHull_2D)(_this._verts);\n    }\n    return _this;\n  }\n\n  /**\n   * Get the untransformed width/height of the polyline. This is essentially\n   * the width/height of the poly's bounds\n   * @return {Vec2d} Width/height of the bounds of the polyline\n   */\n\n\n  _createClass(PolyLine, [{\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return [this.width, this.height];\n    }\n\n    /**\n     * Get the untransformed width of the polyline. This is the width of the\n     * axis-aligned bounds of the poly\n     * @return {number} Width of the poly in world-space units\n     */\n\n  }, {\n    key: \"_collapseVerts\",\n\n\n    /**\n     * Utility function that collapses all the verts, meaning the verts\n     * are flattened to their position with local-space transforms applied\n     * and then the local transforms are cleared. This is done whenever\n     * the vertices of the polygon are modified as it can be a little tricky\n     * to re-adjust the pivot/transforms of the vert when new verts are added,\n     * deleted, etc.\n     * @return {boolean} Returns true if the points were indeed flattened\n     *                   The points wouldn't be flattened if there are no\n     *                   transforms to apply, for example\n     * @private\n     */\n    value: function _collapseVerts() {\n      var _this2 = this;\n\n      Point2d.set(this._pivot, 0, 0);\n\n      // TODO(croot): what if this poly is\n      // parented to another transform?\n\n      var xform = this.localXform;\n      if (_glMatrix.mat2d.equals(xform, identityMatrix)) {\n        // if there are no transforms to apply,\n        // do nothing - fast out\n        return false;\n      }\n\n      AABox2d.initEmpty(this._aabox);\n\n      // flatten all the points to their current world-space position\n      // with transforms applied\n      for (var i = 0; i < this._verts.length; i += 1) {\n        Point2d.transformMat2d(this._verts[i], this._verts[i], xform);\n      }\n\n      // now recalcute the convex hull of all the transformed points\n      if (this._verts.length < 3) {\n        this._convexHull = this._verts.map(function (val, idx) {\n          return idx;\n        });\n      } else {\n        this._convexHull = (0, _convexHull.simpleHull_2D)(this._verts);\n      }\n      // use the convex hull points to rebuild the bounds\n      this._convexHull.forEach(function (idx) {\n        aaboxEncapsulatePt(_this2._aabox, _this2._verts[idx], idx, _this2._extentIndices);\n      });\n\n      // reset the local transforms\n      this.setTransformations(0, 0, 1, 1, 0);\n\n      return true;\n    }\n\n    /**\n     * Translates a specific vertex of the polygon by an offset\n     * @param  {number} vertIndex Index of the vertex to translate\n     * @param  {Vec2d} t         Translation offset, in world-space units\n     * @return {PolyLine}           this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If vertIndex is invalid.\n     */\n\n  }, {\n    key: \"translateVert\",\n    value: function translateVert(vertIndex, t) {\n      if (vertIndex >= this._verts.length) {\n        throw new Error(\"Cannot translate vertex at index \" + vertIndex + \". There are only \" + this._verts.length + \" vertices in the polygon.\");\n      }\n\n      if (t[0] || t[1]) {\n        var prev = Point2d.clone(this._verts[vertIndex]);\n        var newPt = Point2d.clone(this._verts[vertIndex]);\n        Point2d.addVec2(newPt, newPt, t);\n\n        // TODO(croot): this could be made smarter by determining whether\n        // this point affects the convex hull or not by checking it's relationship\n        // with its neighbors\n        this._collapseVerts();\n        this._resetAABox = true;\n        this._geomDirty = true;\n        Point2d.copy(newPt);\n        this.fire(\"changed:geom\", {\n          attr: \"verts[\" + vertIndex + \"]\",\n          prevVal: prev,\n          currVal: newPt\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"setVertPosition\",\n    value: function setVertPosition(vertIndex, pos) {\n      if (vertIndex >= this._verts.length) {\n        throw new Error(\"Cannot translate vertex at index \" + vertIndex + \". There are only \" + this._verts.length + \" vertices in the polygon.\");\n      }\n\n      if (!Point2d.equals(pos, this._verts[vertIndex])) {\n        var prev = Point2d.clone(this._verts[vertIndex]);\n        this._collapseVerts();\n        Point2d.copy(this._verts[vertIndex], pos);\n\n        // TODO(croot): this could be made smarter by determining whether\n        // this point affects the convex hull or not by checking it's relationship\n        // with its neighbors\n        this._resetAABox = true;\n        this._geomDirty = true;\n        this.fire(\"changed:geom\", {\n          attr: \"verts[\" + vertIndex + \"]\",\n          prevVal: prev,\n          currVal: pos\n        });\n      }\n    }\n  }, {\n    key: \"insertVert\",\n    value: function insertVert(vertIndex, pos) {\n      var idx = _math2.default.min(_math2.default.max(vertIndex, 0), this._verts.length);\n      this._collapseVerts();\n      if (vertIndex >= this._verts.length) {\n        this._verts.push(Point2d.clone(pos));\n        idx = this._verts.length - 1;\n      } else {\n        this._verts.splice(vertIndex, 0, Point2d.clone(pos));\n      }\n      this._resetAABox = true;\n      this._geomDirty = true;\n\n      this.fire(\"changed:geom:addvert\", {\n        attr: \"verts[\" + idx + \"]\",\n        currVal: pos\n      });\n\n      return idx;\n    }\n  }, {\n    key: \"appendVert\",\n    value: function appendVert(pos) {\n      return this.insertVert(this._verts.length, pos);\n    }\n  }, {\n    key: \"removeVert\",\n    value: function removeVert(vertIndex) {\n      if (vertIndex >= this._verts.length || vertIndex < 0) {\n        throw new Error(\"Cannot remove vertex \" + vertIndex + \". Invalid index. There are only \" + this._verts.length + \" vertices in the shape.\");\n      }\n\n      var pos = this._verts[vertIndex];\n      this._verts.splice(vertIndex, 1);\n      this._collapseVerts();\n      this._resetAABox = true;\n      this._geomDirty = true;\n\n      this.fire(\"changed:geom:removevert\", {\n        attr: \"verts[\" + vertIndex + \"]\",\n        currVal: pos\n      });\n\n      return vertIndex;\n    }\n  }, {\n    key: \"_rebuildAABox\",\n    value: function _rebuildAABox() {\n      var _this3 = this;\n\n      AABox2d.initEmpty(this._aabox);\n      if (this._verts.length < 3) {\n        this._convexHull = this._verts.map(function (val, idx) {\n          return idx;\n        });\n      } else {\n        this._convexHull = (0, _convexHull.simpleHull_2D)(this._verts);\n      }\n      this._convexHull.forEach(function (idx) {\n        aaboxEncapsulatePt(_this3._aabox, _this3._verts[idx], idx, _this3._extentIndices);\n      });\n\n      var pivot = Point2d.create(0, 0);\n      AABox2d.getCenter(pivot, this._aabox);\n      this.pivot = pivot;\n    }\n  }, {\n    key: \"_updateAABox\",\n    value: function _updateAABox() {\n      var _this4 = this;\n\n      if (this._resetAABox) {\n        this._rebuildAABox();\n        this._resetAABox = false;\n      }\n\n      if (this._boundsOutOfDate || this._geomDirty) {\n        AABox2d.initEmpty(this._aabox);\n        var tmppt = [0, 0];\n        var xform = this.globalXform;\n        this._convexHull.forEach(function (idx) {\n          AABox2d.encapsulatePt(_this4._aabox, _this4._aabox, Point2d.transformMat2d(tmppt, _this4._verts[idx], xform));\n        });\n        this._boundsOutOfDate = false;\n\n        if (this._geomDirty) {\n          var pivot = Point2d.create();\n          pivot[0] = this._verts[this._extentIndices[0]][0] + 0.5 * (this._verts[this._extentIndices[2]][0] - this._verts[this._extentIndices[0]][0]);\n          pivot[1] = this._verts[this._extentIndices[1]][1] + 0.5 * (this._verts[this._extentIndices[3]][1] - this._verts[this._extentIndices[1]][1]);\n          this.pivot = pivot;\n          this._geomDirty = false;\n        }\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      var rtn = false;\n      if (this._verts.length >= 2) {\n        ctx.moveTo(this._verts[0][0], this._verts[0][1]);\n        for (var i = 1; i < this._verts.length; i += 1) {\n          ctx.lineTo(this._verts[i][0], this._verts[i][1]);\n        }\n        rtn = true;\n      }\n      return rtn;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"PolyLine\", // NOTE: this much match the name of the class\n        verts: this.vertsRef.map(function (vert) {\n          return [vert[0], vert[1]];\n        })\n      }, _get(PolyLine.prototype.__proto__ || Object.getPrototypeOf(PolyLine.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      this._updateAABox();\n      if (!this._verts.length || this._extentIndices[0] < 0 || this._extentIndices[2] < 0) {\n        return 0;\n      }\n\n      return this._verts[this._extentIndices[2]][0] - this._verts[this._extentIndices[0]][0];\n    }\n\n    /**\n     * Gets the untransformed height of the polyline. This is the height of the axis-aligned\n     * bounds of the poly\n     * @return {number} Height of the poly in world-space units\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      this._updateAABox();\n      if (!this._verts.length || this._extentIndices[0] < 0 || this._extentIndices[2] < 0) {\n        return 0;\n      }\n\n      return this._verts[this._extentIndices[3]][1] - this._verts[this._extentIndices[1]][1];\n    }\n\n    /**\n     * Gets a reference to the vertex array of the polyline\n     * @return {Point2d[]}\n     * @readOnly\n     */\n\n  }, {\n    key: \"vertsRef\",\n    get: function get() {\n      return this._verts;\n    }\n\n    /**\n     * Gets the number of vertices in the polyline\n     * @return {number}\n     */\n\n  }, {\n    key: \"numVerts\",\n    get: function get() {\n      return this._verts.length;\n    }\n  }]);\n\n  return PolyLine;\n}(_baseShape2.default);\n\nexports.default = PolyLine;\n\n\nPolyLine.aaboxEncapsulatePt = aaboxEncapsulatePt;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9seS1saW5lLmpzPzE4ZDQiXSwibmFtZXMiOlsiQUFCb3gyZCIsIlBvaW50MmQiLCJpZGVudGl0eU1hdHJpeCIsImNyZWF0ZSIsImFhYm94RW5jYXBzdWxhdGVQdCIsImJveCIsInB0IiwicHRJZHgiLCJleHRlbnRJbmRpY2VzIiwiaXNFbXB0eSIsImJ1aWxkQ2VudHJvaWQiLCJjZW50cm9pZFB0IiwicHQxIiwicHQyIiwiYSIsImlzQXJyYXkiLCJvYmoiLCJBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiUG9seUxpbmUiLCJvcHRzIiwidmVydHMiLCJsZW5ndGgiLCJFcnJvciIsIl9leHRlbnRJbmRpY2VzIiwiX2xvY2FsYWFib3giLCJfdmVydHMiLCJfY2VudHJvaWQiLCJpbml0RW1wdHkiLCJfYWFib3giLCJzaWduZWRBcmVhIiwiaSIsInB1c2giLCJjbG9uZSIsImlkeCIsInBpdm90IiwiZ2V0Q2VudGVyIiwiX2NvbnZleEh1bGwiLCJtYXAiLCJ2YWwiLCJ3aWR0aCIsImhlaWdodCIsInNldCIsIl9waXZvdCIsInhmb3JtIiwibG9jYWxYZm9ybSIsImVxdWFscyIsInRyYW5zZm9ybU1hdDJkIiwiZm9yRWFjaCIsInNldFRyYW5zZm9ybWF0aW9ucyIsInZlcnRJbmRleCIsInQiLCJwcmV2IiwibmV3UHQiLCJhZGRWZWMyIiwiX2NvbGxhcHNlVmVydHMiLCJfcmVzZXRBQUJveCIsIl9nZW9tRGlydHkiLCJjb3B5IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsInBvcyIsIm1pbiIsIm1heCIsInNwbGljZSIsImluc2VydFZlcnQiLCJfcmVidWlsZEFBQm94IiwiX2JvdW5kc091dE9mRGF0ZSIsInRtcHB0IiwiZ2xvYmFsWGZvcm0iLCJlbmNhcHN1bGF0ZVB0IiwiY3R4IiwicnRuIiwibW92ZVRvIiwibGluZVRvIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsInZlcnRzUmVmIiwidmVydCIs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QUFLeEQsTUFBTCxDQUFZSixNQUFiLElBQXVCLEtBQUtFLGNBQUwsQ0FBb0IsQ0FBcEIsSUFBeUIsQ0FBaEQsSUFBcUQsS0FBS0EsY0FBTCxDQUFvQixDQUFwQixJQUF5QixDQUFsRixFQUFxRjtBQUNuRixlQUFPLENBQVA7QUFDRDs7QUFFRCxhQUFPLEtBQUtFLE1BQUwsQ0FBWSxLQUFLRixjQUFMLENBQW9CLENBQXBCLENBQVosRUFBb0MsQ0FBcEMsSUFBeUMsS0FBS0UsTUFBTCxDQUFZLEtBQUtGLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBWixFQUFvQyxDQUFwQyxDQUFoRDtBQUNEOztBQUVEOzs7Ozs7Ozt3QkFLYTtBQUNYLFdBQUswRCxZQUFMO0FBQ0EsVUFBSSxDQUFDLEtBQUt4RCxNQUFMLENBQVlKLE1BQWIsSUFBdUIsS0FBS0UsY0FBTCxDQUFvQixDQUFwQixJQUF5QixDQUFoRCxJQUFxRCxLQUFLQSxjQUFMLENBQW9CLENBQXBCLElBQXlCLENBQWxGLEVBQXFGO0FBQ25GLGVBQU8sQ0FBUDtBQUNEOztBQUVELGFBQU8sS0FBS0UsTUFBTCxDQUFZLEtBQUtGLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBWixFQUFvQyxDQUFwQyxJQUF5QyxLQUFLRSxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLENBQWhEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3dCQUtlO0FBQ2IsYUFBTyxLQUFLRSxNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7d0JBSWU7QUFDYixhQUFPLEtBQUtBLE1BQUwsQ0FBWUosTUFBbkI7QUFDRDs7Ozs7O2tCQXpIa0JILFE7OztBQStVckJBLFNBQVNoQixrQkFBVCxHQUE4QkEsa0JBQTlCIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tbWFnaWMtbnVtYmVycyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gXCIuL2Jhc2Utc2hhcGUuanNcIlxuaW1wb3J0IHttYXQyZCBhcyBNYXQyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcbmltcG9ydCB7c2ltcGxlSHVsbF8yRH0gZnJvbSBcIi4uL21hdGgvY29udmV4LWh1bGxcIlxuXG5jb25zdCBpZGVudGl0eU1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG5cbi8qKlxuICogRXhwYW5kcyBhbiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IHRvIGVuY2Fwc3VsYXRlIGEgMmQgdmVydGV4XG4gKiBkZWZpbmVkIGluIGFuIGFycmF5IG9mIHZlcnRpY2VzLCBhbmQgdXBkYXRlcyBhIHN0cnVjdCB1c2VkIHRvXG4gKiBzdG9yZSB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgdGhhdCBkZWZpbmUgdGhlIGZpbmFsIGJvdW5kc1xuICogb2YgdGhlIHZlcnRpY2VzXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggICAgICAgICAgQm91bmRzIHRvIGV4cGFuZFxuICogQHBhcmFtICB7UG9pbnQyZH0gcHQgICAgICAgICAgIDJkIHZlcnRleCB0byBlbmNhcHN1bGF0ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwdElkeCAgICAgICAgIEluZGV4IG9mIHRoZSB2ZXJ0ZXggaW4gaXRzIGxpc3Qgb2YgdmVydGljZXNcbiAqIEBwYXJhbSAge251bWJlcltdfSBleHRlbnRJbmRpY2VzIFN0cnVjdCB0byBzdG9yZSB0aGUgaW5kaWNlcyBvZiB0aGUgYm91bmRpbmcgdmVydGljZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFhYm94RW5jYXBzdWxhdGVQdChib3gsIHB0LCBwdElkeCwgZXh0ZW50SW5kaWNlcykge1xuICBpZiAoQUFCb3gyZC5pc0VtcHR5KGJveCkpIHtcbiAgICBib3hbMF0gPSBwdFswXVxuICAgIGJveFsyXSA9IHB0WzBdXG4gICAgZXh0ZW50SW5kaWNlc1swXSA9IGV4dGVudEluZGljZXNbMl0gPSBwdElkeFxuICAgIGJveFsxXSA9IHB0WzFdXG4gICAgYm94WzNdID0gcHRbMV1cbiAgICBleHRlbnRJbmRpY2VzWzFdID0gZXh0ZW50SW5kaWNlc1szXSA9IHB0SWR4XG4gIH0gZWxzZSB7XG4gICAgaWYgKHB0WzBdIDwgYm94WzBdKSB7XG4gICAgICBib3hbMF0gPSBwdFswXVxuICAgICAgZXh0ZW50SW5kaWNlc1swXSA9IHB0SWR4XG4gICAgfSBlbHNlIGlmIChwdFswXSA+IGJveFsyXSkge1xuICAgICAgYm94WzJdID0gcHRbMF1cbiAgICAgIGV4dGVudEluZGljZXNbMl0gPSBwdElkeFxuICAgIH1cblxuICAgIGlmIChwdFsxXSA8IGJveFsxXSkge1xuICAgICAgYm94WzFdID0gcHRbMV1cbiAgICAgIGV4dGVudEluZGljZXNbMV0gPSBwdElkeFxuICAgIH0gZWxzZSBpZiAocHRbMV0gPiBib3hbM10pIHtcbiAgICAgIGJveFszXSA9IHB0WzFdXG4gICAgICBleHRlbnRJbmRpY2VzWzNdID0gcHRJZHhcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjYWxsZWQgc2VxdWVudGlhbGx5IHRvIGNhbGN1bGF0ZSB0aGUgY2VudHJvaWQgb2YgYSBwb2x5Z29uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBjZW50cm9pZFB0IEN1cnJlbnQgY2VudHJvaWQgcG9pbnRcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0MSAgICAgICAgUG9pbnQgZGVzY3JpYmluZyBvbmUgZW5kIG9mIGFuIGVkZ2Ugb2YgYSBwb2x5Z29uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdDIgICAgICAgIFBvaW50IGRlc2NyaWJpbmcgb3RoZXIgZW5kIG9mIGFuIGVkZ2Ugb2YgYSBwb2x5Z29uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWlsZENlbnRyb2lkKGNlbnRyb2lkUHQsIHB0MSwgcHQyKSB7XG4gIGNvbnN0IGEgPSBwdDFbMF0gKiBwdDJbMV0gLSBwdDJbMF0gKiBwdDFbMV1cbiAgY2VudHJvaWRQdFswXSArPSAocHQxWzBdICsgcHQyWzBdKSAqIGFcbiAgY2VudHJvaWRQdFsxXSArPSAocHQxWzFdICsgcHQyWzFdKSAqIGFcbiAgcmV0dXJuIGFcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgd2hldGhlciBhbiBhcmd1bWVudCBpcyBhbiBhcnJheVxuICogb2YgYW4gYXJyYXlidWZmZXJcbiAqIEBwYXJhbSAge30gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYXJyYXktbGlrZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8IChBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSlcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQb2x5TGluZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW118UG9pbnQyZFtdfSBbdmVydHM9W11dIEluaXRpYWwgdmVydGljZXMgb2YgdGhlIHBvbHlsaW5lXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQ2xhc3MgZGVmaW5pbmcgYSBwb2x5IGxpbmVcbiAqIEBleHRlbmRzIHtCYXNlU2hhcGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlMaW5lIGV4dGVuZHMgQmFzZVNoYXBlIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwb2x5IGxpbmUgc2hhcGVcbiAgICogQHBhcmFtICB7UG9seUxpbmVPcHRpb25zfSBbb3B0c10gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtQb2x5TGluZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB2ZXJ0cyA9IG9wdHMudmVydHMgfHwgW11cbiAgICBzdXBlcihvcHRzKVxuICAgIGlmICghaXNBcnJheSh2ZXJ0cykgfHxcbiAgICAgIHZlcnRzLmxlbmd0aCA9PT0gMCB8fCAoaXNBcnJheSh2ZXJ0c1swXSkgJiYgdmVydHMubGVuZ3RoIDwgMSkgfHxcbiAgICAgICghaXNBcnJheSh2ZXJ0c1swXSkgJiYgKHZlcnRzLmxlbmd0aCA8IDIgfHwgdmVydHMubGVuZ3RoICUgMiAhPT0gMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5TGluZSBzaGFwZXMgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGFycmF5IG9mIDJkIHBvaW50cyBhbmQgY29udGFpbiBhdCBsZWFzdCAxIHBvaW50c1wiKVxuICAgIH1cblxuICAgIC8vIGdvaW5nIHRvIGJ1aWxkIHRoZSBhYWJveCBhbmQgc3RvcmUgdGhlIGluZGljZXMgZm9yIGVhY2ggdmVydGV4XG4gICAgLy8gdGhhdCBkZWZpbmVzIHRoZSBib3VuZHNcbiAgICB0aGlzLl9leHRlbnRJbmRpY2VzID0gWy0xLCAtMSwgLTEsIC0xXVxuICAgIHRoaXMuX2xvY2FsYWFib3ggPSBBQUJveDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fdmVydHMgPSBbXVxuICAgIHRoaXMuX2NlbnRyb2lkID0gWzAsIDBdXG4gICAgQUFCb3gyZC5pbml0RW1wdHkodGhpcy5fYWFib3gpXG4gICAgbGV0IHNpZ25lZEFyZWEgPSAwXG4gICAgbGV0IGkgPSAwXG4gICAgaWYgKGlzQXJyYXkodmVydHNbMF0pKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jbG9uZSh2ZXJ0c1tpXSkpXG4gICAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdmVydHNbaV0sIGksIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICAgIHNpZ25lZEFyZWEgKz0gYnVpbGRDZW50cm9pZCh0aGlzLl9jZW50cm9pZCwgdmVydHNbaV0sIHZlcnRzW2kgKyAxXSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jbG9uZSh2ZXJ0c1tpXSkpXG4gICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHZlcnRzW2ldLCBpLCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgICAgc2lnbmVkQXJlYSArPSBidWlsZENlbnRyb2lkKHRoaXMuX2NlbnRyb2lkLCB2ZXJ0c1tpXSwgdmVydHNbMF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jcmVhdGUodmVydHNbMF0sIHZlcnRzWzFdKSlcbiAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdGhpcy5fdmVydHNbMF0sIDAsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICBsZXQgaWR4ID0gMVxuICAgICAgZm9yIChpID0gMjsgaSA8IHZlcnRzLmxlbmd0aCAtIDI7IGkgKz0gMiwgaWR4ICs9IDEpIHtcbiAgICAgICAgdGhpcy5fdmVydHMucHVzaChQb2ludDJkLmNyZWF0ZSh2ZXJ0c1tpXSwgdmVydHNbaSArIDFdKSlcbiAgICAgICAgYWFib3hFbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB0aGlzLl92ZXJ0c1tpZHhdLCBpZHgsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICAgIHNpZ25lZEFyZWEgKz0gYnVpbGRDZW50cm9pZCh0aGlzLl9jZW50cm9pZCwgdGhpcy5fdmVydHNbaWR4IC0gMV0sIHRoaXMuX3ZlcnRzW2lkeF0pXG4gICAgICB9XG4gICAgICB0aGlzLl92ZXJ0cy5wdXNoKFBvaW50MmQuY3JlYXRlKHZlcnRzW2ldLCB2ZXJ0c1tpICsgMV0pKVxuICAgICAgYWFib3hFbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB0aGlzLl92ZXJ0c1tpZHhdLCBpZHgsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICBzaWduZWRBcmVhICs9IGJ1aWxkQ2VudHJvaWQodGhpcy5fY2VudHJvaWQsIHRoaXMuX3ZlcnRzW2lkeF0sIHRoaXMuX3ZlcnRzWzBdKVxuICAgIH1cbiAgICBzaWduZWRBcmVhICo9IDAuNVxuICAgIHRoaXMuX2NlbnRyb2lkWzBdIC89IDYuMCAqIHNpZ25lZEFyZWFcbiAgICB0aGlzLl9jZW50cm9pZFsxXSAvPSA2LjAgKiBzaWduZWRBcmVhXG5cbiAgICAvLyBleHRyYWN0IHRoZSBjZW50ZXIgb2YgdGhlIGFhYm94LiBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoaXMgYXMgdGhlXG4gICAgLy8gc2hhcGUncyBwaXZvdCwgc28gYWxsIHJvdGF0aW9uL3NjYWxlIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHNvdXJjZWRcbiAgICAvLyBhdCB0aGlzIGxvY2F0aW9uXG4gICAgY29uc3QgcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgpXG4gICAgQUFCb3gyZC5nZXRDZW50ZXIocGl2b3QsIHRoaXMuX2FhYm94KVxuICAgIHRoaXMucGl2b3QgPSBwaXZvdFxuXG4gICAgLy8gbm93IGJ1aWxkIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgdmVydGljZXMuXG4gICAgLy8gV2hlbiByZWJ1aWxkaW5nIHRoZSBheGlzIGFsaWduZWQgYm94IChhIHRyYW5zZm9ybSBpcyBhcHBsaWVkIGZvciBleGFtcGxlKSxcbiAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhdmVyc2UgYWxsIHRoZSBwb2ludHMuIEFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRyYXZlcnNlXG4gICAgLy8gdGhlIHBvaW50cyB0aGF0IGRlZmluZSB0aGUgY29udmV4IGh1bGwgdG8gcmVidWlsZCB0aGUgYm91bmRzXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSB0aGlzLl92ZXJ0cy5tYXAoKHZhbCwgaWR4KSA9PiBpZHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSBzaW1wbGVIdWxsXzJEKHRoaXMuX3ZlcnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGgvaGVpZ2h0IG9mIHRoZSBwb2x5bGluZS4gVGhpcyBpcyBlc3NlbnRpYWxseVxuICAgKiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBwb2x5J3MgYm91bmRzXG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9oZWlnaHQgb2YgdGhlIGJvdW5kcyBvZiB0aGUgcG9seWxpbmVcbiAgICovXG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodF1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHBvbHlsaW5lLiBUaGlzIGlzIHRoZSB3aWR0aCBvZiB0aGVcbiAgICogYXhpcy1hbGlnbmVkIGJvdW5kcyBvZiB0aGUgcG9seVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSBwb2x5IGluIHdvcmxkLXNwYWNlIHVuaXRzXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgdGhpcy5fdXBkYXRlQUFCb3goKVxuICAgIGlmICghdGhpcy5fdmVydHMubGVuZ3RoIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMF0gPCAwIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMl0gPCAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzJdXVswXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMF1dWzBdXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW50cmFuc2Zvcm1lZCBoZWlnaHQgb2YgdGhlIHBvbHlsaW5lLiBUaGlzIGlzIHRoZSBoZWlnaHQgb2YgdGhlIGF4aXMtYWxpZ25lZFxuICAgKiBib3VuZHMgb2YgdGhlIHBvbHlcbiAgICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIHBvbHkgaW4gd29ybGQtc3BhY2UgdW5pdHNcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdGhpcy5fdXBkYXRlQUFCb3goKVxuICAgIGlmICghdGhpcy5fdmVydHMubGVuZ3RoIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMF0gPCAwIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMl0gPCAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzNdXVsxXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMV1dWzFdXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgdmVydGV4IGFycmF5IG9mIHRoZSBwb2x5bGluZVxuICAgKiBAcmV0dXJuIHtQb2ludDJkW119XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0IHZlcnRzUmVmKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJ0c1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgcG9seWxpbmVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG51bVZlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJ0cy5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgY29sbGFwc2VzIGFsbCB0aGUgdmVydHMsIG1lYW5pbmcgdGhlIHZlcnRzXG4gICAqIGFyZSBmbGF0dGVuZWQgdG8gdGhlaXIgcG9zaXRpb24gd2l0aCBsb2NhbC1zcGFjZSB0cmFuc2Zvcm1zIGFwcGxpZWRcbiAgICogYW5kIHRoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybXMgYXJlIGNsZWFyZWQuIFRoaXMgaXMgZG9uZSB3aGVuZXZlclxuICAgKiB0aGUgdmVydGljZXMgb2YgdGhlIHBvbHlnb24gYXJlIG1vZGlmaWVkIGFzIGl0IGNhbiBiZSBhIGxpdHRsZSB0cmlja3lcbiAgICogdG8gcmUtYWRqdXN0IHRoZSBwaXZvdC90cmFuc2Zvcm1zIG9mIHRoZSB2ZXJ0IHdoZW4gbmV3IHZlcnRzIGFyZSBhZGRlZCxcbiAgICogZGVsZXRlZCwgZXRjLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50cyB3ZXJlIGluZGVlZCBmbGF0dGVuZWRcbiAgICogICAgICAgICAgICAgICAgICAgVGhlIHBvaW50cyB3b3VsZG4ndCBiZSBmbGF0dGVuZWQgaWYgdGhlcmUgYXJlIG5vXG4gICAqICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXMgdG8gYXBwbHksIGZvciBleGFtcGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29sbGFwc2VWZXJ0cygpIHtcbiAgICBQb2ludDJkLnNldCh0aGlzLl9waXZvdCwgMCwgMClcblxuICAgIC8vIFRPRE8oY3Jvb3QpOiB3aGF0IGlmIHRoaXMgcG9seSBpc1xuICAgIC8vIHBhcmVudGVkIHRvIGFub3RoZXIgdHJhbnNmb3JtP1xuXG4gICAgY29uc3QgeGZvcm0gPSB0aGlzLmxvY2FsWGZvcm1cbiAgICBpZiAoTWF0MmQuZXF1YWxzKHhmb3JtLCBpZGVudGl0eU1hdHJpeCkpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0cmFuc2Zvcm1zIHRvIGFwcGx5LFxuICAgICAgLy8gZG8gbm90aGluZyAtIGZhc3Qgb3V0XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBBQUJveDJkLmluaXRFbXB0eSh0aGlzLl9hYWJveClcblxuICAgIC8vIGZsYXR0ZW4gYWxsIHRoZSBwb2ludHMgdG8gdGhlaXIgY3VycmVudCB3b3JsZC1zcGFjZSBwb3NpdGlvblxuICAgIC8vIHdpdGggdHJhbnNmb3JtcyBhcHBsaWVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl92ZXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl92ZXJ0c1tpXSwgdGhpcy5fdmVydHNbaV0sIHhmb3JtKVxuICAgIH1cblxuICAgIC8vIG5vdyByZWNhbGN1dGUgdGhlIGNvbnZleCBodWxsIG9mIGFsbCB0aGUgdHJhbnNmb3JtZWQgcG9pbnRzXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSB0aGlzLl92ZXJ0cy5tYXAoKHZhbCwgaWR4KSA9PiBpZHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSBzaW1wbGVIdWxsXzJEKHRoaXMuX3ZlcnRzKVxuICAgIH1cbiAgICAvLyB1c2UgdGhlIGNvbnZleCBodWxsIHBvaW50cyB0byByZWJ1aWxkIHRoZSBib3VuZHNcbiAgICB0aGlzLl9jb252ZXhIdWxsLmZvckVhY2goaWR4ID0+IHtcbiAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdGhpcy5fdmVydHNbaWR4XSwgaWR4LCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgIH0pXG5cbiAgICAvLyByZXNldCB0aGUgbG9jYWwgdHJhbnNmb3Jtc1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtYXRpb25zKDAsIDAsIDEsIDEsIDApXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgYSBzcGVjaWZpYyB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gYnkgYW4gb2Zmc2V0XG4gICAqIEBwYXJhbSAge251bWJlcn0gdmVydEluZGV4IEluZGV4IG9mIHRoZSB2ZXJ0ZXggdG8gdHJhbnNsYXRlXG4gICAqIEBwYXJhbSAge1ZlYzJkfSB0ICAgICAgICAgVHJhbnNsYXRpb24gb2Zmc2V0LCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKiBAcmV0dXJuIHtQb2x5TGluZX0gICAgICAgICAgIHRoaXNcbiAgICogQGZpcmVzIHtTaGFwZSNnZW9tQ2hhbmdlZH1cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZlcnRJbmRleCBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdHJhbnNsYXRlVmVydCh2ZXJ0SW5kZXgsIHQpIHtcbiAgICBpZiAodmVydEluZGV4ID49IHRoaXMuX3ZlcnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdHJhbnNsYXRlIHZlcnRleCBhdCBpbmRleCAke3ZlcnRJbmRleH0uIFRoZXJlIGFyZSBvbmx5ICR7dGhpcy5fdmVydHMubGVuZ3RofSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbi5gKVxuICAgIH1cblxuICAgIGlmICh0WzBdIHx8IHRbMV0pIHtcbiAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3ZlcnRzW3ZlcnRJbmRleF0pXG4gICAgICBjb25zdCBuZXdQdCA9IFBvaW50MmQuY2xvbmUodGhpcy5fdmVydHNbdmVydEluZGV4XSlcbiAgICAgIFBvaW50MmQuYWRkVmVjMihuZXdQdCwgbmV3UHQsIHQpXG5cbiAgICAgIC8vIFRPRE8oY3Jvb3QpOiB0aGlzIGNvdWxkIGJlIG1hZGUgc21hcnRlciBieSBkZXRlcm1pbmluZyB3aGV0aGVyXG4gICAgICAvLyB0aGlzIHBvaW50IGFmZmVjdHMgdGhlIGNvbnZleCBodWxsIG9yIG5vdCBieSBjaGVja2luZyBpdCdzIHJlbGF0aW9uc2hpcFxuICAgICAgLy8gd2l0aCBpdHMgbmVpZ2hib3JzXG4gICAgICB0aGlzLl9jb2xsYXBzZVZlcnRzKClcbiAgICAgIHRoaXMuX3Jlc2V0QUFCb3ggPSB0cnVlXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlXG4gICAgICBQb2ludDJkLmNvcHkobmV3UHQpXG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOmdlb21cIiwge1xuICAgICAgICBhdHRyOiBgdmVydHNbJHt2ZXJ0SW5kZXh9XWAsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IG5ld1B0XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc2V0VmVydFBvc2l0aW9uKHZlcnRJbmRleCwgcG9zKSB7XG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHRyYW5zbGF0ZSB2ZXJ0ZXggYXQgaW5kZXggJHt2ZXJ0SW5kZXh9LiBUaGVyZSBhcmUgb25seSAke3RoaXMuX3ZlcnRzLmxlbmd0aH0gdmVydGljZXMgaW4gdGhlIHBvbHlnb24uYClcbiAgICB9XG5cbiAgICBpZiAoIVBvaW50MmQuZXF1YWxzKHBvcywgdGhpcy5fdmVydHNbdmVydEluZGV4XSkpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3ZlcnRzW3ZlcnRJbmRleF0pXG4gICAgICB0aGlzLl9jb2xsYXBzZVZlcnRzKClcbiAgICAgIFBvaW50MmQuY29weSh0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXhdLCBwb3MpXG5cbiAgICAgIC8vIFRPRE8oY3Jvb3QpOiB0aGlzIGNvdWxkIGJlIG1hZGUgc21hcnRlciBieSBkZXRlcm1pbmluZyB3aGV0aGVyXG4gICAgICAvLyB0aGlzIHBvaW50IGFmZmVjdHMgdGhlIGNvbnZleCBodWxsIG9yIG5vdCBieSBjaGVja2luZyBpdCdzIHJlbGF0aW9uc2hpcFxuICAgICAgLy8gd2l0aCBpdHMgbmVpZ2hib3JzXG4gICAgICB0aGlzLl9yZXNldEFBQm94ID0gdHJ1ZVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdHJ1ZVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tXCIsIHtcbiAgICAgICAgYXR0cjogYHZlcnRzWyR7dmVydEluZGV4fV1gLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiBwb3NcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0VmVydCh2ZXJ0SW5kZXgsIHBvcykge1xuICAgIGxldCBpZHggPSBNYXRoLm1pbihNYXRoLm1heCh2ZXJ0SW5kZXgsIDApLCB0aGlzLl92ZXJ0cy5sZW5ndGgpXG4gICAgdGhpcy5fY29sbGFwc2VWZXJ0cygpXG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jbG9uZShwb3MpKVxuICAgICAgaWR4ID0gdGhpcy5fdmVydHMubGVuZ3RoIC0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92ZXJ0cy5zcGxpY2UodmVydEluZGV4LCAwLCBQb2ludDJkLmNsb25lKHBvcykpXG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0QUFCb3ggPSB0cnVlXG4gICAgdGhpcy5fZ2VvbURpcnR5ID0gdHJ1ZVxuXG4gICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tOmFkZHZlcnRcIiwge1xuICAgICAgYXR0cjogYHZlcnRzWyR7aWR4fV1gLFxuICAgICAgY3VyclZhbDogcG9zXG4gICAgfSlcblxuICAgIHJldHVybiBpZHhcbiAgfVxuXG4gIGFwcGVuZFZlcnQocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0VmVydCh0aGlzLl92ZXJ0cy5sZW5ndGgsIHBvcylcbiAgfVxuXG4gIHJlbW92ZVZlcnQodmVydEluZGV4KSB7XG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGggfHwgdmVydEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHZlcnRleCAke3ZlcnRJbmRleH0uIEludmFsaWQgaW5kZXguIFRoZXJlIGFyZSBvbmx5ICR7dGhpcy5fdmVydHMubGVuZ3RofSB2ZXJ0aWNlcyBpbiB0aGUgc2hhcGUuYClcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXhdXG4gICAgdGhpcy5fdmVydHMuc3BsaWNlKHZlcnRJbmRleCwgMSlcbiAgICB0aGlzLl9jb2xsYXBzZVZlcnRzKClcbiAgICB0aGlzLl9yZXNldEFBQm94ID0gdHJ1ZVxuICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWVcblxuICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbTpyZW1vdmV2ZXJ0XCIsIHtcbiAgICAgIGF0dHI6IGB2ZXJ0c1ske3ZlcnRJbmRleH1dYCxcbiAgICAgIGN1cnJWYWw6IHBvc1xuICAgIH0pXG5cbiAgICByZXR1cm4gdmVydEluZGV4XG4gIH1cblxuICBfcmVidWlsZEFBQm94KCkge1xuICAgIEFBQm94MmQuaW5pdEVtcHR5KHRoaXMuX2FhYm94KVxuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gdGhpcy5fdmVydHMubWFwKCh2YWwsIGlkeCkgPT4gaWR4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gc2ltcGxlSHVsbF8yRCh0aGlzLl92ZXJ0cylcbiAgICB9XG4gICAgdGhpcy5fY29udmV4SHVsbC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHRoaXMuX3ZlcnRzW2lkeF0sIGlkeCwgdGhpcy5fZXh0ZW50SW5kaWNlcylcbiAgICB9KVxuXG4gICAgY29uc3QgcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuICAgIEFBQm94MmQuZ2V0Q2VudGVyKHBpdm90LCB0aGlzLl9hYWJveClcbiAgICB0aGlzLnBpdm90ID0gcGl2b3RcbiAgfVxuXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fcmVzZXRBQUJveCkge1xuICAgICAgdGhpcy5fcmVidWlsZEFBQm94KClcbiAgICAgIHRoaXMuX3Jlc2V0QUFCb3ggPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib3VuZHNPdXRPZkRhdGUgfHwgdGhpcy5fZ2VvbURpcnR5KSB7XG4gICAgICBBQUJveDJkLmluaXRFbXB0eSh0aGlzLl9hYWJveClcbiAgICAgIGNvbnN0IHRtcHB0ID0gWzAsIDBdXG4gICAgICBjb25zdCB4Zm9ybSA9IHRoaXMuZ2xvYmFsWGZvcm1cbiAgICAgIHRoaXMuX2NvbnZleEh1bGwuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICBBQUJveDJkLmVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHRoaXMuX2FhYm94LCBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcHB0LCB0aGlzLl92ZXJ0c1tpZHhdLCB4Zm9ybSkpXG4gICAgICB9KVxuICAgICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXMuX2dlb21EaXJ0eSkge1xuICAgICAgICBjb25zdCBwaXZvdCA9IFBvaW50MmQuY3JlYXRlKClcbiAgICAgICAgcGl2b3RbMF0gPSB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzBdXVswXSArIDAuNSAqICh0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzJdXVswXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMF1dWzBdKVxuICAgICAgICBwaXZvdFsxXSA9IHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMV1dWzFdICsgMC41ICogKHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbM11dWzFdIC0gdGhpcy5fdmVydHNbdGhpcy5fZXh0ZW50SW5kaWNlc1sxXV1bMV0pXG4gICAgICAgIHRoaXMucGl2b3QgPSBwaXZvdFxuICAgICAgICB0aGlzLl9nZW9tRGlydHkgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9kcmF3KGN0eCkge1xuICAgIGxldCBydG4gPSBmYWxzZVxuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLl92ZXJ0c1swXVswXSwgdGhpcy5fdmVydHNbMF1bMV0pXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX3ZlcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5fdmVydHNbaV1bMF0sIHRoaXMuX3ZlcnRzW2ldWzFdKVxuICAgICAgfVxuICAgICAgcnRuID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcnRuXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogXCJQb2x5TGluZVwiLCAvLyBOT1RFOiB0aGlzIG11Y2ggbWF0Y2ggdGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgICB2ZXJ0czogdGhpcy52ZXJ0c1JlZi5tYXAodmVydCA9PiBbdmVydFswXSwgdmVydFsxXV0pXG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cblxufVxuXG5Qb2x5TGluZS5hYWJveEVuY2Fwc3VsYXRlUHQgPSBhYWJveEVuY2Fwc3VsYXRlUHRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9wb2x5LWxpbmUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.buildXformMatrix = buildXformMatrix;\nexports.createEventedTransform2dMixin = createEventedTransform2dMixin;\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _aggregation = __webpack_require__(8);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nvar _math = __webpack_require__(6);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Builds a 2D transformation matrix (2x3 matrix) from a rotation (in degrees),\n * an x,y scale, a translation, and a pivot (an offset from the origin to\n * apply the transformation around)\n * @param  {Mat2d} mat   Matrix to store the result of the operation\n * @param  {number} rdeg  rotation, in degrees\n * @param  {Vec2d} s     Scale vector, in x & y\n * @param  {Vec2d} t     Translation vector, in x & y\n * @param  {Vec2d} pivot Offset from origin to apply the transformation\n * @return {Mat2d}       Matrix referenced by the mat argument\n */\nfunction buildXformMatrix(mat, rdeg, s, t, pivot) {\n  _glMatrix.mat2d.identity(mat);\n  _glMatrix.mat2d.translate(mat, mat, [t[0] + pivot[0], t[1] + pivot[1]]);\n  _glMatrix.mat2d.rotate(mat, mat, _math2.default.DEG_TO_RAD * rdeg);\n  _glMatrix.mat2d.scale(mat, mat, s);\n  _glMatrix.mat2d.translate(mat, mat, [-pivot[0], -pivot[1]]);\n  return mat;\n}\n\n/**\n * Utility function to dirty all the descendants of a transform node.\n * This is called when a transform node has been modified in some way\n * that it's children need to be notified about.\n * @param  {Transform2d[]} children\n */\nfunction dirtyChildren(children) {\n  children.forEach(function (child) {\n    child._xformDirty = true;\n    dirtyChildren(child._children);\n  });\n}\n\n/**\n * @typedef {object} Transform2dOptions\n * @property {Point2d} [position = [0,0]] Position in world space coords\n * @property {Vec2d} [scale = [1,1]] Scale in world space coords\n * @property {number} [rotation = 0] Rotation in degrees\n * @property {Vec2d} [pivot = [0, 0]] Offset from origin to apply the setTransformations\n */\n\n/**\n * @class Class to manage basic 2d affine transformations\n * @mixin Can also be used as a mixin\n */\n\nvar Transform2d = function () {\n  /**\n   * Creates a new Transform2d\n   * @param  {Transform2dOptions} [opts]\n   * @return {Transform2d}\n   */\n  function Transform2d(opts) {\n    _classCallCheck(this, Transform2d);\n\n    this.initializer(opts);\n  }\n\n  /**\n   * Initializes a transform 2d object from options\n   * @param  {Transform2dOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(Transform2d, [{\n    key: \"_initTransformFromOptions\",\n    value: function _initTransformFromOptions(opts) {\n      if (!opts) {\n        return;\n      }\n\n      if (typeof opts.position !== \"undefined\") {\n        this.setPosition(opts.position);\n      }\n\n      if (typeof opts.scale !== \"undefined\") {\n        this.setScale(opts.scale);\n      }\n\n      if (typeof opts.rotation !== \"undefined\") {\n        this.setRotation(opts.rotation);\n      }\n\n      if (typeof opts.pivot !== \"undefined\") {\n        this.pivot = opts.pivot;\n      }\n    }\n\n    /**\n     * Initializes a transform 2d object from options,\n     * called from either constructor (if used as base class)\n     * or base mixin class (if used as a mixin)\n     * @param  {Transform2dOptions} [opts]\n     * @protected\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._localXform = _glMatrix.mat2d.create();\n      this._lxformDirty = false;\n\n      this._pivot = Point2d.create(0, 0);\n\n      this._pos = Point2d.create(0, 0);\n      this._scale = _glMatrix.vec2.fromValues(1, 1);\n      this._rotDeg = 0;\n\n      this._globalXform = _glMatrix.mat2d.create();\n      this._xformDirty = false;\n      this._parent = null;\n      this._children = new Set();\n\n      this._initTransformFromOptions(opts);\n    }\n\n    /**\n     * Adds a child to this transform node\n     * @param {Transform2d} childXform\n     */\n\n  }, {\n    key: \"addChildXform\",\n    value: function addChildXform(childXform) {\n      if (!this._children.has(childXform)) {\n        this._children.add(childXform);\n        if (childXform._parent) {\n          childXform._parent.removeChild(childXform);\n        }\n        childXform._parent = this;\n        childXform._xformDirty = true;\n        dirtyChildren(childXform._children);\n      }\n    }\n\n    /**\n     * Removes a child from this transform node\n     * @param  {Transform2d} childXform\n     */\n\n  }, {\n    key: \"removeChildXform\",\n    value: function removeChildXform(childXform) {\n      this._children.delete(childXform);\n    }\n\n    /**\n     * Unparents this node from its parent, if it has one\n     */\n\n  }, {\n    key: \"unparentXform\",\n    value: function unparentXform() {\n      if (this._parent) {\n        this._parent.removeChild(this);\n        this._parent = null;\n        _glMatrix.mat2d.copy(this._globalXform, this.localXform);\n      }\n    }\n\n    /**\n     * Sets the pivot of the transform\n     * @param  {Vec2d} pivot Offset vector from the origin to apply the transformations\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"getPosition\",\n\n\n    /**\n     * Gets the current unparented position of the transform\n     * @return {Point2d} This is the position of the node as if it were unparented\n     */\n    value: function getPosition() {\n      return _glMatrix.vec2.clone(this._pos);\n    }\n\n    /**\n     * Gets the reference to the unparented position of the transform, avoiding\n     * a copy\n     * @return {Point2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"getPositionRef\",\n    value: function getPositionRef() {\n      return this._pos;\n    }\n\n    /**\n     * Gets the current world position of the transform, this is its position\n     * after all parent transformations have been applied\n     * @return {Point2d}\n     */\n\n  }, {\n    key: \"getWorldPosition\",\n    value: function getWorldPosition() {\n      var xform = this.globalXform;\n      return Point2d.create(xform[4], xform[5]);\n    }\n\n    /**\n     * Sets the unparented world position of the transform\n     * @param {Point2d} pos\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(pos) {\n      Point2d.copy(this._pos, pos);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n    }\n\n    /**\n     * Translates the unparented world position of the transform by an offset\n     * @param  {Vec2d} translation\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(translation) {\n      if (translation[0] || translation[1]) {\n        Point2d.addVec2(this._pos, this._pos, translation);\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current unparented x,y scale of the transform\n     * @return {Vec2d}\n     */\n\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return _glMatrix.vec2.clone(this._scale);\n    }\n\n    /**\n     * Gets the current unparented x/y scale reference of the transform\n     * avoiding a copy\n     * @return {Vec2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"getScaleRef\",\n    value: function getScaleRef() {\n      return this._scale;\n    }\n\n    /**\n     * Sets the unparented scale of the transform\n     * @param {Vec2d} scale\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      _glMatrix.vec2.copy(this._scale, scale);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Scales the current unparented scale by a 2d multiplier\n     * @param  {Vec2d} scaleMult\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(scaleMult) {\n      if (scaleMult[0] !== 1 || scaleMult[1] !== 1) {\n        _glMatrix.vec2.multiply(this._scale, this._scale, scaleMult);\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current unparented rotation in degrees of the transform\n     * @return {number}\n     */\n\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      return this._rotDeg;\n    }\n\n    /**\n     * Sets the unparented rotation of the transform\n     * @param {number} deg Rotation in degrees\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(deg) {\n      this._rotDeg = deg;\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Adds an additional rotation in degrees to the current rotation\n     * of the transform\n     * @param  {number} deg Rotation offset in degrees\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(deg) {\n      if (deg) {\n        this._rotDeg += deg;\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Utility function to dirty all the descendants of this node\n     * @private\n     */\n\n  }, {\n    key: \"_dirtyChildren\",\n    value: function _dirtyChildren() {\n      dirtyChildren(this._children);\n    }\n\n    /**\n     * Updates the local affine matrix if marked as dirty\n     * If derived/mixin classes have a _localXformUpdates method\n     * defined, that will be called here when the local transform\n     * is updated.\n     * @private\n     */\n\n  }, {\n    key: \"_updatelocalxform\",\n    value: function _updatelocalxform() {\n      if (this._lxformDirty) {\n        buildXformMatrix(this._localXform, this._rotDeg, this._scale, this._pos, this._pivot);\n        if (this._localXformUpdated) {\n          this._localXformUpdated();\n        }\n        this._lxformDirty = false;\n      }\n    }\n\n    /**\n     * Updates the global 2x3 matrix of the transform if marked dirty\n     * If derived/mixin classes have a _globalXformUpdates method\n     * defined, that will be called here when the global transform\n     * is updated.\n     * @private\n     */\n\n  }, {\n    key: \"_updateglobalxform\",\n    value: function _updateglobalxform() {\n      if (this._lxformDirty || this._xformDirty) {\n        this._updatelocalxform();\n        if (this._parent) {\n          _glMatrix.mat2d.multiply(this._globalXform, this._parent.globalXform, this._localXform);\n        } else {\n          _glMatrix.mat2d.copy(this._globalXform, this._localXform);\n        }\n        if (this._globalXformUpdated) {\n          this._globalXformUpdated();\n        }\n        this._xformDirty = false;\n      }\n    }\n\n    /**\n     * Gets the current local transformation matrix of the node.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"transformCtx\",\n\n\n    /**\n     * Sets the transform state of a 2d rendering context\n     * @param  {CanvasRenderingContext2D} ctx\n     * @param  {Mat2d} currMatrix          The current matrix used to store the result of the\n     *                                     model-view-projection-screen matrix multiplication for this node\n     * @param  {Mat2d} worldToScreenMatrix The current world-to-screen tranform\n     */\n    value: function transformCtx(ctx, currMatrix, worldToScreenMatrix) {\n      _glMatrix.mat2d.multiply(currMatrix, worldToScreenMatrix, this.globalXform);\n\n      ctx.setTransform(currMatrix[0], currMatrix[1], currMatrix[2], currMatrix[3], currMatrix[4], currMatrix[5]);\n    }\n\n    /**\n     * Converts a Transform2d instance to a JSON object\n     * @param  {Transform2d} xformObj\n     * @return {{position: Point2d, scale: Vec2d, rotation: number, pivot: Vec2d}}\n     */\n\n  }, {\n    key: \"pivot\",\n    set: function set(pivot) {\n      Point2d.copy(this._pivot, pivot);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Gets the current pivot of the transform\n     * @return {Vec2d}\n     */\n    ,\n    get: function get() {\n      return Point2d.clone(this._pivot);\n    }\n\n    /**\n     * Gets the current pivot reference of the transform.\n     * @return {[type]} [description]\n     * @readOnly\n     */\n\n  }, {\n    key: \"pivotRef\",\n    get: function get() {\n      return this._pivot;\n    }\n\n    /**\n     * Gets the parent transform node, if one is attached\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n  }, {\n    key: \"localXform\",\n    get: function get() {\n      this._updatelocalxform();\n      return this._localXform;\n    }\n\n    /**\n     * Gets the current global transformation matrix of the node. This is essentially\n     * its local transform multiplied against all the local transforms of its parents.\n     * This is ultimately used to convert a point from object space to world space, and\n     * inversely, from world space to object space.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"globalXform\",\n    get: function get() {\n      this._updateglobalxform();\n      return this._globalXform;\n    }\n  }], [{\n    key: \"toJSON\",\n    value: function toJSON(xformObj) {\n      // TODO(croot): How do we deal with parenting here?\n      // To properly deal with this, we may need to supply an\n      // identifier for every created object... This may likely\n      // need to be a name string supplied by the user\n      var pos = xformObj.getPositionRef();\n      var scale = xformObj.getScaleRef();\n      var pivot = xformObj.pivotRef;\n      return {\n        position: [pos[0], pos[1]],\n        scale: [scale[0], scale[1]],\n        rotation: xformObj.getRotation(),\n        pivot: [pivot[0], pivot[1]]\n      };\n    }\n  }]);\n\n  return Transform2d;\n}();\n\n/**\n * Creates a new Transform2d mixin class that is intended to be mixed in with\n * a class that inherits from the EventHandler class\n * @param  {string} eventName Type name of the event fired when the transform is modified\n * @return {function}           Mixin\n */\n\n\nexports.default = Transform2d;\nfunction createEventedTransform2dMixin(eventName) {\n  /**\n   * Transform2d modification event\n   * @event EventedTransform2d#changed\n   * @type {object}\n   * @property {string} attr Name of the attribute modified\n   * @property {} prevVal Previous value of the attribute prior to modification\n   * @property {} currVal Value of the attribute post modification\n   */\n\n  /**\n   * @mixin Transform2d mixin with event firing when modified\n   */\n  return (0, _aggregation2.default)(null, Transform2d, function () {\n    function EventedTransform2d() {\n      _classCallCheck(this, EventedTransform2d);\n    }\n\n    _createClass(EventedTransform2d, [{\n      key: \"setPosition\",\n\n\n      /**\n       * Sets the unparented position of the transform.\n       * @param {Point2d} pos\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n      value: function setPosition(pos) {\n        if (!Point2d.equals(pos, this._pos)) {\n          var prev = [this._pos[0], this._pos[1]];\n          Point2d.copy(this._pos, pos);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"position\",\n            prevVal: prev,\n            currVal: pos\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Translates the unparented position of a transform by an offset.\n       * @param  {Vec2d} translation\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"translate\",\n      value: function translate(translation) {\n        if (translation[0] || translation[1]) {\n          var prev = [this._pos[0], this._pos[1]];\n          Point2d.addVec2(this._pos, this._pos, translation);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"position\",\n            prevVal: prev,\n            currVal: [this._pos[0], this._pos[1]]\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Sets the unparented 2d scale of the transform\n       * @param {Vec2d} scale\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setScale\",\n      value: function setScale(scale) {\n        if (!_glMatrix.vec2.equals(scale, this._scale)) {\n          var prev = [this._scale[0], this._scale[1]];\n          _glMatrix.vec2.copy(this._scale, scale);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"size\",\n            prevVal: prev,\n            currVal: scale\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Multiplies the current unparented scale of the transform by a 2d scalar\n       * @param  {Vec2d} scaleMult\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"scale\",\n      value: function scale(scaleMult) {\n        if (scaleMult[0] !== 1 || scaleMult[1] !== 1) {\n          var prev = [this._scale[0], this._scale[1]];\n          _glMatrix.vec2.multiply(this._scale, this._scale, scaleMult);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"size\",\n            prevVal: prev,\n            currVal: [this._scale[0], this._scale[1]]\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Sets the unparented rotation of the transform in degrees\n       * @param {number} deg Rotation angle in degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setRotation\",\n      value: function setRotation(deg) {\n        var degToUse = deg % 360;\n        if (degToUse !== this._rotDeg) {\n          var prev = this._rotDeg;\n          this._rotDeg = degToUse;\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"orientation\",\n            prevVal: prev,\n            curral: this._rotDeg\n          });\n        }\n      }\n\n      /**\n       * Adds a rotation angle in degrees to the current unparented\n       * rotation of the transform.\n       * @param  {number} deg Additional rotation angle in degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"rotate\",\n      value: function rotate(deg) {\n        if (deg) {\n          var prev = this._rotDeg;\n          this._rotDeg += deg;\n          this._rotDeg %= 360;\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"orientation\",\n            prevVal: prev,\n            curral: this._rotDeg\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Utility function to reset all the unparented transform parameters\n       * @param {number} tx  Translation in x in world units\n       * @param {number} ty  Translation in y in world units\n       * @param {number} sx  Scale in x in world units\n       * @param {number} sy  Scale in y in world units\n       * @param {number} deg Rotation angle degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setTransformations\",\n      value: function setTransformations(tx, ty, sx, sy, deg) {\n        var attrs = [];\n        var prevVals = [];\n        var currVals = [];\n        if (typeof tx !== \"undefined\" && typeof ty !== \"undefined\" && (!_glMatrix.glMatrix.equals(tx, this._pos[0]) || !_glMatrix.glMatrix.equals(ty, this._pos[1]))) {\n          var prev = Point2d.clone(this._pos);\n          this._pos[0] = tx;\n          this._pos[1] = ty;\n          attrs.push(\"position\");\n          prevVals.push(prev);\n          currVals.push(Point2d.clone(this._pos));\n        }\n\n        if (typeof sx !== \"undefined\" && typeof sy !== \"undefined\" && (!_glMatrix.glMatrix.equals(sx, this._scale[0]) || !_glMatrix.glMatrix.equals(sy, this._scale[1]))) {\n          var _prev = _glMatrix.vec2.clone(this._scale);\n          _glMatrix.vec2.set(this._scale, sx, sy);\n          attrs.push(\"size\");\n          prevVals.push(_prev);\n          currVals.push(_glMatrix.vec2.clone(this._scale));\n        }\n\n        if (typeof deg !== \"undefined\") {\n          var degToUse = deg % 360;\n          if (!_glMatrix.glMatrix.equals(degToUse, this._rotDeg)) {\n            var _prev2 = this._rotDeg;\n            this._rotDeg = degToUse;\n            attrs.push(\"orientation\");\n            prevVals.push(_prev2);\n            currVals.push(this._rotDeg);\n          }\n        }\n\n        if (attrs.length) {\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attrs: attrs,\n            prevVals: prevVals,\n            currVals: currVals\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"pivot\",\n\n      /**\n       * Sets the unparented pivot of the transform. The pivot is\n       * the offset from the transform's primary position where the\n       * transformation is applied.\n       * @param {Vec2d} pivot\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n      set: function set(pivot) {\n        if (!Point2d.equals(pivot, this._pivot)) {\n          var prev = [this._pivot[0], this._pivot[1]];\n          Point2d.copy(this._pivot, pivot);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"pivot\",\n            prevVal: prev,\n            currVal: pivot\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets a copy of the unparented pivot of the transform\n       * @return {Vec2d}\n       */\n      ,\n      get: function get() {\n        return Point2d.clone(this._pivot);\n      }\n    }]);\n\n    return EventedTransform2d;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvdHJhbnNmb3JtMmQuanM/ZDAwMiJdLCJuYW1lcyI6WyJidWlsZFhmb3JtTWF0cml4IiwiY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4iLCJQb2ludDJkIiwibWF0IiwicmRlZyIsInMiLCJ0IiwicGl2b3QiLCJpZGVudGl0eSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsIkRFR19UT19SQUQiLCJzY2FsZSIsImRpcnR5Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImZvckVhY2giLCJjaGlsZCIsIl94Zm9ybURpcnR5IiwiX2NoaWxkcmVuIiwiVHJhbnNmb3JtMmQiLCJvcHRzIiwiaW5pdGlhbGl6ZXIiLCJwb3NpdGlvbiIsInNldFBvc2l0aW9uIiwic2V0U2NhbGUiLCJyb3RhdGlvbiIsInNldFJvdGF0aW9uIiwiX2xvY2FsWGZvcm0iLCJjcmVhdGUiLCJfbHhmb3JtRGlydHkiLCJfcGl2b3QiLCJfcG9zIiwiX3NjYWxlIiwiZnJvbVZhbHVlcyIsIl9yb3REZWciLCJfZ2xvYmFsWGZvcm0iLCJfcGFyZW50IiwiU2V0IiwiX2luaXRUcmFuc2Zvcm1Gcm9tT3B0aW9ucyIsImNoaWxkWGZvcm0iLCJoYXMiLCJhZGQiLCJyZW1vdmVDaGlsZCIsImRlbGV0ZSIsImNvcHkiLCJsb2NhbFhmb3JtIiwiY2xvbmUiLCJ4Zm9ybSIsImdsb2JhbFhmb3JtIiwicG9zIiwidHJhbnNsYXRpb24iLCJhZGRWZWMyIiwic2NhbGVNdWx0IiwibXVsdGlwbHkiLCJkZWciLCJfbG9jYWxYZm9ybVVwZGF0ZWQiLCJfdXBkYXRlbG9jYWx4Zm9ybSIsIl9nbG9iYWxYZm9ybVVwZGF0ZWQiLCJjdHgiLCJjdXJyTWF0cml4Iiwid29ybGRUb1NjcmVlbk1hdHJpeCIsInNldFRyYW5zZm9ybSIsIl91cGRhdGVnbG9iYWx4Zm9ybSIsInhmb3JtT2JqIiwiZ2V0UG9zaXRpb25SZWYiLCJnZXRTY2FsZVJlZiIsInBpdm90UmVmIiwiZ2V0Um90YXRpb24iLCJldmVudE5hbWUiLCJlcXVhbHMiLCJwcmV2IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsImRlZ1RvVXNlIiwiY3VycmFsIiwidHgiLCJ0eSIsInN4Iiwic3kiLCJhdHRycyIsInByZXZWYWxzIiwiY3VyclZhbHMiLCJwdXNoIiwic2V0IiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7UUFrQmdCQSxnQixHQUFBQSxnQjtRQTZaQUMsNkIsR0FBQUEsNkI7O0FBN2FoQjs7SUFBWUMsTzs7QUFDWjs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7O0FBV08sU0FBU0YsZ0JBQVQsQ0FBMEJHLEdBQTFCLEVBQStCQyxJQUEvQixFQUFxQ0MsQ0FBckMsRUFBd0NDLENBQXhDLEVBQTJDQyxLQUEzQyxFQUFrRDtBQUN2RCxrQkFBTUMsUUFBTixDQUFlTCxHQUFmO0FBQ0Esa0JBQU1NLFNBQU4sQ0FBZ0JOLEdBQWhCLEVBQXFCQSxHQUFyQixFQUEwQixDQUFDRyxFQUFFLENBQUYsSUFBT0MsTUFBTSxDQUFOLENBQVIsRUFBa0JELEVBQUUsQ0FBRixJQUFPQyxNQUFNLENBQU4sQ0FBekIsQ0FBMUI7QUFDQSxrQkFBTUcsTUFBTixDQUFhUCxHQUFiLEVBQWtCQSxHQUFsQixFQUF1QixlQUFLUSxVQUFMLEdBQWtCUCxJQUF6QztBQUNBLGtCQUFNUSxLQUFOLENBQVlULEdBQVosRUFBaUJBLEdBQWpCLEVBQXNCRSxDQUF0QjtBQUNBLGtCQUFNSSxTQUFOLENBQWdCTixHQUFoQixFQUFxQkEsR0FBckIsRUFBMEIsQ0FBQyxDQUFDSSxNQUFNLENBQU4sQ0FBRixFQUFZLENBQUNBLE1BQU0sQ0FBTixDQUFiLENBQTFCO0FBQ0EsU0FBT0osR0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTVSxhQUFULENBQXVCQyxRQUF2QixFQUFpQztBQUMvQkEsV0FBU0MsT0FBVCxDQUFpQixpQkFBUztBQUN4QkMsVUFBTUMsV0FBTixHQUFvQixJQUFwQjtBQUNBSixrQkFBY0csTUFBTUUs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Q25CYSx3QkFEbUI7QUFFbkJDLDhCQUZtQjtBQUduQkM7QUFIbUIsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBcE5JO0FBQUE7O0FBQ0w7Ozs7Ozs7O0FBREssd0JBU0s1RSxLQVRMLEVBU1k7QUFDZixZQUFJLENBQUNMLFFBQVFtRSxNQUFSLENBQWU5RCxLQUFmLEVBQXNCLEtBQUt1QixNQUEzQixDQUFMLEVBQXlDO0FBQ3ZDLGNBQU13QyxPQUFPLENBQUMsS0FBS3hDLE1BQUwsQ0FBWSxDQUFaLENBQUQsRUFBaUIsS0FBS0EsTUFBTCxDQUFZLENBQVosQ0FBakIsQ0FBYjtBQUNBNUIsa0JBQVEwQyxJQUFSLENBQWEsS0FBS2QsTUFBbEIsRUFBMEJ2QixLQUExQjtBQUNBLGVBQUtzQixZQUFMLEdBQW9CLElBQXBCO0FBQ0FoQix3QkFBYyxLQUFLSyxTQUFuQjtBQUNBLGVBQUtxRCxJQUFMLENBQVVILFNBQVYsRUFBcUI7QUFDbkJJLGtCQUFNLE9BRGE7QUFFbkJDLHFCQUFTSCxJQUZVO0FBR25CSSxxQkFBU25FO0FBSFUsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBeEJLO0FBQUEsMEJBNEJPO0FBQ1YsZUFBT0wsUUFBUTRDLEtBQVIsQ0FBYyxLQUFLaEIsTUFBbkIsQ0FBUDtBQUNEO0FBOUJJOztBQUFBO0FBQUEsTUFBUDtBQXNORCIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQge2dsTWF0cml4IGFzIEdMTWF0cml4LCBtYXQyZCBhcyBNYXQyZCwgdmVjMiBhcyBWZWMyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5pbXBvcnQgYWdncmVnYXRpb24gZnJvbSBcIi4uL3V0aWwvYWdncmVnYXRpb25cIlxuaW1wb3J0IE1hdGggZnJvbSBcIi4uL21hdGgvbWF0aFwiXG5cbi8qKlxuICogQnVpbGRzIGEgMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4ICgyeDMgbWF0cml4KSBmcm9tIGEgcm90YXRpb24gKGluIGRlZ3JlZXMpLFxuICogYW4geCx5IHNjYWxlLCBhIHRyYW5zbGF0aW9uLCBhbmQgYSBwaXZvdCAoYW4gb2Zmc2V0IGZyb20gdGhlIG9yaWdpbiB0b1xuICogYXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uIGFyb3VuZClcbiAqIEBwYXJhbSAge01hdDJkfSBtYXQgICBNYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJkZWcgIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG4gKiBAcGFyYW0gIHtWZWMyZH0gcyAgICAgU2NhbGUgdmVjdG9yLCBpbiB4ICYgeVxuICogQHBhcmFtICB7VmVjMmR9IHQgICAgIFRyYW5zbGF0aW9uIHZlY3RvciwgaW4geCAmIHlcbiAqIEBwYXJhbSAge1ZlYzJkfSBwaXZvdCBPZmZzZXQgZnJvbSBvcmlnaW4gdG8gYXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcmV0dXJuIHtNYXQyZH0gICAgICAgTWF0cml4IHJlZmVyZW5jZWQgYnkgdGhlIG1hdCBhcmd1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRYZm9ybU1hdHJpeChtYXQsIHJkZWcsIHMsIHQsIHBpdm90KSB7XG4gIE1hdDJkLmlkZW50aXR5KG1hdClcbiAgTWF0MmQudHJhbnNsYXRlKG1hdCwgbWF0LCBbdFswXSArIHBpdm90WzBdLCB0WzFdICsgcGl2b3RbMV1dKVxuICBNYXQyZC5yb3RhdGUobWF0LCBtYXQsIE1hdGguREVHX1RPX1JBRCAqIHJkZWcpXG4gIE1hdDJkLnNjYWxlKG1hdCwgbWF0LCBzKVxuICBNYXQyZC50cmFuc2xhdGUobWF0LCBtYXQsIFstcGl2b3RbMF0sIC1waXZvdFsxXV0pXG4gIHJldHVybiBtYXRcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGRpcnR5IGFsbCB0aGUgZGVzY2VuZGFudHMgb2YgYSB0cmFuc2Zvcm0gbm9kZS5cbiAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB0cmFuc2Zvcm0gbm9kZSBoYXMgYmVlbiBtb2RpZmllZCBpbiBzb21lIHdheVxuICogdGhhdCBpdCdzIGNoaWxkcmVuIG5lZWQgdG8gYmUgbm90aWZpZWQgYWJvdXQuXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm0yZFtdfSBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBkaXJ0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGNoaWxkLl94Zm9ybURpcnR5ID0gdHJ1ZVxuICAgIGRpcnR5Q2hpbGRyZW4oY2hpbGQuX2NoaWxkcmVuKVxuICB9KVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zZm9ybTJkT3B0aW9uc1xuICogQHByb3BlcnR5IHtQb2ludDJkfSBbcG9zaXRpb24gPSBbMCwwXV0gUG9zaXRpb24gaW4gd29ybGQgc3BhY2UgY29vcmRzXG4gKiBAcHJvcGVydHkge1ZlYzJkfSBbc2NhbGUgPSBbMSwxXV0gU2NhbGUgaW4gd29ybGQgc3BhY2UgY29vcmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uID0gMF0gUm90YXRpb24gaW4gZGVncmVlc1xuICogQHByb3BlcnR5IHtWZWMyZH0gW3Bpdm90ID0gWzAsIDBdXSBPZmZzZXQgZnJvbSBvcmlnaW4gdG8gYXBwbHkgdGhlIHNldFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbi8qKlxuICogQGNsYXNzIENsYXNzIHRvIG1hbmFnZSBiYXNpYyAyZCBhZmZpbmUgdHJhbnNmb3JtYXRpb25zXG4gKiBAbWl4aW4gQ2FuIGFsc28gYmUgdXNlZCBhcyBhIG1peGluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybTJkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHJhbnNmb3JtMmRcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmRPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgdHJhbnNmb3JtIDJkIG9iamVjdCBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmRPcHRpb25zfSBbb3B0c11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0VHJhbnNmb3JtRnJvbU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBvc2l0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNjYWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFNjYWxlKG9wdHMuc2NhbGUpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnJvdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKG9wdHMucm90YXRpb24pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBpdm90ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnBpdm90ID0gb3B0cy5waXZvdFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHRyYW5zZm9ybSAyZCBvYmplY3QgZnJvbSBvcHRpb25zLFxuICAgKiBjYWxsZWQgZnJvbSBlaXRoZXIgY29uc3RydWN0b3IgKGlmIHVzZWQgYXMgYmFzZSBjbGFzcylcbiAgICogb3IgYmFzZSBtaXhpbiBjbGFzcyAoaWYgdXNlZCBhcyBhIG1peGluKVxuICAgKiBAcGFyYW0gIHtUcmFuc2Zvcm0yZE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgdGhpcy5fbG9jYWxYZm9ybSA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fbHhmb3JtRGlydHkgPSBmYWxzZVxuXG4gICAgdGhpcy5fcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuXG4gICAgdGhpcy5fcG9zID0gUG9pbnQyZC5jcmVhdGUoMCwgMClcbiAgICB0aGlzLl9zY2FsZSA9IFZlYzJkLmZyb21WYWx1ZXMoMSwgMSlcbiAgICB0aGlzLl9yb3REZWcgPSAwXG5cbiAgICB0aGlzLl9nbG9iYWxYZm9ybSA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5feGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNldCgpXG5cbiAgICB0aGlzLl9pbml0VHJhbnNmb3JtRnJvbU9wdGlvbnMob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhpcyB0cmFuc2Zvcm0gbm9kZVxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybTJkfSBjaGlsZFhmb3JtXG4gICAqL1xuICBhZGRDaGlsZFhmb3JtKGNoaWxkWGZvcm0pIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuLmhhcyhjaGlsZFhmb3JtKSkge1xuICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKGNoaWxkWGZvcm0pXG4gICAgICBpZiAoY2hpbGRYZm9ybS5fcGFyZW50KSB7XG4gICAgICAgIGNoaWxkWGZvcm0uX3BhcmVudC5yZW1vdmVDaGlsZChjaGlsZFhmb3JtKVxuICAgICAgfVxuICAgICAgY2hpbGRYZm9ybS5fcGFyZW50ID0gdGhpc1xuICAgICAgY2hpbGRYZm9ybS5feGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgIGRpcnR5Q2hpbGRyZW4oY2hpbGRYZm9ybS5fY2hpbGRyZW4pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoaXMgdHJhbnNmb3JtIG5vZGVcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmR9IGNoaWxkWGZvcm1cbiAgICovXG4gIHJlbW92ZUNoaWxkWGZvcm0oY2hpbGRYZm9ybSkge1xuICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZShjaGlsZFhmb3JtKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucGFyZW50cyB0aGlzIG5vZGUgZnJvbSBpdHMgcGFyZW50LCBpZiBpdCBoYXMgb25lXG4gICAqL1xuICB1bnBhcmVudFhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKVxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICAgICAgTWF0MmQuY29weSh0aGlzLl9nbG9iYWxYZm9ybSwgdGhpcy5sb2NhbFhmb3JtKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwaXZvdCBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSAge1ZlYzJkfSBwaXZvdCBPZmZzZXQgdmVjdG9yIGZyb20gdGhlIG9yaWdpbiB0byBhcHBseSB0aGUgdHJhbnNmb3JtYXRpb25zXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgc2V0IHBpdm90KHBpdm90KSB7XG4gICAgUG9pbnQyZC5jb3B5KHRoaXMuX3Bpdm90LCBwaXZvdClcbiAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwaXZvdCBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge1ZlYzJkfVxuICAgKi9cbiAgZ2V0IHBpdm90KCkge1xuICAgIHJldHVybiBQb2ludDJkLmNsb25lKHRoaXMuX3Bpdm90KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcGl2b3QgcmVmZXJlbmNlIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCBwaXZvdFJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl2b3RcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJlbnQgdHJhbnNmb3JtIG5vZGUsIGlmIG9uZSBpcyBhdHRhY2hlZFxuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm0yZH1cbiAgICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCBwb3NpdGlvbiBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge1BvaW50MmR9IFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFzIGlmIGl0IHdlcmUgdW5wYXJlbnRlZFxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIFZlYzJkLmNsb25lKHRoaXMuX3BvcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWZlcmVuY2UgdG8gdGhlIHVucGFyZW50ZWQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSwgYXZvaWRpbmdcbiAgICogYSBjb3B5XG4gICAqIEByZXR1cm4ge1BvaW50MmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0UG9zaXRpb25SZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSwgdGhpcyBpcyBpdHMgcG9zaXRpb25cbiAgICogYWZ0ZXIgYWxsIHBhcmVudCB0cmFuc2Zvcm1hdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICogQHJldHVybiB7UG9pbnQyZH1cbiAgICovXG4gIGdldFdvcmxkUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeGZvcm0gPSB0aGlzLmdsb2JhbFhmb3JtXG4gICAgcmV0dXJuIFBvaW50MmQuY3JlYXRlKHhmb3JtWzRdLCB4Zm9ybVs1XSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtQb2ludDJkfSBwb3NcbiAgICovXG4gIHNldFBvc2l0aW9uKHBvcykge1xuICAgIFBvaW50MmQuY29weSh0aGlzLl9wb3MsIHBvcylcbiAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgdGhlIHVucGFyZW50ZWQgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSBieSBhbiBvZmZzZXRcbiAgICogQHBhcmFtICB7VmVjMmR9IHRyYW5zbGF0aW9uXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgdHJhbnNsYXRlKHRyYW5zbGF0aW9uKSB7XG4gICAgaWYgKHRyYW5zbGF0aW9uWzBdIHx8IHRyYW5zbGF0aW9uWzFdKSB7XG4gICAgICBQb2ludDJkLmFkZFZlYzIodGhpcy5fcG9zLCB0aGlzLl9wb3MsIHRyYW5zbGF0aW9uKVxuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCB4LHkgc2NhbGUgb2YgdGhlIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiBWZWMyZC5jbG9uZSh0aGlzLl9zY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVucGFyZW50ZWQgeC95IHNjYWxlIHJlZmVyZW5jZSBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIGF2b2lkaW5nIGEgY29weVxuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBnZXRTY2FsZVJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtWZWMyZH0gc2NhbGVcbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIFZlYzJkLmNvcHkodGhpcy5fc2NhbGUsIHNjYWxlKVxuICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZXMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCBzY2FsZSBieSBhIDJkIG11bHRpcGxpZXJcbiAgICogQHBhcmFtICB7VmVjMmR9IHNjYWxlTXVsdFxuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm0yZH1cbiAgICovXG4gIHNjYWxlKHNjYWxlTXVsdCkge1xuICAgIGlmIChzY2FsZU11bHRbMF0gIT09IDEgfHwgc2NhbGVNdWx0WzFdICE9PSAxKSB7XG4gICAgICBWZWMyZC5tdWx0aXBseSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHNjYWxlTXVsdClcbiAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVucGFyZW50ZWQgcm90YXRpb24gaW4gZGVncmVlcyBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3REZWdcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHJvdGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyBSb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgc2V0Um90YXRpb24oZGVnKSB7XG4gICAgdGhpcy5fcm90RGVnID0gZGVnXG4gICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gYWRkaXRpb25hbCByb3RhdGlvbiBpbiBkZWdyZWVzIHRvIHRoZSBjdXJyZW50IHJvdGF0aW9uXG4gICAqIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtICB7bnVtYmVyfSBkZWcgUm90YXRpb24gb2Zmc2V0IGluIGRlZ3JlZXNcbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICByb3RhdGUoZGVnKSB7XG4gICAgaWYgKGRlZykge1xuICAgICAgdGhpcy5fcm90RGVnICs9IGRlZ1xuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZGlydHkgYWxsIHRoZSBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXJ0eUNoaWxkcmVuKCkge1xuICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgYWZmaW5lIG1hdHJpeCBpZiBtYXJrZWQgYXMgZGlydHlcbiAgICogSWYgZGVyaXZlZC9taXhpbiBjbGFzc2VzIGhhdmUgYSBfbG9jYWxYZm9ybVVwZGF0ZXMgbWV0aG9kXG4gICAqIGRlZmluZWQsIHRoYXQgd2lsbCBiZSBjYWxsZWQgaGVyZSB3aGVuIHRoZSBsb2NhbCB0cmFuc2Zvcm1cbiAgICogaXMgdXBkYXRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVsb2NhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSkge1xuICAgICAgYnVpbGRYZm9ybU1hdHJpeCh0aGlzLl9sb2NhbFhmb3JtLCB0aGlzLl9yb3REZWcsIHRoaXMuX3NjYWxlLCB0aGlzLl9wb3MsIHRoaXMuX3Bpdm90KVxuICAgICAgaWYgKHRoaXMuX2xvY2FsWGZvcm1VcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsWGZvcm1VcGRhdGVkKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZ2xvYmFsIDJ4MyBtYXRyaXggb2YgdGhlIHRyYW5zZm9ybSBpZiBtYXJrZWQgZGlydHlcbiAgICogSWYgZGVyaXZlZC9taXhpbiBjbGFzc2VzIGhhdmUgYSBfZ2xvYmFsWGZvcm1VcGRhdGVzIG1ldGhvZFxuICAgKiBkZWZpbmVkLCB0aGF0IHdpbGwgYmUgY2FsbGVkIGhlcmUgd2hlbiB0aGUgZ2xvYmFsIHRyYW5zZm9ybVxuICAgKiBpcyB1cGRhdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZWdsb2JhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCB0aGlzLl94Zm9ybURpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVsb2NhbHhmb3JtKClcbiAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgTWF0MmQubXVsdGlwbHkodGhpcy5fZ2xvYmFsWGZvcm0sIHRoaXMuX3BhcmVudC5nbG9iYWxYZm9ybSwgdGhpcy5fbG9jYWxYZm9ybSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1hdDJkLmNvcHkodGhpcy5fZ2xvYmFsWGZvcm0sIHRoaXMuX2xvY2FsWGZvcm0pXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZ2xvYmFsWGZvcm1VcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFhmb3JtVXBkYXRlZCgpXG4gICAgICB9XG4gICAgICB0aGlzLl94Zm9ybURpcnR5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IGxvY2FsWGZvcm0oKSB7XG4gICAgdGhpcy5fdXBkYXRlbG9jYWx4Zm9ybSgpXG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsWGZvcm1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIG5vZGUuIFRoaXMgaXMgZXNzZW50aWFsbHlcbiAgICogaXRzIGxvY2FsIHRyYW5zZm9ybSBtdWx0aXBsaWVkIGFnYWluc3QgYWxsIHRoZSBsb2NhbCB0cmFuc2Zvcm1zIG9mIGl0cyBwYXJlbnRzLlxuICAgKiBUaGlzIGlzIHVsdGltYXRlbHkgdXNlZCB0byBjb252ZXJ0IGEgcG9pbnQgZnJvbSBvYmplY3Qgc3BhY2UgdG8gd29ybGQgc3BhY2UsIGFuZFxuICAgKiBpbnZlcnNlbHksIGZyb20gd29ybGQgc3BhY2UgdG8gb2JqZWN0IHNwYWNlLlxuICAgKiBAcmV0dXJuIHtNYXQyZH1cbiAgICovXG4gIGdldCBnbG9iYWxYZm9ybSgpIHtcbiAgICB0aGlzLl91cGRhdGVnbG9iYWx4Zm9ybSgpXG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFhmb3JtXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIHN0YXRlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtICB7TWF0MmR9IGN1cnJNYXRyaXggICAgICAgICAgVGhlIGN1cnJlbnQgbWF0cml4IHVzZWQgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwtdmlldy1wcm9qZWN0aW9uLXNjcmVlbiBtYXRyaXggbXVsdGlwbGljYXRpb24gZm9yIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0gIHtNYXQyZH0gd29ybGRUb1NjcmVlbk1hdHJpeCBUaGUgY3VycmVudCB3b3JsZC10by1zY3JlZW4gdHJhbmZvcm1cbiAgICovXG4gIHRyYW5zZm9ybUN0eChjdHgsIGN1cnJNYXRyaXgsIHdvcmxkVG9TY3JlZW5NYXRyaXgpIHtcbiAgICBNYXQyZC5tdWx0aXBseShjdXJyTWF0cml4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLmdsb2JhbFhmb3JtKVxuXG4gICAgY3R4LnNldFRyYW5zZm9ybShjdXJyTWF0cml4WzBdLFxuICAgICAgY3Vyck1hdHJpeFsxXSxcbiAgICAgIGN1cnJNYXRyaXhbMl0sXG4gICAgICBjdXJyTWF0cml4WzNdLFxuICAgICAgY3Vyck1hdHJpeFs0XSxcbiAgICAgIGN1cnJNYXRyaXhbNV0pXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBUcmFuc2Zvcm0yZCBpbnN0YW5jZSB0byBhIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSAge1RyYW5zZm9ybTJkfSB4Zm9ybU9ialxuICAgKiBAcmV0dXJuIHt7cG9zaXRpb246IFBvaW50MmQsIHNjYWxlOiBWZWMyZCwgcm90YXRpb246IG51bWJlciwgcGl2b3Q6IFZlYzJkfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oeGZvcm1PYmopIHtcbiAgICAvLyBUT0RPKGNyb290KTogSG93IGRvIHdlIGRlYWwgd2l0aCBwYXJlbnRpbmcgaGVyZT9cbiAgICAvLyBUbyBwcm9wZXJseSBkZWFsIHdpdGggdGhpcywgd2UgbWF5IG5lZWQgdG8gc3VwcGx5IGFuXG4gICAgLy8gaWRlbnRpZmllciBmb3IgZXZlcnkgY3JlYXRlZCBvYmplY3QuLi4gVGhpcyBtYXkgbGlrZWx5XG4gICAgLy8gbmVlZCB0byBiZSBhIG5hbWUgc3RyaW5nIHN1cHBsaWVkIGJ5IHRoZSB1c2VyXG4gICAgY29uc3QgcG9zID0geGZvcm1PYmouZ2V0UG9zaXRpb25SZWYoKVxuICAgIGNvbnN0IHNjYWxlID0geGZvcm1PYmouZ2V0U2NhbGVSZWYoKVxuICAgIGNvbnN0IHBpdm90ID0geGZvcm1PYmoucGl2b3RSZWZcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IFtwb3NbMF0sIHBvc1sxXV0sXG4gICAgICBzY2FsZTogW3NjYWxlWzBdLCBzY2FsZVsxXV0sXG4gICAgICByb3RhdGlvbjogeGZvcm1PYmouZ2V0Um90YXRpb24oKSxcbiAgICAgIHBpdm90OiBbcGl2b3RbMF0sIHBpdm90WzFdXVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVHJhbnNmb3JtMmQgbWl4aW4gY2xhc3MgdGhhdCBpcyBpbnRlbmRlZCB0byBiZSBtaXhlZCBpbiB3aXRoXG4gKiBhIGNsYXNzIHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgRXZlbnRIYW5kbGVyIGNsYXNzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZSBUeXBlIG5hbWUgb2YgdGhlIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRyYW5zZm9ybSBpcyBtb2RpZmllZFxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICBNaXhpblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4oZXZlbnROYW1lKSB7XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0yZCBtb2RpZmljYXRpb24gZXZlbnRcbiAgICogQGV2ZW50IEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBtb2RpZmllZFxuICAgKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICAgKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWl4aW4gVHJhbnNmb3JtMmQgbWl4aW4gd2l0aCBldmVudCBmaXJpbmcgd2hlbiBtb2RpZmllZFxuICAgKi9cbiAgcmV0dXJuIGFnZ3JlZ2F0aW9uKG51bGwsIFRyYW5zZm9ybTJkLCBjbGFzcyBFdmVudGVkVHJhbnNmb3JtMmQge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVucGFyZW50ZWQgcGl2b3Qgb2YgdGhlIHRyYW5zZm9ybS4gVGhlIHBpdm90IGlzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSB0cmFuc2Zvcm0ncyBwcmltYXJ5IHBvc2l0aW9uIHdoZXJlIHRoZVxuICAgICAqIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtWZWMyZH0gcGl2b3RcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHNldCBwaXZvdChwaXZvdCkge1xuICAgICAgaWYgKCFQb2ludDJkLmVxdWFscyhwaXZvdCwgdGhpcy5fcGl2b3QpKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fcGl2b3RbMF0sIHRoaXMuX3Bpdm90WzFdXVxuICAgICAgICBQb2ludDJkLmNvcHkodGhpcy5fcGl2b3QsIHBpdm90KVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwicGl2b3RcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IHBpdm90XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb3B5IG9mIHRoZSB1bnBhcmVudGVkIHBpdm90IG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICAgKi9cbiAgICBnZXQgcGl2b3QoKSB7XG4gICAgICByZXR1cm4gUG9pbnQyZC5jbG9uZSh0aGlzLl9waXZvdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtQb2ludDJkfSBwb3NcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uKHBvcykge1xuICAgICAgaWYgKCFQb2ludDJkLmVxdWFscyhwb3MsIHRoaXMuX3BvcykpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IFt0aGlzLl9wb3NbMF0sIHRoaXMuX3Bvc1sxXV1cbiAgICAgICAgUG9pbnQyZC5jb3B5KHRoaXMuX3BvcywgcG9zKVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwicG9zaXRpb25cIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IHBvc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSB1bnBhcmVudGVkIHBvc2l0aW9uIG9mIGEgdHJhbnNmb3JtIGJ5IGFuIG9mZnNldC5cbiAgICAgKiBAcGFyYW0gIHtWZWMyZH0gdHJhbnNsYXRpb25cbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh0cmFuc2xhdGlvbikge1xuICAgICAgaWYgKHRyYW5zbGF0aW9uWzBdIHx8IHRyYW5zbGF0aW9uWzFdKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fcG9zWzBdLCB0aGlzLl9wb3NbMV1dXG4gICAgICAgIFBvaW50MmQuYWRkVmVjMih0aGlzLl9wb3MsIHRoaXMuX3BvcywgdHJhbnNsYXRpb24pXG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJwb3NpdGlvblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VyclZhbDogW3RoaXMuX3Bvc1swXSwgdGhpcy5fcG9zWzFdXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIDJkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge1ZlYzJkfSBzY2FsZVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZFRyYW5zZm9ybTJkI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gICAgICovXG4gICAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICAgIGlmICghVmVjMmQuZXF1YWxzKHNjYWxlLCB0aGlzLl9zY2FsZSkpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IFt0aGlzLl9zY2FsZVswXSwgdGhpcy5fc2NhbGVbMV1dXG4gICAgICAgIFZlYzJkLmNvcHkodGhpcy5fc2NhbGUsIHNjYWxlKVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwic2l6ZVwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VyclZhbDogc2NhbGVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCB1bnBhcmVudGVkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm0gYnkgYSAyZCBzY2FsYXJcbiAgICAgKiBAcGFyYW0gIHtWZWMyZH0gc2NhbGVNdWx0XG4gICAgICogQGZpcmVzICBFdmVudGVkVHJhbnNmb3JtMmQjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAgICAgKi9cbiAgICBzY2FsZShzY2FsZU11bHQpIHtcbiAgICAgIGlmIChzY2FsZU11bHRbMF0gIT09IDEgfHwgc2NhbGVNdWx0WzFdICE9PSAxKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fc2NhbGVbMF0sIHRoaXMuX3NjYWxlWzFdXVxuICAgICAgICBWZWMyZC5tdWx0aXBseSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHNjYWxlTXVsdClcbiAgICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICBhdHRyOiBcInNpemVcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IFt0aGlzLl9zY2FsZVswXSwgdGhpcy5fc2NhbGVbMV1dXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVucGFyZW50ZWQgcm90YXRpb24gb2YgdGhlIHRyYW5zZm9ybSBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyBSb3RhdGlvbiBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQGZpcmVzICBFdmVudGVkVHJhbnNmb3JtMmQjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbihkZWcpIHtcbiAgICAgIGNvbnN0IGRlZ1RvVXNlID0gZGVnICUgMzYwXG4gICAgICBpZiAoZGVnVG9Vc2UgIT09IHRoaXMuX3JvdERlZykge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcm90RGVnXG4gICAgICAgIHRoaXMuX3JvdERlZyA9IGRlZ1RvVXNlXG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9yb3REZWdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYW5nbGUgaW4gZGVncmVlcyB0byB0aGUgY3VycmVudCB1bnBhcmVudGVkXG4gICAgICogcm90YXRpb24gb2YgdGhlIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGRlZyBBZGRpdGlvbmFsIHJvdGF0aW9uIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHJvdGF0ZShkZWcpIHtcbiAgICAgIGlmIChkZWcpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3JvdERlZ1xuICAgICAgICB0aGlzLl9yb3REZWcgKz0gZGVnXG4gICAgICAgIHRoaXMuX3JvdERlZyAlPSAzNjBcbiAgICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICBhdHRyOiBcIm9yaWVudGF0aW9uXCIsXG4gICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICBjdXJyYWw6IHRoaXMuX3JvdERlZ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHJlc2V0IGFsbCB0aGUgdW5wYXJlbnRlZCB0cmFuc2Zvcm0gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAgVHJhbnNsYXRpb24gaW4geCBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAgVHJhbnNsYXRpb24gaW4geSBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCAgU2NhbGUgaW4geCBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSAgU2NhbGUgaW4geSBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgUm90YXRpb24gYW5nbGUgZGVncmVlc1xuICAgICAqIEBmaXJlcyAgRXZlbnRlZFRyYW5zZm9ybTJkI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtYXRpb25zKHR4LCB0eSwgc3gsIHN5LCBkZWcpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gW11cbiAgICAgIGNvbnN0IHByZXZWYWxzID0gW11cbiAgICAgIGNvbnN0IGN1cnJWYWxzID0gW11cbiAgICAgIGlmICh0eXBlb2YgdHggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHR5ICE9PSBcInVuZGVmaW5lZFwiICYmICghR0xNYXRyaXguZXF1YWxzKHR4LCB0aGlzLl9wb3NbMF0pIHx8ICFHTE1hdHJpeC5lcXVhbHModHksIHRoaXMuX3Bvc1sxXSkpKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3BvcylcbiAgICAgICAgdGhpcy5fcG9zWzBdID0gdHhcbiAgICAgICAgdGhpcy5fcG9zWzFdID0gdHlcbiAgICAgICAgYXR0cnMucHVzaChcInBvc2l0aW9uXCIpXG4gICAgICAgIHByZXZWYWxzLnB1c2gocHJldilcbiAgICAgICAgY3VyclZhbHMucHVzaChQb2ludDJkLmNsb25lKHRoaXMuX3BvcykpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHN5ICE9PSBcInVuZGVmaW5lZFwiICYmICghR0xNYXRyaXguZXF1YWxzKHN4LCB0aGlzLl9zY2FsZVswXSkgfHwgIUdMTWF0cml4LmVxdWFscyhzeSwgdGhpcy5fc2NhbGVbMV0pKSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gVmVjMmQuY2xvbmUodGhpcy5fc2NhbGUpXG4gICAgICAgIFZlYzJkLnNldCh0aGlzLl9zY2FsZSwgc3gsIHN5KVxuICAgICAgICBhdHRycy5wdXNoKFwic2l6ZVwiKVxuICAgICAgICBwcmV2VmFscy5wdXNoKHByZXYpXG4gICAgICAgIGN1cnJWYWxzLnB1c2goVmVjMmQuY2xvbmUodGhpcy5fc2NhbGUpKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBkZWdUb1VzZSA9IGRlZyAlIDM2MFxuICAgICAgICBpZiAoIUdMTWF0cml4LmVxdWFscyhkZWdUb1VzZSwgdGhpcy5fcm90RGVnKSkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9yb3REZWdcbiAgICAgICAgICB0aGlzLl9yb3REZWcgPSBkZWdUb1VzZVxuICAgICAgICAgIGF0dHJzLnB1c2goXCJvcmllbnRhdGlvblwiKVxuICAgICAgICAgIHByZXZWYWxzLnB1c2gocHJldilcbiAgICAgICAgICBjdXJyVmFscy5wdXNoKHRoaXMuX3JvdERlZylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgcHJldlZhbHMsXG4gICAgICAgICAgY3VyclZhbHNcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3RyYW5zZm9ybTJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n  @typedef EventObject\n  @type {object}\n  @property {string} type - the type of the event\n  @property {string} target - the target object that fired the event\n /\n\n/**\n * This callback is displayed as a global member.\n * @callback EventCallback\n * @param {EventObject} Event object describing the event being fired\n */\n\n/**\n * Recursively fires hierarchical events from an handler's registered\n * event types. For example, if an event is registered as \"changed:color\",\n * both a \"changed:color\" and \"changed\" event is fired, so listeners who\n * only generically care if something changed on an object can be notified.\n * @param  {Map} currMap  map datastructure holding all hierarchical events and callbacks\n * @param  {string[]} subtypes the \":\" separated list of the event\n * @param  {number} currIdx  the current index of subtypes being processed\n * @param  {Object} fireData the event object to fire\n * @return {number}          total number of listeners called\n * @private\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction recursiveFire(currMap, subtypes, currIdx, fireData) {\n  var _this = this;\n\n  if (currIdx >= subtypes.length) {\n    return 0;\n  }\n\n  var cnt = 0;\n  var data = null;\n  data = currMap.get(subtypes[currIdx]);\n  if (data) {\n    cnt = recursiveFire(data[0], subtypes, currIdx + 1, fireData);\n    data[1].forEach(function (listener) {\n      return listener.call(_this, fireData);\n    });\n    cnt += data[1].length;\n  }\n  return cnt;\n}\n\n/**\n * Recursively deletes specific listeners from a handlers event\n * data structure. For instance, if the same callback is used for both\n * a \"changed\" and a \"changed:color\" event, and that callback is deleted\n * from the \"changed\" event, it is also deleted from the \"changed:color\" event\n * @param  {Object} currNode  Current node of the map data structure being processed\n * @param  {function[]} listeners Array of listeners to delete\n * @private\n */\nfunction recursiveDelete(currNode, listeners) {\n  var index = -1;\n  var subnodes = currNode[0];\n  var nodelisteners = currNode[1];\n  if (nodelisteners.length) {\n    listeners.forEach(function (listener) {\n      if ((index = nodelisteners.indexOf(listener)) >= 0) {\n        nodelisteners.splice(index, 1);\n      }\n    });\n  }\n  subnodes.forEach(function (node) {\n    recursiveDelete(node, listeners);\n  });\n}\n\n/**\n * Validates that an input is a string or an array of strings, and if the former\n * returns a 1-element string array\n * @param  {string|string[]} intype\n * @return {string[]}\n * @private\n */\nfunction arrayify(intype) {\n  var arrayToUse = intype;\n  if (typeof intype === \"string\") {\n    arrayToUse = [intype];\n  } else if (!Array.isArray(intype)) {\n    throw new Error(\"Input must be an array of strings\");\n  }\n  return arrayToUse;\n}\n\n/** Class for managing events and listeners. Can be used as a base class or a mixin (using @see {@link aggregation}) */\n\nvar EventHandler = function () {\n\n  /**\n   * Create a new event handler\n   * @param  {string|string[]} eventsToRegister initial events to register\n   */\n  function EventHandler(eventsToRegister) {\n    _classCallCheck(this, EventHandler);\n\n    this.initializer(eventsToRegister);\n  }\n\n  /**\n   * Initializes an event handler object\n   * @param  {string|string[]} eventsToRegister events to initialize event handler with\n   * @see  {@link aggregation}\n   */\n\n\n  _createClass(EventHandler, [{\n    key: \"initializer\",\n    value: function initializer(eventsToRegister) {\n      this._listeners = new Map();\n      this.registerEvents(eventsToRegister);\n    }\n\n    /**\n     * Registers new events for the event handler\n     * @param  {string|string[]} events new event(s) to register\n     */\n\n  }, {\n    key: \"registerEvents\",\n    value: function registerEvents(events) {\n      var _this2 = this;\n\n      if (!events) {\n        return;\n      }\n\n      var eventsToUse = arrayify(events);\n      if (typeof events === \"string\") {\n        eventsToUse = [events];\n      } else if (!Array.isArray(events)) {\n        throw new Error(\"Events must be an array of strings\");\n      }\n\n      eventsToUse.forEach(function (event) {\n        var subevents = event.split(\":\");\n        var currMap = _this2._listeners;\n        for (var i = 0; i < subevents.length; i += 1) {\n          var data = currMap.get(subevents[i]);\n          if (!data) {\n            data = [new Map(), []];\n            currMap.set(subevents[i], data);\n          }\n          currMap = data[0];\n        }\n      });\n    }\n\n    /**\n     * Adds a new listener to a specific event or list of different events\n     * @param  {string|string[]} types    event(s) this listener is listening to\n     * @param  {EventCallback} listener function to be called when events destribed by types is fired\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(types, listener) {\n      var _this3 = this;\n\n      var typesToUse = arrayify(types);\n      typesToUse.forEach(function (type) {\n        var subtypes = type.split(\":\");\n        var currMap = _this3._listeners;\n        var data = null;\n        subtypes.forEach(function (subtype) {\n          data = currMap.get(subtype);\n          if (!data) {\n            var keys = [];\n            currMap.forEach(function (val, key) {\n              return keys.push(key);\n            });\n            throw new Error(type + \" is not a valid event type. The registered event types at this level are [\" + keys + \"]\");\n          }\n          currMap = data[0];\n        });\n        if (data[1].indexOf(listener) < 0) {\n          data[1].push(listener);\n        }\n      });\n\n      return this;\n    }\n\n    /**\n     * Removes a listener from specific events\n     * @param  {string|string[]} types    event(s) the listener is being removed from\n     * @param  {EventCallback} listener callback function to be cleared from the specified event types\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(types, listener) {\n      var _this4 = this;\n\n      var typesToUse = arrayify(types);\n      var listeners = listener;\n      if (!Array.isArray(listeners)) {\n        listeners = [listener];\n      }\n      typesToUse.forEach(function (type) {\n        var subtypes = type.split(\":\");\n        var currMap = _this4._listeners;\n        var data = null;\n        var i = 0;\n        for (i = 0; i < subtypes.length; i += 1) {\n          data = currMap.get(subtypes[i]);\n          if (!data) {\n            break;\n          }\n          currMap = data[0];\n        }\n        if (data) {\n          recursiveDelete(data, listeners);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Sets up a lister callback to only be called once\n     * @param  {string|string[]} types    event(s) the listener is listening to\n     * @param  {EventCallback} listener callback function to be called with event(s) are fired\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(types, listener) {\n      var _this5 = this;\n\n      var wrapper = function wrapper(data) {\n        _this5.off(types, wrapper);\n        listener.call(_this5, data);\n      };\n      this.on(types, wrapper);\n      return this;\n    }\n\n    /**\n     * Fires a specific event and calls any listeners of that event type.\n     * @param  {string} type Event type to fire\n     * @param  {Object} data Additional data to fire with the event\n     * @return {EventHandler}      this\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(type, data) {\n      var subtypes = type.split(\":\");\n\n      var fireData = {\n        type: type,\n        target: this\n      };\n\n      Object.assign(fireData, data);\n\n      recursiveFire(this._listeners, subtypes, 0, fireData);\n\n      // To ensure that no error events are dropped, print them to the\n      // console if they have no listeners.\n      // if (!numFires && endsWith(type, \"error\")) {\n      //   console.error((data && data.error) || data || \"Empty error event\")\n      // }\n\n      if (this._eventParent) {\n        fireData = {};\n        Object.getOwnPropertyNames(data).forEach(function (key) {\n          fireData[key] = data[key];\n        });\n        this._eventParent.fire(type, fireData);\n      }\n\n      return this;\n    }\n\n    /**\n     * Returns whether or not this event hander fires a specific event type\n     * @param  {string} type Event type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"listens\",\n    value: function listens(type) {\n      var subtypes = type.split(\":\");\n      var currMap = this._listeners;\n      var data = null;\n      for (var i = 0; i < subtypes.length; i += 1) {\n        data = currMap.get(subtypes[i]);\n        if (!data) {\n          break;\n        }\n        currMap = data[0];\n      }\n      return data || this._eventParent && this._eventParent.listens(type);\n    }\n\n    /**\n     * Sets a parent event handler\n     * @param {EventHandler} parent\n     * @param {object} data\n     */\n\n  }, {\n    key: \"setEventedParent\",\n    value: function setEventedParent(parent, data) {\n      this._eventParent = parent;\n      this._eventParentData = data;\n\n      return this;\n    }\n  }]);\n\n  return EventHandler;\n}();\n\nexports.default = EventHandler;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2V2ZW50LWhhbmRsZXIuanM/MWM0OSJdLCJuYW1lcyI6WyJyZWN1cnNpdmVGaXJlIiwiY3Vyck1hcCIsInN1YnR5cGVzIiwiY3VycklkeCIsImZpcmVEYXRhIiwibGVuZ3RoIiwiY250IiwiZGF0YSIsImdldCIsImZvckVhY2giLCJsaXN0ZW5lciIsImNhbGwiLCJyZWN1cnNpdmVEZWxldGUiLCJjdXJyTm9kZSIsImxpc3RlbmVycyIsImluZGV4Iiwic3Vibm9kZXMiLCJub2RlbGlzdGVuZXJzIiwiaW5kZXhPZiIsInNwbGljZSIsIm5vZGUiLCJhcnJheWlmeSIsImludHlwZSIsImFycmF5VG9Vc2UiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsIkV2ZW50SGFuZGxlciIsImV2ZW50c1RvUmVnaXN0ZXIiLCJpbml0aWFsaXplciIsIl9saXN0ZW5lcnMiLCJNYXAiLCJyZWdpc3RlckV2ZW50cyIsImV2ZW50cyIsImV2ZW50c1RvVXNlIiwic3ViZXZlbnRzIiwiZXZlbnQiLCJzcGxpdCIsImkiLCJzZXQiLCJ0eXBlcyIsInR5cGVzVG9Vc2UiLCJ0eXBlIiwic3VidHlwZSIsImtleXMiLCJ2YWwiLCJrZXkiLCJwdXNoIiwid3JhcHBlciIsIm9mZiIsIm9uIiwidGFyZ2V0IiwiT2JqZWN0IiwiYXNzaWduIiwiX2V2ZW50UGFyZW50IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpcmUiLCJsaXN0ZW5zIiwicGFyZW50IiwiX2V2ZW50UGFyZW50RGF0YSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUEsU0FBU0EsYUFBVCxDQUF1QkMsT0FBdkIsRUFBZ0NDLFFBQWhDLEVBQTBDQyxPQUExQyxFQUFtREMsUUFBbkQsRUFBNkQ7QUFBQTs7QUFDM0QsTUFBSUQsV0FBV0QsU0FBU0csTUFBeEIsRUFBZ0M7QUFDOUIsV0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBSUMs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Ozs7a0JBN0xrQm9CLFkiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG4vKipcbiAgQHR5cGVkZWYgRXZlbnRPYmplY3RcbiAgQHR5cGUge29iamVjdH1cbiAgQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSB0aGUgdHlwZSBvZiB0aGUgZXZlbnRcbiAgQHByb3BlcnR5IHtzdHJpbmd9IHRhcmdldCAtIHRoZSB0YXJnZXQgb2JqZWN0IHRoYXQgZmlyZWQgdGhlIGV2ZW50XG4gL1xuXG4vKipcbiAqIFRoaXMgY2FsbGJhY2sgaXMgZGlzcGxheWVkIGFzIGEgZ2xvYmFsIG1lbWJlci5cbiAqIEBjYWxsYmFjayBFdmVudENhbGxiYWNrXG4gKiBAcGFyYW0ge0V2ZW50T2JqZWN0fSBFdmVudCBvYmplY3QgZGVzY3JpYmluZyB0aGUgZXZlbnQgYmVpbmcgZmlyZWRcbiAqL1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGZpcmVzIGhpZXJhcmNoaWNhbCBldmVudHMgZnJvbSBhbiBoYW5kbGVyJ3MgcmVnaXN0ZXJlZFxuICogZXZlbnQgdHlwZXMuIEZvciBleGFtcGxlLCBpZiBhbiBldmVudCBpcyByZWdpc3RlcmVkIGFzIFwiY2hhbmdlZDpjb2xvclwiLFxuICogYm90aCBhIFwiY2hhbmdlZDpjb2xvclwiIGFuZCBcImNoYW5nZWRcIiBldmVudCBpcyBmaXJlZCwgc28gbGlzdGVuZXJzIHdob1xuICogb25seSBnZW5lcmljYWxseSBjYXJlIGlmIHNvbWV0aGluZyBjaGFuZ2VkIG9uIGFuIG9iamVjdCBjYW4gYmUgbm90aWZpZWQuXG4gKiBAcGFyYW0gIHtNYXB9IGN1cnJNYXAgIG1hcCBkYXRhc3RydWN0dXJlIGhvbGRpbmcgYWxsIGhpZXJhcmNoaWNhbCBldmVudHMgYW5kIGNhbGxiYWNrc1xuICogQHBhcmFtICB7c3RyaW5nW119IHN1YnR5cGVzIHRoZSBcIjpcIiBzZXBhcmF0ZWQgbGlzdCBvZiB0aGUgZXZlbnRcbiAqIEBwYXJhbSAge251bWJlcn0gY3VycklkeCAgdGhlIGN1cnJlbnQgaW5kZXggb2Ygc3VidHlwZXMgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0gIHtPYmplY3R9IGZpcmVEYXRhIHRoZSBldmVudCBvYmplY3QgdG8gZmlyZVxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICB0b3RhbCBudW1iZXIgb2YgbGlzdGVuZXJzIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlRmlyZShjdXJyTWFwLCBzdWJ0eXBlcywgY3VycklkeCwgZmlyZURhdGEpIHtcbiAgaWYgKGN1cnJJZHggPj0gc3VidHlwZXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGxldCBjbnQgPSAwXG4gIGxldCBkYXRhID0gbnVsbFxuICBkYXRhID0gY3Vyck1hcC5nZXQoc3VidHlwZXNbY3VycklkeF0pXG4gIGlmIChkYXRhKSB7XG4gICAgY250ID0gcmVjdXJzaXZlRmlyZShkYXRhWzBdLCBzdWJ0eXBlcywgY3VycklkeCArIDEsIGZpcmVEYXRhKVxuICAgIGRhdGFbMV0uZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lci5jYWxsKHRoaXMsIGZpcmVEYXRhKSlcbiAgICBjbnQgKz0gZGF0YVsxXS5sZW5ndGhcbiAgfVxuICByZXR1cm4gY250XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZGVsZXRlcyBzcGVjaWZpYyBsaXN0ZW5lcnMgZnJvbSBhIGhhbmRsZXJzIGV2ZW50XG4gKiBkYXRhIHN0cnVjdHVyZS4gRm9yIGluc3RhbmNlLCBpZiB0aGUgc2FtZSBjYWxsYmFjayBpcyB1c2VkIGZvciBib3RoXG4gKiBhIFwiY2hhbmdlZFwiIGFuZCBhIFwiY2hhbmdlZDpjb2xvclwiIGV2ZW50LCBhbmQgdGhhdCBjYWxsYmFjayBpcyBkZWxldGVkXG4gKiBmcm9tIHRoZSBcImNoYW5nZWRcIiBldmVudCwgaXQgaXMgYWxzbyBkZWxldGVkIGZyb20gdGhlIFwiY2hhbmdlZDpjb2xvclwiIGV2ZW50XG4gKiBAcGFyYW0gIHtPYmplY3R9IGN1cnJOb2RlICBDdXJyZW50IG5vZGUgb2YgdGhlIG1hcCBkYXRhIHN0cnVjdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSAge2Z1bmN0aW9uW119IGxpc3RlbmVycyBBcnJheSBvZiBsaXN0ZW5lcnMgdG8gZGVsZXRlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVEZWxldGUoY3Vyck5vZGUsIGxpc3RlbmVycykge1xuICBsZXQgaW5kZXggPSAtMVxuICBjb25zdCBzdWJub2RlcyA9IGN1cnJOb2RlWzBdXG4gIGNvbnN0IG5vZGVsaXN0ZW5lcnMgPSBjdXJyTm9kZVsxXVxuICBpZiAobm9kZWxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICBpZiAoKGluZGV4ID0gbm9kZWxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSkgPj0gMCkge1xuICAgICAgICBub2RlbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIHN1Ym5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICByZWN1cnNpdmVEZWxldGUobm9kZSwgbGlzdGVuZXJzKVxuICB9KVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IGFuIGlucHV0IGlzIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MsIGFuZCBpZiB0aGUgZm9ybWVyXG4gKiByZXR1cm5zIGEgMS1lbGVtZW50IHN0cmluZyBhcnJheVxuICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSBpbnR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXJyYXlpZnkoaW50eXBlKSB7XG4gIGxldCBhcnJheVRvVXNlID0gaW50eXBlXG4gIGlmICh0eXBlb2YgaW50eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgYXJyYXlUb1VzZSA9IFtpbnR5cGVdXG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoaW50eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiKVxuICB9XG4gIHJldHVybiBhcnJheVRvVXNlXG59XG5cbi8qKiBDbGFzcyBmb3IgbWFuYWdpbmcgZXZlbnRzIGFuZCBsaXN0ZW5lcnMuIENhbiBiZSB1c2VkIGFzIGEgYmFzZSBjbGFzcyBvciBhIG1peGluICh1c2luZyBAc2VlIHtAbGluayBhZ2dyZWdhdGlvbn0pICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFdmVudEhhbmRsZXIge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50c1RvUmVnaXN0ZXIgaW5pdGlhbCBldmVudHMgdG8gcmVnaXN0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGV2ZW50c1RvUmVnaXN0ZXIpIHtcbiAgICB0aGlzLmluaXRpYWxpemVyKGV2ZW50c1RvUmVnaXN0ZXIpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYW4gZXZlbnQgaGFuZGxlciBvYmplY3RcbiAgICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSBldmVudHNUb1JlZ2lzdGVyIGV2ZW50cyB0byBpbml0aWFsaXplIGV2ZW50IGhhbmRsZXIgd2l0aFxuICAgKiBAc2VlICB7QGxpbmsgYWdncmVnYXRpb259XG4gICAqL1xuICBpbml0aWFsaXplcihldmVudHNUb1JlZ2lzdGVyKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50cyhldmVudHNUb1JlZ2lzdGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBuZXcgZXZlbnRzIGZvciB0aGUgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50cyBuZXcgZXZlbnQocykgdG8gcmVnaXN0ZXJcbiAgICovXG4gIHJlZ2lzdGVyRXZlbnRzKGV2ZW50cykge1xuICAgIGlmICghZXZlbnRzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZXZlbnRzVG9Vc2UgPSBhcnJheWlmeShldmVudHMpXG4gICAgaWYgKHR5cGVvZiBldmVudHMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGV2ZW50c1RvVXNlID0gW2V2ZW50c11cbiAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50cykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV2ZW50cyBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIilcbiAgICB9XG5cbiAgICBldmVudHNUb1VzZS5mb3JFYWNoKGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHN1YmV2ZW50cyA9IGV2ZW50LnNwbGl0KFwiOlwiKVxuICAgICAgbGV0IGN1cnJNYXAgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxldCBkYXRhID0gY3Vyck1hcC5nZXQoc3ViZXZlbnRzW2ldKVxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gW25ldyBNYXAoKSwgW11dXG4gICAgICAgICAgY3Vyck1hcC5zZXQoc3ViZXZlbnRzW2ldLCBkYXRhKVxuICAgICAgICB9XG4gICAgICAgIGN1cnJNYXAgPSBkYXRhWzBdXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbmV3IGxpc3RlbmVyIHRvIGEgc3BlY2lmaWMgZXZlbnQgb3IgbGlzdCBvZiBkaWZmZXJlbnQgZXZlbnRzXG4gICAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gdHlwZXMgICAgZXZlbnQocykgdGhpcyBsaXN0ZW5lciBpcyBsaXN0ZW5pbmcgdG9cbiAgICogQHBhcmFtICB7RXZlbnRDYWxsYmFja30gbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gZXZlbnRzIGRlc3RyaWJlZCBieSB0eXBlcyBpcyBmaXJlZFxuICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZXJ9ICAgICAgICAgIHRoaXNcbiAgICovXG4gIG9uKHR5cGVzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHR5cGVzVG9Vc2UgPSBhcnJheWlmeSh0eXBlcylcbiAgICB0eXBlc1RvVXNlLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjb25zdCBzdWJ0eXBlcyA9IHR5cGUuc3BsaXQoXCI6XCIpXG4gICAgICBsZXQgY3Vyck1hcCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgICAgbGV0IGRhdGEgPSBudWxsXG4gICAgICBzdWJ0eXBlcy5mb3JFYWNoKHN1YnR5cGUgPT4ge1xuICAgICAgICBkYXRhID0gY3Vyck1hcC5nZXQoc3VidHlwZSlcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgY29uc3Qga2V5cyA9IFtdXG4gICAgICAgICAgY3Vyck1hcC5mb3JFYWNoKCh2YWwsIGtleSkgPT4ga2V5cy5wdXNoKGtleSkpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3R5cGV9IGlzIG5vdCBhIHZhbGlkIGV2ZW50IHR5cGUuIFRoZSByZWdpc3RlcmVkIGV2ZW50IHR5cGVzIGF0IHRoaXMgbGV2ZWwgYXJlIFske2tleXN9XWApXG4gICAgICAgIH1cbiAgICAgICAgY3Vyck1hcCA9IGRhdGFbMF1cbiAgICAgIH0pXG4gICAgICBpZiAoZGF0YVsxXS5pbmRleE9mKGxpc3RlbmVyKSA8IDApIHtcbiAgICAgICAgZGF0YVsxXS5wdXNoKGxpc3RlbmVyKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmcm9tIHNwZWNpZmljIGV2ZW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IHR5cGVzICAgIGV2ZW50KHMpIHRoZSBsaXN0ZW5lciBpcyBiZWluZyByZW1vdmVkIGZyb21cbiAgICogQHBhcmFtICB7RXZlbnRDYWxsYmFja30gbGlzdGVuZXIgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2xlYXJlZCBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQgdHlwZXNcbiAgICogQHJldHVybiB7RXZlbnRIYW5kbGVyfSAgICAgICAgICB0aGlzXG4gICAqL1xuICBvZmYodHlwZXMsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgdHlwZXNUb1VzZSA9IGFycmF5aWZ5KHR5cGVzKVxuICAgIGxldCBsaXN0ZW5lcnMgPSBsaXN0ZW5lclxuICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICBsaXN0ZW5lcnMgPSBbbGlzdGVuZXJdXG4gICAgfVxuICAgIHR5cGVzVG9Vc2UuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IHN1YnR5cGVzID0gdHlwZS5zcGxpdChcIjpcIilcbiAgICAgIGxldCBjdXJyTWFwID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgICBsZXQgZGF0YSA9IG51bGxcbiAgICAgIGxldCBpID0gMFxuICAgICAgZm9yIChpID0gMDsgaSA8IHN1YnR5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGRhdGEgPSBjdXJyTWFwLmdldChzdWJ0eXBlc1tpXSlcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjdXJyTWFwID0gZGF0YVswXVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgcmVjdXJzaXZlRGVsZXRlKGRhdGEsIGxpc3RlbmVycylcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCBhIGxpc3RlciBjYWxsYmFjayB0byBvbmx5IGJlIGNhbGxlZCBvbmNlXG4gICAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gdHlwZXMgICAgZXZlbnQocykgdGhlIGxpc3RlbmVyIGlzIGxpc3RlbmluZyB0b1xuICAgKiBAcGFyYW0gIHtFdmVudENhbGxiYWNrfSBsaXN0ZW5lciBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2l0aCBldmVudChzKSBhcmUgZmlyZWRcbiAgICogQHJldHVybiB7RXZlbnRIYW5kbGVyfSAgICAgICAgICB0aGlzXG4gICAqL1xuICBvbmNlKHR5cGVzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHdyYXBwZXIgPSAoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5vZmYodHlwZXMsIHdyYXBwZXIpXG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGRhdGEpXG4gICAgfVxuICAgIHRoaXMub24odHlwZXMsIHdyYXBwZXIpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIHNwZWNpZmljIGV2ZW50IGFuZCBjYWxscyBhbnkgbGlzdGVuZXJzIG9mIHRoYXQgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGUgdG8gZmlyZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgQWRkaXRpb25hbCBkYXRhIHRvIGZpcmUgd2l0aCB0aGUgZXZlbnRcbiAgICogQHJldHVybiB7RXZlbnRIYW5kbGVyfSAgICAgIHRoaXNcbiAgICovXG4gIGZpcmUodHlwZSwgZGF0YSkge1xuICAgIGNvbnN0IHN1YnR5cGVzID0gdHlwZS5zcGxpdChcIjpcIilcblxuICAgIGxldCBmaXJlRGF0YSA9IHtcbiAgICAgIHR5cGUsXG4gICAgICB0YXJnZXQ6IHRoaXNcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKGZpcmVEYXRhLCBkYXRhKVxuXG4gICAgcmVjdXJzaXZlRmlyZSh0aGlzLl9saXN0ZW5lcnMsIHN1YnR5cGVzLCAwLCBmaXJlRGF0YSlcblxuICAgIC8vIFRvIGVuc3VyZSB0aGF0IG5vIGVycm9yIGV2ZW50cyBhcmUgZHJvcHBlZCwgcHJpbnQgdGhlbSB0byB0aGVcbiAgICAvLyBjb25zb2xlIGlmIHRoZXkgaGF2ZSBubyBsaXN0ZW5lcnMuXG4gICAgLy8gaWYgKCFudW1GaXJlcyAmJiBlbmRzV2l0aCh0eXBlLCBcImVycm9yXCIpKSB7XG4gICAgLy8gICBjb25zb2xlLmVycm9yKChkYXRhICYmIGRhdGEuZXJyb3IpIHx8IGRhdGEgfHwgXCJFbXB0eSBlcnJvciBldmVudFwiKVxuICAgIC8vIH1cblxuICAgIGlmICh0aGlzLl9ldmVudFBhcmVudCkge1xuICAgICAgZmlyZURhdGEgPSB7fVxuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBmaXJlRGF0YVtrZXldID0gZGF0YVtrZXldXG4gICAgICB9KVxuICAgICAgdGhpcy5fZXZlbnRQYXJlbnQuZmlyZSh0eXBlLCBmaXJlRGF0YSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBldmVudCBoYW5kZXIgZmlyZXMgYSBzcGVjaWZpYyBldmVudCB0eXBlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBsaXN0ZW5zKHR5cGUpIHtcbiAgICBjb25zdCBzdWJ0eXBlcyA9IHR5cGUuc3BsaXQoXCI6XCIpXG4gICAgbGV0IGN1cnJNYXAgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICBsZXQgZGF0YSA9IG51bGxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnR5cGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkYXRhID0gY3Vyck1hcC5nZXQoc3VidHlwZXNbaV0pXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGN1cnJNYXAgPSBkYXRhWzBdXG4gICAgfVxuICAgIHJldHVybiBkYXRhIHx8ICh0aGlzLl9ldmVudFBhcmVudCAmJiB0aGlzLl9ldmVudFBhcmVudC5saXN0ZW5zKHR5cGUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBwYXJlbnQgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0ge0V2ZW50SGFuZGxlcn0gcGFyZW50XG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhXG4gICAqL1xuICBzZXRFdmVudGVkUGFyZW50KHBhcmVudCwgZGF0YSkge1xuICAgIHRoaXMuX2V2ZW50UGFyZW50ID0gcGFyZW50XG4gICAgdGhpcy5fZXZlbnRQYXJlbnREYXRhID0gZGF0YVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdXRpbC9ldmVudC1oYW5kbGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventConstants = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _canvasUtils = __webpack_require__(30);\n\nvar CanvasUtils = _interopRequireWildcard(_canvasUtils);\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(7);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _utils = __webpack_require__(31);\n\nvar _camera2d = __webpack_require__(32);\n\nvar _camera2d2 = _interopRequireDefault(_camera2d);\n\nvar _eventHandler = __webpack_require__(13);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _ResizeSensor = __webpack_require__(33);\n\nvar _ResizeSensor2 = _interopRequireDefault(_ResizeSensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar mouseevents = [\"mousedown\", \"mouseup\", \"mousemove\", \"click\", \"dblclick\", \"mouseover\", \"mouseout\"];\nvar marginProps = [\"top\", \"bottom\", \"left\", \"right\"];\n\nvar EventConstants = exports.EventConstants = {\n  MOUSEDOWN: \"mousedown\",\n  MOUSEUP: \"mouseup\",\n  MOUSEMOVE: \"mousemove\",\n  CLICK: \"click\",\n  DBLCLICK: \"dblclick\",\n  MOUSEOVER: \"mouseover\",\n  MOUSEOUT: \"mouseout\",\n  SHAPE_ADD: \"shape:add\",\n  SHAPE_DELETE: \"shape:delete\"\n};\n\nvar DrawStyleState = function (_BasicStyle) {\n  _inherits(DrawStyleState, _BasicStyle);\n\n  function DrawStyleState() {\n    var _ref;\n\n    _classCallCheck(this, DrawStyleState);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = _possibleConstructorReturn(this, (_ref = DrawStyleState.__proto__ || Object.getPrototypeOf(DrawStyleState)).call.apply(_ref, [this].concat(args)));\n\n    _this._defaults = {\n      packedFillColor: _this.packedFillColor,\n      packedStrokeColor: _this.packedStrokeColor,\n      strokeWidth: _this.strokeWidth,\n      lineJoin: _this.lineJoin,\n      lineCap: _this.lineCap,\n      dashPattern: _this.dashPattern,\n      dashOffset: _this.dashOffset\n    };\n    return _this;\n  }\n\n  _createClass(DrawStyleState, [{\n    key: \"setFillStyle\",\n    value: function setFillStyle(ctx, fillStyle) {\n      if (fillStyle.packedFillColor !== this.packedFillColor) {\n        this.packedFillColor = fillStyle.packedFillColor;\n        ctx.fillStyle = this.fillColor;\n      }\n    }\n  }, {\n    key: \"setStrokeStyle\",\n    value: function setStrokeStyle(ctx, strokeStyle) {\n      if (strokeStyle.packedStrokeColor !== this.packedStrokeColor) {\n        this.packedStrokeColor = strokeStyle.packedStrokeColor;\n        ctx.strokeStyle = this.strokeColor;\n      }\n      if (strokeStyle.strokeWidth !== this._strokeWidth) {\n        this.strokeWidth = strokeStyle.strokeWidth;\n        ctx.lineWidth = this._strokeWidth;\n      }\n      if (strokeStyle.lineJoin !== this._lineJoin) {\n        this.lineJoin = strokeStyle.lineJoin;\n        ctx.lineJoin = this._lineJoin;\n      }\n      if (strokeStyle.lineCap !== this._lineCap) {\n        this.lineCap = strokeStyle.lineCap;\n        ctx.lineCap = this._lineCap;\n      }\n\n      var dashPattern = strokeStyle._dashPattern;\n      var diff = false;\n      if (dashPattern.length === this._dashPattern.length) {\n        for (var i = 0; i < dashPattern.length; i += 1) {\n          if (dashPattern[i] !== this._dashPattern[i]) {\n            diff = true;\n            break;\n          }\n        }\n      } else {\n        diff = true;\n      }\n\n      if (diff) {\n        this.dashPattern = dashPattern;\n        ctx.setLineDash(this._dashPattern);\n      }\n\n      if (strokeStyle.dashOffset !== this._dashOffset) {\n        this.dashOffset = strokeStyle.dashOffset;\n        ctx.lineDashOffset = this._dashOffset;\n      }\n    }\n  }, {\n    key: \"applyDefaults\",\n    value: function applyDefaults(ctx) {\n      var _this2 = this;\n\n      Object.getOwnPropertyNames(this._defaults).forEach(function (prop) {\n        _this2[prop] = _this2._defaults[prop];\n      });\n      this.setFillCtx(ctx);\n      this.setStrokeCtx(ctx);\n    }\n  }]);\n\n  return DrawStyleState;\n}(_basicStyle2.default);\n\nfunction addClass(element, className) {\n  if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") < 0) {\n    element.className += (element.className ? \" \" : \"\") + className;\n  }\n}\n\nfunction createCanvas(parent) {\n  var canvasContainer = document.createElement(\"div\");\n  addClass(canvasContainer, \"mapd-draw-canvas-container\");\n\n  var canvas = document.createElement(\"canvas\");\n  var canvasContext = canvas.getContext(\"2d\");\n  var ratio = CanvasUtils.makeCanvasAutoHighDPI(canvasContext);\n  // const ratio = 1\n\n  // add class?\n  addClass(canvas, \"mapd-draw-canvas\");\n  canvas.style.position = \"absolute\";\n  canvas.style.pointerEvents = \"none\";\n\n  canvasContainer.appendChild(canvas);\n\n  // canvas.setAttribute(\"width\", ratio * parent.offsetX)\n  // canvas.setAttribute(\"height\", ratio * parent.offsetY)\n  // parent.insertBefore(canvas, parent.firstChild)\n  parent.appendChild(canvasContainer);\n\n  return {\n    canvasContainer: canvasContainer,\n    canvas: canvas,\n    canvasContext: canvasContext,\n    ratio: ratio\n  };\n}\n\nfunction addShapesToMap(newShapes, existingObjectsMap, currIds, reorderCb, redrawCb) {\n  newShapes.forEach(function (shape) {\n    existingObjectsMap.set(shape, {\n      shapeObj: shape,\n      shapeId: currIds.shapeId,\n      shapeIdx: -1\n    });\n    shape.on([\"changed:order\", \"changed:visibility\", \"changed:style\"], reorderCb);\n    shape.on([\"changed:geom\", \"changed:visibility\", \"changed:xform\"], redrawCb);\n    currIds.shapeId += 1;\n  });\n}\n\nfunction deleteShapesFromMap(shapes, existingObjectsMap, reorderCb, redrawCb) {\n  var idxs = [];\n  shapes.forEach(function (shape) {\n    var shapeInfo = existingObjectsMap.get(shape);\n    if (shapeInfo) {\n      idxs.push(shapeInfo.shapeIdx);\n    }\n    existingObjectsMap.delete(shape);\n    shape.off([\"changed\"], [reorderCb, redrawCb]);\n  });\n  return idxs;\n}\n\nvar DrawEngine = function (_EventHander) {\n  _inherits(DrawEngine, _EventHander);\n\n  function DrawEngine(parent, opts) {\n    _classCallCheck(this, DrawEngine);\n\n    var _this3 = _possibleConstructorReturn(this, (DrawEngine.__proto__ || Object.getPrototypeOf(DrawEngine)).call(this));\n\n    _this3._init(parent, opts);\n    return _this3;\n  }\n\n  _createClass(DrawEngine, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this4 = this;\n\n      this._destroyCanvas();\n\n      if (this._objects) {\n        this._objects.forEach(function (shapeInfo, shape) {\n          shape.off(\"changed\", [_this4._reorderCb, _this4._redrawCb]);\n        });\n        this._objects.clear();\n        this._sortedObjs = [];\n        this._reorderedObjIdxs.clear();\n      }\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(opts) {\n      var width = 0;\n      if (this._parent.offsetWidth) {\n        width = Math.max(width, this._parent.offsetWidth - this._margins.left - this._margins.right);\n      }\n\n      var height = 0;\n      if (this._parent.offsetHeight) {\n        height = Math.max(height, this._parent.offsetHeight - this._margins.top - this._margins.bottom);\n      }\n\n      this._drawCanvas.width = width * this._pixelRatio;\n      this._drawCanvas.height = height * this._pixelRatio;\n\n      this._drawCanvas.style.left = this._margins.left + \"px\";\n      this._drawCanvas.style.top = this._margins.top + \"px\";\n      this._drawCanvas.style.width = width + \"px\";\n      this._drawCanvas.style.height = height + \"px\";\n\n      if (this._camera) {\n        // const currViewport = this._camera.viewport\n        // const currSpace = this._camera.projectionBounds\n        // const viewportExtents = [0, 0]\n        // AABox2d.getExtents(viewportExtents, currViewport)\n        // const spaceCenter = [0, 0]\n        // const spaceExtents = [0, 0]\n        // AABox2d.getCenter(spaceCenter, currSpace)\n        // AABox2d.getExtents(spaceExtents, currSpace)\n        // const ratio = spaceExtents\n        // Vec2d.div(ratio, spaceExtents, viewportExtents)\n        // AABox2d.set(currViewport, 0, 0, width, height)\n        // AABox2d.getExtents(viewportExtents, currViewport)\n        // Vec2d.multiply(spaceExtents, ratio, viewportExtents)\n        // AABox2d.initCenterExtents(currSpace, spaceCenter, spaceExtents)\n        // this._camera.viewport = currViewport\n        // this._camera.projectionBounds = currSpace\n        //   // this._camera.viewport = [0, 0, width, height]\n        //   // this._camera.projectionBounds = [0, 0, width, height]\n      } else {\n        var projDims = opts && opts.projectionDimensions ? opts.projectionDimensions : [width, height];\n        this._camera = new _camera2d2.default([0, 0, width, height], projDims, opts.flipY ? Boolean(opts.flipY) : false);\n        this._camera.setPosition(opts && opts.cameraPosition ? opts.cameraPosition : [width / 2.0, height / 2.0]);\n        this._camera.on(\"changed\", this._rerenderCb);\n      }\n      // this._camera = new Camera2d([0, 0, this.width, this.height], [0, 0, this.width, this.height])\n      // this._camera.on(\"changed\", this._rerenderCb)\n\n      this._rerenderCb();\n    }\n  }, {\n    key: \"_mousedownCB\",\n    value: function _mousedownCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mousedown\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseupCB\",\n    value: function _mouseupCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseup\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mousemoveCB\",\n    value: function _mousemoveCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mousemove\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_clickCB\",\n    value: function _clickCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"click\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_dblclickCB\",\n    value: function _dblclickCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"dblclick\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseoverCB\",\n    value: function _mouseoverCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseover\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseoutCB\",\n    value: function _mouseoutCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseout\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_enableEvents\",\n    value: function _enableEvents() {\n      this.registerEvents(mouseevents);\n      var callbacks = mouseevents.map(function (event) {\n        return \"_\" + event + \"CB\";\n      });\n      // bindAll(callbacks, this)\n      for (var i = 0; i < mouseevents.length; i += 1) {\n        document.addEventListener(mouseevents[i], this[callbacks[i]], true);\n      }\n    }\n  }, {\n    key: \"_disableEvents\",\n    value: function _disableEvents() {\n      var callbacks = mouseevents.map(function (event) {\n        return \"_\" + event + \"CB\";\n      });\n      for (var i = 0; i < mouseevents.length; i += 1) {\n        document.removeEventListener(mouseevents[i], this[callbacks[i]], true);\n      }\n    }\n  }, {\n    key: \"_initCanvas\",\n    value: function _initCanvas(parent, opts) {\n      var _this5 = this;\n\n      var forceEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this._margins = opts && opts.margins ? Object.assign({}, opts.margins) : {};\n      marginProps.forEach(function (prop) {\n        if (typeof _this5._margins[prop] !== \"number\") {\n          _this5._margins[prop] = 0;\n        }\n      });\n\n      var _createCanvas = createCanvas(parent),\n          canvasContainer = _createCanvas.canvasContainer,\n          canvas = _createCanvas.canvas,\n          canvasContext = _createCanvas.canvasContext,\n          ratio = _createCanvas.ratio;\n\n      this._container = canvasContainer;\n      this._drawCanvas = canvas;\n      this._drawCtx = canvasContext;\n      this._pixelRatio = ratio;\n      this._parent = parent;\n\n      (0, _utils.bindAll)([\"_resize\"], this);\n      this._resize(opts);\n      this._resizeSensor = new _ResizeSensor2.default(parent, this._resize);\n\n      if (forceEvents || forceEvents === null && opts && opts.enableEvents) {\n        this._enableEvents();\n      }\n    }\n  }, {\n    key: \"_destroyCanvas\",\n    value: function _destroyCanvas() {\n      if (this._drawCanvas) {\n        this._disableEvents();\n      }\n\n      if (this._parent) {\n        this._parent.removeChild(this._drawCanvas);\n\n        if (this._resizeSensor) {\n          this._resizeSensor.detach(this._parent, this._resize);\n        }\n      }\n\n      this._drawCanvas = null;\n      this._drawCtx = null;\n      this._parent = null;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(parent, opts) {\n      var forceEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this.registerEvents([EventConstants.SHAPE_ADD, EventConstants.SHAPE_DELETE]);\n\n      (0, _utils.bindAll)([\"_reorderCb\", \"_rerenderCb\"], this);\n      (0, _utils.bindAll)([\"_mousedownCB\", \"_mouseupCB\", \"_mousemoveCB\", \"_clickCB\", \"_dblclickCB\", \"_mouseoverCB\", \"_mouseoutCB\"], this);\n\n      this._renderFrameCb = this.renderAll.bind(this);\n      this._renderRequestId = 0;\n      this._ids = {\n        shapeId: 1\n      };\n\n      this._objects = new Map();\n      this._sortedObjs = [];\n      this._reorderedObjIdxs = new Set();\n\n      this._initCanvas(parent, opts, forceEvents);\n\n      this._styleState = new DrawStyleState({\n        fillColor: \"red\"\n      });\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this._parent;\n    }\n  }, {\n    key: \"getCanvasContainer\",\n    value: function getCanvasContainer() {\n      return this._container;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this._drawCanvas;\n    }\n  }, {\n    key: \"project\",\n    value: function project(out, screenPt) {\n      var screenToWorldMatrix = this._camera.screenToWorldMatrix;\n      return Point2d.transformMat2d(out, screenPt, screenToWorldMatrix);\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(out, worldPt) {\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      return Point2d.transformMat2d(out, worldPt, worldToScreenMatrix);\n    }\n  }, {\n    key: \"hasShape\",\n    value: function hasShape(shape) {\n      return this._objects.has(shape);\n    }\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      addShapesToMap(shapes, this._objects, this._ids, this._reorderCb, this._rerenderCb);\n\n      // fire add event\n      this.fire(\"shape:add\", {\n        shape: shapes\n      });\n\n      var proxyEvent = {\n        target: shapes\n      };\n      this._reorderCb(proxyEvent);\n\n      return this;\n    }\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      var idxs = deleteShapesFromMap(shapes, this._objects, this._reorderCb, this._rerenderCb);\n      var index = -1;\n      for (var i = 0; i < shapes.length; i += 1) {\n        if ((index = this._sortedObjs.indexOf(shapes[i])) >= 0) {\n          this._sortedObjs.splice(index, 1);\n        }\n        this._reorderedObjIdxs.add(idxs[i]);\n      }\n      this._rerenderCb();\n\n      this.fire(\"shape:delete\", {\n        shape: shapes\n      });\n\n      return this;\n    }\n  }, {\n    key: \"deleteAllShapes\",\n    value: function deleteAllShapes() {\n      this.deleteShape(this.sortedShapes.slice());\n      return this;\n    }\n  }, {\n    key: \"moveShapeToTop\",\n    value: function moveShapeToTop(shape) {\n      if (this._objects.has(shape)) {\n        var shapes = this.sortedShapes;\n        var zindex = shapes[shapes.length - 1].zIndex;\n        shape.zIndex = zindex + 1;\n      }\n    }\n  }, {\n    key: \"moveShapeToBack\",\n    value: function moveShapeToBack(shape) {\n      if (this._objects.has(shape)) {\n        var shapes = this.sortedShapes;\n        var zindex = shapes[0].zIndex;\n        shape.zIndex = zindex;\n      }\n    }\n  }, {\n    key: \"getShapesAsJSON\",\n    value: function getShapesAsJSON() {\n      var shapes = this.sortedShapes;\n      return shapes.map(function (shape) {\n        return shape.toJSON();\n      });\n    }\n  }, {\n    key: \"_rerenderCb\",\n    value: function _rerenderCb() {\n      if (this._renderRequestId) {\n        window.cancelAnimationFrame(this._renderRequestId);\n      }\n      this._renderRequestId = window.requestAnimationFrame(this._renderFrameCb);\n    }\n  }, {\n    key: \"_reorderCb\",\n    value: function _reorderCb(event) {\n      var _this6 = this;\n\n      var changedShapes = event.target;\n      if (!Array.isArray(changedShapes)) {\n        changedShapes = [event.target];\n      }\n      changedShapes.forEach(function (changedShape) {\n        console.assert(changedShape, \"A changed event doesn't have an object\");\n        var shapeInfo = _this6._objects.get(changedShape);\n        console.assert(shapeInfo, \"A changed event target isn't in the list of shapes \" + changedShape);\n        if (shapeInfo.shapeIdx < 0) {\n          shapeInfo.shapeIdx = _this6._sortedObjs.push(changedShape) - 1;\n        }\n        _this6._reorderedObjIdxs.add(shapeInfo.shapeIdx);\n      });\n      this._rerenderCb();\n    }\n  }, {\n    key: \"_renderShapes\",\n    value: function _renderShapes(ctx, drawShapes, camera) {\n      var _this7 = this;\n\n      var worldToScreenMat = camera.worldToScreenMatrix;\n      drawShapes.forEach(function (shape) {\n        if (shape.visible) {\n          shape.render(ctx, worldToScreenMat, _this7._styleState);\n        }\n      });\n    }\n  }, {\n    key: \"renderAll\",\n    value: function renderAll() {\n      var ctx = this._drawCtx;\n      // ctx.clearRect(0, 0, this.width, this.height)\n      ctx.clearRect(0, 0, this._drawCanvas.offsetWidth, this._drawCanvas.offsetHeight);\n\n      if (!this._objects.size) {\n        return;\n      }\n\n      ctx.save();\n      var drawShapes = this.sortedShapes;\n      this._styleState.applyDefaults(ctx);\n      this._renderShapes(ctx, drawShapes, this._camera);\n      ctx.restore();\n    }\n  }, {\n    key: \"sortedShapes\",\n    get: function get() {\n      if (this._reorderedObjIdxs.size) {\n        console.assert(this._sortedObjs.length === this._objects.size, \"Size mismatch when rendering objets. Something got out of sync - sorted objs length: \" + this._sortedObjs.length + \", objects length: \" + this._objects.size);\n\n        // if (this._reorderedObjIdxs.length / this._sortedObjs.length > 0.7) {\n        //   // might as well just resort the whole thing over\n        //   this._sortedObjs.sort(shapeInfoCompare)\n        // } else {\n        // }\n\n        this._sortedObjs.sort(_baseShape2.default.shapeCompare);\n        this._reorderedObjIdxs.clear();\n      }\n      return this._sortedObjs;\n    }\n  }, {\n    key: \"margins\",\n    get: function get() {\n      var _this8 = this;\n\n      var rtn = {};\n      marginProps.forEach(function (prop) {\n        rtn[prop] = _this8._margins[prop];\n      });\n      return rtn;\n    },\n    set: function set(margins) {\n      var _this9 = this;\n\n      marginProps.forEach(function (prop) {\n        if (typeof margins[prop] === \"number\" && margins[prop] !== _this9._margins[prop]) {\n          _this9._margins[prop] = margins.prop;\n        }\n      });\n\n      this._resize();\n    }\n  }, {\n    key: \"viewport\",\n    get: function get() {\n      return this._camera.viewport;\n    },\n    set: function set(viewport) {\n      this._camera.viewport = viewport;\n    }\n  }, {\n    key: \"projectionDimensions\",\n    get: function get() {\n      return this._camera.projectionDimensions;\n    },\n    set: function set(projectionDimensions) {\n      this._camera.projectionDimensions = projectionDimensions;\n      return this;\n    }\n  }, {\n    key: \"cameraPosition\",\n    get: function get() {\n      return this._camera.getPosition();\n    },\n    set: function set(pos) {\n      this._camera.setPosition(pos);\n      return this;\n    }\n  }]);\n\n  return DrawEngine;\n}(_eventHandler2.default);\n\nexports.default = DrawEngine;\n\n\nDrawEngine.EventConstants = EventConstants;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvZHJhdy1lbmdpbmUuanM/ZmYwMiJdLCJuYW1lcyI6WyJDYW52YXNVdGlscyIsIlBvaW50MmQiLCJtb3VzZWV2ZW50cyIsIm1hcmdpblByb3BzIiwiRXZlbnRDb25zdGFudHMiLCJNT1VTRURPV04iLCJNT1VTRVVQIiwiTU9VU0VNT1ZFIiwiQ0xJQ0siLCJEQkxDTElDSyIsIk1PVVNFT1ZFUiIsIk1PVVNFT1VUIiwiU0hBUEVfQUREIiwiU0hBUEVfREVMRVRFIiwiRHJhd1N0eWxlU3RhdGUiLCJhcmdzIiwiX2RlZmF1bHRzIiwicGFja2VkRmlsbENvbG9yIiwicGFja2VkU3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImxpbmVKb2luIiwibGluZUNhcCIsImRhc2hQYXR0ZXJuIiwiZGFzaE9mZnNldCIsImN0eCIsImZpbGxTdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZVN0eWxlIiwic3Ryb2tlQ29sb3IiLCJfc3Ryb2tlV2lkdGgiLCJsaW5lV2lkdGgiLCJfbGluZUpvaW4iLCJfbGluZUNhcCIsIl9kYXNoUGF0dGVybiIsImRpZmYiLCJsZW5ndGgiLCJpIiwic2V0TGluZURhc2giLCJfZGFzaE9mZnNldCIsImxpbmVEYXNoT2Zmc2V0IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZvckVhY2giLCJwcm9wIiwic2V0RmlsbEN0eCIsInNldFN0cm9rZUN0eCIsImFkZENsYXNzIiwiZWxlbWVudCIsImNsYXNzTmFtZSIsImluZGV4T2YiLCJjcmVhdGVDYW52YXMiLCJwYXJlbnQiLCJjYW52YXNDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjYW52YXMiLCJjYW52YXNDb250ZXh0IiwiZ2V0Q29udGV4dCIsInJhdGlvIiwibWFrZUNhbnZhc0F1dG9IaWdoRFBJIiwic3R5bGUiLCJwb3NpdGlvbiIsInBvaW50ZXJFdmVudHMiLCJhcHBlbmRDaGlsZCIsImFkZFNoYXBlc1RvTWFwIiwibmV3U2hhcGVzIiwiZXhpc3RpbmdPYmplY3RzTWFwIiwiY3VycklkcyIsInJlb3JkZXJDYiIsInJlZHJhd0NiIiwic2V0Iiwic2hhcGUiLCJzaGFwZU9iaiIsInNoYXBlSWQiLCJzaGFwZUlkeCIsIm9uIiwiZGVsZXRlU2hhcGVzRnJvbU1hcCIsInNoYXBlcyIsImlkeHMiLCJzaGFwZUluZm8iLCJnZXQiLCJwdXNoIiwiZGVsZXRlIiwib2ZmIiwiRHJhd0VuZ2luZSIsIm9wdHMiLCJfaW5pdCIsIl9kZXN0cm95Q2FudmFzIiwiX29iamVjdHMiLCJfcmVvcmRlckNiIiwiX3JlZHJhd0NiIiwiY2xlYXIiLCJfc29ydGVkT2JqcyIsIl9yZW9yZGVyZWRPYmpJZHhzIiwid2lkdGgiLCJfcGFyZW50Iiwib2Zmc2V0V2lkdGgiLCJNYXRoIiwibWF4IiwiX21hcmdpbnMiLCJsZWZ0IiwicmlnaHQiLCJoZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJ0b3AiLCJib3R0b20iLCJfZHJhd0NhbnZhcyIsIl9waXhlbFJhdGlvIiwiX2NhbWVyYSIsInByb2pEaW1zIiwicHJvamVjdGlvbkRpbWVuc2lvbnMiLCJmbGlwWSIsIkJvb2xlYW4iLCJzZXRQb3NpdGlvbiIsImNhbWVyYVBvc2l0aW9uIiwiX3JlcmVuZGVyQ2IiLCJldmVudCIsInRhcmdldCIsImZpcmUiLCJvcmlnaW5hbEV2ZW50IiwicmVnaXN0ZXJFdmVudHMiLCJjYWxsYmFja3MiLCJtYXAiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZvcmNlRXZlbnRzIiwibWFyZ2lucyIsImFzc2lnbiIsIl9jb250YWluZXIiLCJfZHJhd0N0eCIsIl9yZXNpemUiLCJfcmVzaXplU2Vuc29yIiwiZW5hYmxlRXZlbnRzIiwiX2VuYWJsZUV2ZW50cyIsIl9kaXNhYmxlRXZlbnRzIiwicmVtb3ZlQ2hpbGQiLCJkZXRhY2giLCJfcmVuZGVyRnJhbWVDYiIsInJlbmRlckFsbCIsImJpbmQiLCJfcmVuZGVyUmVxdWVzdElkIiwiX2lkcyIsIk1hcCIsIlNldCIsIl9pbml0Q2FudmFzIiwiX3N0eWxlU3RhdGUiLCJvdXQiLCJzY3JlZW5QdCIsInNjcmVlblRvV29ybGRNYXRyaXgiLCJ0cmFuc2Zvcm1NYXQyZCIsIndvcmxkUHQiLCJ3b3JsZFRvU2NyZWVuTWF0cml4IiwiaGFzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJveHlFdmVudCIsImluZGV4Iiwic3BsaWNlIiwiYWRkIiwiZGVsZXRlU2hhcGUiLCJzb3J0ZWRTaGFwZXMiLCJzbGljZSIsInppbmRleCIsInpJbmRleCIsInRvSlNPTiIsIndpbmRvdyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2hhbmdlZFNoYXBlcyIsImNvbnNvbGUiLCJhc3NlcnQiLCJjaGFuZ2VkU2hhcGUiLCJkcmF3U2hhcGVzIiwiY2FtZXJhIiwid29ybGRUb1NjcmVlbk1hdCIsInZpc2libGUiLCJyZW5kZXIiLCJjbGVhclJlY3QiLCJzaXplIiwic2F2ZSIsImFwcGx5RGVmYXVsdHMiLCJfcmVuZGVyU2hhcGVzIiwicmVzdG9yZSIsInNvcnQiLCJzaGFwZUNvbXBhcmUiLCJydG4iLCJ2aWV3cG9ydCIsImdldFBvc2l0aW9uIiwicG9zIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBRUE7O0lBQVlBLFc7O0FBQ1o7O0lBQVlDLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQyxjQUFjLENBQUMsV0FBRCxFQUFjLFNBQWQsRUFBeUIsV0FBekIsRUFBc0MsT0FBdEMsRUFBK0MsVUFBL0MsRUFBMkQsV0FBM0QsRUFBd0UsVUFBeEUsQ0FBcEI7QUFDQSxJQUFNQyxjQUFjLENBQUMsS0FBRCxFQUFRLFFBQVIsRUFBa0IsTUFBbEIsRUFBMEIsT0FBMUIsQ0FBcEI7O0FBRU8sSUFBTUMsMENBQWlCO0FBQzVCQyxhQUFXLFdBRGlCO0FBRTVCQyxXQUFTLFNBRm1CO0FBRzVCQyxhQUFXLFdBSGlCO0FBSTVCQyxTQUFP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M0QsRUFBZ0Y7QUFDOUUsaUJBQUt3RCxRQUFMLENBQWN4RCxJQUFkLElBQXNCbUYsUUFBUW5GLElBQTlCO0FBQ0Q7QUFDRixPQUpEOztBQU1BLFdBQUt1RixPQUFMO0FBQ0Q7Ozt3QkFFYztBQUNiLGFBQU8sS0FBS3RCLE9BQUwsQ0FBYThFLFFBQXBCO0FBQ0QsSztzQkFFWUEsUSxFQUFVO0FBQ3JCLFdBQUs5RSxPQUFMLENBQWE4RSxRQUFiLEdBQXdCQSxRQUF4QjtBQUNEOzs7d0JBRTBCO0FBQ3pCLGFBQU8sS0FBSzlFLE9BQUwsQ0FBYUUsb0JBQXBCO0FBQ0QsSztzQkFFd0JBLG9CLEVBQXNCO0FBQzdDLFdBQUtGLE9BQUwsQ0FBYUUsb0JBQWIsR0FBb0NBLG9CQUFwQztBQUNBLGFBQU8sSUFBUDtBQUNEOzs7d0JBRW9CO0FBQ25CLGFBQU8sS0FBS0YsT0FBTCxDQUFhK0UsV0FBYixFQUFQO0FBQ0QsSztzQkFFa0JDLEcsRUFBSztBQUN0QixXQUFLaEYsT0FBTCxDQUFhSyxXQUFiLENBQXlCMkUsR0FBekI7QUFDQSxhQUFPLElBQVA7QUFDRDs7Ozs7O2tCQXpTa0J4RyxVOzs7QUFpYnJCQSxXQUFXaEYsY0FBWCxHQUE0QkEsY0FBNUIiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBDYW52YXNVdGlscyBmcm9tIFwiLi4vdXRpbC9jYW52YXMtdXRpbHNcIlxuaW1wb3J0ICogYXMgUG9pbnQyZCBmcm9tIFwiLi4vY29yZS9wb2ludDJkXCJcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSBcIi4uL3NoYXBlcy9iYXNlLXNoYXBlXCJcbmltcG9ydCBCYXNpY1N0eWxlIGZyb20gXCIuLi9zdHlsZS9iYXNpYy1zdHlsZVwiXG5pbXBvcnQge1xuICBiaW5kQWxsXG59IGZyb20gXCIuLi91dGlsL3V0aWxzXCJcbmltcG9ydCBDYW1lcmEyZCBmcm9tIFwiLi4vdmlldy9jYW1lcmEyZFwiXG5pbXBvcnQgRXZlbnRIYW5kZXIgZnJvbSBcIi4uL3V0aWwvZXZlbnQtaGFuZGxlclwiXG5pbXBvcnQgUmVzaXplU2Vuc29yIGZyb20gXCJjc3MtZWxlbWVudC1xdWVyaWVzL3NyYy9SZXNpemVTZW5zb3JcIlxuXG5jb25zdCBtb3VzZWV2ZW50cyA9IFtcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJtb3VzZW1vdmVcIiwgXCJjbGlja1wiLCBcImRibGNsaWNrXCIsIFwibW91c2VvdmVyXCIsIFwibW91c2VvdXRcIl1cbmNvbnN0IG1hcmdpblByb3BzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdXG5cbmV4cG9ydCBjb25zdCBFdmVudENvbnN0YW50cyA9IHtcbiAgTU9VU0VET1dOOiBcIm1vdXNlZG93blwiLFxuICBNT1VTRVVQOiBcIm1vdXNldXBcIixcbiAgTU9VU0VNT1ZFOiBcIm1vdXNlbW92ZVwiLFxuICBDTElDSzogXCJjbGlja1wiLFxuICBEQkxDTElDSzogXCJkYmxjbGlja1wiLFxuICBNT1VTRU9WRVI6IFwibW91c2VvdmVyXCIsXG4gIE1PVVNFT1VUOiBcIm1vdXNlb3V0XCIsXG4gIFNIQVBFX0FERDogXCJzaGFwZTphZGRcIixcbiAgU0hBUEVfREVMRVRFOiBcInNoYXBlOmRlbGV0ZVwiXG59XG5cbmNsYXNzIERyYXdTdHlsZVN0YXRlIGV4dGVuZHMgQmFzaWNTdHlsZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICAgIHRoaXMuX2RlZmF1bHRzID0ge1xuICAgICAgcGFja2VkRmlsbENvbG9yOiB0aGlzLnBhY2tlZEZpbGxDb2xvcixcbiAgICAgIHBhY2tlZFN0cm9rZUNvbG9yOiB0aGlzLnBhY2tlZFN0cm9rZUNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lSm9pbjogdGhpcy5saW5lSm9pbixcbiAgICAgIGxpbmVDYXA6IHRoaXMubGluZUNhcCxcbiAgICAgIGRhc2hQYXR0ZXJuOiB0aGlzLmRhc2hQYXR0ZXJuLFxuICAgICAgZGFzaE9mZnNldDogdGhpcy5kYXNoT2Zmc2V0XG4gICAgfVxuICB9XG5cbiAgc2V0RmlsbFN0eWxlKGN0eCwgZmlsbFN0eWxlKSB7XG4gICAgaWYgKGZpbGxTdHlsZS5wYWNrZWRGaWxsQ29sb3IgIT09IHRoaXMucGFja2VkRmlsbENvbG9yKSB7XG4gICAgICB0aGlzLnBhY2tlZEZpbGxDb2xvciA9IGZpbGxTdHlsZS5wYWNrZWRGaWxsQ29sb3JcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxDb2xvclxuICAgIH1cbiAgfVxuXG4gIHNldFN0cm9rZVN0eWxlKGN0eCwgc3Ryb2tlU3R5bGUpIHtcbiAgICBpZiAoc3Ryb2tlU3R5bGUucGFja2VkU3Ryb2tlQ29sb3IgIT09IHRoaXMucGFja2VkU3Ryb2tlQ29sb3IpIHtcbiAgICAgIHRoaXMucGFja2VkU3Ryb2tlQ29sb3IgPSBzdHJva2VTdHlsZS5wYWNrZWRTdHJva2VDb2xvclxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2VDb2xvclxuICAgIH1cbiAgICBpZiAoc3Ryb2tlU3R5bGUuc3Ryb2tlV2lkdGggIT09IHRoaXMuX3N0cm9rZVdpZHRoKSB7XG4gICAgICB0aGlzLnN0cm9rZVdpZHRoID0gc3Ryb2tlU3R5bGUuc3Ryb2tlV2lkdGhcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9zdHJva2VXaWR0aFxuICAgIH1cbiAgICBpZiAoc3Ryb2tlU3R5bGUubGluZUpvaW4gIT09IHRoaXMuX2xpbmVKb2luKSB7XG4gICAgICB0aGlzLmxpbmVKb2luID0gc3Ryb2tlU3R5bGUubGluZUpvaW5cbiAgICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuX2xpbmVKb2luXG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZS5saW5lQ2FwICE9PSB0aGlzLl9saW5lQ2FwKSB7XG4gICAgICB0aGlzLmxpbmVDYXAgPSBzdHJva2VTdHlsZS5saW5lQ2FwXG4gICAgICBjdHgubGluZUNhcCA9IHRoaXMuX2xpbmVDYXBcbiAgICB9XG5cbiAgICBjb25zdCBkYXNoUGF0dGVybiA9IHN0cm9rZVN0eWxlLl9kYXNoUGF0dGVyblxuICAgIGxldCBkaWZmID0gZmFsc2VcbiAgICBpZiAoZGFzaFBhdHRlcm4ubGVuZ3RoID09PSB0aGlzLl9kYXNoUGF0dGVybi5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGFzaFBhdHRlcm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGRhc2hQYXR0ZXJuW2ldICE9PSB0aGlzLl9kYXNoUGF0dGVybltpXSkge1xuICAgICAgICAgIGRpZmYgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmIChkaWZmKSB7XG4gICAgICB0aGlzLmRhc2hQYXR0ZXJuID0gZGFzaFBhdHRlcm5cbiAgICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLl9kYXNoUGF0dGVybilcbiAgICB9XG5cbiAgICBpZiAoc3Ryb2tlU3R5bGUuZGFzaE9mZnNldCAhPT0gdGhpcy5fZGFzaE9mZnNldCkge1xuICAgICAgdGhpcy5kYXNoT2Zmc2V0ID0gc3Ryb2tlU3R5bGUuZGFzaE9mZnNldFxuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldFxuICAgIH1cbiAgfVxuXG4gIGFwcGx5RGVmYXVsdHMoY3R4KSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5fZGVmYXVsdHMpLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICB0aGlzW3Byb3BdID0gdGhpcy5fZGVmYXVsdHNbcHJvcF1cbiAgICB9KVxuICAgIHRoaXMuc2V0RmlsbEN0eChjdHgpXG4gICAgdGhpcy5zZXRTdHJva2VDdHgoY3R4KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudCAmJiAoYCAke2VsZW1lbnQuY2xhc3NOYW1lfSBgKS5pbmRleE9mKGAgJHtjbGFzc05hbWV9IGApIDwgMCkge1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IChlbGVtZW50LmNsYXNzTmFtZSA/IFwiIFwiIDogXCJcIikgKyBjbGFzc05hbWVcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMocGFyZW50KSB7XG4gIGNvbnN0IGNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgYWRkQ2xhc3MoY2FudmFzQ29udGFpbmVyLCBcIm1hcGQtZHJhdy1jYW52YXMtY29udGFpbmVyXCIpXG5cbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuICBjb25zdCBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuICBjb25zdCByYXRpbyA9IENhbnZhc1V0aWxzLm1ha2VDYW52YXNBdXRvSGlnaERQSShjYW52YXNDb250ZXh0KVxuICAgIC8vIGNvbnN0IHJhdGlvID0gMVxuXG4gIC8vIGFkZCBjbGFzcz9cbiAgYWRkQ2xhc3MoY2FudmFzLCBcIm1hcGQtZHJhdy1jYW52YXNcIilcbiAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiXG4gIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCJcblxuICBjYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gIC8vIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByYXRpbyAqIHBhcmVudC5vZmZzZXRYKVxuICAvLyBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJhdGlvICogcGFyZW50Lm9mZnNldFkpXG4gIC8vIHBhcmVudC5pbnNlcnRCZWZvcmUoY2FudmFzLCBwYXJlbnQuZmlyc3RDaGlsZClcbiAgcGFyZW50LmFwcGVuZENoaWxkKGNhbnZhc0NvbnRhaW5lcilcblxuICByZXR1cm4ge1xuICAgIGNhbnZhc0NvbnRhaW5lcixcbiAgICBjYW52YXMsXG4gICAgY2FudmFzQ29udGV4dCxcbiAgICByYXRpb1xuICB9XG59XG5cblxuZnVuY3Rpb24gYWRkU2hhcGVzVG9NYXAobmV3U2hhcGVzLCBleGlzdGluZ09iamVjdHNNYXAsIGN1cnJJZHMsIHJlb3JkZXJDYiwgcmVkcmF3Q2IpIHtcbiAgbmV3U2hhcGVzLmZvckVhY2goc2hhcGUgPT4ge1xuICAgIGV4aXN0aW5nT2JqZWN0c01hcC5zZXQoc2hhcGUsIHtcbiAgICAgIHNoYXBlT2JqOiBzaGFwZSxcbiAgICAgIHNoYXBlSWQ6IGN1cnJJZHMuc2hhcGVJZCxcbiAgICAgIHNoYXBlSWR4OiAtMVxuICAgIH0pXG4gICAgc2hhcGUub24oW1wiY2hhbmdlZDpvcmRlclwiLCBcImNoYW5nZWQ6dmlzaWJpbGl0eVwiLCBcImNoYW5nZWQ6c3R5bGVcIl0sIHJlb3JkZXJDYilcbiAgICBzaGFwZS5vbihbXCJjaGFuZ2VkOmdlb21cIiwgXCJjaGFuZ2VkOnZpc2liaWxpdHlcIiwgXCJjaGFuZ2VkOnhmb3JtXCJdLCByZWRyYXdDYilcbiAgICBjdXJySWRzLnNoYXBlSWQgKz0gMVxuICB9KVxufVxuXG5mdW5jdGlvbiBkZWxldGVTaGFwZXNGcm9tTWFwKHNoYXBlcywgZXhpc3RpbmdPYmplY3RzTWFwLCByZW9yZGVyQ2IsIHJlZHJhd0NiKSB7XG4gIGNvbnN0IGlkeHMgPSBbXVxuICBzaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgY29uc3Qgc2hhcGVJbmZvID0gZXhpc3RpbmdPYmplY3RzTWFwLmdldChzaGFwZSlcbiAgICBpZiAoc2hhcGVJbmZvKSB7XG4gICAgICBpZHhzLnB1c2goc2hhcGVJbmZvLnNoYXBlSWR4KVxuICAgIH1cbiAgICBleGlzdGluZ09iamVjdHNNYXAuZGVsZXRlKHNoYXBlKVxuICAgIHNoYXBlLm9mZihbXCJjaGFuZ2VkXCJdLCBbcmVvcmRlckNiLCByZWRyYXdDYl0pXG4gIH0pXG4gIHJldHVybiBpZHhzXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYXdFbmdpbmUgZXh0ZW5kcyBFdmVudEhhbmRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb3B0cykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pbml0KHBhcmVudCwgb3B0cylcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveUNhbnZhcygpXG5cbiAgICBpZiAodGhpcy5fb2JqZWN0cykge1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKChzaGFwZUluZm8sIHNoYXBlKSA9PiB7XG4gICAgICAgIHNoYXBlLm9mZihcImNoYW5nZWRcIiwgW3RoaXMuX3Jlb3JkZXJDYiwgdGhpcy5fcmVkcmF3Q2JdKVxuICAgICAgfSlcbiAgICAgIHRoaXMuX29iamVjdHMuY2xlYXIoKVxuICAgICAgdGhpcy5fc29ydGVkT2JqcyA9IFtdXG4gICAgICB0aGlzLl9yZW9yZGVyZWRPYmpJZHhzLmNsZWFyKClcbiAgICB9XG4gIH1cblxuICBfcmVzaXplKG9wdHMpIHtcbiAgICBsZXQgd2lkdGggPSAwXG4gICAgaWYgKHRoaXMuX3BhcmVudC5vZmZzZXRXaWR0aCkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5fcGFyZW50Lm9mZnNldFdpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodClcbiAgICB9XG5cbiAgICBsZXQgaGVpZ2h0ID0gMFxuICAgIGlmICh0aGlzLl9wYXJlbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRoaXMuX3BhcmVudC5vZmZzZXRIZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tKVxuICAgIH1cblxuICAgIHRoaXMuX2RyYXdDYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMuX3BpeGVsUmF0aW9cbiAgICB0aGlzLl9kcmF3Q2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW9cblxuICAgIHRoaXMuX2RyYXdDYW52YXMuc3R5bGUubGVmdCA9IGAke3RoaXMuX21hcmdpbnMubGVmdH1weGBcbiAgICB0aGlzLl9kcmF3Q2FudmFzLnN0eWxlLnRvcCA9IGAke3RoaXMuX21hcmdpbnMudG9wfXB4YFxuICAgIHRoaXMuX2RyYXdDYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGBcbiAgICB0aGlzLl9kcmF3Q2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGBcblxuICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcbiAgICAgIC8vIGNvbnN0IGN1cnJWaWV3cG9ydCA9IHRoaXMuX2NhbWVyYS52aWV3cG9ydFxuICAgICAgLy8gY29uc3QgY3VyclNwYWNlID0gdGhpcy5fY2FtZXJhLnByb2plY3Rpb25Cb3VuZHNcbiAgICAgIC8vIGNvbnN0IHZpZXdwb3J0RXh0ZW50cyA9IFswLCAwXVxuICAgICAgLy8gQUFCb3gyZC5nZXRFeHRlbnRzKHZpZXdwb3J0RXh0ZW50cywgY3VyclZpZXdwb3J0KVxuICAgICAgLy8gY29uc3Qgc3BhY2VDZW50ZXIgPSBbMCwgMF1cbiAgICAgIC8vIGNvbnN0IHNwYWNlRXh0ZW50cyA9IFswLCAwXVxuICAgICAgLy8gQUFCb3gyZC5nZXRDZW50ZXIoc3BhY2VDZW50ZXIsIGN1cnJTcGFjZSlcbiAgICAgIC8vIEFBQm94MmQuZ2V0RXh0ZW50cyhzcGFjZUV4dGVudHMsIGN1cnJTcGFjZSlcbiAgICAgIC8vIGNvbnN0IHJhdGlvID0gc3BhY2VFeHRlbnRzXG4gICAgICAvLyBWZWMyZC5kaXYocmF0aW8sIHNwYWNlRXh0ZW50cywgdmlld3BvcnRFeHRlbnRzKVxuICAgICAgLy8gQUFCb3gyZC5zZXQoY3VyclZpZXdwb3J0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgLy8gQUFCb3gyZC5nZXRFeHRlbnRzKHZpZXdwb3J0RXh0ZW50cywgY3VyclZpZXdwb3J0KVxuICAgICAgLy8gVmVjMmQubXVsdGlwbHkoc3BhY2VFeHRlbnRzLCByYXRpbywgdmlld3BvcnRFeHRlbnRzKVxuICAgICAgLy8gQUFCb3gyZC5pbml0Q2VudGVyRXh0ZW50cyhjdXJyU3BhY2UsIHNwYWNlQ2VudGVyLCBzcGFjZUV4dGVudHMpXG4gICAgICAvLyB0aGlzLl9jYW1lcmEudmlld3BvcnQgPSBjdXJyVmlld3BvcnRcbiAgICAgIC8vIHRoaXMuX2NhbWVyYS5wcm9qZWN0aW9uQm91bmRzID0gY3VyclNwYWNlXG4gICAgICAvLyAgIC8vIHRoaXMuX2NhbWVyYS52aWV3cG9ydCA9IFswLCAwLCB3aWR0aCwgaGVpZ2h0XVxuICAgICAgLy8gICAvLyB0aGlzLl9jYW1lcmEucHJvamVjdGlvbkJvdW5kcyA9IFswLCAwLCB3aWR0aCwgaGVpZ2h0XVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm9qRGltcyA9IChvcHRzICYmIG9wdHMucHJvamVjdGlvbkRpbWVuc2lvbnMgPyBvcHRzLnByb2plY3Rpb25EaW1lbnNpb25zIDogW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgdGhpcy5fY2FtZXJhID0gbmV3IENhbWVyYTJkKFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgcHJvakRpbXMsIChvcHRzLmZsaXBZID8gQm9vbGVhbihvcHRzLmZsaXBZKSA6IGZhbHNlKSlcbiAgICAgIHRoaXMuX2NhbWVyYS5zZXRQb3NpdGlvbigob3B0cyAmJiBvcHRzLmNhbWVyYVBvc2l0aW9uID8gb3B0cy5jYW1lcmFQb3NpdGlvbiA6IFt3aWR0aCAvIDIuMCwgaGVpZ2h0IC8gMi4wXSkpXG4gICAgICB0aGlzLl9jYW1lcmEub24oXCJjaGFuZ2VkXCIsIHRoaXMuX3JlcmVuZGVyQ2IpXG4gICAgfVxuICAgIC8vIHRoaXMuX2NhbWVyYSA9IG5ldyBDYW1lcmEyZChbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLCBbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdKVxuICAgIC8vIHRoaXMuX2NhbWVyYS5vbihcImNoYW5nZWRcIiwgdGhpcy5fcmVyZW5kZXJDYilcblxuICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuICB9XG5cbiAgX21vdXNlZG93bkNCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJtb3VzZWRvd25cIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX21vdXNldXBDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwibW91c2V1cFwiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfbW91c2Vtb3ZlQ0IoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmlyZShcIm1vdXNlbW92ZVwiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfY2xpY2tDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwiY2xpY2tcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX2RibGNsaWNrQ0IoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmlyZShcImRibGNsaWNrXCIsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIF9tb3VzZW92ZXJDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwibW91c2VvdmVyXCIsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIF9tb3VzZW91dENCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJtb3VzZW91dFwiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfZW5hYmxlRXZlbnRzKCkge1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudHMobW91c2VldmVudHMpXG4gICAgY29uc3QgY2FsbGJhY2tzID0gbW91c2VldmVudHMubWFwKGV2ZW50ID0+IGBfJHtldmVudH1DQmApXG4gICAgLy8gYmluZEFsbChjYWxsYmFja3MsIHRoaXMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb3VzZWV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihtb3VzZWV2ZW50c1tpXSwgdGhpc1tjYWxsYmFja3NbaV1dLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIF9kaXNhYmxlRXZlbnRzKCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IG1vdXNlZXZlbnRzLm1hcChldmVudCA9PiBgXyR7ZXZlbnR9Q0JgKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW91c2VldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VldmVudHNbaV0sIHRoaXNbY2FsbGJhY2tzW2ldXSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBfaW5pdENhbnZhcyhwYXJlbnQsIG9wdHMsIGZvcmNlRXZlbnRzID0gbnVsbCkge1xuICAgIHRoaXMuX21hcmdpbnMgPSAob3B0cyAmJiBvcHRzLm1hcmdpbnMgPyBPYmplY3QuYXNzaWduKHt9LCBvcHRzLm1hcmdpbnMpIDoge30pXG4gICAgbWFyZ2luUHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fbWFyZ2luc1twcm9wXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLl9tYXJnaW5zW3Byb3BdID0gMFxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250YWluZXIsXG4gICAgICBjYW52YXMsXG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgcmF0aW9cbiAgICB9ID0gY3JlYXRlQ2FudmFzKHBhcmVudClcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNhbnZhc0NvbnRhaW5lclxuICAgIHRoaXMuX2RyYXdDYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLl9kcmF3Q3R4ID0gY2FudmFzQ29udGV4dFxuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSByYXRpb1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuXG4gICAgYmluZEFsbChbXCJfcmVzaXplXCJdLCB0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZShvcHRzKVxuICAgIHRoaXMuX3Jlc2l6ZVNlbnNvciA9IG5ldyBSZXNpemVTZW5zb3IocGFyZW50LCB0aGlzLl9yZXNpemUpXG5cbiAgICBpZiAoZm9yY2VFdmVudHMgfHwgKGZvcmNlRXZlbnRzID09PSBudWxsICYmIG9wdHMgJiYgb3B0cy5lbmFibGVFdmVudHMpKSB7XG4gICAgICB0aGlzLl9lbmFibGVFdmVudHMoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95Q2FudmFzKCkge1xuICAgIGlmICh0aGlzLl9kcmF3Q2FudmFzKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlRXZlbnRzKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fZHJhd0NhbnZhcylcblxuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZVNlbnNvcikge1xuICAgICAgICB0aGlzLl9yZXNpemVTZW5zb3IuZGV0YWNoKHRoaXMuX3BhcmVudCwgdGhpcy5fcmVzaXplKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RyYXdDYW52YXMgPSBudWxsXG4gICAgdGhpcy5fZHJhd0N0eCA9IG51bGxcbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsXG4gIH1cblxuICBfaW5pdChwYXJlbnQsIG9wdHMsIGZvcmNlRXZlbnRzID0gbnVsbCkge1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoW0V2ZW50Q29uc3RhbnRzLlNIQVBFX0FERCwgRXZlbnRDb25zdGFudHMuU0hBUEVfREVMRVRFXSlcblxuICAgIGJpbmRBbGwoW1wiX3Jlb3JkZXJDYlwiLCBcIl9yZXJlbmRlckNiXCJdLCB0aGlzKVxuICAgIGJpbmRBbGwoW1wiX21vdXNlZG93bkNCXCIsIFwiX21vdXNldXBDQlwiLCBcIl9tb3VzZW1vdmVDQlwiLCBcIl9jbGlja0NCXCIsIFwiX2RibGNsaWNrQ0JcIiwgXCJfbW91c2VvdmVyQ0JcIiwgXCJfbW91c2VvdXRDQlwiXSwgdGhpcylcblxuICAgIHRoaXMuX3JlbmRlckZyYW1lQ2IgPSB0aGlzLnJlbmRlckFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVuZGVyUmVxdWVzdElkID0gMFxuICAgIHRoaXMuX2lkcyA9IHtcbiAgICAgIHNoYXBlSWQ6IDFcbiAgICB9XG5cbiAgICB0aGlzLl9vYmplY3RzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fc29ydGVkT2JqcyA9IFtdXG4gICAgdGhpcy5fcmVvcmRlcmVkT2JqSWR4cyA9IG5ldyBTZXQoKVxuXG4gICAgdGhpcy5faW5pdENhbnZhcyhwYXJlbnQsIG9wdHMsIGZvcmNlRXZlbnRzKVxuXG4gICAgdGhpcy5fc3R5bGVTdGF0ZSA9IG5ldyBEcmF3U3R5bGVTdGF0ZSh7XG4gICAgICBmaWxsQ29sb3I6IFwicmVkXCJcbiAgICB9KVxuICB9XG5cbiAgZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRcbiAgfVxuXG4gIGdldENhbnZhc0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyXG4gIH1cblxuICBnZXRDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdDYW52YXNcbiAgfVxuXG4gIGdldCBzb3J0ZWRTaGFwZXMoKSB7XG4gICAgaWYgKHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuc2l6ZSkge1xuICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5fc29ydGVkT2Jqcy5sZW5ndGggPT09IHRoaXMuX29iamVjdHMuc2l6ZSxcbiAgICAgICAgYFNpemUgbWlzbWF0Y2ggd2hlbiByZW5kZXJpbmcgb2JqZXRzLiBTb21ldGhpbmcgZ290IG91dCBvZiBzeW5jIC0gc29ydGVkIG9ianMgbGVuZ3RoOiAke3RoaXMuX3NvcnRlZE9ianMubGVuZ3RofSwgb2JqZWN0cyBsZW5ndGg6ICR7dGhpcy5fb2JqZWN0cy5zaXplfWApXG5cbiAgICAgIC8vIGlmICh0aGlzLl9yZW9yZGVyZWRPYmpJZHhzLmxlbmd0aCAvIHRoaXMuX3NvcnRlZE9ianMubGVuZ3RoID4gMC43KSB7XG4gICAgICAvLyAgIC8vIG1pZ2h0IGFzIHdlbGwganVzdCByZXNvcnQgdGhlIHdob2xlIHRoaW5nIG92ZXJcbiAgICAgIC8vICAgdGhpcy5fc29ydGVkT2Jqcy5zb3J0KHNoYXBlSW5mb0NvbXBhcmUpXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gfVxuXG4gICAgICB0aGlzLl9zb3J0ZWRPYmpzLnNvcnQoQmFzZVNoYXBlLnNoYXBlQ29tcGFyZSlcbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuY2xlYXIoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc29ydGVkT2Jqc1xuICB9XG5cbiAgZ2V0IG1hcmdpbnMoKSB7XG4gICAgY29uc3QgcnRuID0ge31cbiAgICBtYXJnaW5Qcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcnRuW3Byb3BdID0gdGhpcy5fbWFyZ2luc1twcm9wXVxuICAgIH0pXG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbiAgc2V0IG1hcmdpbnMobWFyZ2lucykge1xuICAgIG1hcmdpblByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1hcmdpbnNbcHJvcF0gPT09IFwibnVtYmVyXCIgJiYgbWFyZ2luc1twcm9wXSAhPT0gdGhpcy5fbWFyZ2luc1twcm9wXSkge1xuICAgICAgICB0aGlzLl9tYXJnaW5zW3Byb3BdID0gbWFyZ2lucy5wcm9wXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuX3Jlc2l6ZSgpXG4gIH1cblxuICBnZXQgdmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYS52aWV3cG9ydFxuICB9XG5cbiAgc2V0IHZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgdGhpcy5fY2FtZXJhLnZpZXdwb3J0ID0gdmlld3BvcnRcbiAgfVxuXG4gIGdldCBwcm9qZWN0aW9uRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FtZXJhLnByb2plY3Rpb25EaW1lbnNpb25zXG4gIH1cblxuICBzZXQgcHJvamVjdGlvbkRpbWVuc2lvbnMocHJvamVjdGlvbkRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl9jYW1lcmEucHJvamVjdGlvbkRpbWVuc2lvbnMgPSBwcm9qZWN0aW9uRGltZW5zaW9uc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgY2FtZXJhUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYS5nZXRQb3NpdGlvbigpXG4gIH1cblxuICBzZXQgY2FtZXJhUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy5fY2FtZXJhLnNldFBvc2l0aW9uKHBvcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJvamVjdChvdXQsIHNjcmVlblB0KSB7XG4gICAgY29uc3Qgc2NyZWVuVG9Xb3JsZE1hdHJpeCA9IHRoaXMuX2NhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4XG4gICAgcmV0dXJuIFBvaW50MmQudHJhbnNmb3JtTWF0MmQob3V0LCBzY3JlZW5QdCwgc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgfVxuXG4gIHVucHJvamVjdChvdXQsIHdvcmxkUHQpIHtcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICByZXR1cm4gUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChvdXQsIHdvcmxkUHQsIHdvcmxkVG9TY3JlZW5NYXRyaXgpXG4gIH1cblxuICBoYXNTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmhhcyhzaGFwZSlcbiAgfVxuXG4gIGFkZFNoYXBlKHNoYXBlKSB7XG4gICAgbGV0IHNoYXBlcyA9IHNoYXBlXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXBlcykpIHtcbiAgICAgIHNoYXBlcyA9IFtzaGFwZV1cbiAgICB9XG5cbiAgICBhZGRTaGFwZXNUb01hcChzaGFwZXMsIHRoaXMuX29iamVjdHMsIHRoaXMuX2lkcywgdGhpcy5fcmVvcmRlckNiLCB0aGlzLl9yZXJlbmRlckNiKVxuXG4gICAgLy8gZmlyZSBhZGQgZXZlbnRcbiAgICB0aGlzLmZpcmUoXCJzaGFwZTphZGRcIiwge1xuICAgICAgc2hhcGU6IHNoYXBlc1xuICAgIH0pXG5cbiAgICBjb25zdCBwcm94eUV2ZW50ID0ge1xuICAgICAgdGFyZ2V0OiBzaGFwZXNcbiAgICB9XG4gICAgdGhpcy5fcmVvcmRlckNiKHByb3h5RXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZGVsZXRlU2hhcGUoc2hhcGUpIHtcbiAgICBsZXQgc2hhcGVzID0gc2hhcGVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuICAgICAgc2hhcGVzID0gW3NoYXBlXVxuICAgIH1cblxuICAgIGNvbnN0IGlkeHMgPSBkZWxldGVTaGFwZXNGcm9tTWFwKHNoYXBlcywgdGhpcy5fb2JqZWN0cywgdGhpcy5fcmVvcmRlckNiLCB0aGlzLl9yZXJlbmRlckNiKVxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICgoaW5kZXggPSB0aGlzLl9zb3J0ZWRPYmpzLmluZGV4T2Yoc2hhcGVzW2ldKSkgPj0gMCkge1xuICAgICAgICB0aGlzLl9zb3J0ZWRPYmpzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuYWRkKGlkeHNbaV0pXG4gICAgfVxuICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuXG4gICAgdGhpcy5maXJlKFwic2hhcGU6ZGVsZXRlXCIsIHtcbiAgICAgIHNoYXBlOiBzaGFwZXNcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRlbGV0ZUFsbFNoYXBlcygpIHtcbiAgICB0aGlzLmRlbGV0ZVNoYXBlKHRoaXMuc29ydGVkU2hhcGVzLnNsaWNlKCkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG1vdmVTaGFwZVRvVG9wKHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX29iamVjdHMuaGFzKHNoYXBlKSkge1xuICAgICAgY29uc3Qgc2hhcGVzID0gdGhpcy5zb3J0ZWRTaGFwZXNcbiAgICAgIGNvbnN0IHppbmRleCA9IHNoYXBlc1tzaGFwZXMubGVuZ3RoIC0gMV0uekluZGV4XG4gICAgICBzaGFwZS56SW5kZXggPSB6aW5kZXggKyAxXG4gICAgfVxuICB9XG5cbiAgbW92ZVNoYXBlVG9CYWNrKHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX29iamVjdHMuaGFzKHNoYXBlKSkge1xuICAgICAgY29uc3Qgc2hhcGVzID0gdGhpcy5zb3J0ZWRTaGFwZXNcbiAgICAgIGNvbnN0IHppbmRleCA9IHNoYXBlc1swXS56SW5kZXhcbiAgICAgIHNoYXBlLnpJbmRleCA9IHppbmRleFxuICAgIH1cbiAgfVxuXG4gIGdldFNoYXBlc0FzSlNPTigpIHtcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIHJldHVybiBzaGFwZXMubWFwKHNoYXBlID0+IHNoYXBlLnRvSlNPTigpKVxuICB9XG5cbiAgX3JlcmVuZGVyQ2IoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclJlcXVlc3RJZCkge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlclJlcXVlc3RJZClcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyUmVxdWVzdElkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNiKVxuICB9XG5cbiAgX3Jlb3JkZXJDYihldmVudCkge1xuICAgIGxldCBjaGFuZ2VkU2hhcGVzID0gZXZlbnQudGFyZ2V0XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5nZWRTaGFwZXMpKSB7XG4gICAgICBjaGFuZ2VkU2hhcGVzID0gW2V2ZW50LnRhcmdldF1cbiAgICB9XG4gICAgY2hhbmdlZFNoYXBlcy5mb3JFYWNoKGNoYW5nZWRTaGFwZSA9PiB7XG4gICAgICBjb25zb2xlLmFzc2VydChjaGFuZ2VkU2hhcGUsIFwiQSBjaGFuZ2VkIGV2ZW50IGRvZXNuJ3QgaGF2ZSBhbiBvYmplY3RcIilcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KGNoYW5nZWRTaGFwZSlcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KHNoYXBlSW5mbywgYEEgY2hhbmdlZCBldmVudCB0YXJnZXQgaXNuJ3QgaW4gdGhlIGxpc3Qgb2Ygc2hhcGVzICR7Y2hhbmdlZFNoYXBlfWApXG4gICAgICBpZiAoc2hhcGVJbmZvLnNoYXBlSWR4IDwgMCkge1xuICAgICAgICBzaGFwZUluZm8uc2hhcGVJZHggPSB0aGlzLl9zb3J0ZWRPYmpzLnB1c2goY2hhbmdlZFNoYXBlKSAtIDFcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuYWRkKHNoYXBlSW5mby5zaGFwZUlkeClcbiAgICB9KVxuICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuICB9XG5cbiAgX3JlbmRlclNoYXBlcyhjdHgsIGRyYXdTaGFwZXMsIGNhbWVyYSkge1xuICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXQgPSBjYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgIGRyYXdTaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICBpZiAoc2hhcGUudmlzaWJsZSkge1xuICAgICAgICBzaGFwZS5yZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCB0aGlzLl9zdHlsZVN0YXRlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZW5kZXJBbGwoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZHJhd0N0eFxuICAgICAgLy8gY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodClcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2RyYXdDYW52YXMub2Zmc2V0V2lkdGgsIHRoaXMuX2RyYXdDYW52YXMub2Zmc2V0SGVpZ2h0KVxuXG4gICAgaWYgKCF0aGlzLl9vYmplY3RzLnNpemUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGN0eC5zYXZlKClcbiAgICBjb25zdCBkcmF3U2hhcGVzID0gdGhpcy5zb3J0ZWRTaGFwZXNcbiAgICB0aGlzLl9zdHlsZVN0YXRlLmFwcGx5RGVmYXVsdHMoY3R4KVxuICAgIHRoaXMuX3JlbmRlclNoYXBlcyhjdHgsIGRyYXdTaGFwZXMsIHRoaXMuX2NhbWVyYSlcbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cbn1cblxuRHJhd0VuZ2luZS5FdmVudENvbnN0YW50cyA9IEV2ZW50Q29uc3RhbnRzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvZHJhdy1lbmdpbmUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("/* eslint-disable */\n// Copyright 2001 softSurfer, 2012 Dan Sunday\n// This code may be freely used and modified for any purpose\n// providing that this copyright notice is included with it.\n// SoftSurfer makes no warranty for this code, and cannot be held\n// liable for any real or imagined damage resulting from its use.\n// Users of this code must verify correctness for their application.\n\n// from http://geomalgorithms.com/a12-_hull-3.html\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleHull_2D = simpleHull_2D;\nvar X = 0;\nvar Y = 1;\n\n/**\n * Test if a point is Left|On|Right of an infinite line.\n * @param  {Point2d}  P0 [description]\n * @param  {Point2d}  P1 [description]\n * @param  {Point2d}  P2 [description]\n * @return {Boolean}  Returns > 0 if P2 is left of the line thru P0 & P1,\n *                    Returns < 0 if P2 is to the right\n *                    Returns 0 if P2 is on the line\n */\nfunction isLeft(P0, P1, P2) {\n  return (P1[X] - P0[X]) * (P2[Y] - P0[Y]) - (P2[X] - P0[X]) * (P1[Y] - P0[Y]);\n}\n\n/**\n * Melkman's 2D simple polyline O(n) convex hull algorithm\n * @param  {Point2d[]} verts [description]\n * @return {number[]}       [description]\n */\nfunction simpleHull_2D(verts) {\n  // initialize a deque D[] from bottom to top so that the\n  // 1st three vertices of P[] are a ccw triangle\n  var H = [];\n  var n = verts.length;\n\n  if (n < 3) {\n    for (var i = 0; i < n; i += 1) {\n      H[i] = i;\n    }\n    return H;\n  }\n\n  var D = new Array(2 * n + 1);\n  D.fill(-1);\n  var bot = n - 2;\n  var top = bot + 3; // initial bottom and top deque indices\n\n  D[bot] = D[top] = 2; // 3rd vertex is at both bot and top\n  if (isLeft(verts[0], verts[1], verts[2]) > 0) {\n    D[bot + 1] = 0;\n    D[bot + 2] = 1; // ccw vertices are: 2,0,1,2\n  } else {\n    D[bot + 1] = 1;\n    D[bot + 2] = 0; // ccw vertices are: 2,1,0,2\n  }\n\n  // compute the hull on the deque D[]\n  for (var _i = 3; _i < n; _i += 1) {\n    // process the rest of vertices\n    // test if next vertex is outside the deque hull\n    if (isLeft(verts[D[bot]], verts[D[bot + 1]], verts[_i]) <= 0 || isLeft(verts[D[top - 1]], verts[D[top]], verts[_i]) <= 0) {\n\n      // incrementally add an exterior vertex to the deque hull\n      // get the rightmost tangent at the deque bot\n      while (D[bot] >= 0 && D[bot + 1] >= 0 && isLeft(verts[D[bot]], verts[D[bot + 1]], verts[_i]) <= 0) {\n        bot += 1; // remove bot of deque\n      }\n      bot -= 1;\n      D[bot] = _i; // insert verts[i] at bot of deque\n\n      // get the leftmost tangent at the deque top\n      while (D[top] >= 0 && D[top + 1] >= 0 && isLeft(verts[D[top - 1]], verts[D[top]], verts[_i]) <= 0) {\n        top -= 1; // pop top of deque\n      }\n      top += 1;\n      D[top] = _i; // push verts[i] onto top of deque\n    }\n  }\n\n  // transcribe deque D[] to the output hull array H[]\n  var h = 0;\n  for (h = 0; h <= top - bot - 1; h += 1) {\n    H[h] = D[bot + h];\n  }\n\n  if (D[bot + h] !== H[0]) {\n    H[h] = D[bot + h];\n  }\n\n  return H;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRoL2NvbnZleC1odWxsLmpzPzBkYTkiXSwibmFtZXMiOlsic2ltcGxlSHVsbF8yRCIsIlgiLCJZIiwiaXNMZWZ0IiwiUDAiLCJQMSIsIlAyIiwidmVydHMiLCJIIiwibiIsImxlbmd0aCIsImkiLCJEIiwiQXJyYXkiLCJmaWxsIiwiYm90IiwidG9wIiwiaCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7O1FBd0JnQkEsYSxHQUFBQSxhO0FBdEJoQixJQUFNQyxJQUFJLENBQVY7QUFDQSxJQUFNQyxJQUFJLENBQVY7O0FBR0E7Ozs7Ozs7OztBQVNBLFNBQVNDLE1BQVQsQ0FBZ0JDLEVBQWhCLEVBQW9CQyxFQUFwQixFQUF3QkMsRUFBeEIsRUFBNEI7QUFDMUIsU0FBTyxDQUFDRCxHQUFHSixDQUFILElBQVFHLEdBQUdILENBQUgsQ0FBVCxLQUFtQkssR0FBR0osQ0FBSCxJQUFRRSxHQUFHRixDQUFILENBQTNCLElBQW9DLENBQUNJLEdBQUdMLENBQUgsSUFBUUcsR0FBR0gsQ0FBSCxDQUFULEtBQW1CSSxHQUFHSCxDQUFILElBQVFFLEdBQUdGLENBQUgsQ0FBM0IsQ0FBM0M7QUFDRDs7QUFFRDs7Ozs7QUFLTyxTQUFTRixhQUFULENBQXVCTyxLQUF2QixFQUE4QjtBQUNuQztBQUNBO0FBQ0EsTUFBTUMsSUFBSSxFQUFWO0FBQ0EsTUFBTUMsSUFBSUYsTUFBTUcsTUFBaEI7O0FBRUEsTUFBSUQsSUFBSSxDQUFSLEVBQVc7QUFDVCxTQUFLLElBQUlFLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsQ0FBcEIsRUFBdUJFLEtBQUssQ0FBNUIsRUFBK0I7QUFDN0JILFFBQUVHLENBQUYsSUFBT0EsQ0FBUDtBQUNEO0FBQ0QsV0FBT0gsQ0FBUDtBQUNEOztBQUVELE1BQU1JLElBQUksSUFBSUMsS0FBSixDQUFVLElBQUlKLENBQUosR0FBUSxDQUFsQixDQUFWO0FBQ0FHLElBQUVFLElBQUYsQ0FBTyxDQUFDLENBQVI7QUFDQSxNQUFJQyxNQUFNTixJQUFJLENBQWQ7QUFDQSxNQUFJTyxNQUFNRCxNQUFNLENBQWhCLENBaEJtQyxDQWdCakI7O0FBRWxCSCxJQUFFRyxHQUFGLElBQVNILEVBQUVJLEdBQUYsSUFBUyxDQUFsQixDQWxCbUMsQ0FrQmY7QUFDcEIsTUFBSWIsT0FBT0ksTUFBTSxDQUFOLENBQVAsRUFBaUJBLE1BQU0sQ0FBTixDQUFqQixFQUEyQkEsTUFBTSxDQUFOLENBQTNCLElBQXVDLENBQTNDLEVBQThDO0FBQzVDSyxNQUFFRyxNQUFNLENBQVIsSUFBYSxDQUFiO0FBQ0FILE1BQUVHLE1BQU0sQ0FBUixJQUFhLENBQWIsQ0FGNEMsQ0FFN0I7QUFDaEIsR0FIRCxNQUdPO0FBQ0xILE1BQUVHLE1BQU0sQ0FBUixJQUFhLENBQWI7QUFDQUgsTUFBRUcsTUFBTSxDQUFSLElBQWEsQ0FBYixDQUZLLENBRVU7QUFDaEI7O0FBRUQ7QUFDQSxPQUFLLElBQUlKLEtBQUksQ0FBYixFQUFnQkEsS0FBSUYsQ0FBcEIsRUFBdUJFLE1BQUssQ0FBNUIsRUFBK0I7QUFBRTtBQUMvQjtBQUNBLFFBQUtSLE9BQU9JLE1BQU1LLEVBQUVHLEdBQUYsQ0FBTixDQUFQLEVBQXNCUixNQUFNSyxFQUFFRyxNQUFNLENBQVIsQ0FBTixDQUF0QixFQUF5Q1IsTUFBTUksRUFBTixDQUF6QyxLQUFzRCxDQUF2RCxJQUNEUixPQUFPSSxNQUFNSyxFQUFFSSxNQUFNLENBQVIsQ0FBTixDQUFQLEVBQTBCVCxNQUFNSyxFQUFFSSxHQUFGLENBQU4sQ0FBMUIsRUFBeUNULE1BQU1JLEVBQU4sQ0FBekMsS0FBc0QsQ0FEekQsRUFDNkQ7O0FBRTNEO0FBQ0E7QUFDQSxhQUFPQyxFQUFFRyxHQUFGLEtBQVUsQ0FBVixJQUFlSCxFQUFFRyxNQUFNLENBQVIsS0FBYyxDQUE3QixJQUFrQ1osT0FBT0ksTUFBTUssRUFBRUcsR0FBRixDQUFOLENBQVAsRUFBc0JSLE1BQU1LLEVBQUVHLE1BQU0sQ0FBUixDQUFOLENBQXRCLEVBQXlDUixNQUFNSSxFQUFOLENBQXpDLEtBQXNELENBQS9GLEVBQWtHO0FBQ2hHSSxlQUFPLENBQVAsQ0FEZ0csQ0FDdkY7QUFDVjtBQUNEQSxhQUFPLENBQVA7QUFDQUgsUUFBRUcsR0FBRixJQUFTSixFQUFULENBUjJELENBUWhEOztBQUVYO0FBQ0EsYUFBT0MsRUFBRUksR0FBRixLQUFVLENBQVYsSUFBZUosRUFBRUksTUFBTSxDQUFSLEtBQWMsQ0FBN0IsSUFBa0NiLE9BQU9JLE1BQU1LLEVBQUVJLE1BQU0sQ0FBUixDQUFOLENBQVAsRUFBMEJULE1BQU1LLEVBQUVJLEdBQUYsQ0FBTixDQUExQixFQUF5Q1QsTUFBTUksRUFBTixDQUF6QyxLQUFzRCxDQUEvRixFQUFrRztBQUNoR0ssZUFBTyxDQUFQLENBRGdHLENBQ3ZGO0FBQ1Y7QUFDREEsYUFBTyxDQUFQO0FBQ0FKLFFBQUVJLEdBQUYsSUFBU0wsRUFBVCxDQWYyRCxDQWVoRDtBQUNaO0FBQ0Y7O0FBRUQ7QUFDQSxNQUFJTSxJQUFJLENBQVI7QUFDQSxPQUFLQSxJQUFJLENBQVQsRUFBWUEsS0FBTUQsTUFBTUQsR0FBTixHQUFZLENBQTlCLEVBQWtDRSxLQUFLLENBQXZDLEVBQTBDO0FBQ3hDVCxNQUFFUyxDQUFGLElBQU9MLEVBQUVHLE1BQU1FLENBQVIsQ0FBUDtBQUNEOztBQUVELE1BQUlMLEVBQUVHLE1BQU1FLENBQVIsTUFBZVQsRUFBRSxDQUFGLENBQW5CLEVBQXlCO0FBQ3ZCQSxNQUFFUyxDQUFGLElBQU9MLEVBQUVHLE1BQU1FLENBQVIsQ0FBUDtBQUNEOztBQUVELFNBQU9ULENBQVA7QUFDRCIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBDb3B5cmlnaHQgMjAwMSBzb2Z0U3VyZmVyLCAyMDEyIERhbiBTdW5kYXlcbi8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuLy8gcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4vLyBTb2Z0U3VyZmVyIG1ha2VzIG5vIHdhcnJhbnR5IGZvciB0aGlzIGNvZGUsIGFuZCBjYW5ub3QgYmUgaGVsZFxuLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbi8vIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG5cbi8vIGZyb20gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMTItX2h1bGwtMy5odG1sXG5cblwidXNlIHN0cmljdFwiXG5cbmNvbnN0IFggPSAwXG5jb25zdCBZID0gMVxuXG5cbi8qKlxuICogVGVzdCBpZiBhIHBvaW50IGlzIExlZnR8T258UmlnaHQgb2YgYW4gaW5maW5pdGUgbGluZS5cbiAqIEBwYXJhbSAge1BvaW50MmR9ICBQMCBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtQb2ludDJkfSAgUDEgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7UG9pbnQyZH0gIFAyIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICBSZXR1cm5zID4gMCBpZiBQMiBpcyBsZWZ0IG9mIHRoZSBsaW5lIHRocnUgUDAgJiBQMSxcbiAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIDwgMCBpZiBQMiBpcyB0byB0aGUgcmlnaHRcbiAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIDAgaWYgUDIgaXMgb24gdGhlIGxpbmVcbiAqL1xuZnVuY3Rpb24gaXNMZWZ0KFAwLCBQMSwgUDIpIHtcbiAgcmV0dXJuIChQMVtYXSAtIFAwW1hdKSAqIChQMltZXSAtIFAwW1ldKSAtIChQMltYXSAtIFAwW1hdKSAqIChQMVtZXSAtIFAwW1ldKVxufVxuXG4vKipcbiAqIE1lbGttYW4ncyAyRCBzaW1wbGUgcG9seWxpbmUgTyhuKSBjb252ZXggaHVsbCBhbGdvcml0aG1cbiAqIEBwYXJhbSAge1BvaW50MmRbXX0gdmVydHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7bnVtYmVyW119ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUh1bGxfMkQodmVydHMpIHtcbiAgLy8gaW5pdGlhbGl6ZSBhIGRlcXVlIERbXSBmcm9tIGJvdHRvbSB0byB0b3Agc28gdGhhdCB0aGVcbiAgLy8gMXN0IHRocmVlIHZlcnRpY2VzIG9mIFBbXSBhcmUgYSBjY3cgdHJpYW5nbGVcbiAgY29uc3QgSCA9IFtdXG4gIGNvbnN0IG4gPSB2ZXJ0cy5sZW5ndGhcblxuICBpZiAobiA8IDMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuICAgICAgSFtpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIGNvbnN0IEQgPSBuZXcgQXJyYXkoMiAqIG4gKyAxKVxuICBELmZpbGwoLTEpXG4gIGxldCBib3QgPSBuIC0gMlxuICBsZXQgdG9wID0gYm90ICsgMyAvLyBpbml0aWFsIGJvdHRvbSBhbmQgdG9wIGRlcXVlIGluZGljZXNcblxuICBEW2JvdF0gPSBEW3RvcF0gPSAyIC8vIDNyZCB2ZXJ0ZXggaXMgYXQgYm90aCBib3QgYW5kIHRvcFxuICBpZiAoaXNMZWZ0KHZlcnRzWzBdLCB2ZXJ0c1sxXSwgdmVydHNbMl0pID4gMCkge1xuICAgIERbYm90ICsgMV0gPSAwXG4gICAgRFtib3QgKyAyXSA9IDEgLy8gY2N3IHZlcnRpY2VzIGFyZTogMiwwLDEsMlxuICB9IGVsc2Uge1xuICAgIERbYm90ICsgMV0gPSAxXG4gICAgRFtib3QgKyAyXSA9IDAgLy8gY2N3IHZlcnRpY2VzIGFyZTogMiwxLDAsMlxuICB9XG5cbiAgLy8gY29tcHV0ZSB0aGUgaHVsbCBvbiB0aGUgZGVxdWUgRFtdXG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbjsgaSArPSAxKSB7IC8vIHByb2Nlc3MgdGhlIHJlc3Qgb2YgdmVydGljZXNcbiAgICAvLyB0ZXN0IGlmIG5leHQgdmVydGV4IGlzIG91dHNpZGUgdGhlIGRlcXVlIGh1bGxcbiAgICBpZiAoKGlzTGVmdCh2ZXJ0c1tEW2JvdF1dLCB2ZXJ0c1tEW2JvdCArIDFdXSwgdmVydHNbaV0pIDw9IDApIHx8XG4gICAgICAoaXNMZWZ0KHZlcnRzW0RbdG9wIC0gMV1dLCB2ZXJ0c1tEW3RvcF1dLCB2ZXJ0c1tpXSkgPD0gMCkpIHtcblxuICAgICAgLy8gaW5jcmVtZW50YWxseSBhZGQgYW4gZXh0ZXJpb3IgdmVydGV4IHRvIHRoZSBkZXF1ZSBodWxsXG4gICAgICAvLyBnZXQgdGhlIHJpZ2h0bW9zdCB0YW5nZW50IGF0IHRoZSBkZXF1ZSBib3RcbiAgICAgIHdoaWxlIChEW2JvdF0gPj0gMCAmJiBEW2JvdCArIDFdID49IDAgJiYgaXNMZWZ0KHZlcnRzW0RbYm90XV0sIHZlcnRzW0RbYm90ICsgMV1dLCB2ZXJ0c1tpXSkgPD0gMCkge1xuICAgICAgICBib3QgKz0gMSAvLyByZW1vdmUgYm90IG9mIGRlcXVlXG4gICAgICB9XG4gICAgICBib3QgLT0gMVxuICAgICAgRFtib3RdID0gaSAvLyBpbnNlcnQgdmVydHNbaV0gYXQgYm90IG9mIGRlcXVlXG5cbiAgICAgIC8vIGdldCB0aGUgbGVmdG1vc3QgdGFuZ2VudCBhdCB0aGUgZGVxdWUgdG9wXG4gICAgICB3aGlsZSAoRFt0b3BdID49IDAgJiYgRFt0b3AgKyAxXSA+PSAwICYmIGlzTGVmdCh2ZXJ0c1tEW3RvcCAtIDFdXSwgdmVydHNbRFt0b3BdXSwgdmVydHNbaV0pIDw9IDApIHtcbiAgICAgICAgdG9wIC09IDEgLy8gcG9wIHRvcCBvZiBkZXF1ZVxuICAgICAgfVxuICAgICAgdG9wICs9IDFcbiAgICAgIERbdG9wXSA9IGkgLy8gcHVzaCB2ZXJ0c1tpXSBvbnRvIHRvcCBvZiBkZXF1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIHRyYW5zY3JpYmUgZGVxdWUgRFtdIHRvIHRoZSBvdXRwdXQgaHVsbCBhcnJheSBIW11cbiAgbGV0IGggPSAwXG4gIGZvciAoaCA9IDA7IGggPD0gKHRvcCAtIGJvdCAtIDEpOyBoICs9IDEpIHtcbiAgICBIW2hdID0gRFtib3QgKyBoXVxuICB9XG5cbiAgaWYgKERbYm90ICsgaF0gIT09IEhbMF0pIHtcbiAgICBIW2hdID0gRFtib3QgKyBoXVxuICB9XG5cbiAgcmV0dXJuIEhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21hdGgvY29udmV4LWh1bGwuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(7);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} RectOptions\n * @property {number} [width=0] Width of the rect in world space coords\n * @property {number} [height=0] Height of the rect in world space coords\n */\n\n/**\n * @class Class for defining a rectangle shape\n * @extends {BaseShape}\n */\nvar Rect = function (_BaseShape) {\n  _inherits(Rect, _BaseShape);\n\n  /**\n   * Creates a new rectangle shape\n   * @param  {RectOptions} [opts]\n   * @return {Rect}\n   */\n  function Rect(opts) {\n    _classCallCheck(this, Rect);\n\n    var _this = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, opts));\n\n    _this._width = 0;\n    _this._height = 0;\n    if (typeof opts.width !== \"undefined\") {\n      _this.width = opts.width;\n    }\n    if (typeof opts.height !== \"undefined\") {\n      _this.height = opts.height;\n    }\n    return _this;\n  }\n\n  /**\n   * Gets the untransformed width/height of the rect\n   * @return {Vec2d} Width/height of the rect\n   */\n\n\n  _createClass(Rect, [{\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return [this._width, this._height];\n    }\n\n    /**\n     * Sets the width of the rectangle\n     * @param  {number} width Width of the rect in world-space coordinates\n     * @return {Rect}       this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If width is not a valid number\n     */\n\n  }, {\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        AABox2d.initCenterExtents(this._aabox, [0, 0], [this._width / 2, this._height / 2]);\n        AABox2d.transformMat2d(this._aabox, this._aabox, this.globalXform);\n        this._geomDirty = this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the rect using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.rect(0 - this.width / 2, 0 - this.height / 2, this.width, this.height);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Rect\",\n        width: this.width,\n        height: this.height\n      }, _get(Rect.prototype.__proto__ || Object.getPrototypeOf(Rect.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"width\",\n    set: function set(width) {\n      if (typeof width !== \"number\") {\n        throw new Error(\"Width must be a number\");\n      }\n\n      if (width !== this._width) {\n        var prev = this._width;\n        this._width = width;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"width\",\n          prevVal: prev,\n          currVal: this._width\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current untransformed width of the rect\n     * @return {number} Width in world-space units\n     */\n    ,\n    get: function get() {\n      return this._width;\n    }\n\n    /**\n     * Sets the height of the rectangle\n     * @param  {number} height Height of the rect in world-space units\n     * @return {Rect}       this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If height is not a valid number\n     */\n\n  }, {\n    key: \"height\",\n    set: function set(height) {\n      if (typeof height !== \"number\") {\n        throw new Error(\"Height must be a number\");\n      }\n\n      if (height !== this._height) {\n        var prev = this._height;\n        this._height = height;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"height\",\n          prevVal: prev,\n          currVal: this._height\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current untransformed height of the rect\n     * @return {number} Height in world-space units\n     */\n    ,\n    get: function get() {\n      return this._height;\n    }\n  }]);\n\n  return Rect;\n}(_baseShape2.default);\n\nexports.default = Rect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcmVjdC5qcz80ZDJiIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJSZWN0Iiwib3B0cyIsIl93aWR0aCIsIl9oZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJ0cmFuc2Zvcm1NYXQyZCIsImdsb2JhbFhmb3JtIiwiY3R4IiwicmVjdCIsIk9iamVjdCIsImFzc2lnbiIsInR5cGUiLCJFcnJvciIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFNQTs7OztJQUlxQkMsSTs7O0FBQ25COzs7OztBQUtBLGdCQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsNEdBQ1ZBLElBRFU7O0FBRWhCLFVBQUtDLE1BQUwsR0FBYyxDQUFkO0FBQ0EsVUFBS0MsT0FBTCxHQUFlLENBQWY7QUFDQSxRQUFJLE9BQU9GLEtBQUtHLEtBQVosS0FBc0IsV0FBMUIsRUFBdUM7QUFDckMsWUFBS0EsS0FBTCxHQUFhSCxLQUFLRyxLQUFsQjtBQUNEO0FBQ0QsUUFBSSxPQUFPSCxLQUFLSSxNQUFaLEtBQXVCLFdBQTNCLEVBQXdDO0FBQ3RDLFlBQUtBLE1BQUwsR0FBY0osS0FBS0ksTUFBbkI7QUFDRDtBQVRlO0FBVWpCOztBQUVEOzs7Ozs7OztvQ0FJZ0I7QUFDZCxhQUFPLENBQUMsS0FBS0gsTUFBTixFQUFjLEtBQUtDLE9BQW5CLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBb0VBOzs7OzttQ0FLZTtBQUNiLFVBQUksS0FBS0csVUFBTCxJQUFtQixLQUFLQyxnQkFBNUIsRUFBOEM7QUFDNUNSLGdCQUFRUyxpQkFBUixDQUEwQixLQUFLQyxNQUEvQixFQUF1QyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQXZDLEVBQStDLENBQUMsS0FBS1AsTUFBTCxHQUFjLENBQWYsRUFBa0IsS0FBS0MsT0FBTCxHQUFlLENBQWpDLENBQS9DO0FBQ0FKLGdCQUFRVyxjQUFSLENBQXVCLEtBQUtELE1BQTVCLEVBQW9DLEtBQUtBLE1BQXpDLEVBQWlELEtBQUtFLFdBQXREO0FBQ0EsYUFBS0wsVUFBTCxHQUFrQixLQUFLQyxnQkFBTCxHQUF3QixLQUExQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzswQkFNTUssRyxFQUFLO0FBQ1RBLFVBQUlDLElBQUosQ0FBUyxJQUFJLEtBQUtULEtBQUwsR0FBYSxDQUExQixFQUE2QixJQUFJLEtBQUtDLE1BQUwsR0FBYyxDQUEvQyxFQUFrRCxLQUFLRCxLQUF2RCxFQUE4RCxLQUFLQyxNQUFuRTtBQUNEOztBQUVEOzs7Ozs7Ozs2QkFLUztBQUNQLGFBQU9TLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxNQURhO0FBRW5CWixlQUFPLEtBQUtBLEtBRk87QUFHbkJDLGdCQUFRLEtBQUtBO0FBSE0sT0FBZCxxR0FBUDtBQUtEOzs7c0JBL0ZTRCxLLEVBQU87QUFDZixVQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsY0FBTSxJQUFJYSxLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUliLFVBQVUsS0FBS0YsTUFBbkIsRUFBMkI7QUFDekIsWUFBTWdCLE9BQU8sS0FBS2hCLE1BQWxCO0FBQ0EsYUFBS0EsTUFBTCxHQUFjRSxLQUFkO0FBQ0EsYUFBS0UsVUFBTCxHQUFrQixJQUFsQixDQUh5QixDQUdGOztBQUV2QixhQUFLYSxJQUFMLENBQVUsY0FBVixFQUEwQjtBQUN4QkMsZ0JBQU0sT0FEa0I7QUFFeEJDLG1CQUFTSCxJQUZlO0FBR3hCSSxtQkFBUyxLQUFLcEI7QUFIVSxTQUExQjtBQUtEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlZO0FBQ1YsYUFBTyxLQUFLQSxNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7c0JBT1dHLE0sRUFBUTtBQUNqQixVQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsY0FBTSxJQUFJWSxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUlaLFdBQVcsS0FBS0YsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTWUsT0FBTyxLQUFLZixPQUFsQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUUsTUFBZjtBQUNBLGFBQUtDLFVBQUwsR0FBa0IsSUFBbEIsQ0FIMkIsQ0FHSjs7QUFFdkIsYUFBS2EsSUFBTCxDQUFVLGNBQVYsRUFBMEI7QUFDeEJDLGdCQUFNLFFBRGtCO0FBRXhCQyxtQkFBU0gsSUFGZTtBQUd4QkksbUJBQVMsS0FBS25CO0FBSFUsU0FBMUI7QUFLRDtBQUNELGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJYTtBQUNYLGFBQU8sS0FBS0EsT0FBWjtBQUNEOzs7Ozs7a0JBNUZrQkgsSSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gXCIuL2Jhc2Utc2hhcGUuanNcIlxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJlY3RPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoPTBdIFdpZHRoIG9mIHRoZSByZWN0IGluIHdvcmxkIHNwYWNlIGNvb3Jkc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHQ9MF0gSGVpZ2h0IG9mIHRoZSByZWN0IGluIHdvcmxkIHNwYWNlIGNvb3Jkc1xuICovXG5cbi8qKlxuICogQGNsYXNzIENsYXNzIGZvciBkZWZpbmluZyBhIHJlY3RhbmdsZSBzaGFwZVxuICogQGV4dGVuZHMge0Jhc2VTaGFwZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJlY3RhbmdsZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtSZWN0T3B0aW9uc30gW29wdHNdXG4gICAqIEByZXR1cm4ge1JlY3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl93aWR0aCA9IDBcbiAgICB0aGlzLl9oZWlnaHQgPSAwXG4gICAgaWYgKHR5cGVvZiBvcHRzLndpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aFxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuaGVpZ2h0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGgvaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9oZWlnaHQgb2YgdGhlIHJlY3RcbiAgICovXG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0XVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdCBpbiB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtSZWN0fSAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB3aWR0aCBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICovXG4gIHNldCB3aWR0aCh3aWR0aCkge1xuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoIG11c3QgYmUgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoKSB7XG4gICAgICBjb25zdCBwcmV2ID0gdGhpcy5fd2lkdGhcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGhcbiAgICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWUgLy8gZGlydHkgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSBmaXJpbmcgZXZlbnRcblxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tXCIsIHtcbiAgICAgICAgYXR0cjogXCJ3aWR0aFwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl93aWR0aFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHJlY3RcbiAgICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKiBAcmV0dXJuIHtSZWN0fSAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBoZWlnaHQgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAqL1xuICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWlnaHQgbXVzdCBiZSBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIGlmIChoZWlnaHQgIT09IHRoaXMuX2hlaWdodCkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2hlaWdodFxuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0XG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwiaGVpZ2h0XCIsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IHRoaXMuX2hlaWdodFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVudHJhbnNmb3JtZWQgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IGluIHdvcmxkLXNwYWNlIHVuaXRzXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgYm91bmRpbmcgYm94IHJlcXVpcmVzIHVwZGF0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX3VwZGF0ZUFBQm94KCkge1xuICAgIGlmICh0aGlzLl9nZW9tRGlydHkgfHwgdGhpcy5fYm91bmRzT3V0T2ZEYXRlKSB7XG4gICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl93aWR0aCAvIDIsIHRoaXMuX2hlaWdodCAvIDJdKVxuICAgICAgQUFCb3gyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl9hYWJveCwgdGhpcy5fYWFib3gsIHRoaXMuZ2xvYmFsWGZvcm0pXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgcmVjdCB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5yZWN0KDAgLSB0aGlzLndpZHRoIC8gMiwgMCAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGNvbnZlcnQgdGhlIHNoYXBlIHRvIGEgc2VyaWFsaXphYmxlIEpTT04gb2JqZWN0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogXCJSZWN0XCIsXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9LCBzdXBlci50b0pTT04oKSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3JlY3QuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedColorRGBAClass = createEventedColorRGBAClass;\n\nvar _math = __webpack_require__(6);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Color keywords as defined by the CSS color modules\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}\n * @type {Map}\n */\nvar colorKeywords = new Map([[\"aliceblue\", \"#F0F8FF\"], [\"antiquewhite\", \"#FAEBD7\"], [\"aqua\", \"#00FFFF\"], [\"aquamarine\", \"#7FFFD4\"], [\"azure\", \"#F0FFFF\"], [\"beige\", \"#F5F5DC\"], [\"bisque\", \"#FFE4C4\"], [\"black\", \"#000000\"], [\"blanchedalmond\", \"#FFEBCD\"], [\"blue\", \"#0000FF\"], [\"blueviolet\", \"#8A2BE2\"], [\"brown\", \"#A52A2A\"], [\"burlywood\", \"#DEB887\"], [\"cadetblue\", \"#5F9EA0\"], [\"chartreuse\", \"#7FFF00\"], [\"chocolate\", \"#D2691E\"], [\"coral\", \"#FF7F50\"], [\"cornflowerblue\", \"#6495ED\"], [\"cornsilk\", \"#FFF8DC\"], [\"crimson\", \"#DC143C\"], [\"cyan\", \"#00FFFF\"], [\"darkblue\", \"#00008B\"], [\"darkcyan\", \"#008B8B\"], [\"darkgoldenrod\", \"#B8860B\"], [\"darkgray\", \"#A9A9A9\"], [\"darkgreen\", \"#006400\"], [\"darkkhaki\", \"#BDB76B\"], [\"darkmagenta\", \"#8B008B\"], [\"darkolivegreen\", \"#556B2F\"], [\"darkorange\", \"#FF8C00\"], [\"darkorchid\", \"#9932CC\"], [\"darkred\", \"#8B0000\"], [\"darksalmon\", \"#E9967A\"], [\"darkseagreen\", \"#8FBC8F\"], [\"darkslateblue\", \"#483D8B\"], [\"darkslategray\", \"#2F4F4F\"], [\"darkturquoise\", \"#00CED1\"], [\"darkviolet\", \"#9400D3\"], [\"deeppink\", \"#FF1493\"], [\"deepskyblue\", \"#00BFFF\"], [\"dimgray\", \"#696969\"], [\"dodgerblue\", \"#1E90FF\"], [\"firebrick\", \"#B22222\"], [\"floralwhite\", \"#FFFAF0\"], [\"forestgreen\", \"#228B22\"], [\"fuchsia\", \"#FF00FF\"], [\"gainsboro\", \"#DCDCDC\"], [\"ghostwhite\", \"#F8F8FF\"], [\"gold\", \"#FFD700\"], [\"goldenrod\", \"#DAA520\"], [\"gray\", \"#808080\"], [\"green\", \"#008000\"], [\"greenyellow\", \"#ADFF2F\"], [\"honeydew\", \"#F0FFF0\"], [\"hotpink\", \"#FF69B4\"], [\"indianred\", \"#CD5C5C\"], [\"indigo\", \"#4B0082\"], [\"ivory\", \"#FFFFF0\"], [\"khaki\", \"#F0E68C\"], [\"lavender\", \"#E6E6FA\"], [\"lavenderblush\", \"#FFF0F5\"], [\"lawngreen\", \"#7CFC00\"], [\"lemonchiffon\", \"#FFFACD\"], [\"lightblue\", \"#ADD8E6\"], [\"lightcoral\", \"#F08080\"], [\"lightcyan\", \"#E0FFFF\"], [\"lightgoldenrodyellow\", \"#FAFAD2\"], [\"lightgray\", \"#D3D3D3\"], [\"lightgreen\", \"#90EE90\"], [\"lightpink\", \"#FFB6C1\"], [\"lightsalmon\", \"#FFA07A\"], [\"lightseagreen\", \"#20B2AA\"], [\"lightskyblue\", \"#87CEFA\"], [\"lightslategray\", \"#778899\"], [\"lightsteelblue\", \"#B0C4DE\"], [\"lightyellow\", \"#FFFFE0\"], [\"lime\", \"#00FF00\"], [\"limegreen\", \"#32CD32\"], [\"linen\", \"#FAF0E6\"], [\"magenta\", \"#FF00FF\"], [\"maroon\", \"#800000\"], [\"mediumaquamarine\", \"#66CDAA\"], [\"mediumblue\", \"#0000CD\"], [\"mediumorchid\", \"#BA55D3\"], [\"mediumpurple\", \"#9370DB\"], [\"mediumseagreen\", \"#3CB371\"], [\"mediumslateblue\", \"#7B68EE\"], [\"mediumspringgreen\", \"#00FA9A\"], [\"mediumturquoise\", \"#48D1CC\"], [\"mediumvioletred\", \"#C71585\"], [\"midnightblue\", \"#191970\"], [\"mintcream\", \"#F5FFFA\"], [\"mistyrose\", \"#FFE4E1\"], [\"moccasin\", \"#FFE4B5\"], [\"navajowhite\", \"#FFDEAD\"], [\"navy\", \"#000080\"], [\"oldlace\", \"#FDF5E6\"], [\"olive\", \"#808000\"], [\"olivedrab\", \"#6B8E23\"], [\"orange\", \"#FFA500\"], [\"orangered\", \"#FF4500\"], [\"orchid\", \"#DA70D6\"], [\"palegoldenrod\", \"#EEE8AA\"], [\"palegreen\", \"#98FB98\"], [\"paleturquoise\", \"#AFEEEE\"], [\"palevioletred\", \"#DB7093\"], [\"papayawhip\", \"#FFEFD5\"], [\"peachpuff\", \"#FFDAB9\"], [\"peru\", \"#CD853F\"], [\"pink\", \"#FFC0CB\"], [\"plum\", \"#DDA0DD\"], [\"powderblue\", \"#B0E0E6\"], [\"purple\", \"#800080\"], [\"rebeccapurple\", \"#663399\"], [\"red\", \"#FF0000\"], [\"rosybrown\", \"#BC8F8F\"], [\"royalblue\", \"#4169E1\"], [\"saddlebrown\", \"#8B4513\"], [\"salmon\", \"#FA8072\"], [\"sandybrown\", \"#F4A460\"], [\"seagreen\", \"#2E8B57\"], [\"seashell\", \"#FFF5EE\"], [\"sienna\", \"#A0522D\"], [\"silver\", \"#C0C0C0\"], [\"skyblue\", \"#87CEEB\"], [\"slateblue\", \"#6A5ACD\"], [\"slategray\", \"#708090\"], [\"snow\", \"#FFFAFA\"], [\"springgreen\", \"#00FF7F\"], [\"steelblue\", \"#4682B4\"], [\"tan\", \"#D2B48C\"], [\"teal\", \"#008080\"], [\"thistle\", \"#D8BFD8\"], [\"tomato\", \"#FF6347\"], [\"turquoise\", \"#40E0D0\"], [\"violet\", \"#EE82EE\"], [\"wheat\", \"#F5DEB3\"], [\"white\", \"#FFFFFF\"], [\"whitesmoke\", \"#F5F5F5\"], [\"yellow\", \"#FFFF00\"], [\"yellowgreen\", \"#9ACD32\"]]);\n\n/**\n * rgb regex to handle \"rgb([0-255],[0-255],[0-255])\" color strings\n * @type {RegExp}\n */\nvar rgbRegex = /^rgb\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)\\s*$/i;\n\n/**\n * rgba regex to handle \"rgba([0-255],[0-255],[0-255],[0.0-1.0])\" color strings\n * @type {RegExp}\n */\nvar rgbaRegex = /^rgba\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([0,1](?:\\.\\d*)?)\\s*\\)\\s*$/i;\n\n/**\n * hex regex to handle \"#[00-FF][00-FF][00-FF]\" color strings.\n * @type {RegExp}\n */\nvar hexRegex = /^#([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})\\s*$/i;\n\n/**\n * Extracts an opacity from an rgba color packed into a 32-bit integer\n * @param  {number} packedRgbaColor\n * @return {number}                 opacity extracted in range of [0,1]\n */\nfunction getOpacity(packedRgbaColor) {\n  return (packedRgbaColor & 0xFF) / 255.0;\n}\n\n/**\n * packs an opacity value [0,1] into an 8-bit integer to be packed\n * into a 32-bit int\n * @param  {number} opacity [0,1]\n * @return {number}         [0,255]\n */\nfunction packOpacity(opacity) {\n  return _math2.default.floor(_math2.default.clamp01(opacity) * 255);\n}\n\n/**\n * Given a color packed into a 32-bit integer, returns a css-style \"rgba()\" string\n * @param  {number} packedRgbaColor\n * @return {string}                 int the form \"rgba([0,255],[0,255],[0,255],[0,1])\"\n */\nfunction getRGBAString(packedRgbaColor) {\n  return \"rgba(\" + (packedRgbaColor >>> 24) + \", \" + ((packedRgbaColor & 0xFF0000) >> 16) + \", \" + ((packedRgbaColor & 0xFF00) >> 8) + \", \" + getOpacity(packedRgbaColor) + \")\";\n}\n\n/**\n * Given an rgba() color string, extracts a numeric color packed into a 32-bit int\n * @param  {string} color\n * @return {number}\n */\nfunction getPackedColorRGBAFromString(color) {\n  if (typeof color !== \"string\") {\n    throw new Error(color + \" is not a valid color string\");\n  }\n\n  var packedColor = 0;\n\n  var match = null;\n  if (match = color.match(rgbRegex)) {\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 10), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 10), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 10), 0, 255) << 24;\n  } else if (match = color.match(rgbaRegex)) {\n    packedColor = packOpacity(Number.parseFloat(match[4], 10));\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 10), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 10), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 10), 0, 255) << 24;\n  } else if (match = color.match(hexRegex)) {\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 16), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 16), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 16), 0, 255) << 24;\n  } else if (colorKeywords.has(color)) {\n    match = colorKeywords.get(color).match(hexRegex);\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 16), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 16), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 16), 0, 255) << 24;\n  } else {\n    throw new Error(color + \" is not a valid color string\");\n  }\n\n  return packedColor;\n}\n\n/** @class manages colors in the RGBA color space. Can also be used as a mixin */\n\nvar ColorRGBA = function () {\n  /**\n   * Creates a new color in the RGBA color space\n   * @param  {string}    initColorStr color string in the form \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"red\")\n   * @param  {...object} args         Additional arguments that may be passed to other initializers/constructors\n   *                                  if this class is used as a base class or mixin\n   * @return {ColorRGBA}\n   */\n  function ColorRGBA(initColorStr) {\n    _classCallCheck(this, ColorRGBA);\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this.initializer.apply(this, [initColorStr].concat(args));\n  }\n\n  /**\n   * initializes a color in the RGBA color space using a color string\n   * @param  {string} initColorStr initializer string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n   */\n\n\n  _createClass(ColorRGBA, [{\n    key: \"initializer\",\n    value: function initializer(initColorStr) {\n      this._color = 0;\n      if (initColorStr) {\n        this.value = initColorStr;\n      }\n    }\n\n    /**\n     * sets all the channels of the RGBA color given a color string\n     * @param  {string} color color string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"isTransparent\",\n\n\n    /**\n     * Returns true if the current opacity of the rgba color < 1\n     * @return {Boolean}\n     */\n    value: function isTransparent() {\n      return getOpacity(this._color) < 1.0;\n    }\n  }, {\n    key: \"value\",\n    set: function set(color) {\n      this._color = getPackedColorRGBAFromString(color);\n      return this;\n    }\n\n    /**\n     * Gets the rgba color as a color string \"rgba()\"\n     * @return {string} rgba color as a string\n     */\n    ,\n    get: function get() {\n      return getRGBAString(this._color);\n    }\n\n    /**\n     * Sets the value of the RGBA color packed as a 32-bit int\n     * @param  {number} packedColor\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"packedValue\",\n    set: function set(packedColor) {\n      this._color = 0;\n      this._color |= packedColor;\n      return this;\n    }\n\n    /**\n     * Gets the current value of the RGBA color as a packed 32-bit int\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._color;\n    }\n\n    /**\n     * sets the opacity of the RGBA color (modifies alpha channel only)\n     * @param  {number} opacity [0,1]\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"opacity\",\n    set: function set(opacity) {\n      if (typeof opacity !== \"number\") {\n        throw new Error(\"Opacity must be a number between 0-1\");\n      }\n\n      var currOpacity = this._color & 0xFF;\n      var newOpacity = packOpacity(opacity);\n      if (newOpacity !== currOpacity) {\n        this._color &= 0xFFFFFF00;\n        this._color |= newOpacity;\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current opacity (alpha channel) of the RGBA color\n     * @return {number} [0,1]\n     */\n    ,\n    get: function get() {\n      return getOpacity(this._color);\n    }\n  }]);\n\n  return ColorRGBA;\n}();\n\n/**\n * Creates a new color RGBA class that fires events whenever the color\n * is changed externally\n * @param  {string} eventName Event type to fire when color is modified\n * @param  {string} colorName Name of the color attribute. This string is used in the event object fired\n * @return {function}         New class constructor function\n */\n\n\nexports.default = ColorRGBA;\nfunction createEventedColorRGBAClass(eventName, colorName) {\n\n  /**\n   * @class New rgba color class that fires events when modified\n   * @extends {ColorRGBA}\n   */\n  return function (_ColorRGBA) {\n    _inherits(EventedColorRGBA, _ColorRGBA);\n\n    function EventedColorRGBA() {\n      _classCallCheck(this, EventedColorRGBA);\n\n      return _possibleConstructorReturn(this, (EventedColorRGBA.__proto__ || Object.getPrototypeOf(EventedColorRGBA)).apply(this, arguments));\n    }\n\n    _createClass(EventedColorRGBA, [{\n      key: \"initializer\",\n\n      /**\n       * Color modification event\n       * @event EventedColor#changed\n       * @type {object}\n       * @property {string} attr Name of the attribute modified\n       * @property {} prevVal Previous value of the attribute prior to modification\n       * @property {} currVal Value of the attribute post modification\n       */\n\n      /**\n       * Initializes the evented color\n       * @param  {string} initColorStr initial color as string\n       * @param  {EventHandler} eventHandler Event handler instance used to manage the color\n       *                                     modification events\n       * @protected\n       */\n      value: function initializer(initColorStr, eventHandler) {\n        this._eventHandler = eventHandler;\n        _get(EventedColorRGBA.prototype.__proto__ || Object.getPrototypeOf(EventedColorRGBA.prototype), \"initializer\", this).call(this, initColorStr);\n      }\n\n      /**\n       * Validates modification of the rgba color, and if modified, fires\n       * modification events\n       * @param  {number} newPackedColor Color defined by a 32-bit int\n       * @private\n       */\n\n    }, {\n      key: \"_checkPackedColorChanged\",\n      value: function _checkPackedColorChanged(newPackedColor) {\n        if (newPackedColor !== this._color) {\n          var prev = this._color;\n          var prevOpacity = getOpacity(prev);\n          var opacity = getOpacity(newPackedColor);\n          this._color = newPackedColor;\n\n          this._eventHandler.fire(eventName, {\n            attr: colorName,\n            prevVal: getRGBAString(prev),\n            currVal: getRGBAString(this._color)\n          });\n\n          if (opacity !== prevOpacity) {\n            this._eventHandler.fire(eventName, {\n              attr: \"opacity\",\n              prevVal: prevOpacity,\n              currVal: opacity\n            });\n          }\n        }\n      }\n\n      /**\n       * sets all the channels of the RGBA color from a color string\n       * @param  {string} color color string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"value\",\n      set: function set(color) {\n        var tmpcolor = getPackedColorRGBAFromString(color);\n        this._checkPackedColorChanged(tmpcolor);\n        return this;\n      }\n\n      /**\n       * Gets the rgba color as a color string \"rgba()\"\n       * @return {string} rgba color as a string\n       */\n      ,\n      get: function get() {\n        return getRGBAString(this._color);\n      }\n\n      /**\n       * Sets the value of the RGBA color packed as a 32-bit int\n       * @param  {number} packedColor\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"packedValue\",\n      set: function set(packedColor) {\n        var tmpcolor = 0;\n        tmpcolor |= packedColor;\n        this._checkPackedColorChanged(tmpcolor);\n        return this;\n      }\n\n      /**\n       * Gets the current value of the RGBA color as a packed 32-bit int\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._color;\n      }\n\n      /**\n       * sets the opacity of the RGBA color (modifies alpha channel only)\n       * @param  {number} opacity [0,1]\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"opacity\",\n      set: function set(opacity) {\n        if (typeof opacity !== \"number\") {\n          throw new Error(\"Opacity must be a number between 0-1\");\n        }\n\n        var currOpacity = this._color & 0xFF;\n        var newOpacity = packOpacity(opacity);\n        if (newOpacity !== currOpacity) {\n          this._color &= 0xFFFFFF00;\n          this._color |= newOpacity;\n\n          this._eventHandler.fire(eventName, {\n            attr: \"opacity\",\n            prevVal: currOpacity / 255.0,\n            currVal: newOpacity / 255.0\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current opacity (alpha channel) of the RGBA color\n       * @return {number} [0,1]\n       */\n      ,\n      get: function get() {\n        return getOpacity(this._color);\n      }\n    }]);\n\n    return EventedColorRGBA;\n  }(ColorRGBA);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9jb2xvci1yZ2JhLmpzPzdlYmEiXSwibmFtZXMiOlsiY3JlYXRlRXZlbnRlZENvbG9yUkdCQUNsYXNzIiwiY29sb3JLZXl3b3JkcyIsIk1hcCIsInJnYlJlZ2V4IiwicmdiYVJlZ2V4IiwiaGV4UmVnZXgiLCJnZXRPcGFjaXR5IiwicGFja2VkUmdiYUNvbG9yIiwicGFja09wYWNpdHkiLCJvcGFjaXR5IiwiZmxvb3IiLCJjbGFtcDAxIiwiZ2V0UkdCQVN0cmluZyIsImdldFBhY2tlZENvbG9yUkdCQUZyb21TdHJpbmciLCJjb2xvciIsIkVycm9yIiwicGFja2VkQ29sb3IiLCJtYXRjaCIsImNsYW1wIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0IiwiaGFzIiwiZ2V0IiwiQ29sb3JSR0JBIiwiaW5pdENvbG9yU3RyIiwiYXJncyIsImluaXRpYWxpemVyIiwiX2NvbG9yIiwidmFsdWUiLCJjdXJyT3BhY2l0eSIsIm5ld09wYWNpdHkiLCJldmVudE5hbWUiLCJjb2xvck5hbWUiLCJldmVudEhhbmRsZXIiLCJfZXZlbnRIYW5kbGVyIiwibmV3UGFja2VkQ29sb3IiLCJwcmV2IiwicHJldk9wYWNpdHkiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwidG1wY29sb3IiLCJfY2hlY2tQYWNrZWRDb2xvckNoYW5nZWQiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7UUFzVmdCQSwyQixHQUFBQSwyQjs7QUFwVmhCOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7QUFLQSxJQUFNQyxnQkFBZ0IsSUFBSUMsR0FBSixDQUFRLENBQUMsQ0FBQyxXQUFELEVBQWMsU0FBZCxDQUFELEVBQ0MsQ0FBQyxjQUFELEVBQWlCLFNBQWpCLENBREQsRUFFQyxDQUFDLE1BQUQsRUFBUyxTQUFULENBRkQsRUFHQyxDQUFDLFlBQUQsRUFBZSxTQUFmLENBSEQsRUFJQyxDQUFDLE9BQUQsRUFBVSxTQUFWLENBSkQsRUFLQyxD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NkVrQlosV0E3RWxCLEVBNkUrQjtBQUMzQixZQUFJMkIsV0FBVyxDQUFmO0FBQ0FBLG9CQUFZM0IsV0FBWjtBQUNBLGFBQUs0Qix3QkFBTCxDQUE4QkQsUUFBOUI7QUFDQSxlQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXBGRjtBQUFBLDBCQXdGb0I7QUFDaEIsZUFBTyxLQUFLZixNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUE1RkY7QUFBQTtBQUFBLHdCQWtHY25CLE9BbEdkLEVBa0d1QjtBQUNuQixZQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IsZ0JBQU0sSUFBSU0sS0FBSixDQUFVLHNDQUFWLENBQU47QUFDRDs7QUFFRCxZQUFNZSxjQUFjLEtBQUtGLE1BQUwsR0FBYyxJQUFsQztBQUNBLFlBQU1HLGFBQWF2QixZQUFZQyxPQUFaLENBQW5CO0FBQ0EsWUFBSXNCLGVBQWVELFdBQW5CLEVBQWdDO0FBQzlCLGVBQUtGLE1BQUwsSUFBZSxVQUFmO0FBQ0EsZUFBS0EsTUFBTCxJQUFlRyxVQUFmOztBQUVBLGVBQUtJLGFBQUwsQ0FBbUJJLElBQW5CLENBQXdCUCxTQUF4QixFQUFtQztBQUNqQ1Esa0JBQU0sU0FEMkI7QUFFakNDLHFCQUFTWCxjQUFjLEtBRlU7QUFHakNZLHFCQUFTWCxhQUFhO0FBSFcsV0FBbkM7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBdEhGO0FBQUEsMEJBMEhnQjtBQUNaLGVBQU96QixXQUFXLEtBQUtzQixNQUFoQixDQUFQO0FBQ0Q7QUE1SEg7O0FBQUE7QUFBQSxJQUFzQ0osU0FBdEM7QUE4SEQiLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1tYWdpYy1udW1iZXJzICovXG5cInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBDb2xvciBrZXl3b3JkcyBhcyBkZWZpbmVkIGJ5IHRoZSBDU1MgY29sb3IgbW9kdWxlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfVxuICogQHR5cGUge01hcH1cbiAqL1xuY29uc3QgY29sb3JLZXl3b3JkcyA9IG5ldyBNYXAoW1tcImFsaWNlYmx1ZVwiLCBcIiNGMEY4RkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYW50aXF1ZXdoaXRlXCIsIFwiI0ZBRUJEN1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhcXVhXCIsIFwiIzAwRkZGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhcXVhbWFyaW5lXCIsIFwiIzdGRkZENFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhenVyZVwiLCBcIiNGMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmVpZ2VcIiwgXCIjRjVGNURDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJpc3F1ZVwiLCBcIiNGRkU0QzRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmxhY2tcIiwgXCIjMDAwMDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJsYW5jaGVkYWxtb25kXCIsIFwiI0ZGRUJDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJibHVlXCIsIFwiIzAwMDBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJibHVldmlvbGV0XCIsIFwiIzhBMkJFMlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJicm93blwiLCBcIiNBNTJBMkFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYnVybHl3b29kXCIsIFwiI0RFQjg4N1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjYWRldGJsdWVcIiwgXCIjNUY5RUEwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNoYXJ0cmV1c2VcIiwgXCIjN0ZGRjAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNob2NvbGF0ZVwiLCBcIiNEMjY5MUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY29yYWxcIiwgXCIjRkY3RjUwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNvcm5mbG93ZXJibHVlXCIsIFwiIzY0OTVFRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjb3Juc2lsa1wiLCBcIiNGRkY4RENcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY3JpbXNvblwiLCBcIiNEQzE0M0NcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY3lhblwiLCBcIiMwMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2JsdWVcIiwgXCIjMDAwMDhCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtjeWFuXCIsIFwiIzAwOEI4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrZ29sZGVucm9kXCIsIFwiI0I4ODYwQlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrZ3JheVwiLCBcIiNBOUE5QTlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2dyZWVuXCIsIFwiIzAwNjQwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJra2hha2lcIiwgXCIjQkRCNzZCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmttYWdlbnRhXCIsIFwiIzhCMDA4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrb2xpdmVncmVlblwiLCBcIiM1NTZCMkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya29yYW5nZVwiLCBcIiNGRjhDMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya29yY2hpZFwiLCBcIiM5OTMyQ0NcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3JlZFwiLCBcIiM4QjAwMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3NhbG1vblwiLCBcIiNFOTk2N0FcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3NlYWdyZWVuXCIsIFwiIzhGQkM4RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrc2xhdGVibHVlXCIsIFwiIzQ4M0Q4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrc2xhdGVncmF5XCIsIFwiIzJGNEY0RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrdHVycXVvaXNlXCIsIFwiIzAwQ0VEMVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrdmlvbGV0XCIsIFwiIzk0MDBEM1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkZWVwcGlua1wiLCBcIiNGRjE0OTNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGVlcHNreWJsdWVcIiwgXCIjMDBCRkZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRpbWdyYXlcIiwgXCIjNjk2OTY5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRvZGdlcmJsdWVcIiwgXCIjMUU5MEZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImZpcmVicmlja1wiLCBcIiNCMjIyMjJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZmxvcmFsd2hpdGVcIiwgXCIjRkZGQUYwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImZvcmVzdGdyZWVuXCIsIFwiIzIyOEIyMlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJmdWNoc2lhXCIsIFwiI0ZGMDBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJnYWluc2Jvcm9cIiwgXCIjRENEQ0RDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdob3N0d2hpdGVcIiwgXCIjRjhGOEZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdvbGRcIiwgXCIjRkZENzAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdvbGRlbnJvZFwiLCBcIiNEQUE1MjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ3JheVwiLCBcIiM4MDgwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ3JlZW5cIiwgXCIjMDA4MDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdyZWVueWVsbG93XCIsIFwiI0FERkYyRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJob25leWRld1wiLCBcIiNGMEZGRjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaG90cGlua1wiLCBcIiNGRjY5QjRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaW5kaWFucmVkXCIsIFwiI0NENUM1Q1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJpbmRpZ29cIiwgXCIjNEIwMDgyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIml2b3J5XCIsIFwiI0ZGRkZGMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJraGFraVwiLCBcIiNGMEU2OENcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGF2ZW5kZXJcIiwgXCIjRTZFNkZBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxhdmVuZGVyYmx1c2hcIiwgXCIjRkZGMEY1XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxhd25ncmVlblwiLCBcIiM3Q0ZDMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGVtb25jaGlmZm9uXCIsIFwiI0ZGRkFDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodGJsdWVcIiwgXCIjQUREOEU2XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Y29yYWxcIiwgXCIjRjA4MDgwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Y3lhblwiLCBcIiNFMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIiwgXCIjRkFGQUQyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Z3JheVwiLCBcIiNEM0QzRDNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRncmVlblwiLCBcIiM5MEVFOTBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRwaW5rXCIsIFwiI0ZGQjZDMVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodHNhbG1vblwiLCBcIiNGRkEwN0FcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRzZWFncmVlblwiLCBcIiMyMEIyQUFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRza3libHVlXCIsIFwiIzg3Q0VGQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodHNsYXRlZ3JheVwiLCBcIiM3Nzg4OTlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRzdGVlbGJsdWVcIiwgXCIjQjBDNERFXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0eWVsbG93XCIsIFwiI0ZGRkZFMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaW1lXCIsIFwiIzAwRkYwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaW1lZ3JlZW5cIiwgXCIjMzJDRDMyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpbmVuXCIsIFwiI0ZBRjBFNlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtYWdlbnRhXCIsIFwiI0ZGMDBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtYXJvb25cIiwgXCIjODAwMDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bWFxdWFtYXJpbmVcIiwgXCIjNjZDREFBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bWJsdWVcIiwgXCIjMDAwMENEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bW9yY2hpZFwiLCBcIiNCQTU1RDNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtcHVycGxlXCIsIFwiIzkzNzBEQlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1zZWFncmVlblwiLCBcIiMzQ0IzNzFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtc2xhdGVibHVlXCIsIFwiIzdCNjhFRVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1zcHJpbmdncmVlblwiLCBcIiMwMEZBOUFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtdHVycXVvaXNlXCIsIFwiIzQ4RDFDQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW12aW9sZXRyZWRcIiwgXCIjQzcxNTg1XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1pZG5pZ2h0Ymx1ZVwiLCBcIiMxOTE5NzBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWludGNyZWFtXCIsIFwiI0Y1RkZGQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtaXN0eXJvc2VcIiwgXCIjRkZFNEUxXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1vY2Nhc2luXCIsIFwiI0ZGRTRCNVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJuYXZham93aGl0ZVwiLCBcIiNGRkRFQURcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibmF2eVwiLCBcIiMwMDAwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib2xkbGFjZVwiLCBcIiNGREY1RTZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib2xpdmVcIiwgXCIjODA4MDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9saXZlZHJhYlwiLCBcIiM2QjhFMjNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib3JhbmdlXCIsIFwiI0ZGQTUwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJvcmFuZ2VyZWRcIiwgXCIjRkY0NTAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9yY2hpZFwiLCBcIiNEQTcwRDZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFsZWdvbGRlbnJvZFwiLCBcIiNFRUU4QUFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFsZWdyZWVuXCIsIFwiIzk4RkI5OFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwYWxldHVycXVvaXNlXCIsIFwiI0FGRUVFRVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwYWxldmlvbGV0cmVkXCIsIFwiI0RCNzA5M1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwYXBheWF3aGlwXCIsIFwiI0ZGRUZENVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwZWFjaHB1ZmZcIiwgXCIjRkZEQUI5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBlcnVcIiwgXCIjQ0Q4NTNGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBpbmtcIiwgXCIjRkZDMENCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBsdW1cIiwgXCIjRERBMEREXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBvd2RlcmJsdWVcIiwgXCIjQjBFMEU2XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInB1cnBsZVwiLCBcIiM4MDAwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicmViZWNjYXB1cnBsZVwiLCBcIiM2NjMzOTlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicmVkXCIsIFwiI0ZGMDAwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJyb3N5YnJvd25cIiwgXCIjQkM4RjhGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInJveWFsYmx1ZVwiLCBcIiM0MTY5RTFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2FkZGxlYnJvd25cIiwgXCIjOEI0NTEzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNhbG1vblwiLCBcIiNGQTgwNzJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2FuZHlicm93blwiLCBcIiNGNEE0NjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2VhZ3JlZW5cIiwgXCIjMkU4QjU3XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNlYXNoZWxsXCIsIFwiI0ZGRjVFRVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzaWVubmFcIiwgXCIjQTA1MjJEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNpbHZlclwiLCBcIiNDMEMwQzBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2t5Ymx1ZVwiLCBcIiM4N0NFRUJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2xhdGVibHVlXCIsIFwiIzZBNUFDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzbGF0ZWdyYXlcIiwgXCIjNzA4MDkwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNub3dcIiwgXCIjRkZGQUZBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNwcmluZ2dyZWVuXCIsIFwiIzAwRkY3RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzdGVlbGJsdWVcIiwgXCIjNDY4MkI0XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInRhblwiLCBcIiNEMkI0OENcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widGVhbFwiLCBcIiMwMDgwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widGhpc3RsZVwiLCBcIiNEOEJGRDhcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widG9tYXRvXCIsIFwiI0ZGNjM0N1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ0dXJxdW9pc2VcIiwgXCIjNDBFMEQwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInZpb2xldFwiLCBcIiNFRTgyRUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wid2hlYXRcIiwgXCIjRjVERUIzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIndoaXRlXCIsIFwiI0ZGRkZGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ3aGl0ZXNtb2tlXCIsIFwiI0Y1RjVGNVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ5ZWxsb3dcIiwgXCIjRkZGRjAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInllbGxvd2dyZWVuXCIsIFwiIzlBQ0QzMlwiXV0pXG5cbi8qKlxuICogcmdiIHJlZ2V4IHRvIGhhbmRsZSBcInJnYihbMC0yNTVdLFswLTI1NV0sWzAtMjU1XSlcIiBjb2xvciBzdHJpbmdzXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCByZ2JSZWdleCA9IC9ecmdiXFxzKlxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqXFwpXFxzKiQvaVxuXG4vKipcbiAqIHJnYmEgcmVnZXggdG8gaGFuZGxlIFwicmdiYShbMC0yNTVdLFswLTI1NV0sWzAtMjU1XSxbMC4wLTEuMF0pXCIgY29sb3Igc3RyaW5nc1xuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgcmdiYVJlZ2V4ID0gL15yZ2JhXFxzKlxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooWzAsMV0oPzpcXC5cXGQqKT8pXFxzKlxcKVxccyokL2lcblxuLyoqXG4gKiBoZXggcmVnZXggdG8gaGFuZGxlIFwiI1swMC1GRl1bMDAtRkZdWzAwLUZGXVwiIGNvbG9yIHN0cmluZ3MuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBoZXhSZWdleCA9IC9eIyhbMC05LGEtZixBLUZdezJ9KShbMC05LGEtZixBLUZdezJ9KShbMC05LGEtZixBLUZdezJ9KVxccyokL2lcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBvcGFjaXR5IGZyb20gYW4gcmdiYSBjb2xvciBwYWNrZWQgaW50byBhIDMyLWJpdCBpbnRlZ2VyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZFJnYmFDb2xvclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgb3BhY2l0eSBleHRyYWN0ZWQgaW4gcmFuZ2Ugb2YgWzAsMV1cbiAqL1xuZnVuY3Rpb24gZ2V0T3BhY2l0eShwYWNrZWRSZ2JhQ29sb3IpIHtcbiAgcmV0dXJuIChwYWNrZWRSZ2JhQ29sb3IgJiAweEZGKSAvIDI1NS4wXG59XG5cbi8qKlxuICogcGFja3MgYW4gb3BhY2l0eSB2YWx1ZSBbMCwxXSBpbnRvIGFuIDgtYml0IGludGVnZXIgdG8gYmUgcGFja2VkXG4gKiBpbnRvIGEgMzItYml0IGludFxuICogQHBhcmFtICB7bnVtYmVyfSBvcGFjaXR5IFswLDFdXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgWzAsMjU1XVxuICovXG5mdW5jdGlvbiBwYWNrT3BhY2l0eShvcGFjaXR5KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGguY2xhbXAwMShvcGFjaXR5KSAqIDI1NSlcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGNvbG9yIHBhY2tlZCBpbnRvIGEgMzItYml0IGludGVnZXIsIHJldHVybnMgYSBjc3Mtc3R5bGUgXCJyZ2JhKClcIiBzdHJpbmdcbiAqIEBwYXJhbSAge251bWJlcn0gcGFja2VkUmdiYUNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBpbnQgdGhlIGZvcm0gXCJyZ2JhKFswLDI1NV0sWzAsMjU1XSxbMCwyNTVdLFswLDFdKVwiXG4gKi9cbmZ1bmN0aW9uIGdldFJHQkFTdHJpbmcocGFja2VkUmdiYUNvbG9yKSB7XG4gIHJldHVybiBgcmdiYSgkeyhwYWNrZWRSZ2JhQ29sb3IpID4+PiAyNH0sICR7KHBhY2tlZFJnYmFDb2xvciAmIDB4RkYwMDAwKSA+PiAxNn0sICR7KHBhY2tlZFJnYmFDb2xvciAmIDB4RkYwMCkgPj4gOH0sICR7Z2V0T3BhY2l0eShwYWNrZWRSZ2JhQ29sb3IpfSlgXG59XG5cbi8qKlxuICogR2l2ZW4gYW4gcmdiYSgpIGNvbG9yIHN0cmluZywgZXh0cmFjdHMgYSBudW1lcmljIGNvbG9yIHBhY2tlZCBpbnRvIGEgMzItYml0IGludFxuICogQHBhcmFtICB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRQYWNrZWRDb2xvclJHQkFGcm9tU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29sb3J9IGlzIG5vdCBhIHZhbGlkIGNvbG9yIHN0cmluZ2ApXG4gIH1cblxuICBsZXQgcGFja2VkQ29sb3IgPSAwXG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoKG1hdGNoID0gY29sb3IubWF0Y2gocmdiUmVnZXgpKSkge1xuICAgIHBhY2tlZENvbG9yID0gMjU1IC8vIChmdWxseSBvcGFxdWUpXG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbM10sIDEwKSwgMCwgMjU1KSA8PCA4XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMl0sIDEwKSwgMCwgMjU1KSA8PCAxNlxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxMCksIDAsIDI1NSkgPDwgMjRcbiAgfSBlbHNlIGlmICgobWF0Y2ggPSBjb2xvci5tYXRjaChyZ2JhUmVnZXgpKSkge1xuICAgIHBhY2tlZENvbG9yID0gcGFja09wYWNpdHkoTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbNF0sIDEwKSlcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFszXSwgMTApLCAwLCAyNTUpIDw8IDhcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsyXSwgMTApLCAwLCAyNTUpIDw8IDE2XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDEwKSwgMCwgMjU1KSA8PCAyNFxuICB9IGVsc2UgaWYgKChtYXRjaCA9IGNvbG9yLm1hdGNoKGhleFJlZ2V4KSkpIHtcbiAgICBwYWNrZWRDb2xvciA9IDI1NSAvLyAoZnVsbHkgb3BhcXVlKVxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzNdLCAxNiksIDAsIDI1NSkgPDwgOFxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzJdLCAxNiksIDAsIDI1NSkgPDwgMTZcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpLCAwLCAyNTUpIDw8IDI0XG4gIH0gZWxzZSBpZiAoY29sb3JLZXl3b3Jkcy5oYXMoY29sb3IpKSB7XG4gICAgbWF0Y2ggPSBjb2xvcktleXdvcmRzLmdldChjb2xvcikubWF0Y2goaGV4UmVnZXgpXG4gICAgcGFja2VkQ29sb3IgPSAyNTUgLy8gKGZ1bGx5IG9wYXF1ZSlcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFszXSwgMTYpLCAwLCAyNTUpIDw8IDhcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsyXSwgMTYpLCAwLCAyNTUpIDw8IDE2XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSwgMCwgMjU1KSA8PCAyNFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtjb2xvcn0gaXMgbm90IGEgdmFsaWQgY29sb3Igc3RyaW5nYClcbiAgfVxuXG4gIHJldHVybiBwYWNrZWRDb2xvclxufVxuXG4vKiogQGNsYXNzIG1hbmFnZXMgY29sb3JzIGluIHRoZSBSR0JBIGNvbG9yIHNwYWNlLiBDYW4gYWxzbyBiZSB1c2VkIGFzIGEgbWl4aW4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yUkdCQSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbG9yIGluIHRoZSBSR0JBIGNvbG9yIHNwYWNlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgaW5pdENvbG9yU3RyIGNvbG9yIHN0cmluZyBpbiB0aGUgZm9ybSBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBhIGNvbG9yIGtleXdvcmQgKGkuZS4gXCJyZWRcIilcbiAgICogQHBhcmFtICB7Li4ub2JqZWN0fSBhcmdzICAgICAgICAgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBtYXkgYmUgcGFzc2VkIHRvIG90aGVyIGluaXRpYWxpemVycy9jb25zdHJ1Y3RvcnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhpcyBjbGFzcyBpcyB1c2VkIGFzIGEgYmFzZSBjbGFzcyBvciBtaXhpblxuICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0Q29sb3JTdHIsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXRpYWxpemVyKGluaXRDb2xvclN0ciwgLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplcyBhIGNvbG9yIGluIHRoZSBSR0JBIGNvbG9yIHNwYWNlIHVzaW5nIGEgY29sb3Igc3RyaW5nXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaW5pdENvbG9yU3RyIGluaXRpYWxpemVyIHN0cmluZyBpbiB0aGUgZm9ybSBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBjb2xvciBrZXl3b3JkXG4gICAqL1xuICBpbml0aWFsaXplcihpbml0Q29sb3JTdHIpIHtcbiAgICB0aGlzLl9jb2xvciA9IDBcbiAgICBpZiAoaW5pdENvbG9yU3RyKSB7XG4gICAgICB0aGlzLnZhbHVlID0gaW5pdENvbG9yU3RyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNldHMgYWxsIHRoZSBjaGFubmVscyBvZiB0aGUgUkdCQSBjb2xvciBnaXZlbiBhIGNvbG9yIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbG9yIGNvbG9yIHN0cmluZyBpbiB0aGUgZm9ybSBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBjb2xvciBrZXl3b3JkXG4gICAqIEByZXR1cm4ge0NvbG9yUkdCQX1cbiAgICovXG4gIHNldCB2YWx1ZShjb2xvcikge1xuICAgIHRoaXMuX2NvbG9yID0gZ2V0UGFja2VkQ29sb3JSR0JBRnJvbVN0cmluZyhjb2xvcilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJnYmEgY29sb3IgYXMgYSBjb2xvciBzdHJpbmcgXCJyZ2JhKClcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJnYmEgY29sb3IgYXMgYSBzdHJpbmdcbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gZ2V0UkdCQVN0cmluZyh0aGlzLl9jb2xvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgUkdCQSBjb2xvciBwYWNrZWQgYXMgYSAzMi1iaXQgaW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gcGFja2VkQ29sb3JcbiAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgKi9cbiAgc2V0IHBhY2tlZFZhbHVlKHBhY2tlZENvbG9yKSB7XG4gICAgdGhpcy5fY29sb3IgPSAwXG4gICAgdGhpcy5fY29sb3IgfD0gcGFja2VkQ29sb3JcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIFJHQkEgY29sb3IgYXMgYSBwYWNrZWQgMzItYml0IGludFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcGFja2VkVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yXG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgUkdCQSBjb2xvciAobW9kaWZpZXMgYWxwaGEgY2hhbm5lbCBvbmx5KVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9wYWNpdHkgWzAsMV1cbiAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgKi9cbiAgc2V0IG9wYWNpdHkob3BhY2l0eSkge1xuICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BhY2l0eSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMC0xXCIpXG4gICAgfVxuXG4gICAgY29uc3QgY3Vyck9wYWNpdHkgPSB0aGlzLl9jb2xvciAmIDB4RkZcbiAgICBjb25zdCBuZXdPcGFjaXR5ID0gcGFja09wYWNpdHkob3BhY2l0eSlcbiAgICBpZiAobmV3T3BhY2l0eSAhPT0gY3Vyck9wYWNpdHkpIHtcbiAgICAgIHRoaXMuX2NvbG9yICY9IDB4RkZGRkZGMDBcbiAgICAgIHRoaXMuX2NvbG9yIHw9IG5ld09wYWNpdHlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9wYWNpdHkgKGFscGhhIGNoYW5uZWwpIG9mIHRoZSBSR0JBIGNvbG9yXG4gICAqIEByZXR1cm4ge251bWJlcn0gWzAsMV1cbiAgICovXG4gIGdldCBvcGFjaXR5KCkge1xuICAgIHJldHVybiBnZXRPcGFjaXR5KHRoaXMuX2NvbG9yKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcGFjaXR5IG9mIHRoZSByZ2JhIGNvbG9yIDwgMVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNUcmFuc3BhcmVudCgpIHtcbiAgICByZXR1cm4gZ2V0T3BhY2l0eSh0aGlzLl9jb2xvcikgPCAxLjBcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29sb3IgUkdCQSBjbGFzcyB0aGF0IGZpcmVzIGV2ZW50cyB3aGVuZXZlciB0aGUgY29sb3JcbiAqIGlzIGNoYW5nZWQgZXh0ZXJuYWxseVxuICogQHBhcmFtICB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgdHlwZSB0byBmaXJlIHdoZW4gY29sb3IgaXMgbW9kaWZpZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29sb3JOYW1lIE5hbWUgb2YgdGhlIGNvbG9yIGF0dHJpYnV0ZS4gVGhpcyBzdHJpbmcgaXMgdXNlZCBpbiB0aGUgZXZlbnQgb2JqZWN0IGZpcmVkXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICBOZXcgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50ZWRDb2xvclJHQkFDbGFzcyhldmVudE5hbWUsIGNvbG9yTmFtZSkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgTmV3IHJnYmEgY29sb3IgY2xhc3MgdGhhdCBmaXJlcyBldmVudHMgd2hlbiBtb2RpZmllZFxuICAgKiBAZXh0ZW5kcyB7Q29sb3JSR0JBfVxuICAgKi9cbiAgcmV0dXJuIGNsYXNzIEV2ZW50ZWRDb2xvclJHQkEgZXh0ZW5kcyBDb2xvclJHQkEge1xuICAgIC8qKlxuICAgICAqIENvbG9yIG1vZGlmaWNhdGlvbiBldmVudFxuICAgICAqIEBldmVudCBFdmVudGVkQ29sb3IjY2hhbmdlZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gICAgICogQHByb3BlcnR5IHt9IHByZXZWYWwgUHJldmlvdXMgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwcmlvciB0byBtb2RpZmljYXRpb25cbiAgICAgKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgZXZlbnRlZCBjb2xvclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaW5pdENvbG9yU3RyIGluaXRpYWwgY29sb3IgYXMgc3RyaW5nXG4gICAgICogQHBhcmFtICB7RXZlbnRIYW5kbGVyfSBldmVudEhhbmRsZXIgRXZlbnQgaGFuZGxlciBpbnN0YW5jZSB1c2VkIHRvIG1hbmFnZSB0aGUgY29sb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmljYXRpb24gZXZlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVyKGluaXRDb2xvclN0ciwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSBldmVudEhhbmRsZXJcbiAgICAgIHN1cGVyLmluaXRpYWxpemVyKGluaXRDb2xvclN0cilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgbW9kaWZpY2F0aW9uIG9mIHRoZSByZ2JhIGNvbG9yLCBhbmQgaWYgbW9kaWZpZWQsIGZpcmVzXG4gICAgICogbW9kaWZpY2F0aW9uIGV2ZW50c1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gbmV3UGFja2VkQ29sb3IgQ29sb3IgZGVmaW5lZCBieSBhIDMyLWJpdCBpbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1BhY2tlZENvbG9yQ2hhbmdlZChuZXdQYWNrZWRDb2xvcikge1xuICAgICAgaWYgKG5ld1BhY2tlZENvbG9yICE9PSB0aGlzLl9jb2xvcikge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fY29sb3JcbiAgICAgICAgY29uc3QgcHJldk9wYWNpdHkgPSBnZXRPcGFjaXR5KHByZXYpXG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBnZXRPcGFjaXR5KG5ld1BhY2tlZENvbG9yKVxuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld1BhY2tlZENvbG9yXG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogY29sb3JOYW1lLFxuICAgICAgICAgIHByZXZWYWw6IGdldFJHQkFTdHJpbmcocHJldiksXG4gICAgICAgICAgY3VyclZhbDogZ2V0UkdCQVN0cmluZyh0aGlzLl9jb2xvcilcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gcHJldk9wYWNpdHkpIHtcbiAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICAgIGF0dHI6IFwib3BhY2l0eVwiLFxuICAgICAgICAgICAgcHJldlZhbDogcHJldk9wYWNpdHksXG4gICAgICAgICAgICBjdXJyVmFsOiBvcGFjaXR5XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHMgYWxsIHRoZSBjaGFubmVscyBvZiB0aGUgUkdCQSBjb2xvciBmcm9tIGEgY29sb3Igc3RyaW5nXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb2xvciBjb2xvciBzdHJpbmcgaW4gdGhlIGZvcm0gXCJyZ2IoKVwiLCBcInJnYmEoKVwiLCBcIiMuLi4uLi5cIiwgb3IgY29sb3Iga2V5d29yZFxuICAgICAqIEBmaXJlcyAgRXZlbnRlZENvbG9yI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAgICovXG4gICAgc2V0IHZhbHVlKGNvbG9yKSB7XG4gICAgICBjb25zdCB0bXBjb2xvciA9IGdldFBhY2tlZENvbG9yUkdCQUZyb21TdHJpbmcoY29sb3IpXG4gICAgICB0aGlzLl9jaGVja1BhY2tlZENvbG9yQ2hhbmdlZCh0bXBjb2xvcilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmdiYSBjb2xvciBhcyBhIGNvbG9yIHN0cmluZyBcInJnYmEoKVwiXG4gICAgICogQHJldHVybiB7c3RyaW5nfSByZ2JhIGNvbG9yIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGdldFJHQkFTdHJpbmcodGhpcy5fY29sb3IpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFJHQkEgY29sb3IgcGFja2VkIGFzIGEgMzItYml0IGludFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGFja2VkQ29sb3JcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRDb2xvciNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgICAqL1xuICAgIHNldCBwYWNrZWRWYWx1ZShwYWNrZWRDb2xvcikge1xuICAgICAgbGV0IHRtcGNvbG9yID0gMFxuICAgICAgdG1wY29sb3IgfD0gcGFja2VkQ29sb3JcbiAgICAgIHRoaXMuX2NoZWNrUGFja2VkQ29sb3JDaGFuZ2VkKHRtcGNvbG9yKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBSR0JBIGNvbG9yIGFzIGEgcGFja2VkIDMyLWJpdCBpbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHBhY2tlZFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgUkdCQSBjb2xvciAobW9kaWZpZXMgYWxwaGEgY2hhbm5lbCBvbmx5KVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gb3BhY2l0eSBbMCwxXVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZENvbG9yI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAgICovXG4gICAgc2V0IG9wYWNpdHkob3BhY2l0eSkge1xuICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wYWNpdHkgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAtMVwiKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyT3BhY2l0eSA9IHRoaXMuX2NvbG9yICYgMHhGRlxuICAgICAgY29uc3QgbmV3T3BhY2l0eSA9IHBhY2tPcGFjaXR5KG9wYWNpdHkpXG4gICAgICBpZiAobmV3T3BhY2l0eSAhPT0gY3Vyck9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5fY29sb3IgJj0gMHhGRkZGRkYwMFxuICAgICAgICB0aGlzLl9jb2xvciB8PSBuZXdPcGFjaXR5XG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJvcGFjaXR5XCIsXG4gICAgICAgICAgcHJldlZhbDogY3Vyck9wYWNpdHkgLyAyNTUuMCxcbiAgICAgICAgICBjdXJyVmFsOiBuZXdPcGFjaXR5IC8gMjU1LjBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBvcGFjaXR5IChhbHBoYSBjaGFubmVsKSBvZiB0aGUgUkdCQSBjb2xvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gWzAsMV1cbiAgICAgKi9cbiAgICBnZXQgb3BhY2l0eSgpIHtcbiAgICAgIHJldHVybiBnZXRPcGFjaXR5KHRoaXMuX2NvbG9yKVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvY29sb3ItcmdiYS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedFillStyleMixin = createEventedFillStyleMixin;\n\nvar _colorRgba = __webpack_require__(17);\n\nvar _colorRgba2 = _interopRequireDefault(_colorRgba);\n\nvar _aggregation = __webpack_require__(8);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {object} FillStyleOptions\n * @property {string} [fillColor=\"black\"] Fill color defined as a string\n * @property {number} [fillOpacity=1] Opacity of the fill color. This supersedes any opacity inherent in fillColor\n */\n\n/**\n * Manages the fill style of a 2d rendering context. Can be used as a mixin or base class\n * @class\n * @mixin\n */\nvar FillStyle = function () {\n  /**\n   * Creates a new fill style object\n   * @param {FillStyleOptions} [opts]\n   * @return {FillStyle}\n   */\n  function FillStyle(opts) {\n    _classCallCheck(this, FillStyle);\n\n    // TODO(croot): support gradients and patterns\n    this.initializer(opts);\n  }\n\n  /**\n   * initializes the fill style object from an options object\n   * @param  {FillStyleOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(FillStyle, [{\n    key: \"_initFillStyleFromOptions\",\n    value: function _initFillStyleFromOptions(opts) {\n      if (opts) {\n        if (typeof opts.fillColor !== \"undefined\") {\n          this.fillColor = opts.fillColor;\n        }\n        if (typeof opts.fillOpacity !== \"undefined\") {\n          this.fillOpacity = opts.fillOpacity;\n        }\n      }\n    }\n\n    /**\n     * Initializer method to initialize a fill style. Used for both initializing\n     * via base-class and mixin hierarchy.\n     * @param  {FillStyleOptions} [opts]\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._fillColor = new _colorRgba2.default(\"black\");\n      this._initFillStyleFromOptions(opts);\n    }\n\n    /**\n     * Sets the fill color\n     * @param  {string} fillColor Color as a string, \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"black\")\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"isFillVisible\",\n\n\n    /**\n     * Returns true if the fill style is visible, i.e. it has an opacity > 0\n     * @return {Boolean}\n     */\n    value: function isFillVisible() {\n      return this._fillColor.opacity > 0;\n    }\n\n    /**\n     * Returns true if the fill style is transparent in any way, i.e. opacity < 1\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isTransparent\",\n    value: function isTransparent() {\n      return this._fillColor.isTransparent();\n    }\n\n    /**\n     * Sets the fill style state of a 2d rendering context\n     * @param {CanvasRenderingContext2D} ctx\n     */\n\n  }, {\n    key: \"setFillCtx\",\n    value: function setFillCtx(ctx) {\n      ctx.fillStyle = this.fillColor;\n    }\n\n    /**\n     * Copies the properties of one fill style to another\n     * @param  {FillStyle} srcStyle FillStyle object to copy from\n     * @param  {FillStyle} dstStyle FillStyle object to copy to\n     */\n\n  }, {\n    key: \"fillColor\",\n    set: function set(fillColor) {\n      this._fillColor.value = fillColor;\n      return this;\n    }\n\n    /**\n     * Gets the fill color of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return this._fillColor.value;\n    }\n\n    /**\n     * Sets the opacity of the fill style\n     * @param  {number} opacity [0,1]\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"fillOpacity\",\n    set: function set(opacity) {\n      this._fillColor.opacity = opacity;\n      return this;\n    }\n\n    /**\n     * Gets the current opacity of the fill style [0,1]\n     * @return {number} Opacity in the range [0,1]\n     */\n    ,\n    get: function get() {\n      return this._fillColor.opacity;\n    }\n\n    /**\n     * Sets the fill color of the style defined as a 32-bit int\n     * @param  {number} packedFillColor Color value as a 32-bit int (i.e. 0xFFFFFFFF)\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"packedFillColor\",\n    set: function set(packedFillColor) {\n      this._fillColor.packedValue = packedFillColor;\n      return this;\n    }\n\n    /**\n     * Gets the current value of the color of the fill style as a 32-bit int\n     * @return {number} i.e. 0xFFFFFFFF\n     */\n    ,\n    get: function get() {\n      return this._fillColor.packedValue;\n    }\n  }], [{\n    key: \"copyFillStyle\",\n    value: function copyFillStyle(srcStyle, dstStyle) {\n      if (typeof srcStyle.packedFillColor === \"undefined\") {\n        if (typeof srcStyle.fillColor !== \"undefined\") {\n          dstStyle.fillColor = srcStyle.fillColor;\n        }\n        if (typeof srcStyle.fillOpacity !== \"undefined\") {\n          dstStyle.fillOpacity = srcStyle.fillOpacity;\n        }\n      } else {\n        dstStyle.packedFillColor = srcStyle.packedFillColor;\n      }\n    }\n\n    /**\n     * Comparison operator between two FillStyle objects. This is primarily\n     * used for sorting to minimize context switching of a 2d renderer\n     * @param  {FillStyle} fillStyleA\n     * @param  {FillStyle} fillStyleB\n     * @return {number}            Returns < 0 if fillStyleA < fillStyleB, > 0 if fillStyleA > fillStyleB, or 0 if they are equal.\n     */\n\n  }, {\n    key: \"compareFillStyle\",\n    value: function compareFillStyle(fillStyleA, fillStyleB) {\n      var valA = fillStyleA.isFillVisible();\n      var valB = fillStyleB.isFillVisible();\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      return fillStyleA.packedFillColor - fillStyleB.packedFillColor;\n    }\n\n    /**\n     * Returns a json object of a FillStyle object\n     * @param  {FillStyle} fillStyleObj\n     * @return {{fillColor: string}}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(fillStyleObj) {\n      return {\n        fillColor: fillStyleObj.fillColor\n      };\n    }\n  }]);\n\n  return FillStyle;\n}();\n\n/**\n * Creates a new fill style class that fires events whenever the style\n * is modified.\n * @param  {string} eventName Event type to fire when fill style is modified\n * @return {function}         New class constructor function\n */\n\n\nexports.default = FillStyle;\nfunction createEventedFillStyleMixin(eventName) {\n  /**\n   * Evented fill color class to handle fill color modifications\n   * @type {ColorRGBA}\n   */\n  var FillColorClass = (0, _colorRgba.createEventedColorRGBAClass)(eventName, \"fillColor\");\n\n  /**\n   * @mixin New evented fill style mixin. Will fire events whenever\n   *        the fill color is modified\n   */\n  return (0, _aggregation2.default)(null, FillStyle, function () {\n    function EventedFillStyle() {\n      _classCallCheck(this, EventedFillStyle);\n    }\n\n    _createClass(EventedFillStyle, [{\n      key: \"initializer\",\n      value: function initializer(opts) {\n        this._fillColor = new FillColorClass(\"red\", this);\n        this._initFillStyleFromOptions(opts);\n      }\n    }]);\n\n    return EventedFillStyle;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9maWxsLXN0eWxlLmpzP2I3MGIiXSwibmFtZXMiOlsiY3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGluIiwiRmlsbFN0eWxlIiwib3B0cyIsImluaXRpYWxpemVyIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJfZmlsbENvbG9yIiwiX2luaXRGaWxsU3R5bGVGcm9tT3B0aW9ucyIsIm9wYWNpdHkiLCJpc1RyYW5zcGFyZW50IiwiY3R4IiwiZmlsbFN0eWxlIiwidmFsdWUiLCJwYWNrZWRGaWxsQ29sb3IiLCJwYWNrZWRWYWx1ZSIsInNyY1N0eWxlIiwiZHN0U3R5bGUiLCJmaWxsU3R5bGVBIiwiZmlsbFN0eWxlQiIsInZhbEEiLCJpc0ZpbGxWaXNpYmxlIiwidmFsQiIsImZpbGxTdHlsZU9iaiIsImV2ZW50TmFtZSIsIkZpbGxDb2xvckNsYXNzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7UUF1TGdCQSwyQixHQUFBQSwyQjs7QUFyTGhCOzs7O0FBQ0E7Ozs7Ozs7O0FBRUE7Ozs7OztBQU1BOzs7OztJQUtxQkMsUztBQUNuQjs7Ozs7QUFLQSxxQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUNoQjtBQUNBLFNBQUtDLFdBQUwsQ0FBaUJELElBQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs4Q0FLMEJBLEksRUFBTTtBQUM5QixVQUFJQSxJQUFKLEVBQVU7QUFDUixZQUFJLE9BQU9BLEtBQUtFLFNBQVosS0FBMEIsV0FBOUIsRUFBMkM7QUFDekMsZUFBS0EsU0FBTCxHQUFpQkYsS0FBS0UsU0FBdEI7QUFDRDtBQUNELFlBQUksT0FBT0YsS0FBS0csV0FBWixLQUE0QixXQUFoQyxFQUE2QztBQUMzQyxlQUFLQSxXQUFMLEdBQW1CSCxLQUFLRyxXQUF4QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Z0NBS1lILEksRUFBTTtBQUNoQixXQUFLSSxVQUFMLEdBQWtCLHdCQUFjLE9BQWQsQ0FBbEI7QUFDQSxXQUFLQyx5QkFBTCxDQUErQkwsSUFBL0I7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQXNEQTs7OztvQ0FJZ0I7QUFDZCxhQUFPLEtBQUtJLFVBQUwsQ0FBZ0JFLE9BQWhCLEdBQTBCLENBQWpDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7b0NBSWdCO0FBQ2QsYUFBTyxLQUFLRixVQUFMLENBQWdCRyxhQUFoQixFQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7K0JBSVdDLEcsRUFBSztBQUNkQSxVQUFJQyxTQUFKLEdBQWdCLEtBQUtQLFNBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3NCQXpFY0EsUyxFQUFXO0FBQ3ZCLFdBQUtFLFVBQUwsQ0FBZ0JNLEtBQWhCLEdBQXdCUixTQUF4QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJZ0I7QUFDZCxhQUFPLEtBQUtFLFVBQUwsQ0FBZ0JNLEtBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3NCQUtnQkosTyxFQUFTO0FBQ3ZCLFdBQUtGLFVBQUwsQ0FBZ0JFLE9BQWhCLEdBQTBCQSxPQUExQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJa0I7QUFDaEIsYUFBTyxLQUFLRixVQUFMLENBQWdCRSxPQUF2QjtBQUNEOztBQUVEOzs7Ozs7OztzQkFLb0JLLGUsRUFBaUI7QUFDbkMsV0FBS1AsVUFBTCxDQUFnQlEsV0FBaEIsR0FBOEJELGVBQTlCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlzQjtBQUNwQixhQUFPLEtBQUtQLFVBQUwsQ0FBZ0JRLFdBQXZCO0FBQ0Q7OztrQ0ErQm9CQyxRLEVBQVVDLFEsRUFBVTtBQUN2QyxVQUFJLE9BQU9ELFNBQVNGLGVBQWhCLEtBQW9DLFdBQXhDLEVBQXFEO0FBQ25ELFlBQUksT0FBT0UsU0FBU1gsU0FBaEIsS0FBOEIsV0FBbEMsRUFBK0M7QUFDN0NZLG1CQUFTWixTQUFULEdBQXFCVyxTQUFTWCxTQUE5QjtBQUNEO0FBQ0QsWUFBSSxPQUFPVyxTQUFTVixXQUFoQixLQUFnQyxXQUFwQyxFQUFpRDtBQUMvQ1csbUJBQVNYLFdBQVQsR0FBdUJVLFNBQVNWLFdBQWhDO0FBQ0Q7QUFDRixPQVBELE1BT087QUFDTFcsaUJBQVNILGVBQVQsR0FBMkJFLFNBQVNGLGVBQXBDO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OztxQ0FPd0JJLFUsRUFBWUMsVSxFQUFZO0FBQzlDLFVBQU1DLE9BQU9GLFdBQVdHLGFBQVgsRUFBYjtBQUNBLFVBQU1DLE9BQU9ILFdBQVdFLGFBQVgsRUFBYjtBQUNBLFVBQUlELFNBQVNFLElBQWIsRUFBbUI7QUFDakIsZUFBT0YsT0FBT0UsSUFBZDtBQUNEO0FBQ0QsYUFBT0osV0FBV0osZUFBWCxHQUE2QkssV0FBV0wsZUFBL0M7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS2NTLFksRUFBYztBQUMxQixhQUFPO0FBQ0xsQixtQkFBV2tCLGFBQWFsQjtBQURuQixPQUFQO0FBR0Q7Ozs7OztBQUdIOzs7Ozs7OztrQkFqS3FCSCxTO0FBdUtkLFNBQVNELDJCQUFULENBQXFDdUIsU0FBckMsRUFBZ0Q7QUFDckQ7Ozs7QUFJQSxNQUFNQyxpQkFBaUIsNENBQTRCRCxTQUE1QixFQUF1QyxXQUF2QyxDQUF2Qjs7QUFFQTs7OztBQUlBLFNBQU8sMkJBQVksSUFBWixFQUFrQnRCLFNBQWxCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxrQ0FDT0MsSUFEUCxFQUNhO0FBQ2hCLGFBQUtJLFVBQUwsR0FBa0IsSUFBSWtCLGNBQUosQ0FBbUIsS0FBbkIsRUFBMEIsSUFBMUIsQ0FBbEI7QUFDQSxhQUFLakIseUJBQUwsQ0FBK0JMLElBQS9CO0FBQ0Q7QUFKSTs7QUFBQTtBQUFBLE1BQVA7QUFNRCIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCBDb2xvclJHQkEsIHtjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3N9IGZyb20gXCIuL2NvbG9yLXJnYmFcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWxsU3R5bGVPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpbGxDb2xvcj1cImJsYWNrXCJdIEZpbGwgY29sb3IgZGVmaW5lZCBhcyBhIHN0cmluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmaWxsT3BhY2l0eT0xXSBPcGFjaXR5IG9mIHRoZSBmaWxsIGNvbG9yLiBUaGlzIHN1cGVyc2VkZXMgYW55IG9wYWNpdHkgaW5oZXJlbnQgaW4gZmlsbENvbG9yXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBmaWxsIHN0eWxlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHQuIENhbiBiZSB1c2VkIGFzIGEgbWl4aW4gb3IgYmFzZSBjbGFzc1xuICogQGNsYXNzXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsbFN0eWxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZmlsbCBzdHlsZSBvYmplY3RcbiAgICogQHBhcmFtIHtGaWxsU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7RmlsbFN0eWxlfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8vIFRPRE8oY3Jvb3QpOiBzdXBwb3J0IGdyYWRpZW50cyBhbmQgcGF0dGVybnNcbiAgICB0aGlzLmluaXRpYWxpemVyKG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogaW5pdGlhbGl6ZXMgdGhlIGZpbGwgc3R5bGUgb2JqZWN0IGZyb20gYW4gb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7RmlsbFN0eWxlT3B0aW9uc30gW29wdHNdXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdEZpbGxTdHlsZUZyb21PcHRpb25zKG9wdHMpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLmZpbGxDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG9wdHMuZmlsbENvbG9yXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMuZmlsbE9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5maWxsT3BhY2l0eSA9IG9wdHMuZmlsbE9wYWNpdHlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgbWV0aG9kIHRvIGluaXRpYWxpemUgYSBmaWxsIHN0eWxlLiBVc2VkIGZvciBib3RoIGluaXRpYWxpemluZ1xuICAgKiB2aWEgYmFzZS1jbGFzcyBhbmQgbWl4aW4gaGllcmFyY2h5LlxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICovXG4gIGluaXRpYWxpemVyKG9wdHMpIHtcbiAgICB0aGlzLl9maWxsQ29sb3IgPSBuZXcgQ29sb3JSR0JBKFwiYmxhY2tcIilcbiAgICB0aGlzLl9pbml0RmlsbFN0eWxlRnJvbU9wdGlvbnMob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxsIGNvbG9yXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsbENvbG9yIENvbG9yIGFzIGEgc3RyaW5nLCBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBhIGNvbG9yIGtleXdvcmQgKGkuZS4gXCJibGFja1wiKVxuICAgKiBAcmV0dXJuIHtGaWxsU3R5bGV9XG4gICAqL1xuICBzZXQgZmlsbENvbG9yKGZpbGxDb2xvcikge1xuICAgIHRoaXMuX2ZpbGxDb2xvci52YWx1ZSA9IGZpbGxDb2xvclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsbCBjb2xvciBvZiB0aGUgc3R5bGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGZpbGxDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgZmlsbCBzdHlsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9wYWNpdHkgWzAsMV1cbiAgICogQHJldHVybiB7RmlsbFN0eWxlfVxuICAgKi9cbiAgc2V0IGZpbGxPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9maWxsQ29sb3Iub3BhY2l0eSA9IG9wYWNpdHlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3BhY2l0eSBvZiB0aGUgZmlsbCBzdHlsZSBbMCwxXVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkgaW4gdGhlIHJhbmdlIFswLDFdXG4gICAqL1xuICBnZXQgZmlsbE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvci5vcGFjaXR5XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsbCBjb2xvciBvZiB0aGUgc3R5bGUgZGVmaW5lZCBhcyBhIDMyLWJpdCBpbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwYWNrZWRGaWxsQ29sb3IgQ29sb3IgdmFsdWUgYXMgYSAzMi1iaXQgaW50IChpLmUuIDB4RkZGRkZGRkYpXG4gICAqIEByZXR1cm4ge0ZpbGxTdHlsZX1cbiAgICovXG4gIHNldCBwYWNrZWRGaWxsQ29sb3IocGFja2VkRmlsbENvbG9yKSB7XG4gICAgdGhpcy5fZmlsbENvbG9yLnBhY2tlZFZhbHVlID0gcGFja2VkRmlsbENvbG9yXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb2xvciBvZiB0aGUgZmlsbCBzdHlsZSBhcyBhIDMyLWJpdCBpbnRcbiAgICogQHJldHVybiB7bnVtYmVyfSBpLmUuIDB4RkZGRkZGRkZcbiAgICovXG4gIGdldCBwYWNrZWRGaWxsQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvci5wYWNrZWRWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsbCBzdHlsZSBpcyB2aXNpYmxlLCBpLmUuIGl0IGhhcyBhbiBvcGFjaXR5ID4gMFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNGaWxsVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLm9wYWNpdHkgPiAwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxsIHN0eWxlIGlzIHRyYW5zcGFyZW50IGluIGFueSB3YXksIGkuZS4gb3BhY2l0eSA8IDFcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVHJhbnNwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvci5pc1RyYW5zcGFyZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxsIHN0eWxlIHN0YXRlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgc2V0RmlsbEN0eChjdHgpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsQ29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHByb3BlcnRpZXMgb2Ygb25lIGZpbGwgc3R5bGUgdG8gYW5vdGhlclxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGV9IHNyY1N0eWxlIEZpbGxTdHlsZSBvYmplY3QgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZX0gZHN0U3R5bGUgRmlsbFN0eWxlIG9iamVjdCB0byBjb3B5IHRvXG4gICAqL1xuICBzdGF0aWMgY29weUZpbGxTdHlsZShzcmNTdHlsZSwgZHN0U3R5bGUpIHtcbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnBhY2tlZEZpbGxDb2xvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5maWxsQ29sb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZHN0U3R5bGUuZmlsbENvbG9yID0gc3JjU3R5bGUuZmlsbENvbG9yXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNyY1N0eWxlLmZpbGxPcGFjaXR5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRzdFN0eWxlLmZpbGxPcGFjaXR5ID0gc3JjU3R5bGUuZmlsbE9wYWNpdHlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHN0U3R5bGUucGFja2VkRmlsbENvbG9yID0gc3JjU3R5bGUucGFja2VkRmlsbENvbG9yXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmlzb24gb3BlcmF0b3IgYmV0d2VlbiB0d28gRmlsbFN0eWxlIG9iamVjdHMuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIHVzZWQgZm9yIHNvcnRpbmcgdG8gbWluaW1pemUgY29udGV4dCBzd2l0Y2hpbmcgb2YgYSAyZCByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGV9IGZpbGxTdHlsZUFcbiAgICogQHBhcmFtICB7RmlsbFN0eWxlfSBmaWxsU3R5bGVCXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICBSZXR1cm5zIDwgMCBpZiBmaWxsU3R5bGVBIDwgZmlsbFN0eWxlQiwgPiAwIGlmIGZpbGxTdHlsZUEgPiBmaWxsU3R5bGVCLCBvciAwIGlmIHRoZXkgYXJlIGVxdWFsLlxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmVGaWxsU3R5bGUoZmlsbFN0eWxlQSwgZmlsbFN0eWxlQikge1xuICAgIGNvbnN0IHZhbEEgPSBmaWxsU3R5bGVBLmlzRmlsbFZpc2libGUoKVxuICAgIGNvbnN0IHZhbEIgPSBmaWxsU3R5bGVCLmlzRmlsbFZpc2libGUoKVxuICAgIGlmICh2YWxBICE9PSB2YWxCKSB7XG4gICAgICByZXR1cm4gdmFsQSAtIHZhbEJcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxTdHlsZUEucGFja2VkRmlsbENvbG9yIC0gZmlsbFN0eWxlQi5wYWNrZWRGaWxsQ29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEganNvbiBvYmplY3Qgb2YgYSBGaWxsU3R5bGUgb2JqZWN0XG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZX0gZmlsbFN0eWxlT2JqXG4gICAqIEByZXR1cm4ge3tmaWxsQ29sb3I6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgdG9KU09OKGZpbGxTdHlsZU9iaikge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsQ29sb3I6IGZpbGxTdHlsZU9iai5maWxsQ29sb3JcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGwgc3R5bGUgY2xhc3MgdGhhdCBmaXJlcyBldmVudHMgd2hlbmV2ZXIgdGhlIHN0eWxlXG4gKiBpcyBtb2RpZmllZC5cbiAqIEBwYXJhbSAge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IHR5cGUgdG8gZmlyZSB3aGVuIGZpbGwgc3R5bGUgaXMgbW9kaWZpZWRcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgIE5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGluKGV2ZW50TmFtZSkge1xuICAvKipcbiAgICogRXZlbnRlZCBmaWxsIGNvbG9yIGNsYXNzIHRvIGhhbmRsZSBmaWxsIGNvbG9yIG1vZGlmaWNhdGlvbnNcbiAgICogQHR5cGUge0NvbG9yUkdCQX1cbiAgICovXG4gIGNvbnN0IEZpbGxDb2xvckNsYXNzID0gY3JlYXRlRXZlbnRlZENvbG9yUkdCQUNsYXNzKGV2ZW50TmFtZSwgXCJmaWxsQ29sb3JcIilcblxuICAvKipcbiAgICogQG1peGluIE5ldyBldmVudGVkIGZpbGwgc3R5bGUgbWl4aW4uIFdpbGwgZmlyZSBldmVudHMgd2hlbmV2ZXJcbiAgICogICAgICAgIHRoZSBmaWxsIGNvbG9yIGlzIG1vZGlmaWVkXG4gICAqL1xuICByZXR1cm4gYWdncmVnYXRpb24obnVsbCwgRmlsbFN0eWxlLCBjbGFzcyBFdmVudGVkRmlsbFN0eWxlIHtcbiAgICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgICB0aGlzLl9maWxsQ29sb3IgPSBuZXcgRmlsbENvbG9yQ2xhc3MoXCJyZWRcIiwgdGhpcylcbiAgICAgIHRoaXMuX2luaXRGaWxsU3R5bGVGcm9tT3B0aW9ucyhvcHRzKVxuICAgIH1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3N0eWxlL2ZpbGwtc3R5bGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedStrokeStyleMixin = createEventedStrokeStyleMixin;\n\nvar _colorRgba = __webpack_require__(17);\n\nvar _colorRgba2 = _interopRequireDefault(_colorRgba);\n\nvar _aggregation = __webpack_require__(8);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {object} StrokeStyleOptions\n * @property {string} [strokeColor = \"black\"]\n * @property {number} [strokeWidth = 0]\n * @property {string} [lineJoin = \"miter\"]\n * @property {string} [lineCap = \"butt\"]\n * @property {number[]} [dashPattern = []]\n * @property {number} [dashOffset = 0]\n */\n\n/**\n * validates a possible stroke width value\n * @param  {number} strokeWidth\n * @throws If validation fails\n * @private\n */\nfunction validateStrokeWidth(strokeWidth) {\n  if (typeof strokeWidth !== \"number\") {\n    throw new Error(\"Stroke width must be a number\");\n  }\n}\n\n/**\n * Enum for line join values\n * @enum {number}\n */\nvar JoinEnum = {\n  MITER: 0,\n  BEVEL: 1,\n  ROUND: 2\n};\n\n/**\n * line join values as strings, the enum values match the index in this string\n * @type {string[]}\n */\nvar lineJoinOpts = [\"miter\", \"bevel\", \"round\"];\n\n/**\n * validates a line join value\n * @param  {string} lineJoin Should be one of [\"miter\", \"bevel\", \"round\"]\n * @throws If validation fails\n * @return {JoinEnum}\n * @private\n */\nfunction validateLineJoin(lineJoin) {\n  var idx = -1;\n  if (typeof lineJoin !== \"string\" || (idx = lineJoinOpts.indexOf(lineJoin.toLowerCase())) < 0) {\n    throw new Error(\"Line join must be a string and must be one of [\" + lineJoinOpts.join(\", \") + \"]\");\n  }\n  return idx;\n}\n\n/**\n * Enum for line cap values\n * @enum {number}\n */\nvar CapEnum = {\n  BUTT: 0,\n  SQUARE: 1,\n  ROUND: 2\n};\n\n/**\n * line cap values as strings, the CapEnum values match the index in this string\n * @type {string[]}\n */\nvar lineCapOpts = [\"butt\", \"square\", \"round\"];\n\n/**\n * validates a line cap value\n * @param  {string} lineCap Should be one of \"butt\", \"square\", \"round\"\n * @throws If validation fails\n * @return {CapEnum}\n * @private\n */\nfunction validateLineCap(lineCap) {\n  var idx = -1;\n  if (typeof lineCap !== \"string\" || (idx = lineCapOpts.indexOf(lineCap.toLowerCase())) < 0) {\n    throw new Error(\"Line cap must be a string and must be one of [\" + lineCapOpts.join(\", \") + \"]\");\n  }\n  return idx;\n}\n\n/**\n * validates a dash pattern value\n * @param  {number[]} dashPattern\n * @throws If validation fails\n * @private\n */\nfunction validateDashPattern(dashPattern) {\n  if (!dashPattern || !Array.isArray(dashPattern) || dashPattern.length % 2 !== 0) {\n    throw new Error(\"The dash pattern must be an array with an even number of numbers (or an empty array)\");\n  }\n}\n\n/**\n * validates a dash offset value\n * @param  {number} dashOffset\n * @throws If validation fails\n * @private\n */\nfunction validateDashOffset(dashOffset) {\n  if (typeof dashOffset !== \"number\") {\n    throw new Error(\"The dash offset must be a number\");\n  }\n}\n\n/**\n * Manages the stroke style of a 2d rendering context. Can be used as a mixin or base class\n * @class\n * @mixin\n */\n\nvar StrokeStyle = function () {\n  function StrokeStyle(opts) {\n    _classCallCheck(this, StrokeStyle);\n\n    this.initializer(opts);\n  }\n\n  /**\n   * initializes the stroke style object from an options object\n   * @param  {StrokeStyleOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(StrokeStyle, [{\n    key: \"_initStrokeStyleFromOptions\",\n    value: function _initStrokeStyleFromOptions(opts) {\n      if (opts) {\n        if (typeof opts.strokeColor !== \"undefined\") {\n          this.strokeColor = opts.strokeColor;\n        }\n        if (typeof opts.strokeOpacity !== \"undefined\") {\n          this.strokeOpacity = opts.strokeOpacity;\n        }\n        if (typeof opts.strokeWidth !== \"undefined\") {\n          this.strokeWidth = opts.strokeWidth;\n        }\n        if (typeof opts.lineMiter !== \"undefined\") {\n          this.lineJoin = opts.lineMiter;\n        }\n        if (typeof opts.lineCap !== \"undefined\") {\n          this.lineCap = opts.lineCap;\n        }\n        if (typeof opts.dashPattern !== \"undefined\") {\n          this.dashPattern = opts.dashPattern;\n        }\n        if (typeof opts.dashOffset !== \"undefined\") {\n          this.dashOffset = opts.dashOffset;\n        }\n      }\n    }\n\n    /**\n     * Initializer method to initialize a stroke style. Used for both initializing\n     * via base-class and mixin hierarchy.\n     * @param  {StrokeStyleOptions} [opts]\n     * @protected\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._strokeColor = new _colorRgba2.default(\"black\");\n      this._strokeWidth = 0;\n      this._lineJoin = JoinEnum.MITER;\n      this._lineCap = CapEnum.BUTT;\n      this._dashPattern = [];\n      this._dashOffset = 0;\n      this._initStrokeStyleFromOptions(opts);\n    }\n\n    /**\n     * Sets the stroke color\n     * @param  {string} strokeColor Color as a string, \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"black\")\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"isStrokeVisible\",\n\n\n    /**\n     * Returns true if the stroke style is visible, i.e. it is not fully transparent\n     * and has a width > 0\n     * @return {Boolean}\n     */\n    value: function isStrokeVisible() {\n      return this._strokeColor.opacity > 0 && this._strokeWidth > 0;\n    }\n\n    /**\n     * Returns true if stroke is partially transparent, i.e. opacity < 1\n     * @return {Boolean} [description]\n     */\n\n  }, {\n    key: \"isTransparent\",\n    value: function isTransparent() {\n      return this._strokeColor.isTransparent();\n    }\n\n    /**\n     * Sets the stroke style state of a 2d rendering context\n     * @param {CanvasRenderingContext2D} ctx\n     */\n\n  }, {\n    key: \"setStrokeCtx\",\n    value: function setStrokeCtx(ctx) {\n      ctx.strokeStyle = this.strokeColor;\n      ctx.lineWidth = this._strokeWidth;\n      ctx.lineJoin = this._lineJoin;\n      ctx.lineCap = this._lineCap;\n      ctx.setLineDash(this._dashPattern);\n      ctx.lineDashOffset = this._dashOffset;\n    }\n\n    /**\n     * Copies the properties of one stroke style to another\n     * @param  {StrokeStyle} srcStyle StrokeStyle object to copy from\n     * @param  {StrokeStyle} dstStyle StrokeStyle object to copy to\n     */\n\n  }, {\n    key: \"strokeColor\",\n    set: function set(strokeColor) {\n      this._strokeColor.value = strokeColor;\n      return this;\n    }\n\n    /**\n     * Gets the stroke color of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.value;\n    }\n\n    /**\n     * Sets the opacity of the stroke style\n     * @param  {number} opacity [0,1]\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"strokeOpacity\",\n    set: function set(opacity) {\n      this._strokeColor.opacity = opacity;\n    }\n\n    /**\n     * Gets the current opacity of the stroke style [0,1]\n     * @return {number} Opacity in the range [0,1]\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.opacity;\n    }\n\n    /**\n     * Sets the stroke color of the style defined as a 32-bit int\n     * @param  {number} packedStrokeColor Color value as a 32-bit int (i.e. 0xFFFFFFFF)\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"packedStrokeColor\",\n    set: function set(packedStrokeColor) {\n      this._strokeColor.packedValue = packedStrokeColor;\n    }\n\n    /**\n     * Gets the current value of the color of the stroke style as a 32-bit int\n     * @return {number} i.e. 0xFFFFFFFF\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.packedValue;\n    }\n\n    /**\n     * Sets the stroke width\n     * @param  {number} strokeWidth\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"strokeWidth\",\n    set: function set(strokeWidth) {\n      validateStrokeWidth(strokeWidth);\n      this._strokeWidth = strokeWidth;\n      return this;\n    }\n\n    /**\n     * Gets the current stroke width\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._strokeWidth;\n    }\n\n    /**\n     * Sets how lines should be joined\n     * @param  {string} lineJoin One of \"miter\", \"round\", or \"bevel\"\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"lineJoin\",\n    set: function set(lineJoin) {\n      var enumVal = validateLineJoin(lineJoin);\n      this._lineJoin = enumVal;\n      return this;\n    }\n\n    /**\n     * Gets the current line join\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return lineJoinOpts[this._lineJoin];\n    }\n\n    /**\n     * Sets how lines should be capped\n     * @param  {string} lineCap One of \"butt\", \"square\", or \"round\"\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"lineCap\",\n    set: function set(lineCap) {\n      var enumVal = validateLineCap(lineCap);\n      this._lineCap = enumVal;\n      return this;\n    }\n\n    /**\n     * Gets the current line cap of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return lineCapOpts[this._lineJoin];\n    }\n\n    /**\n     * Sets the dash pattern of the style\n     * @param  {number[]} dashPattern A list of numbers that specifies distances to alternately\n     *                                draw a line and a gap (in screen units)\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"dashPattern\",\n    set: function set(dashPattern) {\n      validateDashPattern(dashPattern);\n      this._dashPattern = dashPattern.slice();\n      return this;\n    }\n\n    /**\n     * Gets the current dash pattern of the style\n     * @return {number[]}\n     */\n    ,\n    get: function get() {\n      return this._dashPattern.slice();\n    }\n\n    /**\n     * Sets the dash offset of the style\n     * @param  {number} dashOffset\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"dashOffset\",\n    set: function set(dashOffset) {\n      validateDashOffset(dashOffset);\n      this._dashOffset = dashOffset;\n      return this;\n    }\n\n    /**\n     * Gets the current dash offset\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._dashOffset;\n    }\n  }], [{\n    key: \"copyStrokeStyle\",\n    value: function copyStrokeStyle(srcStyle, dstStyle) {\n      if (typeof srcStyle.packedStrokeColor === \"undefined\") {\n        if (typeof srcStyle.strokeColor !== \"undefined\") {\n          dstStyle.strokeColor = srcStyle.strokeColor;\n        }\n        if (typeof srcStyle.strokeOpacity !== \"undefined\") {\n          dstStyle.strokeOpacity = srcStyle.strokeOpacity;\n        }\n      } else {\n        dstStyle.packedStrokeColor = srcStyle.packedStrokeColor;\n      }\n      if (typeof srcStyle.strokeWidth !== \"undefined\") {\n        dstStyle.strokeWidth = srcStyle.strokeWidth;\n      }\n      if (typeof srcStyle.lineJoin !== \"undefined\") {\n        dstStyle.lineJoin = srcStyle.lineJoin;\n      }\n      if (typeof srcStyle.lineCap !== \"undefined\") {\n        dstStyle.lineCap = srcStyle.lineCap;\n      }\n      if (typeof srcStyle.dashPattern !== \"undefined\") {\n        dstStyle.dashPattern = srcStyle.dashPattern;\n      }\n      if (typeof srcStyle.dashOffset !== \"undefined\") {\n        dstStyle.dashOffset = srcStyle.dashOffset;\n      }\n    }\n\n    /**\n     * Comparison operator between two StrokeStyle objects. This is primarily\n     * used for sorting to minimize context switching of a 2d renderer\n     * @param  {StrokeStyle} strokeStyleA\n     * @param  {StrokeStyle} strokeStyleB\n     * @return {number}            Returns < 0 if strokeStyleA < strokeStyleB, > 0 if strokeStyleA > strokeStyleB, or 0 if they are equal.\n     */\n\n  }, {\n    key: \"compareStrokeStyle\",\n    value: function compareStrokeStyle(strokeStyleA, strokeStyleB) {\n      var valA = strokeStyleA.isStrokeVisible();\n      var valB = strokeStyleB.isStrokeVisible();\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA.packedStrokeColor;\n      valB = strokeStyleB.packedStrokeColor;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA.strokeWidth;\n      valB = strokeStyleB.strokeWidth;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._lineJoin;\n      valB = strokeStyleB._lineJoin;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._lineCap;\n      valB = strokeStyleB._lineCap;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._dashPattern;\n      valB = strokeStyleB._dashPattern;\n      if (valA.length === valB.length && valA.length > 0) {\n        for (var i = 0; i < valA.length; i += 1) {\n          if (valA[i] !== valB[i]) {\n            return valA[i] - valB[i];\n          }\n        }\n        return strokeStyleA.dashOffset - strokeStyleB.dashOffset;\n      }\n      return valA.length - valB.length;\n    }\n\n    /**\n     * Returns a json object of a StrokeStyle object\n     * @param  {StrokeStyle} strokeStyleObj\n     * @return {{strokeColor: string,\n     *           strokeWidth: number,\n     *           lineJoin: string,\n     *           lineCap: string,\n     *           dashPattern: number[],\n     *           dashOffset: number\n     *          }}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(strokeStyleObj) {\n      return {\n        strokeColor: strokeStyleObj.strokeColor,\n        strokeWidth: strokeStyleObj.strokeWidth,\n        lineJoin: strokeStyleObj.lineJoin,\n        lineCap: strokeStyleObj.lineCap,\n        dashPattern: strokeStyleObj.dashPattern,\n        dashOffset: strokeStyleObj.dashOffset\n      };\n    }\n  }]);\n\n  return StrokeStyle;\n}();\n\n/**\n * Creates a new stroke style class that fires events whenever the style\n * is modified.\n * @param  {string} eventName Event type to fire when stroke style is modified\n * @return {function}         New class constructor function\n */\n\n\nexports.default = StrokeStyle;\nfunction createEventedStrokeStyleMixin(eventName) {\n  /**\n   * Evented stroke color class to handle color modification events\n   * @type {ColorRGBA}\n   */\n  var StrokeColorClass = (0, _colorRgba.createEventedColorRGBAClass)(eventName, \"strokeColor\");\n\n  /**\n   * Stroke style modification event\n   * @event EventedStrokeStyle#changed\n   * @type {object}\n   * @property {string} attr Name of the attribute modified\n   * @property {} prevVal Previous value of the attribute prior to modification\n   * @property {} currVal Value of the attribute post modification\n   */\n\n  /**\n   * @mixin New evented stroke style mixin. Will fire events whenever\n   *        the stroke is modified\n   */\n  return (0, _aggregation2.default)(null, StrokeStyle, function () {\n    function EventedStrokeStyle() {\n      _classCallCheck(this, EventedStrokeStyle);\n    }\n\n    _createClass(EventedStrokeStyle, [{\n      key: \"initializer\",\n\n      /**\n       * Initializer method to initialize an evented stroke style.\n       * @param  {StrokeStyleOptions} [opts]\n       * @protected\n       */\n      value: function initializer(opts) {\n        this._strokeColor = new StrokeColorClass(\"black\", this);\n        this._strokeWidth = 0;\n        this._lineJoin = JoinEnum.MITER;\n        this._lineCap = CapEnum.BUTT;\n        this._dashPattern = [];\n        this._dashOffset = 0;\n        this._initStrokeStyleFromOptions(opts);\n      }\n\n      /**\n       * Sets the stroke width\n       * @param  {number}\n       * @fires  EventedStrokeStyle#changed\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"strokeWidth\",\n      set: function set(strokeWidth) {\n        validateStrokeWidth(strokeWidth);\n        if (strokeWidth !== this._strokeWidth) {\n          var prev = this._strokeWidth;\n          this._strokeWidth = strokeWidth;\n          this.fire(eventName, {\n            attr: \"strokeWidth\",\n            prevVal: prev,\n            curral: this._strokeWidth\n          });\n        }\n\n        return this;\n      }\n\n      /**\n       * Gets the current stroke width\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._strokeWidth;\n      }\n\n      /**\n       * Sets the line join\n       * @param  {string} lineJoin\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"lineJoin\",\n      set: function set(lineJoin) {\n        var enumVal = validateLineJoin(lineJoin);\n\n        if (enumVal !== this._lineJoin) {\n          var prev = this._lineJoin;\n          this._lineJoin = enumVal;\n          this.fire(eventName, {\n            attr: \"lineJoin\",\n            prevVal: prev,\n            curral: this._lineJoin\n          });\n        }\n\n        return this;\n      }\n\n      /**\n       * Gets the current line join\n       * @return {string}\n       */\n      ,\n      get: function get() {\n        return lineJoinOpts[this._lineJoin];\n      }\n\n      /**\n       * Sets the line cap\n       * @param  {string} lineCap\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"lineCap\",\n      set: function set(lineCap) {\n        var enumVal = validateLineCap(lineCap);\n        if (enumVal !== this._lineCap) {\n          var prev = this._lineCap;\n          this._lineCap = enumVal;\n          this.fire(eventName, {\n            attr: \"lineCap\",\n            prevVal: prev,\n            curral: this._lineCap\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the line cap\n       * @return {string}\n       */\n      ,\n      get: function get() {\n        return lineCapOpts[this._lineCap];\n      }\n\n      /**\n       * Sets the dash pattern\n       * @param  {number[]} dashPattern\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"dashPattern\",\n      set: function set(dashPattern) {\n        validateDashPattern(dashPattern);\n        var diff = false;\n        if (dashPattern.length === this._dashPattern.length) {\n          for (var i = 0; i < dashPattern.length; i += 1) {\n            if (dashPattern[i] !== this._dashPattern[i]) {\n              diff = true;\n              break;\n            }\n          }\n        } else {\n          diff = true;\n        }\n\n        if (diff) {\n          var prev = this._dashPattern;\n          this._dashPattern = dashPattern.slice();\n          this.fire(eventName, {\n            attr: \"dashPattern\",\n            prevVal: prev,\n            curral: this._dashPattern.slice()\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current dash pattern\n       * @return {number[]}\n       */\n      ,\n      get: function get() {\n        return this._dashPattern.slice();\n      }\n\n      /**\n       * Sets the current dash offset\n       * @param  {number} dashOffset\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"dashOffset\",\n      set: function set(dashOffset) {\n        validateDashOffset(dashOffset);\n\n        if (dashOffset !== this._dashOffset) {\n          var prev = this._dashOffset;\n          this._dashOffset = dashOffset;\n\n          if (this._dashPattern.length) {\n            // only fire if dashing is activated\n            this.fire(eventName, {\n              attr: \"dashOffset\",\n              prevVal: prev,\n              curral: this._dashOffset\n            });\n          }\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current dash offset\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._dashOffset;\n      }\n    }]);\n\n    return EventedStrokeStyle;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9zdHJva2Utc3R5bGUuanM/MzNkZiJdLCJuYW1lcyI6WyJjcmVhdGVFdmVudGVkU3Ryb2tlU3R5bGVNaXhpbiIsInZhbGlkYXRlU3Ryb2tlV2lkdGgiLCJzdHJva2VXaWR0aCIsIkVycm9yIiwiSm9pbkVudW0iLCJNSVRFUiIsIkJFVkVMIiwiUk9VTkQiLCJsaW5lSm9pbk9wdHMiLCJ2YWxpZGF0ZUxpbmVKb2luIiwibGluZUpvaW4iLCJpZHgiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJqb2luIiwiQ2FwRW51bSIsIkJVVFQiLCJTUVVBUkUiLCJsaW5lQ2FwT3B0cyIsInZhbGlkYXRlTGluZUNhcCIsImxpbmVDYXAiLCJ2YWxpZGF0ZURhc2hQYXR0ZXJuIiwiZGFzaFBhdHRlcm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ2YWxpZGF0ZURhc2hPZmZzZXQiLCJkYXNoT2Zmc2V0IiwiU3Ryb2tlU3R5bGUiLCJvcHRzIiwiaW5pdGlhbGl6ZXIiLCJzdHJva2VDb2xvciIsInN0cm9rZU9wYWNpdHkiLCJsaW5lTWl0ZXIiLCJfc3Ryb2tlQ29sb3IiLCJfc3Ryb2tlV2lkdGgiLCJfbGluZUpvaW4iLCJfbGluZUNhcCIsIl9kYXNoUGF0dGVybiIsIl9kYXNoT2Zmc2V0IiwiX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zIiwib3BhY2l0eSIsImlzVHJhbnNwYXJlbnQiLCJjdHgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJ2YWx1ZSIsInBhY2tlZFN0cm9rZUNvbG9yIiwicGFja2VkVmFsdWUiLCJlbnVtVmFsIiwic2xpY2UiLCJzcmNTdHlsZSIsImRzdFN0eWxlIiwic3Ryb2tlU3R5bGVBIiwic3Ryb2tlU3R5bGVCIiwidmFsQSIsImlzU3Ryb2tlVmlzaWJsZSIsInZhbEIiLCJpIiwic3Ryb2tlU3R5bGVPYmoiLCJldmVudE5hbWUiLCJTdHJva2VDb2xv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T087QUFDTEEsaUJBQU8sSUFBUDtBQUNEOztBQUVELFlBQUlBLElBQUosRUFBVTtBQUNSLGNBQU1MLE9BQU8sS0FBSzFCLFlBQWxCO0FBQ0EsZUFBS0EsWUFBTCxHQUFvQmhCLFlBQVk4QixLQUFaLEVBQXBCO0FBQ0EsZUFBS2EsSUFBTCxDQUFVSCxTQUFWLEVBQXFCO0FBQ25CSSxrQkFBTSxhQURhO0FBRW5CQyxxQkFBU0gsSUFGVTtBQUduQkksb0JBQVEsS0FBSzlCLFlBQUwsQ0FBa0JjLEtBQWxCO0FBSFcsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBdklLO0FBQUEsMEJBMklhO0FBQ2hCLGVBQU8sS0FBS2QsWUFBTCxDQUFrQmMsS0FBbEIsRUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBL0lLO0FBQUE7QUFBQSx3QkFxSlV6QixVQXJKVixFQXFKc0I7QUFDekJELDJCQUFtQkMsVUFBbkI7O0FBRUEsWUFBSUEsZUFBZSxLQUFLWSxXQUF4QixFQUFxQztBQUNuQyxjQUFNeUIsT0FBTyxLQUFLekIsV0FBbEI7QUFDQSxlQUFLQSxXQUFMLEdBQW1CWixVQUFuQjs7QUFFQSxjQUFJLEtBQUtXLFlBQUwsQ0FBa0JiLE1BQXRCLEVBQThCO0FBQzVCO0FBQ0EsaUJBQUt3QyxJQUFMLENBQVVILFNBQVYsRUFBcUI7QUFDbkJJLG9CQUFNLFlBRGE7QUFFbkJDLHVCQUFTSCxJQUZVO0FBR25CSSxzQkFBUSxLQUFLN0I7QUFITSxhQUFyQjtBQUtEO0FBQ0Y7QUFDRCxlQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXhLSztBQUFBLDBCQTRLWTtBQUNmLGVBQU8sS0FBS0EsV0FBWjtBQUNEO0FBOUtJOztBQUFBO0FBQUEsTUFBUDtBQWdMRCIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCBDb2xvclJHQkEsIHtjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3N9IGZyb20gXCIuL2NvbG9yLXJnYmFcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdHJva2VTdHlsZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3Ryb2tlQ29sb3IgPSBcImJsYWNrXCJdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cm9rZVdpZHRoID0gMF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGluZUpvaW4gPSBcIm1pdGVyXCJdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXAgPSBcImJ1dHRcIl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFtkYXNoUGF0dGVybiA9IFtdXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkYXNoT2Zmc2V0ID0gMF1cbiAqL1xuXG4vKipcbiAqIHZhbGlkYXRlcyBhIHBvc3NpYmxlIHN0cm9rZSB3aWR0aCB2YWx1ZVxuICogQHBhcmFtICB7bnVtYmVyfSBzdHJva2VXaWR0aFxuICogQHRocm93cyBJZiB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSB7XG4gIGlmICh0eXBlb2Ygc3Ryb2tlV2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJva2Ugd2lkdGggbXVzdCBiZSBhIG51bWJlclwiKVxuICB9XG59XG5cbi8qKlxuICogRW51bSBmb3IgbGluZSBqb2luIHZhbHVlc1xuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgSm9pbkVudW0gPSB7XG4gIE1JVEVSOiAwLFxuICBCRVZFTDogMSxcbiAgUk9VTkQ6IDJcbn1cblxuLyoqXG4gKiBsaW5lIGpvaW4gdmFsdWVzIGFzIHN0cmluZ3MsIHRoZSBlbnVtIHZhbHVlcyBtYXRjaCB0aGUgaW5kZXggaW4gdGhpcyBzdHJpbmdcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuY29uc3QgbGluZUpvaW5PcHRzID0gW1wibWl0ZXJcIiwgXCJiZXZlbFwiLCBcInJvdW5kXCJdXG5cbi8qKlxuICogdmFsaWRhdGVzIGEgbGluZSBqb2luIHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVKb2luIFNob3VsZCBiZSBvbmUgb2YgW1wibWl0ZXJcIiwgXCJiZXZlbFwiLCBcInJvdW5kXCJdXG4gKiBAdGhyb3dzIElmIHZhbGlkYXRpb24gZmFpbHNcbiAqIEByZXR1cm4ge0pvaW5FbnVtfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMaW5lSm9pbihsaW5lSm9pbikge1xuICBsZXQgaWR4ID0gLTFcbiAgaWYgKHR5cGVvZiBsaW5lSm9pbiAhPT0gXCJzdHJpbmdcIiB8fCAoaWR4ID0gbGluZUpvaW5PcHRzLmluZGV4T2YobGluZUpvaW4udG9Mb3dlckNhc2UoKSkpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGluZSBqb2luIG11c3QgYmUgYSBzdHJpbmcgYW5kIG11c3QgYmUgb25lIG9mIFske2xpbmVKb2luT3B0cy5qb2luKFwiLCBcIil9XWApXG4gIH1cbiAgcmV0dXJuIGlkeFxufVxuXG4vKipcbiAqIEVudW0gZm9yIGxpbmUgY2FwIHZhbHVlc1xuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ2FwRW51bSA9IHtcbiAgQlVUVDogMCxcbiAgU1FVQVJFOiAxLFxuICBST1VORDogMlxufVxuXG4vKipcbiAqIGxpbmUgY2FwIHZhbHVlcyBhcyBzdHJpbmdzLCB0aGUgQ2FwRW51bSB2YWx1ZXMgbWF0Y2ggdGhlIGluZGV4IGluIHRoaXMgc3RyaW5nXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IGxpbmVDYXBPcHRzID0gW1wiYnV0dFwiLCBcInNxdWFyZVwiLCBcInJvdW5kXCJdXG5cbi8qKlxuICogdmFsaWRhdGVzIGEgbGluZSBjYXAgdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30gbGluZUNhcCBTaG91bGQgYmUgb25lIG9mIFwiYnV0dFwiLCBcInNxdWFyZVwiLCBcInJvdW5kXCJcbiAqIEB0aHJvd3MgSWYgdmFsaWRhdGlvbiBmYWlsc1xuICogQHJldHVybiB7Q2FwRW51bX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGluZUNhcChsaW5lQ2FwKSB7XG4gIGxldCBpZHggPSAtMVxuICBpZiAodHlwZW9mIGxpbmVDYXAgIT09IFwic3RyaW5nXCIgfHwgKGlkeCA9IGxpbmVDYXBPcHRzLmluZGV4T2YobGluZUNhcC50b0xvd2VyQ2FzZSgpKSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lIGNhcCBtdXN0IGJlIGEgc3RyaW5nIGFuZCBtdXN0IGJlIG9uZSBvZiBbJHtsaW5lQ2FwT3B0cy5qb2luKFwiLCBcIil9XWApXG4gIH1cbiAgcmV0dXJuIGlkeFxufVxuXG4vKipcbiAqIHZhbGlkYXRlcyBhIGRhc2ggcGF0dGVybiB2YWx1ZVxuICogQHBhcmFtICB7bnVtYmVyW119IGRhc2hQYXR0ZXJuXG4gKiBAdGhyb3dzIElmIHZhbGlkYXRpb24gZmFpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pIHtcbiAgaWYgKCFkYXNoUGF0dGVybiB8fCAhQXJyYXkuaXNBcnJheShkYXNoUGF0dGVybikgfHwgZGFzaFBhdHRlcm4ubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXNoIHBhdHRlcm4gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGFuIGV2ZW4gbnVtYmVyIG9mIG51bWJlcnMgKG9yIGFuIGVtcHR5IGFycmF5KVwiKVxuICB9XG59XG5cbi8qKlxuICogdmFsaWRhdGVzIGEgZGFzaCBvZmZzZXQgdmFsdWVcbiAqIEBwYXJhbSAge251bWJlcn0gZGFzaE9mZnNldFxuICogQHRocm93cyBJZiB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURhc2hPZmZzZXQoZGFzaE9mZnNldCkge1xuICBpZiAodHlwZW9mIGRhc2hPZmZzZXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGFzaCBvZmZzZXQgbXVzdCBiZSBhIG51bWJlclwiKVxuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgc3Ryb2tlIHN0eWxlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHQuIENhbiBiZSB1c2VkIGFzIGEgbWl4aW4gb3IgYmFzZSBjbGFzc1xuICogQGNsYXNzXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Ryb2tlU3R5bGUge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIGluaXRpYWxpemVzIHRoZSBzdHJva2Ugc3R5bGUgb2JqZWN0IGZyb20gYW4gb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7U3Ryb2tlU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0U3Ryb2tlU3R5bGVGcm9tT3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5zdHJva2VDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0cy5zdHJva2VDb2xvclxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzLnN0cm9rZU9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gb3B0cy5zdHJva2VPcGFjaXR5XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMuc3Ryb2tlV2lkdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGhcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5saW5lTWl0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5saW5lSm9pbiA9IG9wdHMubGluZU1pdGVyXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMubGluZUNhcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmxpbmVDYXAgPSBvcHRzLmxpbmVDYXBcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5kYXNoUGF0dGVybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmRhc2hQYXR0ZXJuID0gb3B0cy5kYXNoUGF0dGVyblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzLmRhc2hPZmZzZXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5kYXNoT2Zmc2V0ID0gb3B0cy5kYXNoT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIG1ldGhvZCB0byBpbml0aWFsaXplIGEgc3Ryb2tlIHN0eWxlLiBVc2VkIGZvciBib3RoIGluaXRpYWxpemluZ1xuICAgKiB2aWEgYmFzZS1jbGFzcyBhbmQgbWl4aW4gaGllcmFyY2h5LlxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZU9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSBuZXcgQ29sb3JSR0JBKFwiYmxhY2tcIilcbiAgICB0aGlzLl9zdHJva2VXaWR0aCA9IDBcbiAgICB0aGlzLl9saW5lSm9pbiA9IEpvaW5FbnVtLk1JVEVSXG4gICAgdGhpcy5fbGluZUNhcCA9IENhcEVudW0uQlVUVFxuICAgIHRoaXMuX2Rhc2hQYXR0ZXJuID0gW11cbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMFxuICAgIHRoaXMuX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zKG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3Ryb2tlIGNvbG9yXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc3Ryb2tlQ29sb3IgQ29sb3IgYXMgYSBzdHJpbmcsIFwicmdiKClcIiwgXCJyZ2JhKClcIiwgXCIjLi4uLi4uXCIsIG9yIGEgY29sb3Iga2V5d29yZCAoaS5lLiBcImJsYWNrXCIpXG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IHN0cm9rZUNvbG9yKHN0cm9rZUNvbG9yKSB7XG4gICAgdGhpcy5fc3Ryb2tlQ29sb3IudmFsdWUgPSBzdHJva2VDb2xvclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBzdHlsZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgc3Ryb2tlQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZUNvbG9yLnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlIHN0eWxlXG4gICAqIEBwYXJhbSAge251bWJlcn0gb3BhY2l0eSBbMCwxXVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBzdHJva2VPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9zdHJva2VDb2xvci5vcGFjaXR5ID0gb3BhY2l0eVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlIHN0eWxlIFswLDFdXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3BhY2l0eSBpbiB0aGUgcmFuZ2UgWzAsMV1cbiAgICovXG4gIGdldCBzdHJva2VPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5vcGFjaXR5XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBzdHlsZSBkZWZpbmVkIGFzIGEgMzItYml0IGludFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZFN0cm9rZUNvbG9yIENvbG9yIHZhbHVlIGFzIGEgMzItYml0IGludCAoaS5lLiAweEZGRkZGRkZGKVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBwYWNrZWRTdHJva2VDb2xvcihwYWNrZWRTdHJva2VDb2xvcikge1xuICAgIHRoaXMuX3N0cm9rZUNvbG9yLnBhY2tlZFZhbHVlID0gcGFja2VkU3Ryb2tlQ29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb2xvciBvZiB0aGUgc3Ryb2tlIHN0eWxlIGFzIGEgMzItYml0IGludFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGkuZS4gMHhGRkZGRkZGRlxuICAgKi9cbiAgZ2V0IHBhY2tlZFN0cm9rZUNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5wYWNrZWRWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cm9rZSB3aWR0aFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0cm9rZVdpZHRoXG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IHN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSB7XG4gICAgdmFsaWRhdGVTdHJva2VXaWR0aChzdHJva2VXaWR0aClcbiAgICB0aGlzLl9zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0cm9rZSB3aWR0aFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3Ryb2tlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZVdpZHRoXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBob3cgbGluZXMgc2hvdWxkIGJlIGpvaW5lZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVKb2luIE9uZSBvZiBcIm1pdGVyXCIsIFwicm91bmRcIiwgb3IgXCJiZXZlbFwiXG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgY29uc3QgZW51bVZhbCA9IHZhbGlkYXRlTGluZUpvaW4obGluZUpvaW4pXG4gICAgdGhpcy5fbGluZUpvaW4gPSBlbnVtVmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpbmUgam9pblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIGxpbmVKb2luT3B0c1t0aGlzLl9saW5lSm9pbl1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGhvdyBsaW5lcyBzaG91bGQgYmUgY2FwcGVkXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGluZUNhcCBPbmUgb2YgXCJidXR0XCIsIFwic3F1YXJlXCIsIG9yIFwicm91bmRcIlxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBsaW5lQ2FwKGxpbmVDYXApIHtcbiAgICBjb25zdCBlbnVtVmFsID0gdmFsaWRhdGVMaW5lQ2FwKGxpbmVDYXApXG4gICAgdGhpcy5fbGluZUNhcCA9IGVudW1WYWxcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgbGluZSBjYXAgb2YgdGhlIHN0eWxlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBsaW5lQ2FwKCkge1xuICAgIHJldHVybiBsaW5lQ2FwT3B0c1t0aGlzLl9saW5lSm9pbl1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkYXNoIHBhdHRlcm4gb2YgdGhlIHN0eWxlXG4gICAqIEBwYXJhbSAge251bWJlcltdfSBkYXNoUGF0dGVybiBBIGxpc3Qgb2YgbnVtYmVycyB0aGF0IHNwZWNpZmllcyBkaXN0YW5jZXMgdG8gYWx0ZXJuYXRlbHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXcgYSBsaW5lIGFuZCBhIGdhcCAoaW4gc2NyZWVuIHVuaXRzKVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBkYXNoUGF0dGVybihkYXNoUGF0dGVybikge1xuICAgIHZhbGlkYXRlRGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pXG4gICAgdGhpcy5fZGFzaFBhdHRlcm4gPSBkYXNoUGF0dGVybi5zbGljZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGRhc2ggcGF0dGVybiBvZiB0aGUgc3R5bGVcbiAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAqL1xuICBnZXQgZGFzaFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rhc2hQYXR0ZXJuLnNsaWNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkYXNoIG9mZnNldCBvZiB0aGUgc3R5bGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkYXNoT2Zmc2V0XG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IGRhc2hPZmZzZXQoZGFzaE9mZnNldCkge1xuICAgIHZhbGlkYXRlRGFzaE9mZnNldChkYXNoT2Zmc2V0KVxuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGRhc2ggb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBkYXNoT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXNoT2Zmc2V0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJva2Ugc3R5bGUgaXMgdmlzaWJsZSwgaS5lLiBpdCBpcyBub3QgZnVsbHkgdHJhbnNwYXJlbnRcbiAgICogYW5kIGhhcyBhIHdpZHRoID4gMFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTdHJva2VWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5vcGFjaXR5ID4gMCAmJiB0aGlzLl9zdHJva2VXaWR0aCA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgc3Ryb2tlIGlzIHBhcnRpYWxseSB0cmFuc3BhcmVudCwgaS5lLiBvcGFjaXR5IDwgMVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBpc1RyYW5zcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5pc1RyYW5zcGFyZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJva2Ugc3R5bGUgc3RhdGUgb2YgYSAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBzZXRTdHJva2VDdHgoY3R4KSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2VDb2xvclxuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9zdHJva2VXaWR0aFxuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuX2xpbmVKb2luXG4gICAgY3R4LmxpbmVDYXAgPSB0aGlzLl9saW5lQ2FwXG4gICAgY3R4LnNldExpbmVEYXNoKHRoaXMuX2Rhc2hQYXR0ZXJuKVxuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHByb3BlcnRpZXMgb2Ygb25lIHN0cm9rZSBzdHlsZSB0byBhbm90aGVyXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBzcmNTdHlsZSBTdHJva2VTdHlsZSBvYmplY3QgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBkc3RTdHlsZSBTdHJva2VTdHlsZSBvYmplY3QgdG8gY29weSB0b1xuICAgKi9cbiAgc3RhdGljIGNvcHlTdHJva2VTdHlsZShzcmNTdHlsZSwgZHN0U3R5bGUpIHtcbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnBhY2tlZFN0cm9rZUNvbG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnN0cm9rZUNvbG9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRzdFN0eWxlLnN0cm9rZUNvbG9yID0gc3JjU3R5bGUuc3Ryb2tlQ29sb3JcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuc3Ryb2tlT3BhY2l0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkc3RTdHlsZS5zdHJva2VPcGFjaXR5ID0gc3JjU3R5bGUuc3Ryb2tlT3BhY2l0eVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkc3RTdHlsZS5wYWNrZWRTdHJva2VDb2xvciA9IHNyY1N0eWxlLnBhY2tlZFN0cm9rZUNvbG9yXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuc3Ryb2tlV2lkdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLnN0cm9rZVdpZHRoID0gc3JjU3R5bGUuc3Ryb2tlV2lkdGhcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5saW5lSm9pbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZHN0U3R5bGUubGluZUpvaW4gPSBzcmNTdHlsZS5saW5lSm9pblxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLmxpbmVDYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLmxpbmVDYXAgPSBzcmNTdHlsZS5saW5lQ2FwXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuZGFzaFBhdHRlcm4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLmRhc2hQYXR0ZXJuID0gc3JjU3R5bGUuZGFzaFBhdHRlcm5cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5kYXNoT2Zmc2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkc3RTdHlsZS5kYXNoT2Zmc2V0ID0gc3JjU3R5bGUuZGFzaE9mZnNldFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJpc29uIG9wZXJhdG9yIGJldHdlZW4gdHdvIFN0cm9rZVN0eWxlIG9iamVjdHMuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIHVzZWQgZm9yIHNvcnRpbmcgdG8gbWluaW1pemUgY29udGV4dCBzd2l0Y2hpbmcgb2YgYSAyZCByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gc3Ryb2tlU3R5bGVBXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBzdHJva2VTdHlsZUJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgIFJldHVybnMgPCAwIGlmIHN0cm9rZVN0eWxlQSA8IHN0cm9rZVN0eWxlQiwgPiAwIGlmIHN0cm9rZVN0eWxlQSA+IHN0cm9rZVN0eWxlQiwgb3IgMCBpZiB0aGV5IGFyZSBlcXVhbC5cbiAgICovXG4gIHN0YXRpYyBjb21wYXJlU3Ryb2tlU3R5bGUoc3Ryb2tlU3R5bGVBLCBzdHJva2VTdHlsZUIpIHtcbiAgICBsZXQgdmFsQSA9IHN0cm9rZVN0eWxlQS5pc1N0cm9rZVZpc2libGUoKVxuICAgIGxldCB2YWxCID0gc3Ryb2tlU3R5bGVCLmlzU3Ryb2tlVmlzaWJsZSgpXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICB2YWxBID0gc3Ryb2tlU3R5bGVBLnBhY2tlZFN0cm9rZUNvbG9yXG4gICAgdmFsQiA9IHN0cm9rZVN0eWxlQi5wYWNrZWRTdHJva2VDb2xvclxuICAgIGlmICh2YWxBICE9PSB2YWxCKSB7XG4gICAgICByZXR1cm4gdmFsQSAtIHZhbEJcbiAgICB9XG4gICAgdmFsQSA9IHN0cm9rZVN0eWxlQS5zdHJva2VXaWR0aFxuICAgIHZhbEIgPSBzdHJva2VTdHlsZUIuc3Ryb2tlV2lkdGhcbiAgICBpZiAodmFsQSAhPT0gdmFsQikge1xuICAgICAgcmV0dXJuIHZhbEEgLSB2YWxCXG4gICAgfVxuICAgIHZhbEEgPSBzdHJva2VTdHlsZUEuX2xpbmVKb2luXG4gICAgdmFsQiA9IHN0cm9rZVN0eWxlQi5fbGluZUpvaW5cbiAgICBpZiAodmFsQSAhPT0gdmFsQikge1xuICAgICAgcmV0dXJuIHZhbEEgLSB2YWxCXG4gICAgfVxuICAgIHZhbEEgPSBzdHJva2VTdHlsZUEuX2xpbmVDYXBcbiAgICB2YWxCID0gc3Ryb2tlU3R5bGVCLl9saW5lQ2FwXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICB2YWxBID0gc3Ryb2tlU3R5bGVBLl9kYXNoUGF0dGVyblxuICAgIHZhbEIgPSBzdHJva2VTdHlsZUIuX2Rhc2hQYXR0ZXJuXG4gICAgaWYgKHZhbEEubGVuZ3RoID09PSB2YWxCLmxlbmd0aCAmJiB2YWxBLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsQS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodmFsQVtpXSAhPT0gdmFsQltpXSkge1xuICAgICAgICAgIHJldHVybiB2YWxBW2ldIC0gdmFsQltpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Ryb2tlU3R5bGVBLmRhc2hPZmZzZXQgLSBzdHJva2VTdHlsZUIuZGFzaE9mZnNldFxuICAgIH1cbiAgICByZXR1cm4gdmFsQS5sZW5ndGggLSB2YWxCLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBqc29uIG9iamVjdCBvZiBhIFN0cm9rZVN0eWxlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gc3Ryb2tlU3R5bGVPYmpcbiAgICogQHJldHVybiB7e3N0cm9rZUNvbG9yOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBzdHJva2VXaWR0aDogbnVtYmVyLFxuICAgKiAgICAgICAgICAgbGluZUpvaW46IHN0cmluZyxcbiAgICogICAgICAgICAgIGxpbmVDYXA6IHN0cmluZyxcbiAgICogICAgICAgICAgIGRhc2hQYXR0ZXJuOiBudW1iZXJbXSxcbiAgICogICAgICAgICAgIGRhc2hPZmZzZXQ6IG51bWJlclxuICAgKiAgICAgICAgICB9fVxuICAgKi9cbiAgc3RhdGljIHRvSlNPTihzdHJva2VTdHlsZU9iaikge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2VDb2xvcjogc3Ryb2tlU3R5bGVPYmouc3Ryb2tlQ29sb3IsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlU3R5bGVPYmouc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lSm9pbjogc3Ryb2tlU3R5bGVPYmoubGluZUpvaW4sXG4gICAgICBsaW5lQ2FwOiBzdHJva2VTdHlsZU9iai5saW5lQ2FwLFxuICAgICAgZGFzaFBhdHRlcm46IHN0cm9rZVN0eWxlT2JqLmRhc2hQYXR0ZXJuLFxuICAgICAgZGFzaE9mZnNldDogc3Ryb2tlU3R5bGVPYmouZGFzaE9mZnNldFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc3Ryb2tlIHN0eWxlIGNsYXNzIHRoYXQgZmlyZXMgZXZlbnRzIHdoZW5ldmVyIHRoZSBzdHlsZVxuICogaXMgbW9kaWZpZWQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCB0eXBlIHRvIGZpcmUgd2hlbiBzdHJva2Ugc3R5bGUgaXMgbW9kaWZpZWRcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgIE5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZFN0cm9rZVN0eWxlTWl4aW4oZXZlbnROYW1lKSB7XG4gIC8qKlxuICAgKiBFdmVudGVkIHN0cm9rZSBjb2xvciBjbGFzcyB0byBoYW5kbGUgY29sb3IgbW9kaWZpY2F0aW9uIGV2ZW50c1xuICAgKiBAdHlwZSB7Q29sb3JSR0JBfVxuICAgKi9cbiAgY29uc3QgU3Ryb2tlQ29sb3JDbGFzcyA9IGNyZWF0ZUV2ZW50ZWRDb2xvclJHQkFDbGFzcyhldmVudE5hbWUsIFwic3Ryb2tlQ29sb3JcIilcblxuICAvKipcbiAgICogU3Ryb2tlIHN0eWxlIG1vZGlmaWNhdGlvbiBldmVudFxuICAgKiBAZXZlbnQgRXZlbnRlZFN0cm9rZVN0eWxlI2NoYW5nZWRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gICAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gICAqIEBwcm9wZXJ0eSB7fSBjdXJyVmFsIFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcG9zdCBtb2RpZmljYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtaXhpbiBOZXcgZXZlbnRlZCBzdHJva2Ugc3R5bGUgbWl4aW4uIFdpbGwgZmlyZSBldmVudHMgd2hlbmV2ZXJcbiAgICogICAgICAgIHRoZSBzdHJva2UgaXMgbW9kaWZpZWRcbiAgICovXG4gIHJldHVybiBhZ2dyZWdhdGlvbihudWxsLCBTdHJva2VTdHlsZSwgY2xhc3MgRXZlbnRlZFN0cm9rZVN0eWxlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplciBtZXRob2QgdG8gaW5pdGlhbGl6ZSBhbiBldmVudGVkIHN0cm9rZSBzdHlsZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZU9wdGlvbnN9IFtvcHRzXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgICB0aGlzLl9zdHJva2VDb2xvciA9IG5ldyBTdHJva2VDb2xvckNsYXNzKFwiYmxhY2tcIiwgdGhpcylcbiAgICAgIHRoaXMuX3N0cm9rZVdpZHRoID0gMFxuICAgICAgdGhpcy5fbGluZUpvaW4gPSBKb2luRW51bS5NSVRFUlxuICAgICAgdGhpcy5fbGluZUNhcCA9IENhcEVudW0uQlVUVFxuICAgICAgdGhpcy5fZGFzaFBhdHRlcm4gPSBbXVxuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDBcbiAgICAgIHRoaXMuX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zKG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtICB7bnVtYmVyfVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZFN0cm9rZVN0eWxlI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IHN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSB7XG4gICAgICB2YWxpZGF0ZVN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKVxuICAgICAgaWYgKHN0cm9rZVdpZHRoICE9PSB0aGlzLl9zdHJva2VXaWR0aCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fc3Ryb2tlV2lkdGhcbiAgICAgICAgdGhpcy5fc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aFxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9zdHJva2VXaWR0aFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdHJva2VXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJva2VXaWR0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpbmUgam9pblxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGluZUpvaW5cbiAgICAgKiBAZmlyZXMge0V2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkfVxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRTdHJva2VTdHlsZX1cbiAgICAgKi9cbiAgICBzZXQgbGluZUpvaW4obGluZUpvaW4pIHtcbiAgICAgIGNvbnN0IGVudW1WYWwgPSB2YWxpZGF0ZUxpbmVKb2luKGxpbmVKb2luKVxuXG4gICAgICBpZiAoZW51bVZhbCAhPT0gdGhpcy5fbGluZUpvaW4pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2xpbmVKb2luXG4gICAgICAgIHRoaXMuX2xpbmVKb2luID0gZW51bVZhbFxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJsaW5lSm9pblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9saW5lSm9pblxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGluZSBqb2luXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsaW5lSm9pbigpIHtcbiAgICAgIHJldHVybiBsaW5lSm9pbk9wdHNbdGhpcy5fbGluZUpvaW5dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZSBjYXBcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVDYXBcbiAgICAgKiBAZmlyZXMge0V2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkfVxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRTdHJva2VTdHlsZX1cbiAgICAgKi9cbiAgICBzZXQgbGluZUNhcChsaW5lQ2FwKSB7XG4gICAgICBjb25zdCBlbnVtVmFsID0gdmFsaWRhdGVMaW5lQ2FwKGxpbmVDYXApXG4gICAgICBpZiAoZW51bVZhbCAhPT0gdGhpcy5fbGluZUNhcCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fbGluZUNhcFxuICAgICAgICB0aGlzLl9saW5lQ2FwID0gZW51bVZhbFxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJsaW5lQ2FwXCIsXG4gICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICBjdXJyYWw6IHRoaXMuX2xpbmVDYXBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGluZSBjYXBcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGxpbmVDYXAoKSB7XG4gICAgICByZXR1cm4gbGluZUNhcE9wdHNbdGhpcy5fbGluZUNhcF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkYXNoIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJbXX0gZGFzaFBhdHRlcm5cbiAgICAgKiBAZmlyZXMge0V2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkfVxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRTdHJva2VTdHlsZX1cbiAgICAgKi9cbiAgICBzZXQgZGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pIHtcbiAgICAgIHZhbGlkYXRlRGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pXG4gICAgICBsZXQgZGlmZiA9IGZhbHNlXG4gICAgICBpZiAoZGFzaFBhdHRlcm4ubGVuZ3RoID09PSB0aGlzLl9kYXNoUGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXNoUGF0dGVybi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChkYXNoUGF0dGVybltpXSAhPT0gdGhpcy5fZGFzaFBhdHRlcm5baV0pIHtcbiAgICAgICAgICAgIGRpZmYgPSB0cnVlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZiA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2Rhc2hQYXR0ZXJuXG4gICAgICAgIHRoaXMuX2Rhc2hQYXR0ZXJuID0gZGFzaFBhdHRlcm4uc2xpY2UoKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJkYXNoUGF0dGVyblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9kYXNoUGF0dGVybi5zbGljZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgZGFzaCBwYXR0ZXJuXG4gICAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IGRhc2hQYXR0ZXJuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rhc2hQYXR0ZXJuLnNsaWNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGRhc2ggb2Zmc2V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBkYXNoT2Zmc2V0XG4gICAgICogQGZpcmVzIHtFdmVudGVkU3Ryb2tlU3R5bGUjY2hhbmdlZH1cbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IGRhc2hPZmZzZXQoZGFzaE9mZnNldCkge1xuICAgICAgdmFsaWRhdGVEYXNoT2Zmc2V0KGRhc2hPZmZzZXQpXG5cbiAgICAgIGlmIChkYXNoT2Zmc2V0ICE9PSB0aGlzLl9kYXNoT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9kYXNoT2Zmc2V0XG4gICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0XG5cbiAgICAgICAgaWYgKHRoaXMuX2Rhc2hQYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIG9ubHkgZmlyZSBpZiBkYXNoaW5nIGlzIGFjdGl2YXRlZFxuICAgICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICAgIGF0dHI6IFwiZGFzaE9mZnNldFwiLFxuICAgICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICAgIGN1cnJhbDogdGhpcy5fZGFzaE9mZnNldFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBkYXNoIG9mZnNldFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZGFzaE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXNoT2Zmc2V0XG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvc3Ryb2tlLXN0eWxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 3x3 Matrix\n * @name mat3\n */\nvar mat3 = {};\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nmat3.fromMat4 = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n};\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nmat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n};\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nmat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n};\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nmat3.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n    \n    return out;\n};\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.invert = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b01 = a22 * a11 - a12 * a21,\n        b11 = -a22 * a10 + a12 * a20,\n        b21 = a21 * a10 - a11 * a20,\n\n        // Calculate the determinant\n        det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.adjoint = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    out[0] = (a11 * a22 - a12 * a21);\n    out[1] = (a02 * a21 - a01 * a22);\n    out[2] = (a01 * a12 - a02 * a11);\n    out[3] = (a12 * a20 - a10 * a22);\n    out[4] = (a00 * a22 - a02 * a20);\n    out[5] = (a02 * a10 - a00 * a12);\n    out[6] = (a10 * a21 - a11 * a20);\n    out[7] = (a01 * a20 - a00 * a21);\n    out[8] = (a00 * a11 - a01 * a10);\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nmat3.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n};\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b00 = b[0], b01 = b[1], b02 = b[2],\n        b10 = b[3], b11 = b[4], b12 = b[5],\n        b20 = b[6], b21 = b[7], b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n};\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nmat3.mul = mat3.multiply;\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nmat3.translate = function(out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n        x = v[0], y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n};\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.rotate = function (out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nmat3.scale = function(out, a, v) {\n    var x = v[0], y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\nmat3.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = v[0];\n    out[7] = v[1];\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.fromRotation = function(out, rad) {\n    var s = Math.sin(rad), c = Math.cos(rad);\n\n    out[0] = c;\n    out[1] = s;\n    out[2] = 0;\n\n    out[3] = -s;\n    out[4] = c;\n    out[5] = 0;\n\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\nmat3.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n\n    out[3] = 0;\n    out[4] = v[1];\n    out[5] = 0;\n\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nmat3.fromMat2d = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = 0;\n\n    out[3] = a[2];\n    out[4] = a[3];\n    out[5] = 0;\n\n    out[6] = a[4];\n    out[7] = a[5];\n    out[8] = 1;\n    return out;\n};\n\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\nmat3.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n};\n\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\nmat3.normalFromMat4 = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat3.str = function (a) {\n    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + \n                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + \n                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat3.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))\n};\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n};\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nmat3.sub = mat3.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nmat3.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n};\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nmat3.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    out[6] = a[6] + (b[6] * scale);\n    out[7] = a[7] + (b[7] * scale);\n    out[8] = a[8] + (b[8] * scale);\n    return out;\n};\n\n/*\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat3.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && \n           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&\n           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat3.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));\n};\n\n\nmodule.exports = mat3;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzPzhlYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGU7QUFDQSxvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0Esb0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xubWF0My5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMTA7XG4gICAgb3V0WzRdID0gbTExO1xuICAgIG91dFs1XSA9IG0xMjtcbiAgICBvdXRbNl0gPSBtMjA7XG4gICAgb3V0WzddID0gbTIxO1xuICAgIG91dFs4XSA9IG0yMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0xMDtcbiAgICBvdXRbNF0gPSBtMTE7XG4gICAgb3V0WzVdID0gbTEyO1xuICAgIG91dFs2XSA9IG0yMDtcbiAgICBvdXRbN10gPSBtMjE7XG4gICAgb3V0WzhdID0gbTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IHZbMF07XG4gICAgb3V0WzddID0gdlsxXTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IC1zO1xuICAgIG91dFs0XSA9IGM7XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB2WzFdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5zdWIgPSBtYXQzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgb3V0WzZdID0gYVs2XSAqIGI7XG4gICAgb3V0WzddID0gYVs3XSAqIGI7XG4gICAgb3V0WzhdID0gYVs4XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gICAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICAgIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLypcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0My5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIFxuICAgICAgICAgICBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgICBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sIGE2ID0gYVs2XSwgYTcgPSBhWzddLCBhOCA9IGFbOF07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV0sIGI2ID0gYVs2XSwgYjcgPSBiWzddLCBiOCA9IGJbOF07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 3 Dimensional Vector\n * @name vec3\n */\nvar vec3 = {};\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nvec3.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nvec3.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nvec3.fromValues = function(x, y, z) {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nvec3.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nvec3.set = function(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nvec3.sub = vec3.subtract;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nvec3.mul = vec3.multiply;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nvec3.div = vec3.divide;\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nvec3.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    out[2] = Math.ceil(a[2]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nvec3.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    out[2] = Math.floor(a[2]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nvec3.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    out[2] = Math.round(a[2]);\n    return out;\n};\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nvec3.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n};\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nvec3.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nvec3.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nvec3.dist = vec3.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec3.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return x*x + y*y + z*z;\n};\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nvec3.sqrDist = vec3.squaredDistance;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec3.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nvec3.len = vec3.length;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec3.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return x*x + y*y + z*z;\n};\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nvec3.sqrLen = vec3.squaredLength;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nvec3.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nvec3.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n};\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nvec3.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    var len = x*x + y*y + z*z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n        out[2] = a[2] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.cross = function(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n};\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.hermite = function (out, a, b, c, d, t) {\n  var factorTimes2 = t * t,\n      factor1 = factorTimes2 * (2 * t - 3) + 1,\n      factor2 = factorTimes2 * (t - 2) + t,\n      factor3 = factorTimes2 * (t - 1),\n      factor4 = factorTimes2 * (3 - 2 * t);\n  \n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  \n  return out;\n};\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.bezier = function (out, a, b, c, d, t) {\n  var inverseFactor = 1 - t,\n      inverseFactorTimesTwo = inverseFactor * inverseFactor,\n      factorTimes2 = t * t,\n      factor1 = inverseFactorTimesTwo * inverseFactor,\n      factor2 = 3 * t * inverseFactorTimesTwo,\n      factor3 = 3 * factorTimes2 * inverseFactor,\n      factor4 = factorTimes2 * t;\n  \n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  \n  return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nvec3.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n    var z = (glMatrix.RANDOM() * 2.0) - 1.0;\n    var zScale = Math.sqrt(1.0-z*z) * scale;\n\n    out[0] = Math.cos(r) * zScale;\n    out[1] = Math.sin(r) * zScale;\n    out[2] = z * scale;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat4 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat3 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n};\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nvec3.transformQuat = function(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return out;\n};\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateX = function(out, a, b, c){\n   var p = [], r=[];\n\t  //Translate point to the origin\n\t  p[0] = a[0] - b[0];\n\t  p[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n\n\t  //perform rotation\n\t  r[0] = p[0];\n\t  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);\n\t  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);\n\n\t  //translate to correct position\n\t  out[0] = r[0] + b[0];\n\t  out[1] = r[1] + b[1];\n\t  out[2] = r[2] + b[2];\n\n  \treturn out;\n};\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateY = function(out, a, b, c){\n  \tvar p = [], r=[];\n  \t//Translate point to the origin\n  \tp[0] = a[0] - b[0];\n  \tp[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n  \n  \t//perform rotation\n  \tr[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);\n  \tr[1] = p[1];\n  \tr[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);\n  \n  \t//translate to correct position\n  \tout[0] = r[0] + b[0];\n  \tout[1] = r[1] + b[1];\n  \tout[2] = r[2] + b[2];\n  \n  \treturn out;\n};\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateZ = function(out, a, b, c){\n  \tvar p = [], r=[];\n  \t//Translate point to the origin\n  \tp[0] = a[0] - b[0];\n  \tp[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n  \n  \t//perform rotation\n  \tr[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);\n  \tr[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);\n  \tr[2] = p[2];\n  \n  \t//translate to correct position\n  \tout[0] = r[0] + b[0];\n  \tout[1] = r[1] + b[1];\n  \tout[2] = r[2] + b[2];\n  \n  \treturn out;\n};\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec3.forEach = (function() {\n    var vec = vec3.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 3;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nvec3.angle = function(a, b) {\n   \n    var tempA = vec3.fromValues(a[0], a[1], a[2]);\n    var tempB = vec3.fromValues(b[0], b[1], b[2]);\n \n    vec3.normalize(tempA, tempA);\n    vec3.normalize(tempB, tempB);\n \n    var cosine = vec3.dot(tempA, tempB);\n\n    if(cosine > 1.0){\n        return 0;\n    } else {\n        return Math.acos(cosine);\n    }     \n};\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec3.str = function (a) {\n    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n};\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec3.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec3.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2];\n    var b0 = b[0], b1 = b[1], b2 = b[2];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));\n};\n\nmodule.exports = vec3;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzP2RkOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QiwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jZWlsID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5mbG9vciA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3VuZCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmhlcm1pdGUgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDEsXG4gICAgICBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQsXG4gICAgICBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKSxcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYmV6aWVyID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0LFxuICAgICAgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvLFxuICAgICAgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoZ2xNYXRyaXguUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbnZlYzMuYW5nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICBcbiAgICB2YXIgdGVtcEEgPSB2ZWMzLmZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgdmFyIHRlbXBCID0gdmVjMy5mcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuIFxuICAgIHZlYzMubm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiBcbiAgICB2YXIgY29zaW5lID0gdmVjMy5kb3QodGVtcEEsIHRlbXBCKTtcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9ICAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMzLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 4 Dimensional Vector\n * @name vec4\n */\nvar vec4 = {};\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nvec4.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nvec4.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nvec4.fromValues = function(x, y, z, w) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nvec4.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nvec4.set = function(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nvec4.sub = vec4.subtract;\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    out[3] = a[3] * b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nvec4.mul = vec4.multiply;\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    out[3] = a[3] / b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nvec4.div = vec4.divide;\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to ceil\n * @returns {vec4} out\n */\nvec4.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    out[2] = Math.ceil(a[2]);\n    out[3] = Math.ceil(a[3]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to floor\n * @returns {vec4} out\n */\nvec4.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    out[2] = Math.floor(a[2]);\n    out[3] = Math.floor(a[3]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    out[3] = Math.min(a[3], b[3]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    out[3] = Math.max(a[3], b[3]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to round\n * @returns {vec4} out\n */\nvec4.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    out[2] = Math.round(a[2]);\n    out[3] = Math.round(a[3]);\n    return out;\n};\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nvec4.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nvec4.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nvec4.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return Math.sqrt(x*x + y*y + z*z + w*w);\n};\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nvec4.dist = vec4.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec4.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return x*x + y*y + z*z + w*w;\n};\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nvec4.sqrDist = vec4.squaredDistance;\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec4.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return Math.sqrt(x*x + y*y + z*z + w*w);\n};\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nvec4.len = vec4.length;\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec4.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return x*x + y*y + z*z + w*w;\n};\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nvec4.sqrLen = vec4.squaredLength;\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nvec4.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = -a[3];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to invert\n * @returns {vec4} out\n */\nvec4.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n};\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nvec4.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    var len = x*x + y*y + z*z + w*w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n        out[0] = x * len;\n        out[1] = y * len;\n        out[2] = z * len;\n        out[3] = w * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nvec4.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nvec4.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    //TODO: This is a pretty awful way of doing this. Find something better.\n    out[0] = glMatrix.RANDOM();\n    out[1] = glMatrix.RANDOM();\n    out[2] = glMatrix.RANDOM();\n    out[3] = glMatrix.RANDOM();\n    vec4.normalize(out, out);\n    vec4.scale(out, out, scale);\n    return out;\n};\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nvec4.transformMat4 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2], w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return out;\n};\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nvec4.transformQuat = function(out, a, q) {\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec4.forEach = (function() {\n    var vec = vec4.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 4;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec4.str = function (a) {\n    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec4.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec4.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n};\n\nmodule.exports = vec4;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzP2ZhYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QiwwQkFBMEIsaUJBQWlCLGlCQUFpQjtBQUM1RDtBQUNBLDBCQUEwQixpQkFBaUIsaUJBQWlCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY2VpbCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmZsb29yID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICAgIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucm91bmQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWM0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _interactUtils = __webpack_require__(24);\n\nvar InteractUtils = _interopRequireWildcard(_interactUtils);\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _drawEngine = __webpack_require__(14);\n\nvar _drawEngine2 = _interopRequireDefault(_drawEngine);\n\nvar _mat2d = __webpack_require__(5);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _polyLine = __webpack_require__(11);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nvar _vertEditableShape = __webpack_require__(25);\n\nvar _vertEditableShape2 = _interopRequireDefault(_vertEditableShape);\n\nvar _xformShape = __webpack_require__(26);\n\nvar _xformShape2 = _interopRequireDefault(_xformShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar scaleSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpolygon style='fill:%23ffffff;' points='16,20 16,12 4,24 16,36 16,28 32,28 32,36 44,24 32,12 32,20 '/%3E%3Cpolygon points='14,22 14,17 7,24 14,31 14,26 34,26 34,31 41,24 34,17 34,22 '/%3E%3C/g%3E%3C/svg%3E\\\") no-repeat\";\n\nvar rotateSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpath style='fill:%23ffffff;' d='M25.9,4C16.6,4,8.8,11.2,7.4,20.8H6.7H3.3l1.6,2.9l3.8,7.1l1.8,3.3l1.8-3.3l3.8-7.1l1.6-2.9h-3.3h-0.1 c1.3-5.7,6.1-9.9,11.7-9.9c8,0,12.1,4.4,12.1,13.1c0,7.2-5.4,13.1-12.1,13.1h-2v2V42v2h2c10.4,0,18.8-9,18.8-20 C44.7,11.7,37.5,4,25.9,4L25.9,4z'/%3E%3Cpath d='M25.9,6c10.5,0,16.8,6.7,16.8,18c0,9.9-7.5,18-16.8,18v-2.9c7.8,0,14.1-6.8,14.1-15.1c0-5.6-1.8-15.1-14.1-15.1 c-7.4,0-13.4,6.1-14,13.9h2.4l-3.8,7.1l-3.8-7.1h2.5C9.7,13.4,17,6,25.9,6'/%3E%3C/g%3E%3C/svg%3E\\\") no-repeat\";\n\nvar addSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpolygon style='fill:%23ffffff;' points='31.2,28 24.8,28 24.8,32.8 20,32.8 20,39.2 24.8,39.2 24.8,44 31.2,44 31.2,39.2 36,39.2 36,32.8 31.2,32.8 '/%3E %3Cpolygon style='fill:%23ffffff' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='29.6,29.6 29.6,34.4 34.4,34.4 34.4,37.6 29.6,37.6 29.6,42.4 26.4,42.4 26.4,37.6 21.6,37.6 21.6,34.4 26.4,34.4 26.4,29.6 29.6,29.6  '/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar removeSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Crect style='fill:%23ffffff;' x='20' y='32.8' width='16' height='6.4'/%3E%3Cpolygon  style='fill:%23ffffff;' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='34.4,34.4 34.4,37.6 21.6,37.6 21.6,34.4 '/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar repositionSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath style='fill:%23ffffff;' d='M24,17.5c-3.6,0-6.5,2.9-6.5,6.5s2.9,6.5,6.5,6.5s6.5-2.9,6.5-6.5S27.6,17.5,24,17.5L24,17.5z'/%3E%3Cpath style='fill:%23ffffff;' d='M24,4L4,24l20,20l20-20L24,4z M31.5,31.5h-15v-15h15V31.5z'/%3E%3Cpolygon points='17,34 24,40.5 31,34  '/%3E%3Cpolygon points='31,14 24,7.5 17,14     '/%3E%3Cpolygon points='14,17 7.5,24 14,31   '/%3E%3Cpolygon points='34,31 40.5,24 34,17    '/%3E%3Cpath d='M24,20c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S21.8,20,24,20'/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar EventConstants = {\n  SELECTION_CHANGED: \"draw:selectionChanged\",\n  DRAG_BEGIN: \"draw:drag:begin\",\n  DRAG_END: \"draw:drag:end\"\n};\n\nvar Constants = {\n  SVG_OFFSET: -14,\n  QUICK_CLICK_TIME: 500,\n  RIGHT_ANGLE: 90,\n  STRAIGHT_ANGLE: 180,\n  FORTY_FIVE_ANGLE: 45\n};\n\nvar tmpPt1 = Point2d.create(0, 0);\nvar tmpPt2 = Point2d.create(0, 0);\n\nvar defaultXformStyle = {\n  fillColor: \"white\",\n  strokeColor: \"black\",\n  strokeWidth: 2\n};\n\nfunction inCanvas(canvas, x, y) {\n  var domrect = canvas.getBoundingClientRect();\n  var localX = 0;\n  var localY = 0;\n  var isInCanvas = (localX = x - domrect.left - canvas.clientLeft) >= 0 && localX <= canvas.clientWidth && (localY = y - domrect.top - canvas.clientTop) >= 0 && localY <= canvas.clientHeight;\n  return isInCanvas;\n}\n\nfunction getLocalMousePos(out, elem, event) {\n  var domrect = elem.getBoundingClientRect();\n  out[0] = event.clientX - domrect.left - elem.clientLeft;\n  out[1] = event.clientY - domrect.top - elem.clientTop;\n}\n\nfunction transformSelectedShape(canvas, event, selectedInfo, camera) {\n  getLocalMousePos(tmpPt1, canvas, event);\n  Point2d.transformMat2d(tmpPt2, tmpPt1, camera.screenToWorldMatrix);\n  var shape = selectedInfo.shape;\n  if (shape instanceof _xformShape2.default) {\n    InteractUtils.transformXformShape(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  } else if (shape instanceof _vertEditableShape2.default) {\n    InteractUtils.translateVert(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  } else {\n    InteractUtils.translateShape(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  }\n}\n\nfunction addEventKeysToSelectedInfo(event, selectedInfo) {\n  selectedInfo.keys = {\n    altKey: event.altKey,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    metaKey: event.metaKey\n  };\n}\n\nfunction getSelectedObjsFromMap(selectionMap) {\n  var selectedObjs = [];\n  selectionMap.forEach(function (subshape, shape) {\n    selectedObjs.push(shape);\n  });\n  return selectedObjs;\n}\n\nfunction _selectShape(selectedShape, sortedShapes, currSelectedShapes, selectStyle, xformStyle, selectOpts) {\n  var fireObject = {\n    unselectedShapes: getSelectedObjsFromMap(currSelectedShapes)\n  };\n  clearSelectedShapes(currSelectedShapes);\n  selectedShape.save();\n  var maxZ = sortedShapes[sortedShapes.length - 1].zIndex;\n  selectedShape.zIndex = maxZ + 1;\n  _basicStyle2.default.copyBasicStyle(selectStyle, selectedShape);\n  selectedShape.selected = true;\n  // const dimensions = selectedShape.getDimensions()\n\n  var newSelectShape = null;\n  if (selectOpts.scalable || selectOpts.rotatable) {\n    newSelectShape = new _xformShape2.default(xformStyle || defaultXformStyle, selectOpts);\n    selectedShape.addChildXform(newSelectShape);\n  }\n  currSelectedShapes.set(selectedShape, newSelectShape);\n\n  fireObject.selectedShapes = [selectedShape];\n  return fireObject;\n}\n\nfunction clearSelectedShapes(selectedShapeMap) {\n  selectedShapeMap.forEach(function (selectedShape, shape) {\n    shape.restore();\n    shape.selected = false;\n    shape.removeChildXform(selectedShape);\n  });\n  selectedShapeMap.clear();\n}\n\nfunction clearSpecificShapes(selectedShapeMap, shapes) {\n  var clearedShapes = [];\n  shapes.forEach(function (shape) {\n    var selectedShape = selectedShapeMap.get(shape);\n    shape.restore();\n    shape.selected = false;\n    shape.removeChildXform(selectedShape);\n    selectedShapeMap.delete(shape);\n    clearedShapes.push(shape);\n  });\n  return clearedShapes;\n}\n\nvar hideCursor = function hideCursor() {\n  var cursor = document.getElementById(\"cursor\");\n  if (cursor !== null) {\n    cursor.style.display = \"none\";\n  }\n};\n\nvar showCursor = function showCursor() {\n  var cursor = document.getElementById(\"cursor\");\n  if (cursor !== null) {\n    cursor.style.display = \"block\";\n  }\n};\n\nvar hideCursorWithPointer = function hideCursorWithPointer(e) {\n  e.target.parentNode.style.cursor = \"default\";\n  hideCursor();\n};\n\nvar showCursorWithPointer = function showCursorWithPointer(e) {\n  e.target.parentNode.style.cursor = \"none\";\n  showCursor();\n};\n\n// understands how to return mouse coordinates as an object in the format {x: <X-COORD>, y: <Y-COORD>}\n// accepts a mouse event and a DOM element as arguments\nfunction getMouseCoordinates(e, target) {\n  var canvas = document.querySelector(\"\" + (\"#\" + target.id + \" canvas\"));\n\n  var coords = {\n    x: e.offsetX + canvas.offsetLeft,\n    y: e.offsetY + canvas.offsetTop\n  };\n\n  return coords;\n}\n\n// understands how to append custom cursors to the DOM\n// accepts a mouse event, a DOM element, a cursorStyle, and pixel offsets as arguments\nfunction appendCustomCursor(_event, target, cursorStyle) {\n  var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Constants.SVG_OFFSET;\n  var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Constants.SVG_OFFSET;\n\n  var cursor = document.getElementById(\"cursor\");\n  var mouse = getMouseCoordinates(_event, target);\n\n  if (cursor === null) {\n    var newCursor = document.createElement(\"span\");\n    newCursor.setAttribute(\"id\", \"cursor\");\n    newCursor.setAttribute(\"style\", \"position: absolute; top: \" + (mouse.y + \"px\") + \"; left: \" + (mouse.x + \"px\") + \"; width: 28px; height: 28px; background: \" + cursorStyle + \"; cursor: none; z-index: 10; pointer-events: none; transform: translate(\" + offsetX + \"px, \" + offsetY + \"px)\");\n    target.appendChild(newCursor);\n  } else if (cursor.style.background === cursorStyle) {\n    updateCursorPosition(_event, target);\n  } else {\n    cursor.style.background = cursorStyle;\n    updateCursorPosition(_event, target);\n  }\n}\n\n// understands how to remove the custom cursor from the DOM\nfunction removeCustomCursor() {\n  var cursor = document.getElementById(\"cursor\");\n  if (cursor !== null) {\n    cursor.parentNode.removeChild(cursor);\n  }\n}\n\n// understands how to change the position of the custom cursor on the page\n// accepts a mouse event and a DOM element as arguments\nfunction updateCursorPosition(_event, target) {\n  var cursor = document.getElementById(\"cursor\");\n  var mouse = getMouseCoordinates(_event, target);\n\n  if (cursor !== null) {\n    cursor.style.top = \"\" + (mouse.y + \"px\");\n    cursor.style.left = \"\" + (mouse.x + \"px\");\n  }\n}\n\nvar ShapeBuilder = function (_DrawEngine) {\n  _inherits(ShapeBuilder, _DrawEngine);\n\n  function ShapeBuilder() {\n    _classCallCheck(this, ShapeBuilder);\n\n    return _possibleConstructorReturn(this, (ShapeBuilder.__proto__ || Object.getPrototypeOf(ShapeBuilder)).apply(this, arguments));\n  }\n\n  _createClass(ShapeBuilder, [{\n    key: \"_mousedownCB\",\n    value: function _mousedownCB(event) {\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY)) {\n        return;\n      }\n\n      this.timer = performance.now();\n\n      Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n      Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      var shapes = this.sortedShapes;\n      var i = -1;\n      var selectedShape = null;\n      var selectedInfo = null;\n      for (i = shapes.length - 1; i >= 0; i -= 1) {\n        var shapeInfo = this._objects.get(shapes[i]);\n        if (shapes[i].selected) {\n          selectedShape = this._selectedShapes.get(shapes[i]);\n          selectedInfo = shapeInfo;\n          var hitInfo = null;\n          if (selectedShape && (hitInfo = selectedShape.containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)).hit) {\n            if (selectedShape instanceof _vertEditableShape2.default && event.altKey && hitInfo.controlIndex < shapes[i].numVerts) {\n              shapes[i].removeVert(hitInfo.controlIndex);\n              selectedShape = null;\n            } else {\n              var localXform = selectedShape.parent.localXform;\n              var invLocalXform = _mat2d2.default.clone(localXform);\n              _mat2d2.default.invert(invLocalXform, invLocalXform);\n              var startObjPos = Point2d.clone(tmpPt2);\n              Point2d.transformMat2d(startObjPos, startObjPos, invLocalXform);\n              this._dragInfo = Object.assign({\n                rotate: Boolean(hitInfo.rotate),\n                controlIndex: hitInfo.controlIndex,\n                startObjectPos: startObjPos,\n                worldToObjectMatrix: invLocalXform,\n                startLocalPos: selectedShape.parent.getPosition(),\n                startLocalScale: selectedShape.parent.getScale(),\n                startLocalRot: selectedShape.parent.getRotation(),\n                shapeWidth: selectedShape.parent.width,\n                shapeHeight: selectedShape.parent.height\n              }, selectedInfo);\n            }\n            break;\n          } else if (shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n            selectedShape = shapes[i];\n            break;\n          }\n        }\n        // else if (shapeInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n        //   selectedShape = shapes[i]\n        //   selectedInfo = shapeInfo\n        //   const selectEventObj = selectShape(selectedShape, shapes, this._selectedShapes, this._selectStyle, this._xformStyle, selectedInfo)\n        //   this.fire(EventConstants.SELECTION_CHANGED, selectEventObj)\n        //   break\n        // }\n      }\n\n      if (i < 0 && this._selectedShapes.size) {\n        if (this._selectedShapes.size) {\n          this.fire(EventConstants.SELECTION_CHANGED, {\n            unselectedShapes: getSelectedObjsFromMap(this._selectedShapes),\n            selectedShapes: []\n          });\n        }\n        this._dragInfo = null;\n        clearSelectedShapes(this._selectedShapes);\n      } else if (selectedShape && selectedInfo && (selectedInfo.movable || selectedInfo.rotatable || selectedInfo.scalable)) {\n        var canvas = document.querySelector(\"\" + (\"#\" + this._parent.id + \" > canvas\"));\n        if (canvas === null) {\n          this._parent.addEventListener(\"mouseout\", hideCursor);\n          this._parent.addEventListener(\"mouseover\", showCursor);\n        } else {\n          canvas.addEventListener(\"mouseout\", hideCursorWithPointer);\n          canvas.addEventListener(\"mouseover\", showCursorWithPointer);\n        }\n        if (!this._dragInfo && selectedInfo.movable) {\n          this._dragInfo = {\n            startLocalPos: selectedShape.getPosition()\n          };\n        }\n\n        if (this._dragInfo) {\n          this._dragInfo.shape = selectedShape;\n          this._dragInfo.startPos = Point2d.clone(tmpPt1);\n          this._dragInfo.startWorldPos = Point2d.clone(tmpPt2);\n          this._dragInfo.objectToWorldMatrix = _mat2d2.default.clone(selectedShape.globalXform);\n          addEventKeysToSelectedInfo(event, this._dragInfo);\n          event.stopImmediatePropagation();\n          this.fire(EventConstants.DRAG_BEGIN, {\n            shapes: getSelectedObjsFromMap(this._selectedShapes)\n          });\n        }\n        event.preventDefault();\n      }\n    }\n  }, {\n    key: \"_mouseupCB\",\n    value: function _mouseupCB(event) {\n      if (this._dragInfo && this._dragInfo.shape) {\n        event.stopImmediatePropagation();\n        event.preventDefault();\n        var canvas = document.querySelector(\"\" + (\"#\" + this._parent.id + \" > canvas\"));\n        if (canvas === null) {\n          this._parent.removeEventListener(\"mouseout\", hideCursor);\n          this._parent.removeEventListener(\"mouseover\", showCursor);\n        } else {\n          canvas.removeEventListener(\"mouseout\", hideCursorWithPointer);\n          canvas.removeEventListener(\"mouseover\", showCursorWithPointer);\n        }\n        this._dragInfo = null;\n        this.fire(EventConstants.DRAG_END, {\n          shapes: getSelectedObjsFromMap(this._selectedShapes)\n        });\n      } else if (performance.now() - this.timer < Constants.QUICK_CLICK_TIME) {\n        // this is a relatively quick click\n        Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n        Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n        var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n        var shapes = this.sortedShapes;\n        var selectedShape = null;\n        var selectedInfo = null;\n        for (var i = shapes.length - 1; i >= 0; i -= 1) {\n          selectedInfo = this._objects.get(shapes[i]);\n          if (selectedInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n            selectedShape = shapes[i];\n            break;\n          }\n        }\n        if (selectedShape && !selectedShape.selected) {\n          var selectEventObj = _selectShape(selectedShape, shapes, this._selectedShapes, this._selectStyle, this._xformStyle, selectedInfo);\n          this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n        }\n      }\n    }\n  }, {\n    key: \"_mousemoveCB\",\n    value: function _mousemoveCB(event) {\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY) && !this._dragInfo) {\n        return;\n      }\n\n      if (this._dragInfo && this._dragInfo.shape) {\n        updateCursorPosition(event, this._parent);\n        addEventKeysToSelectedInfo(event, this._dragInfo);\n        transformSelectedShape(this._drawCanvas, event, this._dragInfo, this._camera);\n        event.stopImmediatePropagation();\n        event.preventDefault();\n      } else if (!event.buttons && this._selectedShapes.size) {\n        Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n        Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n        var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n        var shapes = this.sortedShapes;\n        var i = 0;\n        var flipy = this._camera.isYFlipped();\n        for (i = shapes.length - 1; i >= 0; i -= 1) {\n          if (shapes[i].selected) {\n            var selectInfo = this._objects.get(shapes[i]);\n            var selectedShape = this._selectedShapes.get(shapes[i]);\n            var hitInfo = null;\n            this._parent.style.cursor = \"none\";\n            // forEach not supported on nodelist in IE/Edge\n            for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n              this._parent.childNodes[j].style.cursor = \"none\";\n              if (this._parent.childNodes[j].nodeName.toLowerCase() !== \"canvas\") {\n                this._parent.childNodes[j].style.pointerEvents = \"none\";\n              }\n            }\n            if (selectedShape && (hitInfo = selectedShape.containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)).hit) {\n              if (selectedShape instanceof _xformShape2.default) {\n                if (hitInfo.rotate) {\n                  var degrees = shapes[i].getRotation();\n                  if (flipy) {\n                    degrees *= -1;\n                    if (hitInfo.controlIndex === 1) {\n                      degrees -= Constants.RIGHT_ANGLE;\n                    } else if (hitInfo.controlIndex === 0) {\n                      degrees += Constants.STRAIGHT_ANGLE;\n                    } else if (hitInfo.controlIndex === 2) {\n                      degrees += Constants.RIGHT_ANGLE;\n                    }\n                  } else if (hitInfo.controlIndex === 0) {\n                    degrees -= Constants.RIGHT_ANGLE;\n                  } else if (hitInfo.controlIndex === 1) {\n                    degrees += Constants.STRAIGHT_ANGLE;\n                  } else if (hitInfo.controlIndex === 3) {\n                    // eslint-disable-line no-magic-numbers\n                    degrees += Constants.RIGHT_ANGLE;\n                  }\n                  appendCustomCursor(event, this._parent, \"\" + rotateSvg.replace(/<degrees>/g, \"\" + degrees));\n                } else if (hitInfo.controlIndex < 4) {\n                  // eslint-disable-line no-magic-numbers\n                  if (hitInfo.controlIndex === 0 || hitInfo.controlIndex === 3) {\n                    // eslint-disable-line no-magic-numbers\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + (-shapes[i].getRotation() - Constants.FORTY_FIVE_ANGLE)));\n                  } else if (hitInfo.controlIndex === 1 || hitInfo.controlIndex === 2) {\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + (-shapes[i].getRotation() + Constants.FORTY_FIVE_ANGLE)));\n                  }\n                } else if (hitInfo.controlIndex % 2 === 0) {\n                  appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + -shapes[i].getRotation()));\n                } else {\n                  appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + (-shapes[i].getRotation() + Constants.RIGHT_ANGLE)));\n                }\n              } else if (selectedShape instanceof _vertEditableShape2.default) {\n                this._parent.style.cursor = \"none\";\n                // forEach not supported on nodelist in IE/Edge\n                for (var _j = 0; _j < this._parent.childNodes.length; _j += 1) {\n                  this._parent.childNodes[_j].style.cursor = \"none\";\n                  if (this._parent.childNodes[_j].nodeName.toLowerCase() !== \"canvas\") {\n                    this._parent.childNodes[_j].style.pointerEvents = \"none\";\n                  }\n                }\n                if (hitInfo.controlIndex >= shapes[i].numVerts) {\n                  appendCustomCursor(event, this._parent, addSvg, -8, -6); // eslint-disable-line no-magic-numbers\n                } else if (event.altKey) {\n                  appendCustomCursor(event, this._parent, removeSvg, -8, -6); // eslint-disable-line no-magic-numbers\n                } else {\n                  appendCustomCursor(event, this._parent, repositionSvg, Constants.SVG_OFFSET, Constants.SVG_OFFSET);\n                }\n              }\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              break;\n            } else if (shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n              if (selectInfo && selectInfo.movable) {\n                var cursor = document.getElementById(\"cursor\");\n                if (cursor !== null) {\n                  cursor.parentNode.removeChild(cursor);\n                }\n                this._parent.style.cursor = \"move\";\n                for (var _j2 = 0; _j2 < this._parent.childNodes.length; _j2 += 1) {\n                  this._parent.childNodes[_j2].style.cursor = \"move\";\n                }\n                event.stopImmediatePropagation();\n                event.preventDefault();\n              }\n              break;\n            }\n          }\n        }\n\n        if (i < 0) {\n          removeCustomCursor();\n          this._parent.style.cursor = \"default\";\n          // forEach not supported on nodelist in IE/Edge\n          for (var _j3 = 0; _j3 < this._parent.childNodes.length; _j3 += 1) {\n            this._parent.childNodes[_j3].style.cursor = \"default\";\n            if (this._parent.childNodes[_j3].nodeName.toLowerCase() !== \"canvas\") {\n              this._parent.childNodes[_j3].style.pointerEvents = \"auto\";\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_clickCB\",\n    value: function _clickCB() {\n      // noop\n    }\n  }, {\n    key: \"_dblclickCB\",\n    value: function _dblclickCB(event) {\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY)) {\n        return;\n      }\n\n      Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n      Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      var shapes = this.sortedShapes;\n      var i = -1;\n      for (i = shapes.length - 1; i >= 0; i -= 1) {\n        var shapeInfo = this._objects.get(shapes[i]);\n        if (shapeInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n          if (shapeInfo.editable && shapes[i] instanceof _polyLine2.default) {\n            var selectedShape = shapes[i];\n            var doXform = false;\n            if (shapes[i].selected) {\n              var interactiveShape = this._selectedShapes.get(shapes[i]);\n              if (interactiveShape) {\n                selectedShape.restore();\n                selectedShape.removeChildXform(interactiveShape);\n                doXform = !(interactiveShape instanceof _xformShape2.default);\n              }\n            }\n\n            selectedShape.selected = true;\n            selectedShape.save();\n            var maxZ = shapes[shapes.length - 1].zIndex;\n            selectedShape.zIndex = maxZ + 1;\n            _basicStyle2.default.copyBasicStyle(this._selectStyle, selectedShape);\n            var newSelectShape = null;\n            if (doXform) {\n              if (shapeInfo.rotatable || shapeInfo.scalable) {\n                newSelectShape = new _xformShape2.default(this._xformStyle || defaultXformStyle, shapeInfo);\n                selectedShape.addChildXform(newSelectShape);\n              }\n            } else {\n              newSelectShape = new _vertEditableShape2.default(selectedShape, this._xformStyle);\n              selectedShape.addChildXform(newSelectShape);\n            }\n            this._selectedShapes.set(selectedShape, newSelectShape);\n          } else if (!shapes[i].selected) {\n            var selectEventObj = _selectShape(shapes[i], shapes, this._selectedShapes, this._selectStyle, this._xformStyle, shapeInfo);\n            this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n          }\n          break;\n        }\n      }\n\n      if (i < 0 && this._selectedShapes.size) {\n        if (this._selectedShapes.size) {\n          this.fire(EventConstants.SELECTION_CHANGED, {\n            unselectedShapes: getSelectedObjsFromMap(this._selectedShapes),\n            selectedShapes: []\n          });\n        }\n        this._dragInfo = null;\n        clearSelectedShapes(this._selectedShapes);\n      } else {\n        event.stopImmediatePropagation();\n      }\n      event.preventDefault();\n    }\n  }, {\n    key: \"_mouseoverCB\",\n    value: function _mouseoverCB() {\n      // noop\n    }\n  }, {\n    key: \"_mouseoutCB\",\n    value: function _mouseoutCB() {\n      // noop\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(parent, opts) {\n      this._activated = opts && opts.enableInteractions;\n      _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"_init\", this).call(this, parent, opts, this._activated);\n      var myevents = Object.getOwnPropertyNames(EventConstants).map(function (event) {\n        return EventConstants[event];\n      });\n      this.registerEvents(myevents);\n      this._dragInfo = null;\n      this._selectedShapes = new Map();\n      this._selectStyle = new _basicStyle2.default(opts && opts.selectStyle ? opts.selectStyle : {\n        fillColor: \"orange\"\n      });\n\n      this._xformStyle = new _basicStyle2.default(opts && opts.xformStyle ? opts.xformStyle : {\n        fillColor: \"white\",\n        strokeColor: \"black\",\n        strokeWidth: 2\n      });\n\n      this.timer = 0;\n    }\n  }, {\n    key: \"_renderShapes\",\n    value: function _renderShapes(ctx, drawShapes, camera) {\n      var _this2 = this;\n\n      var worldToScreenMat = camera.worldToScreenMatrix;\n      drawShapes.forEach(function (shape) {\n        if (shape.visible) {\n          shape.render(ctx, worldToScreenMat, _this2._styleState);\n          // shape.renderBounds(ctx, worldToScreenMat, boundsStrokeStyle)\n          if (shape.selected) {\n            var interacShape = _this2._selectedShapes.get(shape);\n            if (interacShape) {\n              interacShape.render(ctx, worldToScreenMat, _this2._styleState);\n              // interacShape.renderBounds(ctx, worldToScreenMat, boundsStrokeStyle)\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"selectShape\",\n    value: function selectShape(shape) {\n      var shapeInfo = this._objects.get(shape);\n      if (shapeInfo && shapeInfo.selectable) {\n        var selectEventObj = _selectShape(shape, this.sortedShapes, this._selectedShapes, this._selectStyle, this._xformStyle, shapeInfo);\n        this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (this._selectedShapes.size) {\n        var selectedShapes = getSelectedObjsFromMap(this._selectedShapes);\n        clearSelectedShapes(this._selectedShapes);\n        this.fire(EventConstants.SELECTION_CHANGED, {\n          unselectedShapes: selectedShapes,\n          selectedShapes: []\n        });\n        this._rerenderCb();\n      }\n    }\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape) {\n      var _this3 = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"addShape\", this).call(this, shapes);\n      shapes.forEach(function (newShape) {\n        var shapeInfo = _this3._objects.get(newShape);\n        if (shapeInfo) {\n          shapeInfo.selectable = opts && typeof opts.selectable !== \"undefined\" ? Boolean(opts.selectable) : true;\n          shapeInfo.movable = opts && typeof opts.movable !== \"undefined\" ? Boolean(opts.movable) : true;\n          shapeInfo.rotatable = opts && typeof opts.rotatable !== \"undefined\" ? Boolean(opts.rotatable) : true;\n          shapeInfo.scalable = opts && typeof opts.scalable !== \"undefined\" ? Boolean(opts.scalable) : true;\n          shapeInfo.uniformScaleOnly = opts && typeof opts.uniformScaleOnly !== \"undefined\" ? Boolean(opts.uniformScaleOnly) : false;\n          shapeInfo.centerScaleOnly = opts && typeof opts.centerScaleOnly !== \"undefined\" ? Boolean(opts.centerScaleOnly) : false;\n          shapeInfo.editable = opts && typeof opts.editable !== \"undefined\" ? Boolean(opts.editable) : true;\n        }\n      });\n\n      if (select) {\n        var selectEventObj = {\n          unselectedShapes: getSelectedObjsFromMap(this._selectedShapes)\n        };\n        var selectedShapes = [];\n        shapes.forEach(function (newShape) {\n          var shapeInfo = _this3._objects.get(newShape);\n          if (shapeInfo.selectable) {\n            _selectShape(newShape, _this3.sortedShapes, _this3._selectedShapes, _this3._selectStyle, _this3._xformStyle, shapeInfo);\n            selectedShapes.push(newShape);\n          }\n        });\n\n        if (selectedShapes.length) {\n          selectEventObj.selectedShapes = selectedShapes;\n          this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n      var selectClearedShapes = clearSpecificShapes(this._selectedShapes, shapes);\n      this.fire(EventConstants.SELECTION_CHANGED, {\n        unselectedShapes: selectClearedShapes,\n        selectedShapes: getSelectedObjsFromMap(this._selectedShapes)\n      });\n\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\";\n      // forEach not supported on nodelist in IE/Edge\n      for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n        this._parent.childNodes[j].style.cursor = \"default\";\n        this._parent.childNodes[j].style.pointerEvents = \"auto\";\n      }\n\n      return _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"deleteShape\", this).call(this, shapes);\n    }\n  }, {\n    key: \"deleteSelectedShapes\",\n    value: function deleteSelectedShapes() {\n      var selectedShapes = getSelectedObjsFromMap(this._selectedShapes);\n      clearSelectedShapes(this._selectedShapes);\n      this.fire(EventConstants.SELECTION_CHANGED, {\n        unselectedShapes: selectedShapes,\n        selectedShapes: []\n      });\n\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\";\n      // forEach not supported on nodelist in IE/Edge\n      for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n        this._parent.childNodes[j].style.cursor = \"default\";\n        this._parent.childNodes[j].style.pointerEvents = \"auto\";\n      }\n\n      return _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"deleteShape\", this).call(this, selectedShapes);\n    }\n  }, {\n    key: \"enableInteractions\",\n    value: function enableInteractions() {\n      this._enableEvents();\n      this._activated = true;\n      return this;\n    }\n  }, {\n    key: \"disableInteractions\",\n    value: function disableInteractions() {\n      var clearSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (clearSelection) {\n        this.clearSelection();\n      }\n      this._disableEvents();\n      this._activated = false;\n      return this;\n    }\n  }, {\n    key: \"selectStyle\",\n    set: function set(selectStyle) {\n      _basicStyle2.default.copyBasicStyle(selectStyle, this._selectStyle);\n    },\n    get: function get() {\n      return this._selectStyle;\n    }\n  }, {\n    key: \"selectedShapes\",\n    get: function get() {\n      return getSelectedObjsFromMap(this._selectedShapes);\n    }\n  }, {\n    key: \"interactionsEnabled\",\n    get: function get() {\n      return this._activated;\n    }\n  }]);\n\n  return ShapeBuilder;\n}(_drawEngine2.default);\n\nexports.default = ShapeBuilder;\n\n\nObject.assign(EventConstants, _drawEngine2.default.EventConstants);\nShapeBuilder.EventConstants = EventConstants;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2hhcGUtYnVpbGRlci5qcz8yNjg0Il0sIm5hbWVzIjpbIkludGVyYWN0VXRpbHMiLCJQb2ludDJkIiwic2NhbGVTdmciLCJyb3RhdGVTdmciLCJhZGRTdmciLCJyZW1vdmVTdmciLCJyZXBvc2l0aW9uU3ZnIiwiRXZlbnRDb25zdGFudHMiLCJTRUxFQ1RJT05fQ0hBTkdFRCIsIkRSQUdfQkVHSU4iLCJEUkFHX0VORCIsIkNvbnN0YW50cyIsIlNWR19PRkZTRVQiLCJRVUlDS19DTElDS19USU1FIiwiUklHSFRfQU5HTEUiLCJTVFJBSUdIVF9BTkdMRSIsIkZPUlRZX0ZJVkVfQU5HTEUiLCJ0bXBQdDEiLCJjcmVhdGUiLCJ0bXBQdDIiLCJkZWZhdWx0WGZvcm1TdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJpbkNhbnZhcyIsImNhbnZhcyIsIngiLCJ5IiwiZG9tcmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImxvY2FsWCIsImxvY2FsWSIsImlzSW5DYW52YXMiLCJsZWZ0IiwiY2xpZW50TGVmdCIsImNsaWVudFdpZHRoIiwidG9wIiwiY2xpZW50VG9wIiwiY2xpZW50SGVpZ2h0IiwiZ2V0TG9jYWxNb3VzZVBvcyIsIm91dCIsImVsZW0iLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwidHJhbnNmb3JtU2VsZWN0ZWRTaGFwZSIsInNlbGVjdGVkSW5mbyIsImNhbWVyYSIsInRyYW5zZm9ybU1hdDJkIiwic2NyZWVuVG9Xb3JsZE1hdHJpeCIsInNoYXBlIiwidHJhbnNmb3JtWGZvcm1TaGFwZSIsInRyYW5zbGF0ZVZlcnQiLCJ0cmFuc2xhdGVTaGFwZSIsImFkZEV2ZW50S2V5c1RvU2VsZWN0ZWRJbmZvIiwia2V5cyIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJnZXRTZWxlY3RlZE9ianNGcm9tTWFwIiwic2VsZWN0aW9uTWFwIiwic2VsZWN0ZWRPYmpzIiwiZm9yRWFjaCIsInN1YnNoYXBlIiwicHVzaCIsInNlbGVjdFNoYXBlIiwic2VsZWN0ZWRTaGFwZSIsInNvcnRlZFNoYXBlcyIsImN1cnJTZWxlY3RlZFNoYXBlcyIsInNlbGVjdFN0eWxlIiwieGZvcm1TdHlsZSIsInNlbGVjdE9wdHMiLCJmaXJlT2JqZWN0IiwidW5zZWxlY3RlZFNoYXBlcyIsImNsZWFyU2VsZWN0ZWRTaGFwZXMiLCJzYXZlIiwibWF4WiIsImxlbmd0aCIsInpJbmRleCIsImNvcHlCYXNpY1N0eWxlIiwic2VsZWN0ZWQiLCJuZXdTZWxlY3RTaGFwZSIsInNjYWxhYmxlIiwicm90YXRhYmxlIiwiYWRkQ2hpbGRYZm9ybSIsInNldCIsInNlbGVjdGVkU2hhcGVzIiwic2VsZWN0ZWRTaGFwZU1hcCIsInJlc3RvcmUiLCJyZW1vdmVDaGlsZFhmb3JtIiwiY2xlYXIiLCJjbGVhclNwZWNpZmljU2hhcGVzIiwic2hhcGVzIiwiY2xlYXJlZFNoYXBlcyIsImdldCIsImRlbGV0ZSIsImhpZGVDdXJzb3IiLCJjdXJzb3IiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3R5bGUiLCJkaXNwbGF5Iiwic2hvd0N1cnNvciIsImhpZGVDdXJzb3JXaXRoUG9pbnRlciIsImUiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwic2hvd0N1cnNvcldpdGhQb2ludGVyIiwiZ2V0TW91c2VDb29yZGluYXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpZCIsImNvb3JkcyIsIm9mZnNldFgiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0WSIsIm9mZnNldFRvcCIsImFwcGVuZEN1c3RvbUN1cnNvciIsIl9ldmVudCIsImN1cnNvclN0eWxlIiwibW91c2UiLCJuZXdDdXJzb3IiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJiYWNrZ3JvdW5kIiwidXBkYXRlQ3Vyc29yUG9zaXRpb24iLCJyZW1vdmVDdXN0b21DdXJzb3IiLCJyZW1vdmVDaGlsZCIsIlNoYXBlQnVpbGRlciIsIl9kcmF3Q2FudmFzIiwidGltZXIiLCJwZXJmb3JtYW5jZSIsIm5vdyIsIl9jYW1lcmEiLCJ3b3JsZFRvU2NyZWVuTWF0cml4IiwiaSIsInNoYXBlSW5mbyIsIl9vYmplY3RzIiwiX3NlbGVjdGVkU2hhcGVzIiwiaGl0SW5mbyIsImNvbnRhaW5zUG9pbnQiLCJfZHJhd0N0eCIsImhpdCIsImNvbnRyb2xJbmRleCIsIm51bVZlcnRzIiwicmVtb3ZlVmVydCIsImxvY2FsWGZvcm0iLCJwYXJlbnQiLCJpbnZMb2NhbFhmb3JtIiwiY2xvbmUiLCJpbnZlcnQiLCJzdGFydE9ialBvcyIsIl9kcmFnSW5mbyIsIk9iamVjdCIsImFzc2lnbiIsInJvdGF0ZSIsIkJvb2xlYW4iLCJzdGFydE9iamVjdFBvcyIsIndvcmxkVG9PYmplY3RNYXRyaXgiLCJzdGFydExvY2FsUG9zIiwiZ2V0UG9zaXRpb24iLCJzdGFydExvY2FsU2NhbGUiLCJnZXRTY2FsZSIsInN0YXJ0TG9jYWxSb3QiLCJnZXRSb3RhdGlvbiIsInNoYXBlV2lkdGgiLCJ3aWR0aCIsInNoYXBlSGVpZ2h0IiwiaGVpZ2h0Iiwic2l6ZSIsImZpcmUiLCJtb3ZhYmxlIiwiX3BhcmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJzdGFydFBvcyIsInN0YXJ0V29ybGRQb3MiLCJvYmplY3RUb1dvcmxkTWF0cml4IiwiZ2xvYmFsWGZvcm0iLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmV2ZW50RGVmYXVsdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZWxlY3RhYmxlIiwic2VsZWN0RXZlbnRPYmoiLCJfc2VsZWN0U3R5bGUiLCJfeGZvcm1TdHlsZSIsImJ1dHRvbnMiLCJmbGlweSIsImlzWUZsaXBwZWQiLCJzZWxlY3RJbmZvIiwiaiIsImNoaWxkTm9kZXMiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwicG9pbnRlckV2ZW50cyIsImRlZ3JlZXMiLCJyZXBsYWNlIiwiZWRpdGFibGUiLCJkb1hmb3JtIiwiaW50ZXJhY3RpdmVTaGFwZSIsIm9wdHMiLCJfYWN0aXZhdGVkIiwiZW5hYmxlSW50ZXJhY3Rpb25zIiwibXlldmVudHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibWFwIiwicmVnaXN0ZXJFdmVudHMiLCJNYXAiLCJjdHgiLCJkcmF3U2hhcGVzIiwid29ybGRUb1NjcmVlbk1hdCIsInZpc2libGUiLCJyZW5kZXIiLCJfc3R5bGVTdGF0ZSIsImludGVyYWNTaGFwZSIsIl9yZXJlbmRlckNiIiwic2VsZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwibmV3U2hhcGUiLCJ1bmlmb3JtU2NhbGVPbmx5IiwiY2VudGVyU2NhbGVPbmx5Iiwic2VsZWN0Q2xlYXJlZFNoYXBlcyIsIl9lbmFibGVFdmVudHMiLCJjbGVhclNlbGVjdGlvbiIsIl9kaXNhYmxlRXZlbnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxhOztBQUNaOztJQUFZQyxPOztBQUNaOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQyxXQUFXLG1XQUFqQjs7QUFFQSxJQUFNQyxZQUFZLCtuQkFBbEI7O0FBRUEsSUFBTUMsU0FBUyxra0JBQWY7O0FBRUEsSUFBTUMsWUFBWSwyWkFBbEI7O0FBRUEsSUFBTUMsZ0JBQWdCLHNsQkFBdEI7O0FBRUEsSUFBTUMsaUJBQWlCO0FBQ3JCQyxxQkFBbUIsdUJBREU7QUFFckJDLGNBQVksaUJBRlM7QUFHckJDLFlBQVU7QUFIVyxDQUF2Qjs7QUFNQSxJQUFNQyxZQUFZO0FBQ2hCQyxjQUFZLENBQUMsRUFERztBQUVoQkMsb0JBQWtCLEdBRkY7QUFHaEJDLGVBQWEsRUFIRztBQUloQkMsa0JBQWdCLEdBSkE7QUFLaEJDLG9CQUFrQjtBQUxGLENBQWxCOztBQVFBLElBQU1DLFNBQVNoQixRQUFRaUIsTUFBUixDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZjtBQUNBLElBQU1DLFNBQVNsQixRQUFRaUIsTUFBUixDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZjs7QUFF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QUFLeEIsVUFBTCxHQUFrQixLQUFsQjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7c0JBckllbkksVyxFQUFhO0FBQzNCLDJCQUFXVSxjQUFYLENBQTBCVixXQUExQixFQUF1QyxLQUFLa0gsWUFBNUM7QUFDRCxLO3dCQUVpQjtBQUNoQixhQUFPLEtBQUtBLFlBQVo7QUFDRDs7O3dCQUVvQjtBQUNuQixhQUFPNUgsdUJBQXVCLEtBQUsrRSxlQUE1QixDQUFQO0FBQ0Q7Ozt3QkEwR3lCO0FBQ3hCLGFBQU8sS0FBSzhELFVBQVo7QUFDRDs7Ozs7O2tCQWpla0J4RSxZOzs7QUFtZnJCeUIsT0FBT0MsTUFBUCxDQUFjcEosY0FBZCxFQUE4QixxQkFBV0EsY0FBekM7QUFDQTBILGFBQWExSCxjQUFiLEdBQThCQSxjQUE5QiIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEludGVyYWN0VXRpbHMgZnJvbSBcIi4uL2ludGVyYWN0aW9ucy9pbnRlcmFjdC11dGlsc1wiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IEJhc2ljU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2Jhc2ljLXN0eWxlXCJcbmltcG9ydCBEcmF3RW5naW5lIGZyb20gXCIuL2RyYXctZW5naW5lXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgUG9seUxpbmUgZnJvbSBcIi4uL3NoYXBlcy9wb2x5LWxpbmVcIlxuaW1wb3J0IFZlcnRFZGl0YWJsZVNoYXBlIGZyb20gXCIuLi9pbnRlcmFjdGlvbnMvdmVydC1lZGl0YWJsZS1zaGFwZVwiXG5pbXBvcnQgWGZvcm1TaGFwZSBmcm9tIFwiLi4vaW50ZXJhY3Rpb25zL3hmb3JtLXNoYXBlXCJcblxuY29uc3Qgc2NhbGVTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0NnIHRyYW5zZm9ybT0ncm90YXRlKDxkZWdyZWVzPiwyNCwyNCknJTNFJTNDcG9seWdvbiBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBwb2ludHM9JzE2LDIwIDE2LDEyIDQsMjQgMTYsMzYgMTYsMjggMzIsMjggMzIsMzYgNDQsMjQgMzIsMTIgMzIsMjAgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMTQsMjIgMTQsMTcgNywyNCAxNCwzMSAxNCwyNiAzNCwyNiAzNCwzMSA0MSwyNCAzNCwxNyAzNCwyMiAnLyUzRSUzQy9nJTNFJTNDL3N2ZyUzRVxcXCIpIG5vLXJlcGVhdFwiXG5cbmNvbnN0IHJvdGF0ZVN2ZyA9IFwidXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDQ4IDQ4JyUzRSUzQ2cgdHJhbnNmb3JtPSdyb3RhdGUoPGRlZ3JlZXM+LDI0LDI0KSclM0UlM0NwYXRoIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIGQ9J00yNS45LDRDMTYuNiw0LDguOCwxMS4yLDcuNCwyMC44SDYuN0gzLjNsMS42LDIuOWwzLjgsNy4xbDEuOCwzLjNsMS44LTMuM2wzLjgtNy4xbDEuNi0yLjloLTMuM2gtMC4xIGMxLjMtNS43LDYuMS05LjksMTEuNy05LjljOCwwLDEyLjEsNC40LDEyLjEsMTMuMWMwLDcuMi01LjQsMTMuMS0xMi4xLDEzLjFoLTJ2MlY0MnYyaDJjMTAuNCwwLDE4LjgtOSwxOC44LTIwIEM0NC43LDExLjcsMzcuNSw0LDI1LjksNEwyNS45LDR6Jy8lM0UlM0NwYXRoIGQ9J00yNS45LDZjMTAuNSwwLDE2LjgsNi43LDE2LjgsMThjMCw5LjktNy41LDE4LTE2LjgsMTh2LTIuOWM3LjgsMCwxNC4xLTYuOCwxNC4xLTE1LjFjMC01LjYtMS44LTE1LjEtMTQuMS0xNS4xIGMtNy40LDAtMTMuNCw2LjEtMTQsMTMuOWgyLjRsLTMuOCw3LjFsLTMuOC03LjFoMi41QzkuNywxMy40LDE3LDYsMjUuOSw2Jy8lM0UlM0MvZyUzRSUzQy9zdmclM0VcXFwiKSBuby1yZXBlYXRcIlxuXG5jb25zdCBhZGRTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0Nwb2x5Z29uIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIHBvaW50cz0nMzEuMiwyOCAyNC44LDI4IDI0LjgsMzIuOCAyMCwzMi44IDIwLDM5LjIgMjQuOCwzOS4yIDI0LjgsNDQgMzEuMiw0NCAzMS4yLDM5LjIgMzYsMzkuMiAzNiwzMi44IDMxLjIsMzIuOCAnLyUzRSAlM0Nwb2x5Z29uIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZicgcG9pbnRzPScxMiwzMiAxMiw0IDMyLjMsMjQuMyAyMCwyNC4zIDE5LjcsMjQuNiAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPScxMy44LDguMiAxMy44LDI3LjggMTksMjIuOCAxOS4yLDIyLjUgMjgsMjIuNSAnLyUzRSUzQ3BvbHlsaW5lIHBvaW50cz0nMjkuNiwyOS42IDI5LjYsMzQuNCAzNC40LDM0LjQgMzQuNCwzNy42IDI5LjYsMzcuNiAyOS42LDQyLjQgMjYuNCw0Mi40IDI2LjQsMzcuNiAyMS42LDM3LjYgMjEuNiwzNC40IDI2LjQsMzQuNCAyNi40LDI5LjYgMjkuNiwyOS42ICAnLyUzRSUzQy9zdmclM0VcXFwiKSBuby1yZXBlYXRcIlxuXG5jb25zdCByZW1vdmVTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0NyZWN0IHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIHg9JzIwJyB5PSczMi44JyB3aWR0aD0nMTYnIGhlaWdodD0nNi40Jy8lM0UlM0Nwb2x5Z29uICBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBwb2ludHM9JzEyLDMyIDEyLDQgMzIuMywyNC4zIDIwLDI0LjMgMTkuNywyNC42ICcvJTNFJTNDcG9seWdvbiBwb2ludHM9JzEzLjgsOC4yIDEzLjgsMjcuOCAxOSwyMi44IDE5LjIsMjIuNSAyOCwyMi41ICcvJTNFJTNDcG9seWxpbmUgcG9pbnRzPSczNC40LDM0LjQgMzQuNCwzNy42IDIxLjYsMzcuNiAyMS42LDM0LjQgJy8lM0UlM0Mvc3ZnJTNFXFxcIikgbm8tcmVwZWF0XCJcblxuY29uc3QgcmVwb3NpdGlvblN2ZyA9IFwidXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDQ4IDQ4JyUzRSUzQ3BhdGggc3R5bGU9J2ZpbGw6JTIzZmZmZmZmOycgZD0nTTI0LDE3LjVjLTMuNiwwLTYuNSwyLjktNi41LDYuNXMyLjksNi41LDYuNSw2LjVzNi41LTIuOSw2LjUtNi41UzI3LjYsMTcuNSwyNCwxNy41TDI0LDE3LjV6Jy8lM0UlM0NwYXRoIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIGQ9J00yNCw0TDQsMjRsMjAsMjBsMjAtMjBMMjQsNHogTTMxLjUsMzEuNWgtMTV2LTE1aDE1VjMxLjV6Jy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMTcsMzQgMjQsNDAuNSAzMSwzNCAgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMzEsMTQgMjQsNy41IDE3LDE0ICAgICAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPScxNCwxNyA3LjUsMjQgMTQsMzEgICAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPSczNCwzMSA0MC41LDI0IDM0LDE3ICAgICcvJTNFJTNDcGF0aCBkPSdNMjQsMjBjMi4yLDAsNCwxLjgsNCw0cy0xLjgsNC00LDRzLTQtMS44LTQtNFMyMS44LDIwLDI0LDIwJy8lM0UlM0Mvc3ZnJTNFXFxcIikgbm8tcmVwZWF0XCJcblxuY29uc3QgRXZlbnRDb25zdGFudHMgPSB7XG4gIFNFTEVDVElPTl9DSEFOR0VEOiBcImRyYXc6c2VsZWN0aW9uQ2hhbmdlZFwiLFxuICBEUkFHX0JFR0lOOiBcImRyYXc6ZHJhZzpiZWdpblwiLFxuICBEUkFHX0VORDogXCJkcmF3OmRyYWc6ZW5kXCJcbn1cblxuY29uc3QgQ29uc3RhbnRzID0ge1xuICBTVkdfT0ZGU0VUOiAtMTQsXG4gIFFVSUNLX0NMSUNLX1RJTUU6IDUwMCxcbiAgUklHSFRfQU5HTEU6IDkwLFxuICBTVFJBSUdIVF9BTkdMRTogMTgwLFxuICBGT1JUWV9GSVZFX0FOR0xFOiA0NVxufVxuXG5jb25zdCB0bXBQdDEgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuY29uc3QgdG1wUHQyID0gUG9pbnQyZC5jcmVhdGUoMCwgMClcblxuY29uc3QgZGVmYXVsdFhmb3JtU3R5bGUgPSB7XG4gIGZpbGxDb2xvcjogXCJ3aGl0ZVwiLFxuICBzdHJva2VDb2xvcjogXCJibGFja1wiLFxuICBzdHJva2VXaWR0aDogMlxufVxuXG5mdW5jdGlvbiBpbkNhbnZhcyhjYW52YXMsIHgsIHkpIHtcbiAgY29uc3QgZG9tcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBsZXQgbG9jYWxYID0gMFxuICBsZXQgbG9jYWxZID0gMFxuICBjb25zdCBpc0luQ2FudmFzID0gKChsb2NhbFggPSB4IC0gZG9tcmVjdC5sZWZ0IC0gY2FudmFzLmNsaWVudExlZnQpID49IDAgJiYgbG9jYWxYIDw9IGNhbnZhcy5jbGllbnRXaWR0aCAmJiAobG9jYWxZID0geSAtIGRvbXJlY3QudG9wIC0gY2FudmFzLmNsaWVudFRvcCkgPj0gMCAmJiBsb2NhbFkgPD0gY2FudmFzLmNsaWVudEhlaWdodClcbiAgcmV0dXJuIGlzSW5DYW52YXNcbn1cblxuZnVuY3Rpb24gZ2V0TG9jYWxNb3VzZVBvcyhvdXQsIGVsZW0sIGV2ZW50KSB7XG4gIGNvbnN0IGRvbXJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIG91dFswXSA9IGV2ZW50LmNsaWVudFggLSBkb21yZWN0LmxlZnQgLSBlbGVtLmNsaWVudExlZnRcbiAgb3V0WzFdID0gZXZlbnQuY2xpZW50WSAtIGRvbXJlY3QudG9wIC0gZWxlbS5jbGllbnRUb3Bcbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtU2VsZWN0ZWRTaGFwZShjYW52YXMsIGV2ZW50LCBzZWxlY3RlZEluZm8sIGNhbWVyYSkge1xuICBnZXRMb2NhbE1vdXNlUG9zKHRtcFB0MSwgY2FudmFzLCBldmVudClcbiAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0bXBQdDIsIHRtcFB0MSwgY2FtZXJhLnNjcmVlblRvV29ybGRNYXRyaXgpXG4gIGNvbnN0IHNoYXBlID0gc2VsZWN0ZWRJbmZvLnNoYXBlXG4gIGlmIChzaGFwZSBpbnN0YW5jZW9mIFhmb3JtU2hhcGUpIHtcbiAgICBJbnRlcmFjdFV0aWxzLnRyYW5zZm9ybVhmb3JtU2hhcGUoc2hhcGUsIHNlbGVjdGVkSW5mbywgdG1wUHQxLCB0bXBQdDIsIGNhbWVyYSlcbiAgfSBlbHNlIGlmIChzaGFwZSBpbnN0YW5jZW9mIFZlcnRFZGl0YWJsZVNoYXBlKSB7XG4gICAgSW50ZXJhY3RVdGlscy50cmFuc2xhdGVWZXJ0KHNoYXBlLCBzZWxlY3RlZEluZm8sIHRtcFB0MSwgdG1wUHQyLCBjYW1lcmEpXG4gIH0gZWxzZSB7XG4gICAgSW50ZXJhY3RVdGlscy50cmFuc2xhdGVTaGFwZShzaGFwZSwgc2VsZWN0ZWRJbmZvLCB0bXBQdDEsIHRtcFB0MiwgY2FtZXJhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50S2V5c1RvU2VsZWN0ZWRJbmZvKGV2ZW50LCBzZWxlY3RlZEluZm8pIHtcbiAgc2VsZWN0ZWRJbmZvLmtleXMgPSB7XG4gICAgYWx0S2V5OiBldmVudC5hbHRLZXksXG4gICAgY3RybEtleTogZXZlbnQuY3RybEtleSxcbiAgICBzaGlmdEtleTogZXZlbnQuc2hpZnRLZXksXG4gICAgbWV0YUtleTogZXZlbnQubWV0YUtleVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAoc2VsZWN0aW9uTWFwKSB7XG4gIGNvbnN0IHNlbGVjdGVkT2JqcyA9IFtdXG4gIHNlbGVjdGlvbk1hcC5mb3JFYWNoKChzdWJzaGFwZSwgc2hhcGUpID0+IHtcbiAgICBzZWxlY3RlZE9ianMucHVzaChzaGFwZSlcbiAgfSlcbiAgcmV0dXJuIHNlbGVjdGVkT2Jqc1xufVxuXG5mdW5jdGlvbiBzZWxlY3RTaGFwZShzZWxlY3RlZFNoYXBlLCBzb3J0ZWRTaGFwZXMsIGN1cnJTZWxlY3RlZFNoYXBlcywgc2VsZWN0U3R5bGUsIHhmb3JtU3R5bGUsIHNlbGVjdE9wdHMpIHtcbiAgY29uc3QgZmlyZU9iamVjdCA9IHtcbiAgICB1bnNlbGVjdGVkU2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKGN1cnJTZWxlY3RlZFNoYXBlcylcbiAgfVxuICBjbGVhclNlbGVjdGVkU2hhcGVzKGN1cnJTZWxlY3RlZFNoYXBlcylcbiAgc2VsZWN0ZWRTaGFwZS5zYXZlKClcbiAgY29uc3QgbWF4WiA9IHNvcnRlZFNoYXBlc1tzb3J0ZWRTaGFwZXMubGVuZ3RoIC0gMV0uekluZGV4XG4gIHNlbGVjdGVkU2hhcGUuekluZGV4ID0gbWF4WiArIDFcbiAgQmFzaWNTdHlsZS5jb3B5QmFzaWNTdHlsZShzZWxlY3RTdHlsZSwgc2VsZWN0ZWRTaGFwZSlcbiAgc2VsZWN0ZWRTaGFwZS5zZWxlY3RlZCA9IHRydWVcbiAgICAvLyBjb25zdCBkaW1lbnNpb25zID0gc2VsZWN0ZWRTaGFwZS5nZXREaW1lbnNpb25zKClcblxuICBsZXQgbmV3U2VsZWN0U2hhcGUgPSBudWxsXG4gIGlmIChzZWxlY3RPcHRzLnNjYWxhYmxlIHx8IHNlbGVjdE9wdHMucm90YXRhYmxlKSB7XG4gICAgbmV3U2VsZWN0U2hhcGUgPSBuZXcgWGZvcm1TaGFwZSh4Zm9ybVN0eWxlIHx8IGRlZmF1bHRYZm9ybVN0eWxlLCBzZWxlY3RPcHRzKVxuICAgIHNlbGVjdGVkU2hhcGUuYWRkQ2hpbGRYZm9ybShuZXdTZWxlY3RTaGFwZSlcbiAgfVxuICBjdXJyU2VsZWN0ZWRTaGFwZXMuc2V0KHNlbGVjdGVkU2hhcGUsIG5ld1NlbGVjdFNoYXBlKVxuXG4gIGZpcmVPYmplY3Quc2VsZWN0ZWRTaGFwZXMgPSBbc2VsZWN0ZWRTaGFwZV1cbiAgcmV0dXJuIGZpcmVPYmplY3Rcbn1cblxuZnVuY3Rpb24gY2xlYXJTZWxlY3RlZFNoYXBlcyhzZWxlY3RlZFNoYXBlTWFwKSB7XG4gIHNlbGVjdGVkU2hhcGVNYXAuZm9yRWFjaCgoc2VsZWN0ZWRTaGFwZSwgc2hhcGUpID0+IHtcbiAgICBzaGFwZS5yZXN0b3JlKClcbiAgICBzaGFwZS5zZWxlY3RlZCA9IGZhbHNlXG4gICAgc2hhcGUucmVtb3ZlQ2hpbGRYZm9ybShzZWxlY3RlZFNoYXBlKVxuICB9KVxuICBzZWxlY3RlZFNoYXBlTWFwLmNsZWFyKClcbn1cblxuZnVuY3Rpb24gY2xlYXJTcGVjaWZpY1NoYXBlcyhzZWxlY3RlZFNoYXBlTWFwLCBzaGFwZXMpIHtcbiAgY29uc3QgY2xlYXJlZFNoYXBlcyA9IFtdXG4gIHNoYXBlcy5mb3JFYWNoKHNoYXBlID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZFNoYXBlID0gc2VsZWN0ZWRTaGFwZU1hcC5nZXQoc2hhcGUpXG4gICAgc2hhcGUucmVzdG9yZSgpXG4gICAgc2hhcGUuc2VsZWN0ZWQgPSBmYWxzZVxuICAgIHNoYXBlLnJlbW92ZUNoaWxkWGZvcm0oc2VsZWN0ZWRTaGFwZSlcbiAgICBzZWxlY3RlZFNoYXBlTWFwLmRlbGV0ZShzaGFwZSlcbiAgICBjbGVhcmVkU2hhcGVzLnB1c2goc2hhcGUpXG4gIH0pXG4gIHJldHVybiBjbGVhcmVkU2hhcGVzXG59XG5cbmNvbnN0IGhpZGVDdXJzb3IgPSAoKSA9PiB7XG4gIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3Vyc29yXCIpXG4gIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICBjdXJzb3Iuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gIH1cbn1cblxuY29uc3Qgc2hvd0N1cnNvciA9ICgpID0+IHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJzb3JcIilcbiAgaWYgKGN1cnNvciAhPT0gbnVsbCkge1xuICAgIGN1cnNvci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG4gIH1cbn1cblxuY29uc3QgaGlkZUN1cnNvcldpdGhQb2ludGVyID0gKGUpID0+IHtcbiAgZS50YXJnZXQucGFyZW50Tm9kZS5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIlxuICBoaWRlQ3Vyc29yKClcbn1cblxuY29uc3Qgc2hvd0N1cnNvcldpdGhQb2ludGVyID0gKGUpID0+IHtcbiAgZS50YXJnZXQucGFyZW50Tm9kZS5zdHlsZS5jdXJzb3IgPSBcIm5vbmVcIlxuICBzaG93Q3Vyc29yKClcbn1cblxuLy8gdW5kZXJzdGFuZHMgaG93IHRvIHJldHVybiBtb3VzZSBjb29yZGluYXRlcyBhcyBhbiBvYmplY3QgaW4gdGhlIGZvcm1hdCB7eDogPFgtQ09PUkQ+LCB5OiA8WS1DT09SRD59XG4vLyBhY2NlcHRzIGEgbW91c2UgZXZlbnQgYW5kIGEgRE9NIGVsZW1lbnQgYXMgYXJndW1lbnRzXG5mdW5jdGlvbiBnZXRNb3VzZUNvb3JkaW5hdGVzKGUsIHRhcmdldCkge1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAke2AjJHt0YXJnZXQuaWR9IGNhbnZhc2B9YClcblxuICBjb25zdCBjb29yZHMgPSB7XG4gICAgeDogZS5vZmZzZXRYICsgY2FudmFzLm9mZnNldExlZnQsXG4gICAgeTogZS5vZmZzZXRZICsgY2FudmFzLm9mZnNldFRvcFxuICB9XG5cbiAgcmV0dXJuIGNvb3Jkc1xufVxuXG4vLyB1bmRlcnN0YW5kcyBob3cgdG8gYXBwZW5kIGN1c3RvbSBjdXJzb3JzIHRvIHRoZSBET01cbi8vIGFjY2VwdHMgYSBtb3VzZSBldmVudCwgYSBET00gZWxlbWVudCwgYSBjdXJzb3JTdHlsZSwgYW5kIHBpeGVsIG9mZnNldHMgYXMgYXJndW1lbnRzXG5mdW5jdGlvbiBhcHBlbmRDdXN0b21DdXJzb3IoX2V2ZW50LCB0YXJnZXQsIGN1cnNvclN0eWxlLCBvZmZzZXRYID0gQ29uc3RhbnRzLlNWR19PRkZTRVQsIG9mZnNldFkgPSBDb25zdGFudHMuU1ZHX09GRlNFVCkge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnNvclwiKVxuICBjb25zdCBtb3VzZSA9IGdldE1vdXNlQ29vcmRpbmF0ZXMoX2V2ZW50LCB0YXJnZXQpXG5cbiAgaWYgKGN1cnNvciA9PT0gbnVsbCkge1xuICAgIGNvbnN0IG5ld0N1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpXG4gICAgbmV3Q3Vyc29yLnNldEF0dHJpYnV0ZShcImlkXCIsIFwiY3Vyc29yXCIpXG4gICAgbmV3Q3Vyc29yLnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIGBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogJHtgJHttb3VzZS55fXB4YH07IGxlZnQ6ICR7YCR7bW91c2UueH1weGB9OyB3aWR0aDogMjhweDsgaGVpZ2h0OiAyOHB4OyBiYWNrZ3JvdW5kOiAke2N1cnNvclN0eWxlfTsgY3Vyc29yOiBub25lOyB6LWluZGV4OiAxMDsgcG9pbnRlci1ldmVudHM6IG5vbmU7IHRyYW5zZm9ybTogdHJhbnNsYXRlKCR7b2Zmc2V0WH1weCwgJHtvZmZzZXRZfXB4KWApXG4gICAgdGFyZ2V0LmFwcGVuZENoaWxkKG5ld0N1cnNvcilcbiAgfSBlbHNlIGlmIChjdXJzb3Iuc3R5bGUuYmFja2dyb3VuZCA9PT0gY3Vyc29yU3R5bGUpIHtcbiAgICB1cGRhdGVDdXJzb3JQb3NpdGlvbihfZXZlbnQsIHRhcmdldClcbiAgfSBlbHNlIHtcbiAgICBjdXJzb3Iuc3R5bGUuYmFja2dyb3VuZCA9IGN1cnNvclN0eWxlXG4gICAgdXBkYXRlQ3Vyc29yUG9zaXRpb24oX2V2ZW50LCB0YXJnZXQpXG4gIH1cbn1cblxuLy8gdW5kZXJzdGFuZHMgaG93IHRvIHJlbW92ZSB0aGUgY3VzdG9tIGN1cnNvciBmcm9tIHRoZSBET01cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbUN1cnNvcigpIHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJzb3JcIilcbiAgaWYgKGN1cnNvciAhPT0gbnVsbCkge1xuICAgIGN1cnNvci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGN1cnNvcilcbiAgfVxufVxuXG4vLyB1bmRlcnN0YW5kcyBob3cgdG8gY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VzdG9tIGN1cnNvciBvbiB0aGUgcGFnZVxuLy8gYWNjZXB0cyBhIG1vdXNlIGV2ZW50IGFuZCBhIERPTSBlbGVtZW50IGFzIGFyZ3VtZW50c1xuZnVuY3Rpb24gdXBkYXRlQ3Vyc29yUG9zaXRpb24oX2V2ZW50LCB0YXJnZXQpIHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJzb3JcIilcbiAgY29uc3QgbW91c2UgPSBnZXRNb3VzZUNvb3JkaW5hdGVzKF9ldmVudCwgdGFyZ2V0KVxuXG4gIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gYCR7YCR7bW91c2UueX1weGB9YFxuICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gYCR7YCR7bW91c2UueH1weGB9YFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlQnVpbGRlciBleHRlbmRzIERyYXdFbmdpbmUge1xuICBfbW91c2Vkb3duQ0IoZXZlbnQpIHtcbiAgICBpZiAoIWluQ2FudmFzKHRoaXMuX2RyYXdDYW52YXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpbWVyID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCB0aGlzLl9jYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIGxldCBpID0gLTFcbiAgICBsZXQgc2VsZWN0ZWRTaGFwZSA9IG51bGxcbiAgICBsZXQgc2VsZWN0ZWRJbmZvID0gbnVsbFxuICAgIGZvciAoaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGVzW2ldKVxuICAgICAgaWYgKHNoYXBlc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZFNoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgc2VsZWN0ZWRJbmZvID0gc2hhcGVJbmZvXG4gICAgICAgIGxldCBoaXRJbmZvID0gbnVsbFxuICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSAmJiAoaGl0SW5mbyA9IHNlbGVjdGVkU2hhcGUuY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpLmhpdCkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZFNoYXBlIGluc3RhbmNlb2YgVmVydEVkaXRhYmxlU2hhcGUgJiYgZXZlbnQuYWx0S2V5ICYmIGhpdEluZm8uY29udHJvbEluZGV4IDwgc2hhcGVzW2ldLm51bVZlcnRzKSB7XG4gICAgICAgICAgICBzaGFwZXNbaV0ucmVtb3ZlVmVydChoaXRJbmZvLmNvbnRyb2xJbmRleClcbiAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUgPSBudWxsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsWGZvcm0gPSBzZWxlY3RlZFNoYXBlLnBhcmVudC5sb2NhbFhmb3JtXG4gICAgICAgICAgICBjb25zdCBpbnZMb2NhbFhmb3JtID0gTWF0MmQuY2xvbmUobG9jYWxYZm9ybSlcbiAgICAgICAgICAgIE1hdDJkLmludmVydChpbnZMb2NhbFhmb3JtLCBpbnZMb2NhbFhmb3JtKVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPYmpQb3MgPSBQb2ludDJkLmNsb25lKHRtcFB0MilcbiAgICAgICAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQoc3RhcnRPYmpQb3MsIHN0YXJ0T2JqUG9zLCBpbnZMb2NhbFhmb3JtKVxuICAgICAgICAgICAgdGhpcy5fZHJhZ0luZm8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgcm90YXRlOiBCb29sZWFuKGhpdEluZm8ucm90YXRlKSxcbiAgICAgICAgICAgICAgY29udHJvbEluZGV4OiBoaXRJbmZvLmNvbnRyb2xJbmRleCxcbiAgICAgICAgICAgICAgc3RhcnRPYmplY3RQb3M6IHN0YXJ0T2JqUG9zLFxuICAgICAgICAgICAgICB3b3JsZFRvT2JqZWN0TWF0cml4OiBpbnZMb2NhbFhmb3JtLFxuICAgICAgICAgICAgICBzdGFydExvY2FsUG9zOiBzZWxlY3RlZFNoYXBlLnBhcmVudC5nZXRQb3NpdGlvbigpLFxuICAgICAgICAgICAgICBzdGFydExvY2FsU2NhbGU6IHNlbGVjdGVkU2hhcGUucGFyZW50LmdldFNjYWxlKCksXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYWxSb3Q6IHNlbGVjdGVkU2hhcGUucGFyZW50LmdldFJvdGF0aW9uKCksXG4gICAgICAgICAgICAgIHNoYXBlV2lkdGg6IHNlbGVjdGVkU2hhcGUucGFyZW50LndpZHRoLFxuICAgICAgICAgICAgICBzaGFwZUhlaWdodDogc2VsZWN0ZWRTaGFwZS5wYXJlbnQuaGVpZ2h0XG4gICAgICAgICAgICB9LCBzZWxlY3RlZEluZm8pXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLmNvbnRhaW5zUG9pbnQodG1wUHQxLCB0bXBQdDIsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHRoaXMuX2RyYXdDdHgpKSB7XG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZSA9IHNoYXBlc1tpXVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgaWYgKHNoYXBlSW5mby5zZWxlY3RhYmxlICYmIHNoYXBlc1tpXS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkge1xuICAgICAgLy8gICBzZWxlY3RlZFNoYXBlID0gc2hhcGVzW2ldXG4gICAgICAvLyAgIHNlbGVjdGVkSW5mbyA9IHNoYXBlSW5mb1xuICAgICAgLy8gICBjb25zdCBzZWxlY3RFdmVudE9iaiA9IHNlbGVjdFNoYXBlKHNlbGVjdGVkU2hhcGUsIHNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzZWxlY3RlZEluZm8pXG4gICAgICAvLyAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwgc2VsZWN0RXZlbnRPYmopXG4gICAgICAvLyAgIGJyZWFrXG4gICAgICAvLyB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwICYmIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNpemUpIHtcbiAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgICAgIHVuc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpLFxuICAgICAgICAgIHNlbGVjdGVkU2hhcGVzOiBbXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ0luZm8gPSBudWxsXG4gICAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRTaGFwZSAmJiBzZWxlY3RlZEluZm8gJiYgKHNlbGVjdGVkSW5mby5tb3ZhYmxlIHx8IHNlbGVjdGVkSW5mby5yb3RhdGFibGUgfHwgc2VsZWN0ZWRJbmZvLnNjYWxhYmxlKSkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgJHtgIyR7dGhpcy5fcGFyZW50LmlkfSA+IGNhbnZhc2B9YClcbiAgICAgIGlmIChjYW52YXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBoaWRlQ3Vyc29yKVxuICAgICAgICB0aGlzLl9wYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBzaG93Q3Vyc29yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBoaWRlQ3Vyc29yV2l0aFBvaW50ZXIpXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHNob3dDdXJzb3JXaXRoUG9pbnRlcilcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZHJhZ0luZm8gJiYgc2VsZWN0ZWRJbmZvLm1vdmFibGUpIHtcbiAgICAgICAgdGhpcy5fZHJhZ0luZm8gPSB7XG4gICAgICAgICAgc3RhcnRMb2NhbFBvczogc2VsZWN0ZWRTaGFwZS5nZXRQb3NpdGlvbigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RyYWdJbmZvKSB7XG4gICAgICAgIHRoaXMuX2RyYWdJbmZvLnNoYXBlID0gc2VsZWN0ZWRTaGFwZVxuICAgICAgICB0aGlzLl9kcmFnSW5mby5zdGFydFBvcyA9IFBvaW50MmQuY2xvbmUodG1wUHQxKVxuICAgICAgICB0aGlzLl9kcmFnSW5mby5zdGFydFdvcmxkUG9zID0gUG9pbnQyZC5jbG9uZSh0bXBQdDIpXG4gICAgICAgIHRoaXMuX2RyYWdJbmZvLm9iamVjdFRvV29ybGRNYXRyaXggPSBNYXQyZC5jbG9uZShzZWxlY3RlZFNoYXBlLmdsb2JhbFhmb3JtKVxuICAgICAgICBhZGRFdmVudEtleXNUb1NlbGVjdGVkSW5mbyhldmVudCwgdGhpcy5fZHJhZ0luZm8pXG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5EUkFHX0JFR0lOLCB7XG4gICAgICAgICAgc2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgfVxuXG4gIF9tb3VzZXVwQ0IoZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fZHJhZ0luZm8gJiYgdGhpcy5fZHJhZ0luZm8uc2hhcGUpIHtcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAke2AjJHt0aGlzLl9wYXJlbnQuaWR9ID4gY2FudmFzYH1gKVxuICAgICAgaWYgKGNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGhpZGVDdXJzb3IpXG4gICAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHNob3dDdXJzb3IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3V0XCIsIGhpZGVDdXJzb3JXaXRoUG9pbnRlcilcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgc2hvd0N1cnNvcldpdGhQb2ludGVyKVxuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ0luZm8gPSBudWxsXG4gICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuRFJBR19FTkQsIHtcbiAgICAgICAgc2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy50aW1lciA8IENvbnN0YW50cy5RVUlDS19DTElDS19USU1FKSB7XG4gICAgICAvLyB0aGlzIGlzIGEgcmVsYXRpdmVseSBxdWljayBjbGlja1xuICAgICAgUG9pbnQyZC5zZXQodG1wUHQxLCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKVxuICAgICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0bXBQdDIsIHRtcFB0MSwgdGhpcy5fY2FtZXJhLnNjcmVlblRvV29ybGRNYXRyaXgpXG4gICAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc29ydGVkU2hhcGVzXG4gICAgICBsZXQgc2VsZWN0ZWRTaGFwZSA9IG51bGxcbiAgICAgIGxldCBzZWxlY3RlZEluZm8gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gc2hhcGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHNlbGVjdGVkSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgaWYgKHNlbGVjdGVkSW5mby5zZWxlY3RhYmxlICYmIHNoYXBlc1tpXS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkge1xuICAgICAgICAgIHNlbGVjdGVkU2hhcGUgPSBzaGFwZXNbaV1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWRTaGFwZSAmJiAhc2VsZWN0ZWRTaGFwZS5zZWxlY3RlZCkge1xuICAgICAgICBjb25zdCBzZWxlY3RFdmVudE9iaiA9IHNlbGVjdFNoYXBlKHNlbGVjdGVkU2hhcGUsIHNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzZWxlY3RlZEluZm8pXG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwgc2VsZWN0RXZlbnRPYmopXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX21vdXNlbW92ZUNCKGV2ZW50KSB7XG4gICAgaWYgKCEoaW5DYW52YXModGhpcy5fZHJhd0NhbnZhcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpICYmICF0aGlzLl9kcmFnSW5mbykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RyYWdJbmZvICYmIHRoaXMuX2RyYWdJbmZvLnNoYXBlKSB7XG4gICAgICB1cGRhdGVDdXJzb3JQb3NpdGlvbihldmVudCwgdGhpcy5fcGFyZW50KVxuICAgICAgYWRkRXZlbnRLZXlzVG9TZWxlY3RlZEluZm8oZXZlbnQsIHRoaXMuX2RyYWdJbmZvKVxuICAgICAgdHJhbnNmb3JtU2VsZWN0ZWRTaGFwZSh0aGlzLl9kcmF3Q2FudmFzLCBldmVudCwgdGhpcy5fZHJhZ0luZm8sIHRoaXMuX2NhbWVyYSlcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgfSBlbHNlIGlmICghZXZlbnQuYnV0dG9ucyAmJiB0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICBQb2ludDJkLnNldCh0bXBQdDEsIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpXG4gICAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCB0aGlzLl9jYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXRyaXggPSB0aGlzLl9jYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgICAgY29uc3Qgc2hhcGVzID0gdGhpcy5zb3J0ZWRTaGFwZXNcbiAgICAgIGxldCBpID0gMFxuICAgICAgY29uc3QgZmxpcHkgPSB0aGlzLl9jYW1lcmEuaXNZRmxpcHBlZCgpXG4gICAgICBmb3IgKGkgPSBzaGFwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgaWYgKHNoYXBlc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdEluZm8gPSB0aGlzLl9vYmplY3RzLmdldChzaGFwZXNbaV0pXG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRTaGFwZSA9IHRoaXMuX3NlbGVjdGVkU2hhcGVzLmdldChzaGFwZXNbaV0pXG4gICAgICAgICAgbGV0IGhpdEluZm8gPSBudWxsXG4gICAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwibm9uZVwiXG4gICAgICAgICAgLy8gZm9yRWFjaCBub3Qgc3VwcG9ydGVkIG9uIG5vZGVsaXN0IGluIElFL0VkZ2VcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5jdXJzb3IgPSBcIm5vbmVcIlxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxlY3RlZFNoYXBlICYmIChoaXRJbmZvID0gc2VsZWN0ZWRTaGFwZS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkuaGl0KSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSBpbnN0YW5jZW9mIFhmb3JtU2hhcGUpIHtcbiAgICAgICAgICAgICAgaWYgKGhpdEluZm8ucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZ3JlZXMgPSBzaGFwZXNbaV0uZ2V0Um90YXRpb24oKVxuICAgICAgICAgICAgICAgIGlmIChmbGlweSkge1xuICAgICAgICAgICAgICAgICAgZGVncmVlcyAqPSAtMVxuICAgICAgICAgICAgICAgICAgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgLT0gQ29uc3RhbnRzLlJJR0hUX0FOR0xFXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgKz0gQ29uc3RhbnRzLlNUUkFJR0hUX0FOR0xFXG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgKz0gQ29uc3RhbnRzLlJJR0hUX0FOR0xFXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgZGVncmVlcyAtPSBDb25zdGFudHMuUklHSFRfQU5HTEVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBkZWdyZWVzICs9IENvbnN0YW50cy5TVFJBSUdIVF9BTkdMRVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAgICAgICAgICAgICBkZWdyZWVzICs9IENvbnN0YW50cy5SSUdIVF9BTkdMRVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYCR7cm90YXRlU3ZnLnJlcGxhY2UoLzxkZWdyZWVzPi9nLCBgJHtkZWdyZWVzfWApfWApXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPCA0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICAgICAgICAgIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMCB8fCBoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBgJHtzY2FsZVN2Zy5yZXBsYWNlKC88ZGVncmVlcz4vZywgYCR7LXNoYXBlc1tpXS5nZXRSb3RhdGlvbigpIC0gQ29uc3RhbnRzLkZPUlRZX0ZJVkVfQU5HTEV9YCl9YClcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAxIHx8IGhpdEluZm8uY29udHJvbEluZGV4ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYCR7c2NhbGVTdmcucmVwbGFjZSgvPGRlZ3JlZXM+L2csIGAkey1zaGFwZXNbaV0uZ2V0Um90YXRpb24oKSArIENvbnN0YW50cy5GT1JUWV9GSVZFX0FOR0xFfWApfWApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBgJHtzY2FsZVN2Zy5yZXBsYWNlKC88ZGVncmVlcz4vZywgYCR7LXNoYXBlc1tpXS5nZXRSb3RhdGlvbigpfWApfWApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ3VzdG9tQ3Vyc29yKGV2ZW50LCB0aGlzLl9wYXJlbnQsIGAke3NjYWxlU3ZnLnJlcGxhY2UoLzxkZWdyZWVzPi9nLCBgJHstc2hhcGVzW2ldLmdldFJvdGF0aW9uKCkgKyBDb25zdGFudHMuUklHSFRfQU5HTEV9YCl9YClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZFNoYXBlIGluc3RhbmNlb2YgVmVydEVkaXRhYmxlU2hhcGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwibm9uZVwiXG4gICAgICAgICAgICAgIC8vIGZvckVhY2ggbm90IHN1cHBvcnRlZCBvbiBub2RlbGlzdCBpbiBJRS9FZGdlXG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5jdXJzb3IgPSBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID49IHNoYXBlc1tpXS5udW1WZXJ0cykge1xuICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBhZGRTdmcsIC04LCAtNikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ3VzdG9tQ3Vyc29yKGV2ZW50LCB0aGlzLl9wYXJlbnQsIHJlbW92ZVN2ZywgLTgsIC02KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgcmVwb3NpdGlvblN2ZywgQ29uc3RhbnRzLlNWR19PRkZTRVQsIENvbnN0YW50cy5TVkdfT0ZGU0VUKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdEluZm8gJiYgc2VsZWN0SW5mby5tb3ZhYmxlKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3Vyc29yXCIpXG4gICAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJzb3IpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwibW92ZVwiXG4gICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICByZW1vdmVDdXN0b21DdXJzb3IoKVxuICAgICAgICB0aGlzLl9wYXJlbnQuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCJcbiAgICAgICAgLy8gZm9yRWFjaCBub3Qgc3VwcG9ydGVkIG9uIG5vZGVsaXN0IGluIElFL0VkZ2VcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgICAgICAgaWYgKHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9jbGlja0NCKCkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIF9kYmxjbGlja0NCKGV2ZW50KSB7XG4gICAgaWYgKCFpbkNhbnZhcyh0aGlzLl9kcmF3Q2FudmFzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgUG9pbnQyZC5zZXQodG1wUHQxLCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKVxuICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodG1wUHQyLCB0bXBQdDEsIHRoaXMuX2NhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4KVxuICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXRyaXggPSB0aGlzLl9jYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc29ydGVkU2hhcGVzXG4gICAgbGV0IGkgPSAtMVxuICAgIGZvciAoaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGVzW2ldKVxuICAgICAgaWYgKHNoYXBlSW5mby5zZWxlY3RhYmxlICYmIHNoYXBlc1tpXS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkge1xuICAgICAgICBpZiAoc2hhcGVJbmZvLmVkaXRhYmxlICYmIHNoYXBlc1tpXSBpbnN0YW5jZW9mIFBvbHlMaW5lKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRTaGFwZSA9IHNoYXBlc1tpXVxuICAgICAgICAgIGxldCBkb1hmb3JtID0gZmFsc2VcbiAgICAgICAgICBpZiAoc2hhcGVzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbnRlcmFjdGl2ZVNoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgICAgIGlmIChpbnRlcmFjdGl2ZVNoYXBlKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUucmVzdG9yZSgpXG4gICAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUucmVtb3ZlQ2hpbGRYZm9ybShpbnRlcmFjdGl2ZVNoYXBlKVxuICAgICAgICAgICAgICBkb1hmb3JtID0gIShpbnRlcmFjdGl2ZVNoYXBlIGluc3RhbmNlb2YgWGZvcm1TaGFwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxlY3RlZFNoYXBlLnNlbGVjdGVkID0gdHJ1ZVxuICAgICAgICAgIHNlbGVjdGVkU2hhcGUuc2F2ZSgpXG4gICAgICAgICAgY29uc3QgbWF4WiA9IHNoYXBlc1tzaGFwZXMubGVuZ3RoIC0gMV0uekluZGV4XG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZS56SW5kZXggPSBtYXhaICsgMVxuICAgICAgICAgIEJhc2ljU3R5bGUuY29weUJhc2ljU3R5bGUodGhpcy5fc2VsZWN0U3R5bGUsIHNlbGVjdGVkU2hhcGUpXG4gICAgICAgICAgbGV0IG5ld1NlbGVjdFNoYXBlID0gbnVsbFxuICAgICAgICAgIGlmIChkb1hmb3JtKSB7XG4gICAgICAgICAgICBpZiAoc2hhcGVJbmZvLnJvdGF0YWJsZSB8fCBzaGFwZUluZm8uc2NhbGFibGUpIHtcbiAgICAgICAgICAgICAgbmV3U2VsZWN0U2hhcGUgPSBuZXcgWGZvcm1TaGFwZSh0aGlzLl94Zm9ybVN0eWxlIHx8IGRlZmF1bHRYZm9ybVN0eWxlLCBzaGFwZUluZm8pXG4gICAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUuYWRkQ2hpbGRYZm9ybShuZXdTZWxlY3RTaGFwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3U2VsZWN0U2hhcGUgPSBuZXcgVmVydEVkaXRhYmxlU2hhcGUoc2VsZWN0ZWRTaGFwZSwgdGhpcy5feGZvcm1TdHlsZSlcbiAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUuYWRkQ2hpbGRYZm9ybShuZXdTZWxlY3RTaGFwZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fc2VsZWN0ZWRTaGFwZXMuc2V0KHNlbGVjdGVkU2hhcGUsIG5ld1NlbGVjdFNoYXBlKVxuICAgICAgICB9IGVsc2UgaWYgKCFzaGFwZXNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RFdmVudE9iaiA9IHNlbGVjdFNoYXBlKHNoYXBlc1tpXSwgc2hhcGVzLCB0aGlzLl9zZWxlY3RlZFNoYXBlcywgdGhpcy5fc2VsZWN0U3R5bGUsIHRoaXMuX3hmb3JtU3R5bGUsIHNoYXBlSW5mbylcbiAgICAgICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuU0VMRUNUSU9OX0NIQU5HRUQsIHNlbGVjdEV2ZW50T2JqKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwICYmIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNpemUpIHtcbiAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgICAgIHVuc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpLFxuICAgICAgICAgIHNlbGVjdGVkU2hhcGVzOiBbXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ0luZm8gPSBudWxsXG4gICAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBfbW91c2VvdmVyQ0IoKSB7XG4gICAgLy8gbm9vcFxuICB9XG5cbiAgX21vdXNlb3V0Q0IoKSB7XG4gICAgLy8gbm9vcFxuICB9XG5cbiAgX2luaXQocGFyZW50LCBvcHRzKSB7XG4gICAgdGhpcy5fYWN0aXZhdGVkID0gKG9wdHMgJiYgb3B0cy5lbmFibGVJbnRlcmFjdGlvbnMpXG4gICAgc3VwZXIuX2luaXQocGFyZW50LCBvcHRzLCB0aGlzLl9hY3RpdmF0ZWQpXG4gICAgY29uc3QgbXlldmVudHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhFdmVudENvbnN0YW50cykubWFwKGV2ZW50ID0+IEV2ZW50Q29uc3RhbnRzW2V2ZW50XSlcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKG15ZXZlbnRzKVxuICAgIHRoaXMuX2RyYWdJbmZvID0gbnVsbFxuICAgIHRoaXMuX3NlbGVjdGVkU2hhcGVzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fc2VsZWN0U3R5bGUgPSBuZXcgQmFzaWNTdHlsZSgob3B0cyAmJiBvcHRzLnNlbGVjdFN0eWxlID8gb3B0cy5zZWxlY3RTdHlsZSA6IHtcbiAgICAgIGZpbGxDb2xvcjogXCJvcmFuZ2VcIlxuICAgIH0pKVxuXG4gICAgdGhpcy5feGZvcm1TdHlsZSA9IG5ldyBCYXNpY1N0eWxlKChvcHRzICYmIG9wdHMueGZvcm1TdHlsZSA/IG9wdHMueGZvcm1TdHlsZSA6IHtcbiAgICAgIGZpbGxDb2xvcjogXCJ3aGl0ZVwiLFxuICAgICAgc3Ryb2tlQ29sb3I6IFwiYmxhY2tcIixcbiAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgfSkpXG5cbiAgICB0aGlzLnRpbWVyID0gMFxuICB9XG5cbiAgX3JlbmRlclNoYXBlcyhjdHgsIGRyYXdTaGFwZXMsIGNhbWVyYSkge1xuICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXQgPSBjYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgIGRyYXdTaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICBpZiAoc2hhcGUudmlzaWJsZSkge1xuICAgICAgICBzaGFwZS5yZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCB0aGlzLl9zdHlsZVN0YXRlKVxuICAgICAgICAvLyBzaGFwZS5yZW5kZXJCb3VuZHMoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCBib3VuZHNTdHJva2VTdHlsZSlcbiAgICAgICAgaWYgKHNoYXBlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgY29uc3QgaW50ZXJhY1NoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlKVxuICAgICAgICAgIGlmIChpbnRlcmFjU2hhcGUpIHtcbiAgICAgICAgICAgIGludGVyYWNTaGFwZS5yZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCB0aGlzLl9zdHlsZVN0YXRlKVxuICAgICAgICAgICAgLy8gaW50ZXJhY1NoYXBlLnJlbmRlckJvdW5kcyhjdHgsIHdvcmxkVG9TY3JlZW5NYXQsIGJvdW5kc1N0cm9rZVN0eWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZXQgc2VsZWN0U3R5bGUoc2VsZWN0U3R5bGUpIHtcbiAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHNlbGVjdFN0eWxlLCB0aGlzLl9zZWxlY3RTdHlsZSlcbiAgfVxuXG4gIGdldCBzZWxlY3RTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0U3R5bGVcbiAgfVxuXG4gIGdldCBzZWxlY3RlZFNoYXBlcygpIHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgfVxuXG4gIHNlbGVjdFNoYXBlKHNoYXBlKSB7XG4gICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGUpXG4gICAgaWYgKHNoYXBlSW5mbyAmJiBzaGFwZUluZm8uc2VsZWN0YWJsZSkge1xuICAgICAgY29uc3Qgc2VsZWN0RXZlbnRPYmogPSBzZWxlY3RTaGFwZShzaGFwZSwgdGhpcy5zb3J0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RTdHlsZSwgdGhpcy5feGZvcm1TdHlsZSwgc2hhcGVJbmZvKVxuICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCBzZWxlY3RFdmVudE9iailcbiAgICB9XG4gIH1cblxuICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRTaGFwZXMuc2l6ZSkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRTaGFwZXMgPSBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgY2xlYXJTZWxlY3RlZFNoYXBlcyh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgICB1bnNlbGVjdGVkU2hhcGVzOiBzZWxlY3RlZFNoYXBlcyxcbiAgICAgICAgc2VsZWN0ZWRTaGFwZXM6IFtdXG4gICAgICB9KVxuICAgICAgdGhpcy5fcmVyZW5kZXJDYigpXG4gICAgfVxuICB9XG5cbiAgYWRkU2hhcGUoc2hhcGUsIG9wdHMgPSBudWxsLCBzZWxlY3QgPSBmYWxzZSkge1xuICAgIGxldCBzaGFwZXMgPSBzaGFwZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgICBzaGFwZXMgPSBbc2hhcGVdXG4gICAgfVxuXG4gICAgc3VwZXIuYWRkU2hhcGUoc2hhcGVzKVxuICAgIHNoYXBlcy5mb3JFYWNoKG5ld1NoYXBlID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KG5ld1NoYXBlKVxuICAgICAgaWYgKHNoYXBlSW5mbykge1xuICAgICAgICBzaGFwZUluZm8uc2VsZWN0YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLnNlbGVjdGFibGUgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMuc2VsZWN0YWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8ubW92YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLm1vdmFibGUgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMubW92YWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8ucm90YXRhYmxlID0gKG9wdHMgJiYgdHlwZW9mIG9wdHMucm90YXRhYmxlICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLnJvdGF0YWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8uc2NhbGFibGUgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy5zY2FsYWJsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IEJvb2xlYW4ob3B0cy5zY2FsYWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8udW5pZm9ybVNjYWxlT25seSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLnVuaWZvcm1TY2FsZU9ubHkgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMudW5pZm9ybVNjYWxlT25seSkgOiBmYWxzZSlcbiAgICAgICAgc2hhcGVJbmZvLmNlbnRlclNjYWxlT25seSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLmNlbnRlclNjYWxlT25seSAhPT0gXCJ1bmRlZmluZWRcIiA/IEJvb2xlYW4ob3B0cy5jZW50ZXJTY2FsZU9ubHkpIDogZmFsc2UpXG4gICAgICAgIHNoYXBlSW5mby5lZGl0YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLmVkaXRhYmxlICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLmVkaXRhYmxlKSA6IHRydWUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChzZWxlY3QpIHtcbiAgICAgIGNvbnN0IHNlbGVjdEV2ZW50T2JqID0ge1xuICAgICAgICB1bnNlbGVjdGVkU2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRTaGFwZXMgPSBbXVxuICAgICAgc2hhcGVzLmZvckVhY2gobmV3U2hhcGUgPT4ge1xuICAgICAgICBjb25zdCBzaGFwZUluZm8gPSB0aGlzLl9vYmplY3RzLmdldChuZXdTaGFwZSlcbiAgICAgICAgaWYgKHNoYXBlSW5mby5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgc2VsZWN0U2hhcGUobmV3U2hhcGUsIHRoaXMuc29ydGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RlZFNoYXBlcywgdGhpcy5fc2VsZWN0U3R5bGUsIHRoaXMuX3hmb3JtU3R5bGUsIHNoYXBlSW5mbylcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlcy5wdXNoKG5ld1NoYXBlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoc2VsZWN0ZWRTaGFwZXMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGVjdEV2ZW50T2JqLnNlbGVjdGVkU2hhcGVzID0gc2VsZWN0ZWRTaGFwZXNcbiAgICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCBzZWxlY3RFdmVudE9iailcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICBkZWxldGVTaGFwZShzaGFwZSkge1xuICAgIGxldCBzaGFwZXMgPSBzaGFwZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgICBzaGFwZXMgPSBbc2hhcGVdXG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdENsZWFyZWRTaGFwZXMgPSBjbGVhclNwZWNpZmljU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzLCBzaGFwZXMpXG4gICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCB7XG4gICAgICB1bnNlbGVjdGVkU2hhcGVzOiBzZWxlY3RDbGVhcmVkU2hhcGVzLFxuICAgICAgc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpXG4gICAgfSlcblxuICAgIHJlbW92ZUN1c3RvbUN1cnNvcigpXG4gICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgLy8gZm9yRWFjaCBub3Qgc3VwcG9ydGVkIG9uIG5vZGVsaXN0IGluIElFL0VkZ2VcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZVNoYXBlKHNoYXBlcylcbiAgfVxuXG4gIGRlbGV0ZVNlbGVjdGVkU2hhcGVzKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkU2hhcGVzID0gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgdW5zZWxlY3RlZFNoYXBlczogc2VsZWN0ZWRTaGFwZXMsXG4gICAgICBzZWxlY3RlZFNoYXBlczogW11cbiAgICB9KVxuXG4gICAgcmVtb3ZlQ3VzdG9tQ3Vyc29yKClcbiAgICB0aGlzLl9wYXJlbnQuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCJcbiAgICAvLyBmb3JFYWNoIG5vdCBzdXBwb3J0ZWQgb24gbm9kZWxpc3QgaW4gSUUvRWRnZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCJcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlU2hhcGUoc2VsZWN0ZWRTaGFwZXMpXG4gIH1cblxuICBnZXQgaW50ZXJhY3Rpb25zRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZhdGVkXG4gIH1cblxuICBlbmFibGVJbnRlcmFjdGlvbnMoKSB7XG4gICAgdGhpcy5fZW5hYmxlRXZlbnRzKClcbiAgICB0aGlzLl9hY3RpdmF0ZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRpc2FibGVJbnRlcmFjdGlvbnMoY2xlYXJTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKGNsZWFyU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcbiAgICB9XG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cygpXG4gICAgdGhpcy5fYWN0aXZhdGVkID0gZmFsc2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbk9iamVjdC5hc3NpZ24oRXZlbnRDb25zdGFudHMsIERyYXdFbmdpbmUuRXZlbnRDb25zdGFudHMpXG5TaGFwZUJ1aWxkZXIuRXZlbnRDb25zdGFudHMgPSBFdmVudENvbnN0YW50c1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL3NoYXBlLWJ1aWxkZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformXformShape = transformXformShape;\nexports.translateShape = translateShape;\nexports.translateVert = translateVert;\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _mat2d = __webpack_require__(5);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _vec2d = __webpack_require__(10);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction rotateOBBox(shape, parentShape, selectedInfo, screenPos, worldPos) {\n  var pt = [0, 0];\n  var scale = [0, 0];\n  _mat2d2.default.svd(pt, scale, null, selectedInfo.objectToWorldMatrix);\n  var startDir = [0, 0];\n  Point2d.sub(startDir, selectedInfo.startWorldPos, pt);\n  _vec2d2.default.normalize(startDir, startDir);\n  var dir = pt;\n  Point2d.sub(dir, worldPos, pt);\n  _vec2d2.default.normalize(dir, dir);\n  var angle = _vec2d2.default.angle(startDir, dir);\n\n  if (selectedInfo.keys.shiftKey) {\n    angle = Math.round(angle / Math.QUATER_PI) * Math.QUATER_PI;\n  }\n\n  // if (!camera.isYFlipped()) {\n  //   angle *= -1\n  // }\n\n  parentShape.setRotation(selectedInfo.startLocalRot + Math.RAD_TO_DEG * angle);\n}\n\nfunction transformXformShape(shape, selectedInfo, screenPos, worldPos, camera) {\n  var parentShape = shape.parent;\n  var objPos = [0, 0];\n  var deltaPos = [0, 0];\n  var deltaDims = [0, 0];\n\n  if (selectedInfo.rotate) {\n    rotateOBBox(shape, parentShape, selectedInfo, screenPos, worldPos, camera);\n    return;\n  }\n\n  var uniformScale = selectedInfo.keys.shiftKey || selectedInfo.uniformScaleOnly;\n  var centerScale = selectedInfo.keys.altKey || selectedInfo.centerScaleOnly;\n\n  // get the position of the shape at start of transform\n  var pt = [0, 0];\n  _mat2d2.default.svd(pt, null, null, selectedInfo.objectToWorldMatrix);\n\n  // get the mouse delta in world space\n  _vec2d2.default.sub(deltaPos, worldPos, selectedInfo.startWorldPos);\n\n  if (uniformScale && selectedInfo.controlIndex < 4) {\n    var xAxisDir = [selectedInfo.objectToWorldMatrix[0], selectedInfo.objectToWorldMatrix[1]];\n    var yAxisDir = [selectedInfo.objectToWorldMatrix[2], selectedInfo.objectToWorldMatrix[3]];\n    var diagDir = [0, 0];\n\n    if (selectedInfo.controlIndex < 2) {\n      _vec2d2.default.negate(xAxisDir, xAxisDir);\n    }\n    if (selectedInfo.controlIndex % 2 === 0) {\n      _vec2d2.default.negate(yAxisDir, yAxisDir);\n    }\n\n    _vec2d2.default.normalize(xAxisDir, xAxisDir);\n    _vec2d2.default.normalize(yAxisDir, yAxisDir);\n\n    _vec2d2.default.add(diagDir, xAxisDir, yAxisDir);\n    _vec2d2.default.normalize(diagDir, diagDir);\n\n    var cross = _vec2d2.default.cross2d(deltaPos, diagDir);\n    var axisToUse = null;\n    if (selectedInfo.controlIndex === 0 || selectedInfo.controlIndex === 3) {\n      axisToUse = yAxisDir;\n      if (cross < 0) {\n        axisToUse = xAxisDir;\n      }\n    } else {\n      axisToUse = xAxisDir;\n      if (cross < 0) {\n        axisToUse = yAxisDir;\n      }\n    }\n    var mindist = _vec2d2.default.dot(deltaPos, axisToUse);\n    mindist = Math.sign(mindist) * Math.sqrt(2 * mindist * mindist);\n    _vec2d2.default.scale(deltaPos, diagDir, mindist);\n    Point2d.addVec2(worldPos, selectedInfo.startWorldPos, deltaPos);\n  }\n\n  // first convert world point to object space\n  Point2d.copy(objPos, worldPos);\n  Point2d.transformMat2d(objPos, objPos, selectedInfo.worldToObjectMatrix);\n\n  // get the mouse delta in object space and multipy by the\n  // scale of the selected object at the start of the transform\n  // to get the scale delta in object space\n  _vec2d2.default.sub(deltaDims, objPos, selectedInfo.startObjectPos);\n\n  Point2d.copy(pt, selectedInfo.startLocalPos);\n\n  // now determine the transform direction depending\n  // on which control vertex of the object-oriented bounds\n  // was selected\n  var xScale = 0;\n  var yScale = 0;\n  if (selectedInfo.controlIndex < 4) {\n    // dragging a corner vertex\n    xScale = selectedInfo.controlIndex < 2 ? -1 : 1;\n    yScale = selectedInfo.controlIndex % 2 === 0 ? -1 : 1;\n\n    // can translate based on the mouse delta in world space\n    // This is done to offset the scale, which is done at\n    // the shape's center. This ultimately acts as a pivot\n    // for the transformation. Only do this if the alt key\n    // isn't pressed\n    if (!centerScale) {\n      Point2d.addVec2(pt, pt, _vec2d2.default.scale(deltaPos, deltaPos, 0.5));\n    }\n\n    parentShape.setPosition(pt);\n  } else {\n    // dragging a side vertex, which means we only scale in\n    // one dimension, rather than 2. So we need to figure\n    // out that direction based on the orientation of the\n    // shape\n    var idx = selectedInfo.controlIndex - 4;\n    var axisDir = [0, 0];\n    if (idx % 2 === 0) {\n      // scaling in the object's X direction\n      _vec2d2.default.set(axisDir, selectedInfo.objectToWorldMatrix[0], selectedInfo.objectToWorldMatrix[1]);\n      yScale = 0;\n      xScale = idx < 2 ? -1 : 1;\n      if (uniformScale) {\n        yScale = xScale;\n        deltaDims[1] = deltaDims[0];\n      }\n    } else {\n      // scaling in the object's Y direction\n      _vec2d2.default.set(axisDir, selectedInfo.objectToWorldMatrix[2], selectedInfo.objectToWorldMatrix[3]);\n      xScale = 0;\n      yScale = idx < 2 ? -1 : 1;\n      if (uniformScale) {\n        xScale = yScale;\n        deltaDims[0] = deltaDims[1];\n      }\n    }\n\n    // now find the pivot offset for the axis-aligned scale\n    if (!centerScale) {\n      _vec2d2.default.normalize(axisDir, axisDir);\n      _vec2d2.default.scale(axisDir, axisDir, _vec2d2.default.dot(deltaPos, axisDir));\n      Point2d.addVec2(pt, pt, _vec2d2.default.scale(axisDir, axisDir, 0.5));\n    }\n\n    parentShape.setPosition(pt);\n  }\n\n  if (centerScale) {\n    xScale *= 2;\n    yScale *= 2;\n  }\n\n  // perform the scale\n  parentShape.setScale([selectedInfo.startLocalScale[0] * (1 + xScale * deltaDims[0] / selectedInfo.shapeWidth), selectedInfo.startLocalScale[1] * (1 + yScale * deltaDims[1] / selectedInfo.shapeHeight)]);\n}\n\nfunction translateShape(shape, selectedInfo, screenPos, worldPos, camera) {\n  var diff = [0, 0];\n  var pt = [0, 0];\n  _mat2d2.default.svd(pt, null, null, selectedInfo.objectToWorldMatrix);\n  if (selectedInfo.keys.shiftKey) {\n    Point2d.sub(diff, screenPos, selectedInfo.startPos);\n    var angle = Math.atan2(diff[1], diff[0]);\n    angle = Math.round(angle / Math.QUATER_PI) * Math.QUATER_PI;\n    var transformDir = [Math.cos(angle), Math.sin(angle)];\n    _vec2d2.default.scale(diff, transformDir, _vec2d2.default.dot(diff, transformDir));\n    _vec2d2.default.transformMat2(diff, diff, camera.screenToWorldMatrix);\n  } else {\n    _vec2d2.default.sub(diff, worldPos, selectedInfo.startWorldPos);\n  }\n  Point2d.addVec2(pt, selectedInfo.startLocalPos, diff);\n\n  shape.setPosition(pt);\n}\n\nfunction translateVert(shape, selectedInfo, screenPos, worldPos) {\n  var parentShape = shape.parent;\n\n  // get the position of the shape at start of transform\n  // const pt = [0, 0]\n  // Mat2d.svd(pt, null, null, selectedInfo.objectToWorldMatrix)\n\n  // get the mouse delta in world space\n  // Vec2d.sub(deltaPos, worldPos, selectedInfo.startWorldPos)\n\n  // first convert world point to object space\n  // Point2d.copy(objPos, worldPos)\n  // Point2d.transformMat2d(objPos, objPos, selectedInfo.worldToObjectMatrix)\n\n  // get the diff\n  // const diff = objPos\n  // Point2d.sub(diff, objPos, selectedInfo.startObjectPos)\n\n  var numVerts = parentShape.numVerts;\n  if (selectedInfo.controlIndex >= numVerts) {\n    var idx1 = Math.min(selectedInfo.controlIndex - numVerts, numVerts - 1);\n    var idx2 = idx1 === numVerts - 1 ? 0 : idx1 + 1;\n    var pt = [0, 0];\n    var pt1 = [0, 0];\n    var pt2 = [0, 0];\n    var vec = [0, 0];\n    var verts = parentShape.vertsRef;\n    var xform = parentShape.globalXform;\n    Point2d.transformMat2d(pt1, verts[idx1], xform);\n    Point2d.transformMat2d(pt2, verts[idx2], xform);\n    Point2d.sub(vec, pt2, pt1);\n    _vec2d2.default.scale(vec, vec, 0.5);\n    Point2d.addVec2(pt, pt1, vec);\n    selectedInfo.controlIndex = parentShape.insertVert(idx1 + 1, pt);\n  } else {\n    parentShape.setVertPosition(selectedInfo.controlIndex, worldPos);\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3QtdXRpbHMuanM/NzE0YiJdLCJuYW1lcyI6WyJ0cmFuc2Zvcm1YZm9ybVNoYXBlIiwidHJhbnNsYXRlU2hhcGUiLCJ0cmFuc2xhdGVWZXJ0IiwiUG9pbnQyZCIsInJvdGF0ZU9CQm94Iiwic2hhcGUiLCJwYXJlbnRTaGFwZSIsInNlbGVjdGVkSW5mbyIsInNjcmVlblBvcyIsIndvcmxkUG9zIiwicHQiLCJzY2FsZSIsInN2ZCIsIm9iamVjdFRvV29ybGRNYXRyaXgiLCJzdGFydERpciIsInN1YiIsInN0YXJ0V29ybGRQb3MiLCJub3JtYWxpemUiLCJkaXIiLCJhbmdsZSIsImtleXMiLCJzaGlmdEtleSIsIk1hdGgiLCJyb3VuZCIsIlFVQVRFUl9QSSIsInNldFJvdGF0aW9uIiwic3RhcnRMb2NhbFJvdCIsIlJBRF9UT19ERUciLCJjYW1lcmEiLCJwYXJlbnQiLCJvYmpQb3MiLCJkZWx0YVBvcyIsImRlbHRhRGltcyIsInJvdGF0ZSIsInVuaWZvcm1TY2FsZSIsInVuaWZvcm1TY2FsZU9ubHkiLCJjZW50ZXJTY2FsZSIsImFsdEtleSIsImNlbnRlclNjYWxlT25seSIsImNvbnRyb2xJbmRleCIsInhBeGlzRGlyIiwieUF4aXNEaXIiLCJkaWFnRGlyIiwibmVnYXRlIiwiYWRkIiwiY3Jvc3MiLCJjcm9zczJkIiwiYXhpc1RvVXNlIiwibWluZGlzdCIsImRvdCIsInNpZ24iLCJzcXJ0IiwiYWRkVmVjMiIsImNvcHkiLCJ0cmFuc2Zvcm1NYXQyZCIsIndvcmxkVG9PYmplY3RNYXRyaXgiLCJzdGFydE9iamVjdFBvcyIsInN0YXJ0TG9jYWxQb3MiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJzZXRQb3NpdGlvbiIsImlkeCIsImF4aXNEaXIiLCJzZXQiLCJzZXRTY2FsZSIsInN0YXJ0TG9jYWxTY2FsZSIsInNoYXBlV2lkdGgiLCJzaGFwZUhlaWdodCIsImRpZmYiLCJzdGFydFBvcyIsImF0YW4yIiwidHJhbnNmb3JtRGlyIiwiY29zIiwic2luIiwidHJhbnNmb3JtTWF0MiIsInNjcmVlblRvV29ybGRNYXRyaXgiLCJudW1WZXJ0cyIsImlkeDEiLCJtaW4iLCJpZHgyIiwicHQxIiwicHQyIiwidmVjIiwidmVydHMiLCJ2ZXJ0c1JlZiIsInhmb3JtIiwiZ2xvYmFsWGZvcm0iLCJpbnNlcnRWZXJ0Iiwic2V0VmVydFBvc2l0aW9uIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7OztRQTZCZ0JBLG1CLEdBQUFBLG1CO1FBdUlBQyxjLEdBQUFBLGM7UUFtQkFDLGEsR0FBQUEsYTs7QUFyTGhCOztJQUFZQyxPOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7O0FBRUEsU0FBU0MsV0FBVCxDQUFxQkMsS0FBckIsRUFBNEJDLFdBQTVCLEVBQXlDQyxZQUF6QyxFQUF1REMsU0FBdkQsRUFBa0VDLFFBQWxFLEVBQTRFO0FBQzFFLE1BQU1DLEtBQUssQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFYO0FBQ0EsTUFBTUMsUUFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWQ7QUFDQSxrQkFBTUMsR0FBTixDQUFVRixFQUFWLEVBQWNDLEtBQWQsRUFBcUIsSUFBckIsRUFBMkJKLGFBQWFNLG1CQUF4QztBQUNBLE1BQU1DLFdBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFqQjtBQUNBWCxVQUFRWSxHQUFSLENBQVlELFFBQVosRUFBc0JQLGFBQWFTLGFBQW5DLEVBQWtETixFQUFsRDtBQUNBLGtCQUFNTyxTQUFOLENBQWdCSCxRQUFoQixFQUEwQkEsUUFBMUI7QUFDQSxNQUFNSSxNQUFNUixFQUFaO0FBQ0FQLFVBQVFZLEdBQVIsQ0FBWUcsR0FBWixFQUFpQlQsUUFBakIsRUFBMkJDLEVBQTNCO0FBQ0Esa0JBQU1PLFNBQU4sQ0FBZ0JDLEdBQWhCLEVBQXFCQSxHQUFyQjtBQUNBLE1BQUlDLFFBQVEsZ0JBQU1BLEtBQU4sQ0FBWUwsUUFBWixFQUFzQkksR0FBdEIsQ0FBWjs7QUFFQSxNQUFJWCxhQUFhYSxJQUFiLENBQWtCQyxRQUF0QixFQUFn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TUcsT0FBUUYsU0FBU0QsV0FBVyxDQUFwQixHQUF3QixDQUF4QixHQUE0QkMsT0FBTyxDQUFqRDtBQUNBLFFBQU1uRSxLQUFLLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWDtBQUNBLFFBQU1zRSxNQUFNLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBLFFBQU1DLE1BQU0sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0EsUUFBTUMsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQSxRQUFNQyxRQUFRN0UsWUFBWThFLFFBQTFCO0FBQ0EsUUFBTUMsUUFBUS9FLFlBQVlnRixXQUExQjtBQUNBbkYsWUFBUW1ELGNBQVIsQ0FBdUIwQixHQUF2QixFQUE0QkcsTUFBTU4sSUFBTixDQUE1QixFQUF5Q1EsS0FBekM7QUFDQWxGLFlBQVFtRCxjQUFSLENBQXVCMkIsR0FBdkIsRUFBNEJFLE1BQU1KLElBQU4sQ0FBNUIsRUFBeUNNLEtBQXpDO0FBQ0FsRixZQUFRWSxHQUFSLENBQVltRSxHQUFaLEVBQWlCRCxHQUFqQixFQUFzQkQsR0FBdEI7QUFDQSxvQkFBTXJFLEtBQU4sQ0FBWXVFLEdBQVosRUFBaUJBLEdBQWpCLEVBQXNCLEdBQXRCO0FBQ0EvRSxZQUFRaUQsT0FBUixDQUFnQjFDLEVBQWhCLEVBQW9Cc0UsR0FBcEIsRUFBeUJFLEdBQXpCO0FBQ0EzRSxpQkFBYWdDLFlBQWIsR0FBNEJqQyxZQUFZaUYsVUFBWixDQUF1QlYsT0FBTyxDQUE5QixFQUFpQ25FLEVBQWpDLENBQTVCO0FBQ0QsR0FmRCxNQWVPO0FBQ0xKLGdCQUFZa0YsZUFBWixDQUE0QmpGLGFBQWFnQyxZQUF6QyxFQUF1RDlCLFFBQXZEO0FBQ0Q7QUFDRiIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLW1hZ2ljLW51bWJlcnMgKi9cblwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQgTWF0MmQgZnJvbSBcIi4uL2NvcmUvbWF0MmRcIlxuaW1wb3J0IFZlYzJkIGZyb20gXCIuLi9jb3JlL3ZlYzJkXCJcblxuZnVuY3Rpb24gcm90YXRlT0JCb3goc2hhcGUsIHBhcmVudFNoYXBlLCBzZWxlY3RlZEluZm8sIHNjcmVlblBvcywgd29ybGRQb3MpIHtcbiAgY29uc3QgcHQgPSBbMCwgMF1cbiAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgTWF0MmQuc3ZkKHB0LCBzY2FsZSwgbnVsbCwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXgpXG4gIGNvbnN0IHN0YXJ0RGlyID0gWzAsIDBdXG4gIFBvaW50MmQuc3ViKHN0YXJ0RGlyLCBzZWxlY3RlZEluZm8uc3RhcnRXb3JsZFBvcywgcHQpXG4gIFZlYzJkLm5vcm1hbGl6ZShzdGFydERpciwgc3RhcnREaXIpXG4gIGNvbnN0IGRpciA9IHB0XG4gIFBvaW50MmQuc3ViKGRpciwgd29ybGRQb3MsIHB0KVxuICBWZWMyZC5ub3JtYWxpemUoZGlyLCBkaXIpXG4gIGxldCBhbmdsZSA9IFZlYzJkLmFuZ2xlKHN0YXJ0RGlyLCBkaXIpXG5cbiAgaWYgKHNlbGVjdGVkSW5mby5rZXlzLnNoaWZ0S2V5KSB7XG4gICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlIC8gTWF0aC5RVUFURVJfUEkpICogTWF0aC5RVUFURVJfUElcbiAgfVxuXG4gIC8vIGlmICghY2FtZXJhLmlzWUZsaXBwZWQoKSkge1xuICAvLyAgIGFuZ2xlICo9IC0xXG4gIC8vIH1cblxuICBwYXJlbnRTaGFwZS5zZXRSb3RhdGlvbihzZWxlY3RlZEluZm8uc3RhcnRMb2NhbFJvdCArIE1hdGguUkFEX1RPX0RFRyAqIGFuZ2xlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtWGZvcm1TaGFwZShzaGFwZSwgc2VsZWN0ZWRJbmZvLCBzY3JlZW5Qb3MsIHdvcmxkUG9zLCBjYW1lcmEpIHtcbiAgY29uc3QgcGFyZW50U2hhcGUgPSBzaGFwZS5wYXJlbnRcbiAgY29uc3Qgb2JqUG9zID0gWzAsIDBdXG4gIGNvbnN0IGRlbHRhUG9zID0gWzAsIDBdXG4gIGNvbnN0IGRlbHRhRGltcyA9IFswLCAwXVxuXG4gIGlmIChzZWxlY3RlZEluZm8ucm90YXRlKSB7XG4gICAgcm90YXRlT0JCb3goc2hhcGUsIHBhcmVudFNoYXBlLCBzZWxlY3RlZEluZm8sIHNjcmVlblBvcywgd29ybGRQb3MsIGNhbWVyYSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHVuaWZvcm1TY2FsZSA9IChzZWxlY3RlZEluZm8ua2V5cy5zaGlmdEtleSB8fCBzZWxlY3RlZEluZm8udW5pZm9ybVNjYWxlT25seSlcbiAgY29uc3QgY2VudGVyU2NhbGUgPSAoc2VsZWN0ZWRJbmZvLmtleXMuYWx0S2V5IHx8IHNlbGVjdGVkSW5mby5jZW50ZXJTY2FsZU9ubHkpXG5cbiAgLy8gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGUgYXQgc3RhcnQgb2YgdHJhbnNmb3JtXG4gIGNvbnN0IHB0ID0gWzAsIDBdXG4gIE1hdDJkLnN2ZChwdCwgbnVsbCwgbnVsbCwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXgpXG5cbiAgLy8gZ2V0IHRoZSBtb3VzZSBkZWx0YSBpbiB3b3JsZCBzcGFjZVxuICBWZWMyZC5zdWIoZGVsdGFQb3MsIHdvcmxkUG9zLCBzZWxlY3RlZEluZm8uc3RhcnRXb3JsZFBvcylcblxuICBpZiAodW5pZm9ybVNjYWxlICYmIHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggPCA0KSB7XG4gICAgY29uc3QgeEF4aXNEaXIgPSBbc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMF0sIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzFdXVxuICAgIGNvbnN0IHlBeGlzRGlyID0gW3NlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzJdLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeFszXV1cbiAgICBjb25zdCBkaWFnRGlyID0gWzAsIDBdXG5cbiAgICBpZiAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDIpIHtcbiAgICAgIFZlYzJkLm5lZ2F0ZSh4QXhpc0RpciwgeEF4aXNEaXIpXG4gICAgfVxuICAgIGlmIChzZWxlY3RlZEluZm8uY29udHJvbEluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgVmVjMmQubmVnYXRlKHlBeGlzRGlyLCB5QXhpc0RpcilcbiAgICB9XG5cbiAgICBWZWMyZC5ub3JtYWxpemUoeEF4aXNEaXIsIHhBeGlzRGlyKVxuICAgIFZlYzJkLm5vcm1hbGl6ZSh5QXhpc0RpciwgeUF4aXNEaXIpXG5cbiAgICBWZWMyZC5hZGQoZGlhZ0RpciwgeEF4aXNEaXIsIHlBeGlzRGlyKVxuICAgIFZlYzJkLm5vcm1hbGl6ZShkaWFnRGlyLCBkaWFnRGlyKVxuXG4gICAgY29uc3QgY3Jvc3MgPSBWZWMyZC5jcm9zczJkKGRlbHRhUG9zLCBkaWFnRGlyKVxuICAgIGxldCBheGlzVG9Vc2UgPSBudWxsXG4gICAgaWYgKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggPT09IDAgfHwgc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMykge1xuICAgICAgYXhpc1RvVXNlID0geUF4aXNEaXJcbiAgICAgIGlmIChjcm9zcyA8IDApIHtcbiAgICAgICAgYXhpc1RvVXNlID0geEF4aXNEaXJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1RvVXNlID0geEF4aXNEaXJcbiAgICAgIGlmIChjcm9zcyA8IDApIHtcbiAgICAgICAgYXhpc1RvVXNlID0geUF4aXNEaXJcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pbmRpc3QgPSBWZWMyZC5kb3QoZGVsdGFQb3MsIGF4aXNUb1VzZSlcbiAgICBtaW5kaXN0ID0gTWF0aC5zaWduKG1pbmRpc3QpICogTWF0aC5zcXJ0KDIgKiBtaW5kaXN0ICogbWluZGlzdClcbiAgICBWZWMyZC5zY2FsZShkZWx0YVBvcywgZGlhZ0RpciwgbWluZGlzdClcbiAgICBQb2ludDJkLmFkZFZlYzIod29ybGRQb3MsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zLCBkZWx0YVBvcylcbiAgfVxuXG4gIC8vIGZpcnN0IGNvbnZlcnQgd29ybGQgcG9pbnQgdG8gb2JqZWN0IHNwYWNlXG4gIFBvaW50MmQuY29weShvYmpQb3MsIHdvcmxkUG9zKVxuICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKG9ialBvcywgb2JqUG9zLCBzZWxlY3RlZEluZm8ud29ybGRUb09iamVjdE1hdHJpeClcblxuICAvLyBnZXQgdGhlIG1vdXNlIGRlbHRhIGluIG9iamVjdCBzcGFjZSBhbmQgbXVsdGlweSBieSB0aGVcbiAgLy8gc2NhbGUgb2YgdGhlIHNlbGVjdGVkIG9iamVjdCBhdCB0aGUgc3RhcnQgb2YgdGhlIHRyYW5zZm9ybVxuICAvLyB0byBnZXQgdGhlIHNjYWxlIGRlbHRhIGluIG9iamVjdCBzcGFjZVxuICBWZWMyZC5zdWIoZGVsdGFEaW1zLCBvYmpQb3MsIHNlbGVjdGVkSW5mby5zdGFydE9iamVjdFBvcylcblxuICBQb2ludDJkLmNvcHkocHQsIHNlbGVjdGVkSW5mby5zdGFydExvY2FsUG9zKVxuXG4gIC8vIG5vdyBkZXRlcm1pbmUgdGhlIHRyYW5zZm9ybSBkaXJlY3Rpb24gZGVwZW5kaW5nXG4gIC8vIG9uIHdoaWNoIGNvbnRyb2wgdmVydGV4IG9mIHRoZSBvYmplY3Qtb3JpZW50ZWQgYm91bmRzXG4gIC8vIHdhcyBzZWxlY3RlZFxuICBsZXQgeFNjYWxlID0gMFxuICBsZXQgeVNjYWxlID0gMFxuICBpZiAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDQpIHtcbiAgICAvLyBkcmFnZ2luZyBhIGNvcm5lciB2ZXJ0ZXhcbiAgICB4U2NhbGUgPSAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDIgPyAtMSA6IDEpXG4gICAgeVNjYWxlID0gKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggJSAyID09PSAwID8gLTEgOiAxKVxuXG4gICAgLy8gY2FuIHRyYW5zbGF0ZSBiYXNlZCBvbiB0aGUgbW91c2UgZGVsdGEgaW4gd29ybGQgc3BhY2VcbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gb2Zmc2V0IHRoZSBzY2FsZSwgd2hpY2ggaXMgZG9uZSBhdFxuICAgIC8vIHRoZSBzaGFwZSdzIGNlbnRlci4gVGhpcyB1bHRpbWF0ZWx5IGFjdHMgYXMgYSBwaXZvdFxuICAgIC8vIGZvciB0aGUgdHJhbnNmb3JtYXRpb24uIE9ubHkgZG8gdGhpcyBpZiB0aGUgYWx0IGtleVxuICAgIC8vIGlzbid0IHByZXNzZWRcbiAgICBpZiAoIWNlbnRlclNjYWxlKSB7XG4gICAgICBQb2ludDJkLmFkZFZlYzIocHQsIHB0LCBWZWMyZC5zY2FsZShkZWx0YVBvcywgZGVsdGFQb3MsIDAuNSkpXG4gICAgfVxuXG4gICAgcGFyZW50U2hhcGUuc2V0UG9zaXRpb24ocHQpXG4gIH0gZWxzZSB7XG4gICAgLy8gZHJhZ2dpbmcgYSBzaWRlIHZlcnRleCwgd2hpY2ggbWVhbnMgd2Ugb25seSBzY2FsZSBpblxuICAgIC8vIG9uZSBkaW1lbnNpb24sIHJhdGhlciB0aGFuIDIuIFNvIHdlIG5lZWQgdG8gZmlndXJlXG4gICAgLy8gb3V0IHRoYXQgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGVcbiAgICAvLyBzaGFwZVxuICAgIGNvbnN0IGlkeCA9IHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggLSA0XG4gICAgY29uc3QgYXhpc0RpciA9IFswLCAwXVxuICAgIGlmIChpZHggJSAyID09PSAwKSB7XG4gICAgICAvLyBzY2FsaW5nIGluIHRoZSBvYmplY3QncyBYIGRpcmVjdGlvblxuICAgICAgVmVjMmQuc2V0KGF4aXNEaXIsIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzBdLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeFsxXSlcbiAgICAgIHlTY2FsZSA9IDBcbiAgICAgIHhTY2FsZSA9IChpZHggPCAyID8gLTEgOiAxKVxuICAgICAgaWYgKHVuaWZvcm1TY2FsZSkge1xuICAgICAgICB5U2NhbGUgPSB4U2NhbGVcbiAgICAgICAgZGVsdGFEaW1zWzFdID0gZGVsdGFEaW1zWzBdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNjYWxpbmcgaW4gdGhlIG9iamVjdCdzIFkgZGlyZWN0aW9uXG4gICAgICBWZWMyZC5zZXQoYXhpc0Rpciwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMl0sIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzNdKVxuICAgICAgeFNjYWxlID0gMFxuICAgICAgeVNjYWxlID0gKGlkeCA8IDIgPyAtMSA6IDEpXG4gICAgICBpZiAodW5pZm9ybVNjYWxlKSB7XG4gICAgICAgIHhTY2FsZSA9IHlTY2FsZVxuICAgICAgICBkZWx0YURpbXNbMF0gPSBkZWx0YURpbXNbMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgZmluZCB0aGUgcGl2b3Qgb2Zmc2V0IGZvciB0aGUgYXhpcy1hbGlnbmVkIHNjYWxlXG4gICAgaWYgKCFjZW50ZXJTY2FsZSkge1xuICAgICAgVmVjMmQubm9ybWFsaXplKGF4aXNEaXIsIGF4aXNEaXIpXG4gICAgICBWZWMyZC5zY2FsZShheGlzRGlyLCBheGlzRGlyLCBWZWMyZC5kb3QoZGVsdGFQb3MsIGF4aXNEaXIpKVxuICAgICAgUG9pbnQyZC5hZGRWZWMyKHB0LCBwdCwgVmVjMmQuc2NhbGUoYXhpc0RpciwgYXhpc0RpciwgMC41KSlcbiAgICB9XG5cbiAgICBwYXJlbnRTaGFwZS5zZXRQb3NpdGlvbihwdClcbiAgfVxuXG4gIGlmIChjZW50ZXJTY2FsZSkge1xuICAgIHhTY2FsZSAqPSAyXG4gICAgeVNjYWxlICo9IDJcbiAgfVxuXG4gIC8vIHBlcmZvcm0gdGhlIHNjYWxlXG4gIHBhcmVudFNoYXBlLnNldFNjYWxlKFtzZWxlY3RlZEluZm8uc3RhcnRMb2NhbFNjYWxlWzBdICogKDEgKyB4U2NhbGUgKiBkZWx0YURpbXNbMF0gLyBzZWxlY3RlZEluZm8uc2hhcGVXaWR0aCksIHNlbGVjdGVkSW5mby5zdGFydExvY2FsU2NhbGVbMV0gKiAoMSArIHlTY2FsZSAqIGRlbHRhRGltc1sxXSAvIHNlbGVjdGVkSW5mby5zaGFwZUhlaWdodCldKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlU2hhcGUoc2hhcGUsIHNlbGVjdGVkSW5mbywgc2NyZWVuUG9zLCB3b3JsZFBvcywgY2FtZXJhKSB7XG4gIGNvbnN0IGRpZmYgPSBbMCwgMF1cbiAgY29uc3QgcHQgPSBbMCwgMF1cbiAgTWF0MmQuc3ZkKHB0LCBudWxsLCBudWxsLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeClcbiAgaWYgKHNlbGVjdGVkSW5mby5rZXlzLnNoaWZ0S2V5KSB7XG4gICAgUG9pbnQyZC5zdWIoZGlmZiwgc2NyZWVuUG9zLCBzZWxlY3RlZEluZm8uc3RhcnRQb3MpXG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaWZmWzFdLCBkaWZmWzBdKVxuICAgIGFuZ2xlID0gTWF0aC5yb3VuZChhbmdsZSAvIE1hdGguUVVBVEVSX1BJKSAqIE1hdGguUVVBVEVSX1BJXG4gICAgY29uc3QgdHJhbnNmb3JtRGlyID0gW01hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpXVxuICAgIFZlYzJkLnNjYWxlKGRpZmYsIHRyYW5zZm9ybURpciwgVmVjMmQuZG90KGRpZmYsIHRyYW5zZm9ybURpcikpXG4gICAgVmVjMmQudHJhbnNmb3JtTWF0MihkaWZmLCBkaWZmLCBjYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgfSBlbHNlIHtcbiAgICBWZWMyZC5zdWIoZGlmZiwgd29ybGRQb3MsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zKVxuICB9XG4gIFBvaW50MmQuYWRkVmVjMihwdCwgc2VsZWN0ZWRJbmZvLnN0YXJ0TG9jYWxQb3MsIGRpZmYpXG5cbiAgc2hhcGUuc2V0UG9zaXRpb24ocHQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGVWZXJ0KHNoYXBlLCBzZWxlY3RlZEluZm8sIHNjcmVlblBvcywgd29ybGRQb3MpIHtcbiAgY29uc3QgcGFyZW50U2hhcGUgPSBzaGFwZS5wYXJlbnRcblxuICAvLyBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSBhdCBzdGFydCBvZiB0cmFuc2Zvcm1cbiAgLy8gY29uc3QgcHQgPSBbMCwgMF1cbiAgLy8gTWF0MmQuc3ZkKHB0LCBudWxsLCBudWxsLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeClcblxuICAvLyBnZXQgdGhlIG1vdXNlIGRlbHRhIGluIHdvcmxkIHNwYWNlXG4gIC8vIFZlYzJkLnN1YihkZWx0YVBvcywgd29ybGRQb3MsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zKVxuXG4gIC8vIGZpcnN0IGNvbnZlcnQgd29ybGQgcG9pbnQgdG8gb2JqZWN0IHNwYWNlXG4gIC8vIFBvaW50MmQuY29weShvYmpQb3MsIHdvcmxkUG9zKVxuICAvLyBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKG9ialBvcywgb2JqUG9zLCBzZWxlY3RlZEluZm8ud29ybGRUb09iamVjdE1hdHJpeClcblxuICAvLyBnZXQgdGhlIGRpZmZcbiAgLy8gY29uc3QgZGlmZiA9IG9ialBvc1xuICAvLyBQb2ludDJkLnN1YihkaWZmLCBvYmpQb3MsIHNlbGVjdGVkSW5mby5zdGFydE9iamVjdFBvcylcblxuICBjb25zdCBudW1WZXJ0cyA9IHBhcmVudFNoYXBlLm51bVZlcnRzXG4gIGlmIChzZWxlY3RlZEluZm8uY29udHJvbEluZGV4ID49IG51bVZlcnRzKSB7XG4gICAgY29uc3QgaWR4MSA9IE1hdGgubWluKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggLSBudW1WZXJ0cywgbnVtVmVydHMgLSAxKVxuICAgIGNvbnN0IGlkeDIgPSAoaWR4MSA9PT0gbnVtVmVydHMgLSAxID8gMCA6IGlkeDEgKyAxKVxuICAgIGNvbnN0IHB0ID0gWzAsIDBdXG4gICAgY29uc3QgcHQxID0gWzAsIDBdXG4gICAgY29uc3QgcHQyID0gWzAsIDBdXG4gICAgY29uc3QgdmVjID0gWzAsIDBdXG4gICAgY29uc3QgdmVydHMgPSBwYXJlbnRTaGFwZS52ZXJ0c1JlZlxuICAgIGNvbnN0IHhmb3JtID0gcGFyZW50U2hhcGUuZ2xvYmFsWGZvcm1cbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHB0MSwgdmVydHNbaWR4MV0sIHhmb3JtKVxuICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQocHQyLCB2ZXJ0c1tpZHgyXSwgeGZvcm0pXG4gICAgUG9pbnQyZC5zdWIodmVjLCBwdDIsIHB0MSlcbiAgICBWZWMyZC5zY2FsZSh2ZWMsIHZlYywgMC41KVxuICAgIFBvaW50MmQuYWRkVmVjMihwdCwgcHQxLCB2ZWMpXG4gICAgc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA9IHBhcmVudFNoYXBlLmluc2VydFZlcnQoaWR4MSArIDEsIHB0KVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFNoYXBlLnNldFZlcnRQb3NpdGlvbihzZWxlY3RlZEluZm8uY29udHJvbEluZGV4LCB3b3JsZFBvcylcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vaW50ZXJhY3Rpb25zL2ludGVyYWN0LXV0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _baseShape = __webpack_require__(7);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar VertEditableShape = function (_BaseShape) {\n  _inherits(VertEditableShape, _BaseShape);\n\n  function VertEditableShape(baseVertShape, opts) {\n    _classCallCheck(this, VertEditableShape);\n\n    var _this = _possibleConstructorReturn(this, (VertEditableShape.__proto__ || Object.getPrototypeOf(VertEditableShape)).call(this, opts));\n\n    _this._baseVertShape = baseVertShape;\n    _this._vertRadius = 4;\n    _this._transformedVerts = [];\n    _this._baseaabox = AABox2d.create();\n    _this._worldToScreenMatrix = _glMatrix.mat2d.create();\n    return _this;\n  }\n\n  _createClass(VertEditableShape, [{\n    key: \"_updateAABox\",\n    value: function _updateAABox(worldToScreenMatrix) {\n      var aabox = this._baseVertShape.aabox;\n      if (!AABox2d.equals(aabox, this._baseaabox) || !_glMatrix.mat2d.equals(worldToScreenMatrix, this._worldToScreenMatrix)) {\n        AABox2d.copy(this._baseaabox, aabox);\n        _glMatrix.mat2d.copy(this._worldToScreenMatrix, worldToScreenMatrix);\n        AABox2d.transformMat2d(this._aabox, this._baseaabox, this._worldToScreenMatrix);\n        var pad = this._vertRadius + this.strokeWidth;\n        AABox2d.expand(this._aabox, this._aabox, [pad, pad]);\n      }\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtnObj = {\n        hit: false,\n        controlIndex: -1\n      };\n\n      this._updateAABox(worldToScreenMatrix);\n      if (this.visible && AABox2d.containsPt(this._aabox, screenPt)) {\n        var aabox = AABox2d.create();\n        var pad = this._vertRadius + this.strokeWidth / 2;\n        var extents = [pad, pad];\n\n        var i = 0;\n        for (i = 0; i < this._transformedVerts.length; i += 1) {\n          AABox2d.initCenterExtents(aabox, this._transformedVerts[i], extents);\n          if (AABox2d.containsPt(aabox, screenPt)) {\n            rtnObj.hit = true;\n            rtnObj.controlIndex = i;\n            break;\n          }\n        }\n\n        if (!rtnObj.hit) {\n          var tmpPt = [0, 0];\n          var tmpVec = [0, 0];\n          var radius = ctx.lineWidth * 1.5;\n          _glMatrix.vec2.set(extents, radius, radius);\n          for (i = 0; i < this._transformedVerts.length - 1; i += 1) {\n            Point2d.sub(tmpVec, this._transformedVerts[i + 1], this._transformedVerts[i]);\n            _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n            Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n            AABox2d.initCenterExtents(aabox, tmpPt, extents);\n            if (AABox2d.containsPt(aabox, screenPt)) {\n              rtnObj.hit = true;\n              rtnObj.controlIndex = this._transformedVerts.length + i;\n              break;\n            }\n          }\n\n          if (i > 0 && i === this._transformedVerts.length - 1) {\n            Point2d.sub(tmpVec, this._transformedVerts[0], this._transformedVerts[i]);\n            _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n            Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n            AABox2d.initCenterExtents(aabox, tmpPt, extents);\n            if (AABox2d.containsPt(aabox, screenPt)) {\n              rtnObj.hit = true;\n              rtnObj.controlIndex = this._transformedVerts.length + i;\n            }\n          }\n        }\n      }\n\n      return rtnObj;\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      // we're storing our AABox in screen space here, so worldToScreenMatrix is\n      // unused\n      this._updateAABox(worldToScreenMatrix);\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      AABox2d.getCenter(center, this._aabox);\n      AABox2d.getExtents(extents, this._aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      var _this2 = this;\n\n      ctx.save();\n\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      var objToScreenMatrix = this._baseVertShape._fullXform;\n      var verts = this._baseVertShape.vertsRef;\n      this._transformedVerts = new Array(verts.length);\n      var tmpPt = [0, 0];\n      var tmpVec = [0, 0];\n\n      ctx.beginPath();\n      var i = 0;\n      this._transformedVerts[i] = [0, 0];\n      Point2d.transformMat2d(this._transformedVerts[i], verts[i], objToScreenMatrix);\n\n      var radius = Math.max(ctx.lineWidth * 1.5, 2.5);\n      for (i = 0; i < verts.length - 1; i += 1) {\n        this._transformedVerts[i + 1] = [0, 0];\n        Point2d.transformMat2d(this._transformedVerts[i + 1], verts[i + 1], objToScreenMatrix);\n        Point2d.sub(tmpVec, this._transformedVerts[i + 1], this._transformedVerts[i]);\n        _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n        Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n\n        ctx.moveTo(tmpPt[0] + radius, tmpPt[1]);\n        ctx.arc(tmpPt[0], tmpPt[1], radius, 0, Math.TWO_PI);\n      }\n\n      if (i > 0) {\n        Point2d.sub(tmpVec, this._transformedVerts[0], this._transformedVerts[i]);\n        _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n        Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n        ctx.moveTo(tmpPt[0] + radius, tmpPt[1]);\n        ctx.arc(tmpPt[0], tmpPt[1], radius, 0, Math.TWO_PI);\n\n        // TODO(croot): Is this appropriate? Can the fill/stroke style\n        // be cross compatible? What about gradients/patterns?\n        // We can probably safely assume no gradients/patterns at\n        // this point\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n\n      this._transformedVerts.forEach(function (vert) {\n        ctx.moveTo(vert[0] + _this2._vertRadius, vert[1]);\n        ctx.arc(vert[0], vert[1], _this2._vertRadius, 0, Math.TWO_PI);\n      });\n\n      if (this.isFillVisible()) {\n        this.setFillCtx(ctx);\n        ctx.fill();\n      }\n\n      if (this.isStrokeVisible()) {\n        this.setStrokeCtx(ctx);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }]);\n\n  return VertEditableShape;\n}(_baseShape2.default);\n\nexports.default = VertEditableShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMvdmVydC1lZGl0YWJsZS1zaGFwZS5qcz80ZWQzIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJQb2ludDJkIiwiVmVydEVkaXRhYmxlU2hhcGUiLCJiYXNlVmVydFNoYXBlIiwib3B0cyIsIl9iYXNlVmVydFNoYXBlIiwiX3ZlcnRSYWRpdXMiLCJfdHJhbnNmb3JtZWRWZXJ0cyIsIl9iYXNlYWFib3giLCJjcmVhdGUiLCJfd29ybGRUb1NjcmVlbk1hdHJpeCIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJhYWJveCIsImVxdWFscyIsImNvcHkiLCJ0cmFuc2Zvcm1NYXQyZCIsIl9hYWJveCIsInBhZCIsInN0cm9rZVdpZHRoIiwiZXhwYW5kIiwic2NyZWVuUHQiLCJ3b3JsZFB0IiwiY3R4IiwicnRuT2JqIiwiaGl0IiwiY29udHJvbEluZGV4IiwiX3VwZGF0ZUFBQm94IiwidmlzaWJsZSIsImNvbnRhaW5zUHQiLCJleHRlbnRzIiwiaSIsImxlbmd0aCIsImluaXRDZW50ZXJFeHRlbnRzIiwidG1wUHQiLCJ0bXBWZWMiLCJyYWRpdXMiLCJsaW5lV2lkdGgiLCJzZXQiLCJzdWIiLCJzY2FsZSIsImFkZFZlYzIiLCJib3VuZHNTdHJva2VTdHlsZSIsInNhdmUiLCJzZXRUcmFuc2Zvcm0iLCJzZXRTdHJva2VDdHgiLCJjZW50ZXIiLCJnZXRDZW50ZXIiLCJnZXRFeHRlbnRzIiwiYmVnaW5QYXRoIiwicmVjdCIsInN0cm9rZSIsInJlc3RvcmUiLCJvYmpUb1NjcmVlbk1hdHJpeCIsIl9mdWxsWGZvcm0iLCJ2ZXJ0cyIsInZlcnRzUmVmIiwiQXJyYXkiLCJNYXRoIiwibWF4IiwibW92ZVRvIiwiYXJjIiwiVFdPX1BJIiwiZmlsbFN0eWxlIiwic3Ryb2tlU3R5bGUiLCJmaWxsIiwiZm9yRWFjaCIsInZlcnQiLCJpc0ZpbGxWaXNpYmxlIiwic2V0RmlsbEN0eCIsImlzU3Ryb2tlVmlzaWJsZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFD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QUkwQixTQUFKOztBQUVBLFdBQUt6QyxpQkFBTCxDQUF1QjBELE9BQXZCLENBQStCLGdCQUFRO0FBQ3JDM0MsWUFBSXFDLE1BQUosQ0FBV08sS0FBSyxDQUFMLElBQVUsT0FBSzVELFdBQTFCLEVBQXVDNEQsS0FBSyxDQUFMLENBQXZDO0FBQ0E1QyxZQUFJc0MsR0FBSixDQUFRTSxLQUFLLENBQUwsQ0FBUixFQUFpQkEsS0FBSyxDQUFMLENBQWpCLEVBQTBCLE9BQUs1RCxXQUEvQixFQUE0QyxDQUE1QyxFQUErQ21ELEtBQUtJLE1BQXBEO0FBQ0QsT0FIRDs7QUFLQSxVQUFJLEtBQUtNLGFBQUwsRUFBSixFQUEwQjtBQUN4QixhQUFLQyxVQUFMLENBQWdCOUMsR0FBaEI7QUFDQUEsWUFBSTBDLElBQUo7QUFDRDs7QUFFRCxVQUFJLEtBQUtLLGVBQUwsRUFBSixFQUE0QjtBQUMxQixhQUFLekIsWUFBTCxDQUFrQnRCLEdBQWxCO0FBQ0FBLFlBQUk0QixNQUFKO0FBQ0Q7O0FBRUQ1QixVQUFJNkIsT0FBSjtBQUNEOzs7Ozs7a0JBN0prQmpELGlCIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tbWFnaWMtbnVtYmVycyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQge21hdDJkIGFzIE1hdDJkLCB2ZWMyIGFzIFZlYzJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSBcIi4uL3NoYXBlcy9iYXNlLXNoYXBlXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydEVkaXRhYmxlU2hhcGUgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBjb25zdHJ1Y3RvcihiYXNlVmVydFNoYXBlLCBvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9iYXNlVmVydFNoYXBlID0gYmFzZVZlcnRTaGFwZVxuICAgIHRoaXMuX3ZlcnRSYWRpdXMgPSA0XG4gICAgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cyA9IFtdXG4gICAgdGhpcy5fYmFzZWFhYm94ID0gQUFCb3gyZC5jcmVhdGUoKVxuICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuICB9XG5cbiAgX3VwZGF0ZUFBQm94KHdvcmxkVG9TY3JlZW5NYXRyaXgpIHtcbiAgICBjb25zdCBhYWJveCA9IHRoaXMuX2Jhc2VWZXJ0U2hhcGUuYWFib3hcbiAgICBpZiAoIUFBQm94MmQuZXF1YWxzKGFhYm94LCB0aGlzLl9iYXNlYWFib3gpIHx8ICFNYXQyZC5lcXVhbHMod29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCkpIHtcbiAgICAgIEFBQm94MmQuY29weSh0aGlzLl9iYXNlYWFib3gsIGFhYm94KVxuICAgICAgTWF0MmQuY29weSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB3b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgICAgQUFCb3gyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl9hYWJveCwgdGhpcy5fYmFzZWFhYm94LCB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgICAgY29uc3QgcGFkID0gdGhpcy5fdmVydFJhZGl1cyArIHRoaXMuc3Ryb2tlV2lkdGhcbiAgICAgIEFBQm94MmQuZXhwYW5kKHRoaXMuX2FhYm94LCB0aGlzLl9hYWJveCwgW3BhZCwgcGFkXSlcbiAgICB9XG4gIH1cblxuICBjb250YWluc1BvaW50KHNjcmVlblB0LCB3b3JsZFB0LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBjdHgpIHtcbiAgICAvLyBTaG91bGQgd2UgdXBkYXRlIGhlcmUsIG9yIGlzIGl0IHNhZmUgdG9cbiAgICAvLyBzYXkgdGhhdCB0aGlzIGlzIHN0YXRlZnVsLCBtZWFuaW5nIGEgcmVuZGVyXG4gICAgLy8gc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgYmVmb3JlaGFuZCB3aGljaFxuICAgIC8vIHdvdWxkJ3ZlIHVwZGF0ZWQgaXRzIHN0YXRlXG4gICAgY29uc3QgcnRuT2JqID0ge1xuICAgICAgaGl0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2xJbmRleDogLTFcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBQUJveCh3b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgIGlmICh0aGlzLnZpc2libGUgJiYgQUFCb3gyZC5jb250YWluc1B0KHRoaXMuX2FhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgIGNvbnN0IGFhYm94ID0gQUFCb3gyZC5jcmVhdGUoKVxuICAgICAgY29uc3QgcGFkID0gdGhpcy5fdmVydFJhZGl1cyArIHRoaXMuc3Ryb2tlV2lkdGggLyAyXG4gICAgICBjb25zdCBleHRlbnRzID0gW3BhZCwgcGFkXVxuXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHMoYWFib3gsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIGV4dGVudHMpXG4gICAgICAgIGlmIChBQUJveDJkLmNvbnRhaW5zUHQoYWFib3gsIHNjcmVlblB0KSkge1xuICAgICAgICAgIHJ0bk9iai5oaXQgPSB0cnVlXG4gICAgICAgICAgcnRuT2JqLmNvbnRyb2xJbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcnRuT2JqLmhpdCkge1xuICAgICAgICBjb25zdCB0bXBQdCA9IFswLCAwXVxuICAgICAgICBjb25zdCB0bXBWZWMgPSBbMCwgMF1cbiAgICAgICAgY29uc3QgcmFkaXVzID0gY3R4LmxpbmVXaWR0aCAqIDEuNVxuICAgICAgICBWZWMyZC5zZXQoZXh0ZW50cywgcmFkaXVzLCByYWRpdXMpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgIFBvaW50MmQuc3ViKHRtcFZlYywgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0sIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0pXG4gICAgICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgICAgICBQb2ludDJkLmFkZFZlYzIodG1wUHQsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIHRtcFZlYylcbiAgICAgICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKGFhYm94LCB0bXBQdCwgZXh0ZW50cylcbiAgICAgICAgICBpZiAoQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgICAgICAgIHJ0bk9iai5oaXQgPSB0cnVlXG4gICAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cy5sZW5ndGggKyBpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCAmJiBpID09PSB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBQb2ludDJkLnN1Yih0bXBWZWMsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbMF0sIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0pXG4gICAgICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgICAgICBQb2ludDJkLmFkZFZlYzIodG1wUHQsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIHRtcFZlYylcbiAgICAgICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKGFhYm94LCB0bXBQdCwgZXh0ZW50cylcbiAgICAgICAgICBpZiAoQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgICAgICAgIHJ0bk9iai5oaXQgPSB0cnVlXG4gICAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cy5sZW5ndGggKyBpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ0bk9ialxuICB9XG5cbiAgcmVuZGVyQm91bmRzKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgYm91bmRzU3Ryb2tlU3R5bGUpIHtcbiAgICAvLyB3ZSdyZSBzdG9yaW5nIG91ciBBQUJveCBpbiBzY3JlZW4gc3BhY2UgaGVyZSwgc28gd29ybGRUb1NjcmVlbk1hdHJpeCBpc1xuICAgIC8vIHVudXNlZFxuICAgIHRoaXMuX3VwZGF0ZUFBQm94KHdvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgY3R4LnNhdmUoKVxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBib3VuZHNTdHJva2VTdHlsZS5zZXRTdHJva2VDdHgoY3R4KVxuICAgIGNvbnN0IGNlbnRlciA9IFswLCAwXVxuICAgIGNvbnN0IGV4dGVudHMgPSBbMCwgMF1cbiAgICBBQUJveDJkLmdldENlbnRlcihjZW50ZXIsIHRoaXMuX2FhYm94KVxuICAgIEFBQm94MmQuZ2V0RXh0ZW50cyhleHRlbnRzLCB0aGlzLl9hYWJveClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHgucmVjdChjZW50ZXJbMF0gLSBleHRlbnRzWzBdLCBjZW50ZXJbMV0gLSBleHRlbnRzWzFdLCBleHRlbnRzWzBdICogMiwgZXh0ZW50c1sxXSAqIDIpXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG5cbiAgcmVuZGVyKGN0eCkge1xuICAgIGN0eC5zYXZlKClcblxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjb25zdCBvYmpUb1NjcmVlbk1hdHJpeCA9IHRoaXMuX2Jhc2VWZXJ0U2hhcGUuX2Z1bGxYZm9ybVxuICAgIGNvbnN0IHZlcnRzID0gdGhpcy5fYmFzZVZlcnRTaGFwZS52ZXJ0c1JlZlxuICAgIHRoaXMuX3RyYW5zZm9ybWVkVmVydHMgPSBuZXcgQXJyYXkodmVydHMubGVuZ3RoKVxuICAgIGNvbnN0IHRtcFB0ID0gWzAsIDBdXG4gICAgY29uc3QgdG1wVmVjID0gWzAsIDBdXG5cbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBsZXQgaSA9IDBcbiAgICB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldID0gWzAsIDBdXG4gICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldLCB2ZXJ0c1tpXSwgb2JqVG9TY3JlZW5NYXRyaXgpXG5cbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heChjdHgubGluZVdpZHRoICogMS41LCAyLjUpXG4gICAgZm9yIChpID0gMDsgaSA8IHZlcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0gPSBbMCwgMF1cbiAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0sIHZlcnRzW2kgKyAxXSwgb2JqVG9TY3JlZW5NYXRyaXgpXG4gICAgICBQb2ludDJkLnN1Yih0bXBWZWMsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaSArIDFdLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldKVxuICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgIFBvaW50MmQuYWRkVmVjMih0bXBQdCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgdG1wVmVjKVxuXG4gICAgICBjdHgubW92ZVRvKHRtcFB0WzBdICsgcmFkaXVzLCB0bXBQdFsxXSlcbiAgICAgIGN0eC5hcmModG1wUHRbMF0sIHRtcFB0WzFdLCByYWRpdXMsIDAsIE1hdGguVFdPX1BJKVxuICAgIH1cblxuICAgIGlmIChpID4gMCkge1xuICAgICAgUG9pbnQyZC5zdWIodG1wVmVjLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzWzBdLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldKVxuICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgIFBvaW50MmQuYWRkVmVjMih0bXBQdCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgdG1wVmVjKVxuICAgICAgY3R4Lm1vdmVUbyh0bXBQdFswXSArIHJhZGl1cywgdG1wUHRbMV0pXG4gICAgICBjdHguYXJjKHRtcFB0WzBdLCB0bXBQdFsxXSwgcmFkaXVzLCAwLCBNYXRoLlRXT19QSSlcblxuICAgICAgLy8gVE9ETyhjcm9vdCk6IElzIHRoaXMgYXBwcm9wcmlhdGU/IENhbiB0aGUgZmlsbC9zdHJva2Ugc3R5bGVcbiAgICAgIC8vIGJlIGNyb3NzIGNvbXBhdGlibGU/IFdoYXQgYWJvdXQgZ3JhZGllbnRzL3BhdHRlcm5zP1xuICAgICAgLy8gV2UgY2FuIHByb2JhYmx5IHNhZmVseSBhc3N1bWUgbm8gZ3JhZGllbnRzL3BhdHRlcm5zIGF0XG4gICAgICAvLyB0aGlzIHBvaW50XG4gICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlXG4gICAgICBjdHguZmlsbCgpXG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpXG5cbiAgICB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmZvckVhY2godmVydCA9PiB7XG4gICAgICBjdHgubW92ZVRvKHZlcnRbMF0gKyB0aGlzLl92ZXJ0UmFkaXVzLCB2ZXJ0WzFdKVxuICAgICAgY3R4LmFyYyh2ZXJ0WzBdLCB2ZXJ0WzFdLCB0aGlzLl92ZXJ0UmFkaXVzLCAwLCBNYXRoLlRXT19QSSlcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuaXNGaWxsVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLnNldEZpbGxDdHgoY3R4KVxuICAgICAgY3R4LmZpbGwoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3Ryb2tlVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLnNldFN0cm9rZUN0eChjdHgpXG4gICAgICBjdHguc3Ryb2tlKClcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2ludGVyYWN0aW9ucy92ZXJ0LWVkaXRhYmxlLXNoYXBlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(4);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _transform2d = __webpack_require__(12);\n\nvar _mat2d = __webpack_require__(5);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _rect = __webpack_require__(16);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _vec2d = __webpack_require__(10);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Constants = {\n  SIDES: 4\n};\n\nfunction drawOBBoxModifierRect(ctx, pt, objToScreenMat, modifierSize, modifierHalfSize, modifierRotation, scale) {\n  Point2d.transformMat2d(pt, pt, objToScreenMat);\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.translate(pt[0], pt[1]);\n  ctx.rotate(modifierRotation[1]);\n  ctx.scale(scale[0], scale[1]);\n  ctx.rotate(modifierRotation[0]);\n  ctx.translate(-pt[0], -pt[1]);\n  ctx.rect(pt[0] - modifierHalfSize, pt[1] - modifierHalfSize, modifierSize, modifierSize);\n\n  // ctx.moveTo(pt[0], pt[1])\n  // ctx.lineTo(pt[0], pt[1] + 20)\n  // ctx.moveTo(pt[0], pt[1])\n  // ctx.lineTo(pt[0] + 20, pt[1])\n\n  // ctx.font = \"24px serif\"\n  // ctx.fillText(text, pt[0], pt[1])\n}\n\nfunction isPointInOBBoxModifierRect(screenPt, modifierPt, objToScreenMat, modifierMat, halfBoxSz, boxSz, padBoxSz, padBoxRadius, xScale, yScale) {\n  var hit = false;\n  var rotate = false;\n  Point2d.transformMat2d(modifierPt, modifierPt, objToScreenMat);\n  if (Point2d.distance(modifierPt, screenPt) <= padBoxRadius) {\n    _vec2d2.default.negate(modifierPt, modifierPt);\n    modifierMat[4] = modifierMat[0] * modifierPt[0] + modifierMat[2] * modifierPt[1];\n    modifierMat[5] = modifierMat[1] * modifierPt[0] + modifierMat[3] * modifierPt[1];\n\n    var x = 0;\n    var y = 0;\n    Point2d.transformMat2d(modifierPt, screenPt, modifierMat);\n    if (Math.abs(modifierPt[0]) <= halfBoxSz && Math.abs(modifierPt[1]) <= halfBoxSz || Boolean(xScale) && Boolean(yScale) && (rotate = (x = xScale * modifierPt[0]) > -halfBoxSz && x <= padBoxSz && (y = yScale * modifierPt[1]) > -halfBoxSz && y <= padBoxSz)) {\n      hit = true;\n    }\n  }\n  return {\n    hit: hit,\n    rotate: rotate\n  };\n}\n\nvar XformShape = function (_Rect) {\n  _inherits(XformShape, _Rect);\n\n  function XformShape(opts) {\n    var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      scalable: true,\n      rotatable: true\n    };\n\n    _classCallCheck(this, XformShape);\n\n    var _this = _possibleConstructorReturn(this, (XformShape.__proto__ || Object.getPrototypeOf(XformShape)).call(this, opts));\n\n    _this._interactiveBoxSize = 8;\n    _this._interactiveBoxPadding = 10;\n    if (opts && typeof opts.vertexSize !== \"undefined\") {\n      _this._interactiveBoxSize = opts.vertexSize;\n    }\n\n    _this._scalable = true;\n    _this._rotatable = true;\n    if (selectOpts) {\n      if (typeof selectOpts.scalable !== \"undefined\") {\n        _this._scalable = Boolean(selectOpts.scalable);\n      }\n\n      if (typeof selectOpts.rotatable !== \"undefined\") {\n        _this._rotatable = Boolean(selectOpts.rotatable);\n      }\n    }\n    return _this;\n  }\n\n  _createClass(XformShape, [{\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtnObj = {\n        hit: false,\n        rotate: false,\n        controlIndex: -1\n      };\n\n      var aabox = this.aabox;\n      if ((this._rotatable || this._scalable) && this.visible && AABox2d.containsPt(aabox, screenPt)) {\n        var scale = [0, 0];\n        var rot = [0, 0];\n        _mat2d2.default.svd(null, scale, rot, this._fullXform);\n        var mat = _mat2d2.default.create();\n\n        scale[0] = scale[0] < 0 ? -1 : 1;\n        scale[1] = scale[1] < 0 ? -1 : 1;\n\n        if (scale[0] * scale[1] > 0) {\n          _vec2d2.default.negate(rot, rot);\n        }\n\n        _mat2d2.default.rotate(mat, mat, rot[1]);\n        _mat2d2.default.scale(mat, mat, scale);\n        _mat2d2.default.rotate(mat, mat, rot[0]);\n\n        var boxPadding = this._rotatable ? this._interactiveBoxPadding : 0;\n        var halfBoxSz = this._interactiveBoxSize / 2;\n        var halfWidth = this.width / 2;\n        var halfHeight = this.height / 2;\n        var pt = [0, 0];\n        var padSz = halfBoxSz + boxPadding;\n        var padRadius = Math.sqrt(2 * padSz * padSz);\n        var xScale = 0;\n        var yScale = 0;\n\n        for (var i = 0; i < Constants.SIDES; i += 1) {\n          xScale = i < 2 ? -1 : 1;\n          yScale = i % 2 === 0 ? -1 : 1;\n          Point2d.set(pt, xScale * halfWidth, yScale * halfHeight);\n          rtnObj = isPointInOBBoxModifierRect(screenPt, pt, this._fullXform, mat, halfBoxSz, this._interactiveBoxSize, padSz, padRadius, xScale, yScale, scale);\n          if (rtnObj.hit) {\n            rtnObj.controlIndex = i;\n            break;\n          }\n        }\n\n        if (!rtnObj.hit && this._scalable) {\n          for (var _i = 0; _i < Constants.SIDES; _i += 1) {\n            xScale = _i % 2 === 0 ? _i < 2 ? -1 : 1 : 0;\n            yScale = _i % 2 === 0 ? 0 : _i < 2 ? -1 : 1;\n            Point2d.set(pt, xScale * halfWidth, yScale * halfHeight);\n            rtnObj = isPointInOBBoxModifierRect(screenPt, pt, this._fullXform, mat, halfBoxSz, this._interactiveBoxSize, padSz, padRadius, xScale, yScale, scale);\n            if (rtnObj.hit) {\n              rtnObj.controlIndex = _i + Constants.SIDES;\n              break;\n            }\n          }\n        }\n\n        if (rtnObj.rotate && !this._rotatable) {\n          rtnObj.rotate = false;\n        } else if (!rtnObj.rotate && !this._scalable) {\n          rtnObj.rotate = true;\n        }\n      }\n\n      return rtnObj;\n    }\n  }, {\n    key: \"_updatelocalxform\",\n    value: function _updatelocalxform(force) {\n      if (this._lxformDirty || force) {\n        var pos = Point2d.clone(this._pos);\n        Point2d.addVec2(pos, pos, this._parent.pivotRef);\n        (0, _transform2d.buildXformMatrix)(this._localXform, this._rotDeg, this._scale, pos, this._pivot);\n        if (this._localXformUpdated) {\n          this._localXformUpdated();\n        }\n        this._lxformDirty = false;\n      }\n    }\n  }, {\n    key: \"_updateglobalxform\",\n    value: function _updateglobalxform() {\n      if (this._lxformDirty || this._xformDirty) {\n        this._updatelocalxform(true);\n        if (this._parent) {\n          _mat2d2.default.multiply(this._globalXform, this._parent.globalXform, this._localXform);\n        } else {\n          _mat2d2.default.copy(this._globalXform, this._localXform);\n        }\n        if (this._globalXformUpdated) {\n          this._globalXformUpdated();\n        }\n        this._xformDirty = false;\n      }\n    }\n  }, {\n    key: \"_updateAABox\",\n    value: function _updateAABox() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (force || this._geomDirty || this._boundsOutOfDate) {\n        var boxPadding = this._rotatable ? this._interactiveBoxPadding : 0;\n        var padding = boxPadding + this._interactiveBoxSize / 2;\n        AABox2d.initCenterExtents(this._aabox, [0, 0], [this.width / 2, this.height / 2]);\n        AABox2d.transformMat2d(this._aabox, this._aabox, this._fullXform);\n        AABox2d.expand(this._aabox, this._aabox, [padding, padding]);\n        this._aaboxUpdated = true;\n        this._geomDirty = this._boundsOutOfDate = false;\n      }\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      // we're storing our AABox in screen space here, so worldToScreenMatrix is\n      // unused\n      var aabox = this.aabox;\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      AABox2d.getCenter(center, aabox);\n      AABox2d.getExtents(extents, aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      if (!this.parent || typeof this.parent.width === \"undefined\" || this.parent.height === \"undefined\") {\n        return;\n      }\n\n      this._aaboxUpdated = false;\n      // do not fill the primary rectangle\n      _get(XformShape.prototype.__proto__ || Object.getPrototypeOf(XformShape.prototype), \"render\", this).call(this, ctx, worldToScreenMatrix, styleState, false);\n      if (!this._aaboxUpdated) {\n        this._updateAABox(true);\n      }\n\n      var scale = [0, 0];\n      var rot = [0, 0];\n      _mat2d2.default.svd(null, scale, rot, this._fullXform);\n      scale[0] = scale[0] < 0 ? -1 : 1;\n      scale[1] = scale[1] < 0 ? -1 : 1;\n\n      var halfBoxSz = this._interactiveBoxSize / 2;\n      var halfWidth = this.width / 2;\n      var halfHeight = this.height / 2;\n      var pt = [halfWidth, halfHeight];\n\n      ctx.save();\n\n      ctx.beginPath();\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"3\");\n\n      Point2d.set(pt, halfWidth, -halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"2\");\n\n      Point2d.set(pt, -halfWidth, -halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"0\");\n\n      Point2d.set(pt, -halfWidth, halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"1\");\n\n      if (this._scalable) {\n        Point2d.set(pt, 0, halfHeight);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, 0, -halfHeight);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, halfWidth, 0);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, -halfWidth, 0);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n      }\n\n      if (this.isFillVisible()) {\n        styleState.setFillStyle(ctx, this);\n        ctx.fill();\n      }\n\n      if (this.isStrokeVisible()) {\n        styleState.setStrokeStyle(ctx, this);\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.parent && this.parent.width !== \"undefined\" ? this.parent.width : 0;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.parent && this.parent.height !== \"undefined\" ? this.parent.height : 0;\n    }\n  }]);\n\n  return XformShape;\n}(_rect2.default);\n\nexports.default = XformShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMveGZvcm0tc2hhcGUuanM/MmU2MyJdLCJuYW1lcyI6WyJBQUJveDJkIiwiUG9pbnQyZCIsIkNvbnN0YW50cyIsIlNJREVTIiwiZHJhd09CQm94TW9kaWZpZXJSZWN0IiwiY3R4IiwicHQiLCJvYmpUb1NjcmVlbk1hdCIsIm1vZGlmaWVyU2l6ZSIsIm1vZGlmaWVySGFsZlNpemUiLCJtb2RpZmllclJvdGF0aW9uIiwic2NhbGUiLCJ0cmFuc2Zvcm1NYXQyZCIsInNldFRyYW5zZm9ybSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlY3QiLCJpc1BvaW50SW5PQkJveE1vZGlmaWVyUmVjdCIsInNjcmVlblB0IiwibW9kaWZpZXJQdCIsIm1vZGlmaWVyTWF0IiwiaGFsZkJveFN6IiwiYm94U3oiLCJwYWRCb3hTeiIsInBhZEJveFJhZGl1cyIsInhTY2FsZSIsInlTY2FsZSIsImhpdCIsImRpc3RhbmNlIiwibmVnYXRlIiwieCIsInkiLCJNYXRoIiwiYWJzIiwiQm9vbGVhbiIsIlhmb3JtU2hhcGUiLCJvcHRzIiwic2VsZWN0T3B0cyIsInNjYWxhYmxlIiwicm90YXRhYmxlIiwiX2ludGVyYWN0aXZlQm94U2l6ZSIsIl9pbnRlcmFjdGl2ZUJveFBhZGRpbmciLCJ2ZXJ0ZXhTaXplIiwiX3NjYWxhYmxlIiwiX3JvdGF0YWJsZSIsInJ0bk9iaiIsImNvbnRyb2xJbmRleCIsImFhYm94IiwidmlzaWJsZSIsImNvbnRhaW5zUHQiLCJyb3QiLCJzdmQiLCJfZnVsbFhmb3JtIiwibWF0IiwiY3JlYXRlIiwiYm94UGFkZGluZyIsImhhbGZXaWR0aCIsIndpZHRoIiwiaGFsZkhlaWdodCIsImhlaWdodCIsInBhZFN6IiwicGFkUmFkaXVzIiwic3FydCIsImkiLCJzZXQiLCJmb3JjZSIsIl9seGZvcm1EaXJ0eSIsInBvcyIsImNsb25lIiwiX3BvcyIsImFkZFZlYzIiLCJfcGFyZW50IiwicGl2b3RSZWYiLCJfbG9jYWxYZm9ybSIsIl9yb3REZWciLCJfc2NhbGUiLCJfcGl2b3QiLCJfbG9jYWxYZm9ybVVwZGF0ZWQiLCJfeGZvcm1EaXJ0eSIsIl91cGRhdGVsb2NhbHhmb3JtIiwibXVsdGlwbHkiLCJfZ2xvYmFsWGZvcm0iLCJnbG9iYWxYZm9ybSIsImNvcHkiLCJfZ2xvYmFsWGZvcm1VcGRhdGVkIiwiX2dlb21EaXJ0eSIsIl9ib3VuZHNPdXRPZkRhdGUiLCJwYWRkaW5nIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJleHBhbmQiLCJfYWFib3hVcGRhdGVkIiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImJvdW5kc1N0cm9rZVN0eWxlIiwic2F2ZSIsInNldFN0cm9rZUN0eCIsImNlbnRlciIsImV4dGVudHMiLCJnZXRDZW50ZXIiLCJnZXRFeHRlbnRzIiwiYmVnaW5QYXRoIiwic3Ryb2tlIiwicmVzdG9yZSIsInN0eWxlU3RhdGUiLCJwYXJlbnQiLCJfdXBkYXRlQUFCb3giLCJpc0ZpbGxWaXNpYmxlIiwic2V0RmlsbFN0eWxlIiwiZmlsbCIsImlzU3Ryb2tlVmlzaWJsZSIsInNldFN0cm9rZVN0eWxlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOztJQUFZQyxPOztBQUNaOztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQyxZQUFZO0FBQ2hCQyxTQUFPO0FBRFMsQ0FBbEI7O0FBSUEsU0FBU0MscUJBQVQsQ0FBK0JDLEdBQS9CLEVBQW9DQyxFQUFwQyxFQUF3Q0MsY0FBeEMsRUFBd0RDLFlBQXhELEVBQXNFQyxnQkFBdEUsRUFBd0ZDLGdCQUF4RixFQUEwR0MsS0FBMUcsRUFBaUg7QUFDL0dWLFVBQVFXLGNBQVIsQ0FBdUJOLEVBQXZCLEVBQTJCQSxFQUEzQixFQUErQkMsY0FBL0I7QUFDQUYsTUFBSVEsWUFBSixDQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxDQUFoQztBQUNB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RUFBNEI7QUFDMUJOLG1CQUFXTyxjQUFYLENBQTBCekcsR0FBMUIsRUFBK0IsSUFBL0I7QUFDQUEsWUFBSVEsWUFBSixDQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxDQUFoQztBQUNBUixZQUFJZ0csTUFBSjtBQUNEOztBQUVEaEcsVUFBSWlHLE9BQUo7QUFDRDs7O3dCQXhGVztBQUNWLGFBQVEsS0FBS0UsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWS9DLEtBQVosS0FBc0IsV0FBckMsR0FBbUQsS0FBSytDLE1BQUwsQ0FBWS9DLEtBQS9ELEdBQXVFLENBQS9FO0FBQ0Q7Ozt3QkFFWTtBQUNYLGFBQVEsS0FBSytDLE1BQUwsSUFBZSxLQUFLQSxNQUFMLENBQVk3QyxNQUFaLEtBQXVCLFdBQXRDLEdBQW9ELEtBQUs2QyxNQUFMLENBQVk3QyxNQUFoRSxHQUF5RSxDQUFqRjtBQUNEOzs7Ozs7a0JBaEprQnhCLFUiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0ICogYXMgUG9pbnQyZCBmcm9tIFwiLi4vY29yZS9wb2ludDJkXCJcbmltcG9ydCB7XG4gIGJ1aWxkWGZvcm1NYXRyaXhcbn0gZnJvbSBcIi4uL3NoYXBlcy90cmFuc2Zvcm0yZFwiXG5pbXBvcnQgTWF0MmQgZnJvbSBcIi4uL2NvcmUvbWF0MmRcIlxuaW1wb3J0IFJlY3QgZnJvbSBcIi4uL3NoYXBlcy9yZWN0XCJcbmltcG9ydCBWZWMyZCBmcm9tIFwiLi4vY29yZS92ZWMyZFwiXG5cbmNvbnN0IENvbnN0YW50cyA9IHtcbiAgU0lERVM6IDRcbn1cblxuZnVuY3Rpb24gZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIG9ialRvU2NyZWVuTWF0LCBtb2RpZmllclNpemUsIG1vZGlmaWVySGFsZlNpemUsIG1vZGlmaWVyUm90YXRpb24sIHNjYWxlKSB7XG4gIFBvaW50MmQudHJhbnNmb3JtTWF0MmQocHQsIHB0LCBvYmpUb1NjcmVlbk1hdClcbiAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICBjdHgudHJhbnNsYXRlKHB0WzBdLCBwdFsxXSlcbiAgY3R4LnJvdGF0ZShtb2RpZmllclJvdGF0aW9uWzFdKVxuICBjdHguc2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKVxuICBjdHgucm90YXRlKG1vZGlmaWVyUm90YXRpb25bMF0pXG4gIGN0eC50cmFuc2xhdGUoLXB0WzBdLCAtcHRbMV0pXG4gIGN0eC5yZWN0KHB0WzBdIC0gbW9kaWZpZXJIYWxmU2l6ZSwgcHRbMV0gLSBtb2RpZmllckhhbGZTaXplLCBtb2RpZmllclNpemUsIG1vZGlmaWVyU2l6ZSlcblxuICAvLyBjdHgubW92ZVRvKHB0WzBdLCBwdFsxXSlcbiAgLy8gY3R4LmxpbmVUbyhwdFswXSwgcHRbMV0gKyAyMClcbiAgLy8gY3R4Lm1vdmVUbyhwdFswXSwgcHRbMV0pXG4gIC8vIGN0eC5saW5lVG8ocHRbMF0gKyAyMCwgcHRbMV0pXG5cbiAgLy8gY3R4LmZvbnQgPSBcIjI0cHggc2VyaWZcIlxuICAvLyBjdHguZmlsbFRleHQodGV4dCwgcHRbMF0sIHB0WzFdKVxufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5PQkJveE1vZGlmaWVyUmVjdChzY3JlZW5QdCwgbW9kaWZpZXJQdCwgb2JqVG9TY3JlZW5NYXQsIG1vZGlmaWVyTWF0LCBoYWxmQm94U3osIGJveFN6LCBwYWRCb3hTeiwgcGFkQm94UmFkaXVzLCB4U2NhbGUsIHlTY2FsZSkge1xuICBsZXQgaGl0ID0gZmFsc2VcbiAgbGV0IHJvdGF0ZSA9IGZhbHNlXG4gIFBvaW50MmQudHJhbnNmb3JtTWF0MmQobW9kaWZpZXJQdCwgbW9kaWZpZXJQdCwgb2JqVG9TY3JlZW5NYXQpXG4gIGlmIChQb2ludDJkLmRpc3RhbmNlKG1vZGlmaWVyUHQsIHNjcmVlblB0KSA8PSBwYWRCb3hSYWRpdXMpIHtcbiAgICBWZWMyZC5uZWdhdGUobW9kaWZpZXJQdCwgbW9kaWZpZXJQdClcbiAgICBtb2RpZmllck1hdFs0XSA9IG1vZGlmaWVyTWF0WzBdICogbW9kaWZpZXJQdFswXSArIG1vZGlmaWVyTWF0WzJdICogbW9kaWZpZXJQdFsxXVxuICAgIG1vZGlmaWVyTWF0WzVdID0gbW9kaWZpZXJNYXRbMV0gKiBtb2RpZmllclB0WzBdICsgbW9kaWZpZXJNYXRbM10gKiBtb2RpZmllclB0WzFdXG5cbiAgICBsZXQgeCA9IDBcbiAgICBsZXQgeSA9IDBcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKG1vZGlmaWVyUHQsIHNjcmVlblB0LCBtb2RpZmllck1hdClcbiAgICBpZiAoKE1hdGguYWJzKG1vZGlmaWVyUHRbMF0pIDw9IGhhbGZCb3hTeiAmJiBNYXRoLmFicyhtb2RpZmllclB0WzFdKSA8PSBoYWxmQm94U3opIHx8XG4gICAgICAoQm9vbGVhbih4U2NhbGUpICYmIEJvb2xlYW4oeVNjYWxlKSAmJlxuICAgICAgICAocm90YXRlID0gKCh4ID0geFNjYWxlICogbW9kaWZpZXJQdFswXSkgPiAtaGFsZkJveFN6ICYmIHggPD0gcGFkQm94U3ogJiZcbiAgICAgICAgICAoeSA9IHlTY2FsZSAqIG1vZGlmaWVyUHRbMV0pID4gLWhhbGZCb3hTeiAmJiB5IDw9IHBhZEJveFN6KSkpKSB7XG4gICAgICBoaXQgPSB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaGl0LFxuICAgIHJvdGF0ZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhmb3JtU2hhcGUgZXh0ZW5kcyBSZWN0IHtcbiAgY29uc3RydWN0b3Iob3B0cywgc2VsZWN0T3B0cyA9IHtcbiAgICBzY2FsYWJsZTogdHJ1ZSxcbiAgICByb3RhdGFibGU6IHRydWVcbiAgfSkge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplID0gOFxuICAgIHRoaXMuX2ludGVyYWN0aXZlQm94UGFkZGluZyA9IDEwXG4gICAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMudmVydGV4U2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplID0gb3B0cy52ZXJ0ZXhTaXplXG4gICAgfVxuXG4gICAgdGhpcy5fc2NhbGFibGUgPSB0cnVlXG4gICAgdGhpcy5fcm90YXRhYmxlID0gdHJ1ZVxuICAgIGlmIChzZWxlY3RPcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdE9wdHMuc2NhbGFibGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fc2NhbGFibGUgPSBCb29sZWFuKHNlbGVjdE9wdHMuc2NhbGFibGUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0T3B0cy5yb3RhdGFibGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fcm90YXRhYmxlID0gQm9vbGVhbihzZWxlY3RPcHRzLnJvdGF0YWJsZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb250YWluc1BvaW50KHNjcmVlblB0KSB7XG4gICAgLy8gU2hvdWxkIHdlIHVwZGF0ZSBoZXJlLCBvciBpcyBpdCBzYWZlIHRvXG4gICAgLy8gc2F5IHRoYXQgdGhpcyBpcyBzdGF0ZWZ1bCwgbWVhbmluZyBhIHJlbmRlclxuICAgIC8vIHNob3VsZCBoYXZlIGJlZW4gcGVyZm9ybWVkIGJlZm9yZWhhbmQgd2hpY2hcbiAgICAvLyB3b3VsZCd2ZSB1cGRhdGVkIGl0cyBzdGF0ZVxuICAgIGxldCBydG5PYmogPSB7XG4gICAgICBoaXQ6IGZhbHNlLFxuICAgICAgcm90YXRlOiBmYWxzZSxcbiAgICAgIGNvbnRyb2xJbmRleDogLTFcbiAgICB9XG5cbiAgICBjb25zdCBhYWJveCA9IHRoaXMuYWFib3hcbiAgICBpZiAoKHRoaXMuX3JvdGF0YWJsZSB8fCB0aGlzLl9zY2FsYWJsZSkgJiYgdGhpcy52aXNpYmxlICYmIEFBQm94MmQuY29udGFpbnNQdChhYWJveCwgc2NyZWVuUHQpKSB7XG4gICAgICBjb25zdCBzY2FsZSA9IFswLCAwXVxuICAgICAgY29uc3Qgcm90ID0gWzAsIDBdXG4gICAgICBNYXQyZC5zdmQobnVsbCwgc2NhbGUsIHJvdCwgdGhpcy5fZnVsbFhmb3JtKVxuICAgICAgY29uc3QgbWF0ID0gTWF0MmQuY3JlYXRlKClcblxuICAgICAgc2NhbGVbMF0gPSAoc2NhbGVbMF0gPCAwID8gLTEgOiAxKVxuICAgICAgc2NhbGVbMV0gPSAoc2NhbGVbMV0gPCAwID8gLTEgOiAxKVxuXG4gICAgICBpZiAoc2NhbGVbMF0gKiBzY2FsZVsxXSA+IDApIHtcbiAgICAgICAgVmVjMmQubmVnYXRlKHJvdCwgcm90KVxuICAgICAgfVxuXG4gICAgICBNYXQyZC5yb3RhdGUobWF0LCBtYXQsIHJvdFsxXSlcbiAgICAgIE1hdDJkLnNjYWxlKG1hdCwgbWF0LCBzY2FsZSlcbiAgICAgIE1hdDJkLnJvdGF0ZShtYXQsIG1hdCwgcm90WzBdKVxuXG4gICAgICBjb25zdCBib3hQYWRkaW5nID0gKHRoaXMuX3JvdGF0YWJsZSA/IHRoaXMuX2ludGVyYWN0aXZlQm94UGFkZGluZyA6IDApXG4gICAgICBjb25zdCBoYWxmQm94U3ogPSB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUgLyAyXG4gICAgICBjb25zdCBoYWxmV2lkdGggPSB0aGlzLndpZHRoIC8gMlxuICAgICAgY29uc3QgaGFsZkhlaWdodCA9IHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgY29uc3QgcHQgPSBbMCwgMF1cbiAgICAgIGNvbnN0IHBhZFN6ID0gaGFsZkJveFN6ICsgYm94UGFkZGluZ1xuICAgICAgY29uc3QgcGFkUmFkaXVzID0gTWF0aC5zcXJ0KDIgKiBwYWRTeiAqIHBhZFN6KVxuICAgICAgbGV0IHhTY2FsZSA9IDBcbiAgICAgIGxldCB5U2NhbGUgPSAwXG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ29uc3RhbnRzLlNJREVTOyBpICs9IDEpIHtcbiAgICAgICAgeFNjYWxlID0gKGkgPCAyID8gLTEgOiAxKVxuICAgICAgICB5U2NhbGUgPSAoaSAlIDIgPT09IDAgPyAtMSA6IDEpXG4gICAgICAgIFBvaW50MmQuc2V0KHB0LCB4U2NhbGUgKiBoYWxmV2lkdGgsIHlTY2FsZSAqIGhhbGZIZWlnaHQpXG4gICAgICAgIHJ0bk9iaiA9IGlzUG9pbnRJbk9CQm94TW9kaWZpZXJSZWN0KHNjcmVlblB0LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCBtYXQsIGhhbGZCb3hTeiwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBwYWRTeiwgcGFkUmFkaXVzLCB4U2NhbGUsIHlTY2FsZSwgc2NhbGUpXG4gICAgICAgIGlmIChydG5PYmouaGl0KSB7XG4gICAgICAgICAgcnRuT2JqLmNvbnRyb2xJbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcnRuT2JqLmhpdCAmJiB0aGlzLl9zY2FsYWJsZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IENvbnN0YW50cy5TSURFUzsgaSArPSAxKSB7XG4gICAgICAgICAgeFNjYWxlID0gKGkgJSAyID09PSAwID8gKGkgPCAyID8gLTEgOiAxKSA6IDApXG4gICAgICAgICAgeVNjYWxlID0gKGkgJSAyID09PSAwID8gMCA6IChpIDwgMiA/IC0xIDogMSkpXG4gICAgICAgICAgUG9pbnQyZC5zZXQocHQsIHhTY2FsZSAqIGhhbGZXaWR0aCwgeVNjYWxlICogaGFsZkhlaWdodClcbiAgICAgICAgICBydG5PYmogPSBpc1BvaW50SW5PQkJveE1vZGlmaWVyUmVjdChzY3JlZW5QdCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgbWF0LCBoYWxmQm94U3osIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgcGFkU3osIHBhZFJhZGl1cywgeFNjYWxlLCB5U2NhbGUsIHNjYWxlKVxuICAgICAgICAgIGlmIChydG5PYmouaGl0KSB7XG4gICAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gaSArIENvbnN0YW50cy5TSURFU1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJ0bk9iai5yb3RhdGUgJiYgIXRoaXMuX3JvdGF0YWJsZSkge1xuICAgICAgICBydG5PYmoucm90YXRlID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiAoIXJ0bk9iai5yb3RhdGUgJiYgIXRoaXMuX3NjYWxhYmxlKSB7XG4gICAgICAgIHJ0bk9iai5yb3RhdGUgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ0bk9ialxuICB9XG5cbiAgX3VwZGF0ZWxvY2FseGZvcm0oZm9yY2UpIHtcbiAgICBpZiAodGhpcy5fbHhmb3JtRGlydHkgfHwgZm9yY2UpIHtcbiAgICAgIGNvbnN0IHBvcyA9IFBvaW50MmQuY2xvbmUodGhpcy5fcG9zKVxuICAgICAgUG9pbnQyZC5hZGRWZWMyKHBvcywgcG9zLCB0aGlzLl9wYXJlbnQucGl2b3RSZWYpXG4gICAgICBidWlsZFhmb3JtTWF0cml4KHRoaXMuX2xvY2FsWGZvcm0sIHRoaXMuX3JvdERlZywgdGhpcy5fc2NhbGUsIHBvcywgdGhpcy5fcGl2b3QpXG4gICAgICBpZiAodGhpcy5fbG9jYWxYZm9ybVVwZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxYZm9ybVVwZGF0ZWQoKVxuICAgICAgfVxuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIF91cGRhdGVnbG9iYWx4Zm9ybSgpIHtcbiAgICBpZiAodGhpcy5fbHhmb3JtRGlydHkgfHwgdGhpcy5feGZvcm1EaXJ0eSkge1xuICAgICAgdGhpcy5fdXBkYXRlbG9jYWx4Zm9ybSh0cnVlKVxuICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICBNYXQyZC5tdWx0aXBseSh0aGlzLl9nbG9iYWxYZm9ybSwgdGhpcy5fcGFyZW50Lmdsb2JhbFhmb3JtLCB0aGlzLl9sb2NhbFhmb3JtKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTWF0MmQuY29weSh0aGlzLl9nbG9iYWxYZm9ybSwgdGhpcy5fbG9jYWxYZm9ybSlcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9nbG9iYWxYZm9ybVVwZGF0ZWQpIHtcbiAgICAgICAgdGhpcy5fZ2xvYmFsWGZvcm1VcGRhdGVkKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX3hmb3JtRGlydHkgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG5cbiAgX3VwZGF0ZUFBQm94KGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgdGhpcy5fZ2VvbURpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSkge1xuICAgICAgY29uc3QgYm94UGFkZGluZyA9ICh0aGlzLl9yb3RhdGFibGUgPyB0aGlzLl9pbnRlcmFjdGl2ZUJveFBhZGRpbmcgOiAwKVxuICAgICAgY29uc3QgcGFkZGluZyA9IGJveFBhZGRpbmcgKyB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUgLyAyXG4gICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyXSlcbiAgICAgIEFBQm94MmQudHJhbnNmb3JtTWF0MmQodGhpcy5fYWFib3gsIHRoaXMuX2FhYm94LCB0aGlzLl9mdWxsWGZvcm0pXG4gICAgICBBQUJveDJkLmV4cGFuZCh0aGlzLl9hYWJveCwgdGhpcy5fYWFib3gsIFtwYWRkaW5nLCBwYWRkaW5nXSlcbiAgICAgIHRoaXMuX2FhYm94VXBkYXRlZCA9IHRydWVcbiAgICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRoaXMuX2JvdW5kc091dE9mRGF0ZSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQud2lkdGggIT09IFwidW5kZWZpbmVkXCIgPyB0aGlzLnBhcmVudC53aWR0aCA6IDApXG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaGVpZ2h0ICE9PSBcInVuZGVmaW5lZFwiID8gdGhpcy5wYXJlbnQuaGVpZ2h0IDogMClcbiAgfVxuXG4gIHJlbmRlckJvdW5kcyhjdHgsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIGJvdW5kc1N0cm9rZVN0eWxlKSB7XG4gICAgLy8gd2UncmUgc3RvcmluZyBvdXIgQUFCb3ggaW4gc2NyZWVuIHNwYWNlIGhlcmUsIHNvIHdvcmxkVG9TY3JlZW5NYXRyaXggaXNcbiAgICAvLyB1bnVzZWRcbiAgICBjb25zdCBhYWJveCA9IHRoaXMuYWFib3hcbiAgICBjdHguc2F2ZSgpXG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgIGJvdW5kc1N0cm9rZVN0eWxlLnNldFN0cm9rZUN0eChjdHgpXG4gICAgY29uc3QgY2VudGVyID0gWzAsIDBdXG4gICAgY29uc3QgZXh0ZW50cyA9IFswLCAwXVxuICAgIEFBQm94MmQuZ2V0Q2VudGVyKGNlbnRlciwgYWFib3gpXG4gICAgQUFCb3gyZC5nZXRFeHRlbnRzKGV4dGVudHMsIGFhYm94KVxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5yZWN0KGNlbnRlclswXSAtIGV4dGVudHNbMF0sIGNlbnRlclsxXSAtIGV4dGVudHNbMV0sIGV4dGVudHNbMF0gKiAyLCBleHRlbnRzWzFdICogMilcbiAgICBjdHguc3Ryb2tlKClcbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cblxuICByZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBzdHlsZVN0YXRlKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCB8fCB0eXBlb2YgdGhpcy5wYXJlbnQud2lkdGggPT09IFwidW5kZWZpbmVkXCIgfHwgdGhpcy5wYXJlbnQuaGVpZ2h0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9hYWJveFVwZGF0ZWQgPSBmYWxzZVxuICAgIC8vIGRvIG5vdCBmaWxsIHRoZSBwcmltYXJ5IHJlY3RhbmdsZVxuICAgIHN1cGVyLnJlbmRlcihjdHgsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHN0eWxlU3RhdGUsIGZhbHNlKVxuICAgIGlmICghdGhpcy5fYWFib3hVcGRhdGVkKSB7XG4gICAgICB0aGlzLl91cGRhdGVBQUJveCh0cnVlKVxuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlID0gWzAsIDBdXG4gICAgY29uc3Qgcm90ID0gWzAsIDBdXG4gICAgTWF0MmQuc3ZkKG51bGwsIHNjYWxlLCByb3QsIHRoaXMuX2Z1bGxYZm9ybSlcbiAgICBzY2FsZVswXSA9IChzY2FsZVswXSA8IDAgPyAtMSA6IDEpXG4gICAgc2NhbGVbMV0gPSAoc2NhbGVbMV0gPCAwID8gLTEgOiAxKVxuXG4gICAgY29uc3QgaGFsZkJveFN6ID0gdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplIC8gMlxuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMud2lkdGggLyAyXG4gICAgY29uc3QgaGFsZkhlaWdodCA9IHRoaXMuaGVpZ2h0IC8gMlxuICAgIGNvbnN0IHB0ID0gW2hhbGZXaWR0aCwgaGFsZkhlaWdodF1cblxuICAgIGN0eC5zYXZlKClcblxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlLCBcIjNcIilcblxuICAgIFBvaW50MmQuc2V0KHB0LCBoYWxmV2lkdGgsIC1oYWxmSGVpZ2h0KVxuICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlLCBcIjJcIilcblxuICAgIFBvaW50MmQuc2V0KHB0LCAtaGFsZldpZHRoLCAtaGFsZkhlaWdodClcbiAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSwgXCIwXCIpXG5cbiAgICBQb2ludDJkLnNldChwdCwgLWhhbGZXaWR0aCwgaGFsZkhlaWdodClcbiAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSwgXCIxXCIpXG5cbiAgICBpZiAodGhpcy5fc2NhbGFibGUpIHtcbiAgICAgIFBvaW50MmQuc2V0KHB0LCAwLCBoYWxmSGVpZ2h0KVxuICAgICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUpXG5cbiAgICAgIFBvaW50MmQuc2V0KHB0LCAwLCAtaGFsZkhlaWdodClcbiAgICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlKVxuXG4gICAgICBQb2ludDJkLnNldChwdCwgaGFsZldpZHRoLCAwKVxuICAgICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUpXG5cbiAgICAgIFBvaW50MmQuc2V0KHB0LCAtaGFsZldpZHRoLCAwKVxuICAgICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNGaWxsVmlzaWJsZSgpKSB7XG4gICAgICBzdHlsZVN0YXRlLnNldEZpbGxTdHlsZShjdHgsIHRoaXMpXG4gICAgICBjdHguZmlsbCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTdHJva2VWaXNpYmxlKCkpIHtcbiAgICAgIHN0eWxlU3RhdGUuc2V0U3Ryb2tlU3R5bGUoY3R4LCB0aGlzKVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgICAgY3R4LnN0cm9rZSgpXG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbnRlcmFjdGlvbnMveGZvcm0tc2hhcGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(7);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _math = __webpack_require__(6);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} CircleOptions\n * @property {number} [radius=10] Radius of the circle in world-space coordinates\n */\n\n/**\n * @class Shape class describing a circle\n * @extends {BaseShape}\n */\nvar Circle = function (_BaseShape) {\n  _inherits(Circle, _BaseShape);\n\n  /**\n   * Creates a new Circle shape\n   * @param  {CircleOptions} [opts]\n   * @return {Circle}\n   */\n  function Circle(opts) {\n    _classCallCheck(this, Circle);\n\n    var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, opts));\n\n    _this._radius = 10;\n    if (typeof opts.radius !== \"undefined\") {\n      _this.radius = opts.radius;\n    }\n    AABox2d.initCenterExtents(_this._aabox, [0, 0], [_this._radius, _this._radius]);\n    return _this;\n  }\n\n  /**\n   * Sets the radius of the circle\n   * @param  {number} radius Radius of circle in world-space coordinates\n   * @return {Circle}        this\n   * @fires {Shape#geomChanged}\n   * @throws {Error} If radius is not a valid number\n   */\n\n\n  _createClass(Circle, [{\n    key: \"getDimensions\",\n\n\n    /**\n     * Gets the untransformed width/height of the circle\n     * @return {Vec2d} Width/height of the circle, untransformed\n     */\n    value: function getDimensions() {\n      var diameter = this.radius * 2;\n      return [diameter, diameter];\n    }\n\n    /**\n     * Gets the untransformed width of the circle\n     * @return {number}\n     */\n\n  }, {\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        var pos = this._pos;\n        var scale = this._scale;\n        var rot = _math2.default.DEG_TO_RAD * this._rotDeg;\n        var cossqr = _math2.default.pow(_math2.default.cos(rot), 2);\n        var sinsqr = _math2.default.pow(_math2.default.sin(rot), 2);\n        var asqr = _math2.default.pow(scale[0] * this._radius, 2);\n        var bsqr = _math2.default.pow(scale[1] * this._radius, 2);\n        var A = _math2.default.sqrt(bsqr * sinsqr + asqr * cossqr);\n        var B = _math2.default.sqrt(asqr * sinsqr + bsqr * cossqr);\n        AABox2d.initCenterExtents(this._aabox, pos, [A, B]);\n        this._geomDirty = false;\n        this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the circle using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.arc(0, 0, this._radius, 0, _math2.default.TWO_PI, false);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Circle\", // NOTE: this much match the name of the class\n        radius: this.radius\n      }, _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"radius\",\n    set: function set(radius) {\n      if (typeof radius !== \"number\") {\n        throw new Error(\"Radius must be a number\");\n      }\n\n      if (radius !== this._radius) {\n        var prev = this._radius;\n        this._radius = radius;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"radius\",\n          prevVal: prev,\n          currVal: this._radius\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets the current radius of the circle\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._radius;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.radius * 2;\n    }\n\n    /**\n     * Gets the untransformed height of the circle\n     * @return {number}\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.radius * 2;\n    }\n  }]);\n\n  return Circle;\n}(_baseShape2.default);\n\nexports.default = Circle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvY2lyY2xlLmpzP2FkOWQiXSwibmFtZXMiOlsiQUFCb3gyZCIsIkNpcmNsZSIsIm9wdHMiLCJfcmFkaXVzIiwicmFkaXVzIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJkaWFtZXRlciIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwicG9zIiwiX3BvcyIsInNjYWxlIiwiX3NjYWxlIiwicm90IiwiREVHX1RPX1JBRCIsIl9yb3REZWciLCJjb3NzcXIiLCJwb3ciLCJjb3MiLCJzaW5zcXIiLCJzaW4iLCJhc3FyIiwiYnNxciIsIkEiLCJzcXJ0IiwiQiIsImN0eCIsImFyYyIsIlRXT19QSSIsIk9iamVjdCIsImFzc2lnbiIsInR5cGUiLCJFcnJvciIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7Ozs7SUFJcUJDLE07OztBQUNuQjs7Ozs7QUFLQSxrQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLGdIQUNWQSxJQURVOztBQUVoQixVQUFLQyxPQUFMLEdBQWUsRUFBZjtBQUNBLFFBQUksT0FBT0QsS0FBS0UsTUFBWixLQUF1QixXQUEzQixFQUF3QztBQUN0QyxZQUFLQSxNQUFMLEdBQWNGLEtBQUtFLE1BQW5CO0FBQ0Q7QUFDREosWUFBUUssaUJBQVIsQ0FBMEIsTUFBS0MsTUFBL0IsRUFBdUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUF2QyxFQUErQyxDQUFDLE1BQUtILE9BQU4sRUFBZSxNQUFLQSxPQUFwQixDQUEvQztBQU5nQjtBQU9qQjs7QUFFRDs7Ozs7Ozs7Ozs7OztBQW1DQTs7OztvQ0FJZ0I7QUFDZCxVQUFNSSxXQUFXLEtBQUtILE1BQUwsR0FBYyxDQUEvQjtBQUNBLGFBQU8sQ0FBQ0csUUFBRCxFQUFXQSxRQUFYLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBZ0JBOzs7OzttQ0FLZTtBQUNiLFVBQUksS0FBS0MsVUFBTCxJQUFtQixLQUFLQyxnQkFBNUIsRUFBOEM7QUFDNUMsWUFBTUMsTUFBTSxLQUFLQyxJQUFqQjtBQUNBLFlBQU1DLFFBQVEsS0FBS0MsTUFBbkI7QUFDQSxZQUFNQyxNQUFNLGVBQUtDLFVBQUwsR0FBa0IsS0FBS0MsT0FBbkM7QUFDQSxZQUFNQyxTQUFTLGVBQUtDLEdBQUwsQ0FBUyxlQUFLQyxHQUFMLENBQVNMLEdBQVQsQ0FBVCxFQUF3QixDQUF4QixDQUFmO0FBQ0EsWUFBTU0sU0FBUyxlQUFLRixHQUFMLENBQVMsZUFBS0csR0FBTCxDQUFTUCxHQUFULENBQVQsRUFBd0IsQ0FBeEIsQ0FBZjtBQUNBLFlBQU1RLE9BQU8sZUFBS0osR0FBTCxDQUFTTixNQUFNLENBQU4sSUFBVyxLQUFLVCxPQUF6QixFQUFrQyxDQUFsQyxDQUFiO0FBQ0EsWUFBTW9CLE9BQU8sZUFBS0wsR0FBTCxDQUFTTixNQUFNLENBQU4sSUFBVyxLQUFLVCxPQUF6QixFQUFrQyxDQUFsQyxDQUFiO0FBQ0EsWUFBTXFCLElBQUksZUFBS0MsSUFBTCxDQUFVRixPQUFPSCxNQUFQLEdBQWdCRSxPQUFPTCxNQUFqQyxDQUFWO0FBQ0EsWUFBTVMsSUFBSSxlQUFLRCxJQUFMLENBQVVILE9BQU9GLE1BQVAsR0FBZ0JHLE9BQU9OLE1BQWpDLENBQVY7QUFDQWpCLGdCQUFRSyxpQkFBUixDQUEwQixLQUFLQyxNQUEvQixFQUF1Q0ksR0FBdkMsRUFBNEMsQ0FBQ2MsQ0FBRCxFQUFJRSxDQUFKLENBQTVDO0FBQ0EsYUFBS2xCLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxhQUFLQyxnQkFBTCxHQUF3QixLQUF4QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzswQkFNTWtCLEcsRUFBSztBQUNUQSxVQUFJQyxHQUFKLENBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxLQUFLekIsT0FBbkIsRUFBNEIsQ0FBNUIsRUFBK0IsZUFBSzBCLE1BQXBDLEVBQTRDLEtBQTVDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZCQUtTO0FBQ1AsYUFBT0MsT0FBT0MsTUFBUCxDQUFjO0FBQ25CQyxjQUFNLFFBRGEsRUFDSDtBQUNoQjVCLGdCQUFRLEtBQUtBO0FBRk0sT0FBZCx5R0FBUDtBQUlEOzs7c0JBL0ZVQSxNLEVBQVE7QUFDakIsVUFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCLGNBQU0sSUFBSTZCLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7O0FBRUQsVUFBSTdCLFdBQVcsS0FBS0QsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTStCLE9BQU8sS0FBSy9CLE9BQWxCO0FBQ0EsYUFBS0EsT0FBTCxHQUFlQyxNQUFmO0FBQ0EsYUFBS0ksVUFBTCxHQUFrQixJQUFsQixDQUgyQixDQUdKOztBQUV2QixhQUFLMkIsSUFBTCxDQUFVLGNBQVYsRUFBMEI7QUFDeEJDLGdCQUFNLFFBRGtCO0FBRXhCQyxtQkFBU0gsSUFGZTtBQUd4QkksbUJBQVMsS0FBS25DO0FBSFUsU0FBMUI7QUFLRDs7QUFFRCxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7d0JBSWE7QUFDWCxhQUFPLEtBQUtBLE9BQVo7QUFDRDs7O3dCQWVXO0FBQ1YsYUFBTyxLQUFLQyxNQUFMLEdBQWMsQ0FBckI7QUFDRDs7QUFFRDs7Ozs7Ozt3QkFJYTtBQUNYLGFBQU8sS0FBS0EsTUFBTCxHQUFjLENBQXJCO0FBQ0Q7Ozs7OztrQkF6RWtCSCxNIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSBcIi4vYmFzZS1zaGFwZS5qc1wiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDaXJjbGVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1cz0xMF0gUmFkaXVzIG9mIHRoZSBjaXJjbGUgaW4gd29ybGQtc3BhY2UgY29vcmRpbmF0ZXNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBTaGFwZSBjbGFzcyBkZXNjcmliaW5nIGEgY2lyY2xlXG4gKiBAZXh0ZW5kcyB7QmFzZVNoYXBlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDaXJjbGUgc2hhcGVcbiAgICogQHBhcmFtICB7Q2lyY2xlT3B0aW9uc30gW29wdHNdXG4gICAqIEByZXR1cm4ge0NpcmNsZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3JhZGl1cyA9IDEwXG4gICAgaWYgKHR5cGVvZiBvcHRzLnJhZGl1cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1c1xuICAgIH1cbiAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c10pXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZSBpbiB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtDaXJjbGV9ICAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByYWRpdXMgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAqL1xuICBzZXQgcmFkaXVzKHJhZGl1cykge1xuICAgIGlmICh0eXBlb2YgcmFkaXVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYWRpdXMgbXVzdCBiZSBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIGlmIChyYWRpdXMgIT09IHRoaXMuX3JhZGl1cykge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3JhZGl1c1xuICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwicmFkaXVzXCIsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IHRoaXMuX3JhZGl1c1xuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW50cmFuc2Zvcm1lZCB3aWR0aC9oZWlnaHQgb2YgdGhlIGNpcmNsZVxuICAgKiBAcmV0dXJuIHtWZWMyZH0gV2lkdGgvaGVpZ2h0IG9mIHRoZSBjaXJjbGUsIHVudHJhbnNmb3JtZWRcbiAgICovXG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgZGlhbWV0ZXIgPSB0aGlzLnJhZGl1cyAqIDJcbiAgICByZXR1cm4gW2RpYW1ldGVyLCBkaWFtZXRlcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSBjaXJjbGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyAqIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bnRyYW5zZm9ybWVkIGhlaWdodCBvZiB0aGUgY2lyY2xlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzICogMlxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBib3VuZGluZyBib3ggcmVxdWlyZXMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfdXBkYXRlQUFCb3goKSB7XG4gICAgaWYgKHRoaXMuX2dlb21EaXJ0eSB8fCB0aGlzLl9ib3VuZHNPdXRPZkRhdGUpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3Bvc1xuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY2FsZVxuICAgICAgY29uc3Qgcm90ID0gTWF0aC5ERUdfVE9fUkFEICogdGhpcy5fcm90RGVnXG4gICAgICBjb25zdCBjb3NzcXIgPSBNYXRoLnBvdyhNYXRoLmNvcyhyb3QpLCAyKVxuICAgICAgY29uc3Qgc2luc3FyID0gTWF0aC5wb3coTWF0aC5zaW4ocm90KSwgMilcbiAgICAgIGNvbnN0IGFzcXIgPSBNYXRoLnBvdyhzY2FsZVswXSAqIHRoaXMuX3JhZGl1cywgMilcbiAgICAgIGNvbnN0IGJzcXIgPSBNYXRoLnBvdyhzY2FsZVsxXSAqIHRoaXMuX3JhZGl1cywgMilcbiAgICAgIGNvbnN0IEEgPSBNYXRoLnNxcnQoYnNxciAqIHNpbnNxciArIGFzcXIgKiBjb3NzcXIpXG4gICAgICBjb25zdCBCID0gTWF0aC5zcXJ0KGFzcXIgKiBzaW5zcXIgKyBic3FyICogY29zc3FyKVxuICAgICAgQUFCb3gyZC5pbml0Q2VudGVyRXh0ZW50cyh0aGlzLl9hYWJveCwgcG9zLCBbQSwgQl0pXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSBmYWxzZVxuICAgICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgdGhlIGNpcmNsZSB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5hcmMoMCwgMCwgdGhpcy5fcmFkaXVzLCAwLCBNYXRoLlRXT19QSSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGNvbnZlcnQgdGhlIHNoYXBlIHRvIGEgc2VyaWFsaXphYmxlIEpTT04gb2JqZWN0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogXCJDaXJjbGVcIiwgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1c1xuICAgIH0sIHN1cGVyLnRvSlNPTigpKVxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9jaXJjbGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(7);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _mat2d = __webpack_require__(5);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _math = __webpack_require__(6);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} PointOptions\n * @property {number} [size=5] Size of the point in pixels\n */\n\n/**\n * @class Point shape class. A point differs from a circle in that\n *        a point's size is defined in screen/pixel space whereas\n *        a circle is defined in world space.\n * @extends {BaseShape}\n */\nvar Point = function (_BaseShape) {\n  _inherits(Point, _BaseShape);\n\n  /**\n   * Creates a new point shape\n   * @param  {PointOptions} [opts]\n   * @return {Point}\n   */\n  function Point(opts) {\n    _classCallCheck(this, Point);\n\n    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, opts));\n\n    _this._size = 5;\n    if (typeof opts.size !== \"undefined\") {\n      _this.size = opts.size;\n    }\n    AABox2d.initCenterExtents(_this._aabox, [0, 0], [_this._radius, _this._radius]);\n    _this.translate(opts.x || 0, opts.y || 0);\n    return _this;\n  }\n\n  /**\n   * Sets the size of the point\n   * @param  {nuber} size Size of the point in pixels\n   * @return {Pixel}      this\n   * @fires {Shape#geomChanged}\n   * @throws {Error} If size is not a valid number\n   */\n\n\n  _createClass(Point, [{\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        var pos = this._pos;\n        var scale = this._scale;\n        var rot = _math2.default.DEG_TO_RAD * this._rotDeg;\n        var cossqr = _math2.default.pow(_math2.default.cos(rot), 2);\n        var sinsqr = _math2.default.pow(_math2.default.sin(rot), 2);\n        var asqr = _math2.default.pow(scale[0] * this._size, 2);\n        var bsqr = _math2.default.pow(scale[1] * this._size, 2);\n        var A = _math2.default.sqrt(bsqr * sinsqr + asqr * cossqr);\n        var B = _math2.default.sqrt(asqr * sinsqr + bsqr * cossqr);\n        AABox2d.initCenterExtents(this._aabox, pos, [A, B]);\n        this._geomDirty = false;\n        this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the point using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      var pos = [0, 0];\n      _mat2d2.default.svd(pos, null, null, this._fullXform);\n      ctx.arc(pos[0], pos[1], this._size, 0, _math2.default.TWO_PI, false);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Point\", // NOTE: this much match the name of the class\n        size: this.size\n      }, _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"size\",\n    set: function set(size) {\n      if (typeof size !== \"number\") {\n        throw new Error(\"Radius must be a number\");\n      }\n\n      if (size !== this._size) {\n        var prev = this._size;\n        this._size = size;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"size\",\n          prevVal: prev,\n          currVal: this._size\n        });\n      }\n    }\n\n    /**\n     * Gets the current size of the point\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._size;\n    }\n  }]);\n\n  return Point;\n}(_baseShape2.default);\n\nexports.default = Point;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9pbnQuanM/OWY2OSJdLCJuYW1lcyI6WyJBQUJveDJkIiwiUG9pbnQiLCJvcHRzIiwiX3NpemUiLCJzaXplIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJfcmFkaXVzIiwidHJhbnNsYXRlIiwieCIsInkiLCJfZ2VvbURpcnR5IiwiX2JvdW5kc091dE9mRGF0ZSIsInBvcyIsIl9wb3MiLCJzY2FsZSIsIl9zY2FsZSIsInJvdCIsIkRFR19UT19SQUQiLCJfcm90RGVnIiwiY29zc3FyIiwicG93IiwiY29zIiwic2luc3FyIiwic2luIiwiYXNxciIsImJzcXIiLCJBIiwic3FydCIsIkIiLCJjdHgiLCJzZXRUcmFuc2Zvcm0iLCJzdmQiLCJfZnVsbFhmb3JtIiwiYXJjIiwiVFdPX1BJIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsIkVycm9yIiwicHJldiIsImZpcmUiLCJhdHRyIiwicHJldlZhbCIsImN1cnJWYWwiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7OztBQUtBOzs7Ozs7SUFNcUJDLEs7OztBQUNuQjs7Ozs7QUFLQSxpQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLDhHQUNWQSxJQURVOztBQUVoQixVQUFLQyxLQUFMLEdBQWEsQ0FBYjtBQUNBLFFBQUksT0FBT0QsS0FBS0UsSUFBWixLQUFxQixXQUF6QixFQUFzQztBQUNwQyxZQUFLQSxJQUFMLEdBQVlGLEtBQUtFLElBQWpCO0FBQ0Q7QUFDREosWUFBUUssaUJBQVIsQ0FBMEIsTUFBS0MsTUFBL0IsRUFBdUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUF2QyxFQUErQyxDQUFDLE1BQUtDLE9BQU4sRUFBZSxNQUFLQSxPQUFwQixDQUEvQztBQUNBLFVBQUtDLFNBQUwsQ0FBZU4sS0FBS08sQ0FBTCxJQUFVLENBQXpCLEVBQTRCUCxLQUFLUSxDQUFMLElBQVUsQ0FBdEM7QUFQZ0I7QUFRakI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7Ozs7O21DQUtlO0FBQ2IsVUFBSSxLQUFLQyxVQUFMLElBQW1CLEtBQUtDLGdCQUE1QixFQUE4QztBQUM1QyxZQUFNQyxNQUFNLEtBQUtDLElBQWpCO0FBQ0EsWUFBTUMsUUFBUSxLQUFLQyxNQUFuQjtBQUNBLFlBQU1DLE1BQU0sZUFBS0MsVUFBTCxHQUFrQixLQUFLQyxPQUFuQztBQUNBLFlBQU1DLFNBQVMsZUFBS0MsR0FBTCxDQUFTLGVBQUtDLEdBQUwsQ0FBU0wsR0FBVCxDQUFULEVBQXdCLENBQXhCLENBQWY7QUFDQSxZQUFNTSxTQUFTLGVBQUtGLEdBQUwsQ0FBUyxlQUFLRyxHQUFMLENBQVNQLEdBQVQsQ0FBVCxFQUF3QixDQUF4QixDQUFmO0FBQ0EsWUFBTVEsT0FBTyxlQUFLSixHQUFMLENBQVNOLE1BQU0sQ0FBTixJQUFXLEtBQUtaLEtBQXpCLEVBQWdDLENBQWhDLENBQWI7QUFDQSxZQUFNdUIsT0FBTyxlQUFLTCxHQUFMLENBQVNOLE1BQU0sQ0FBTixJQUFXLEtBQUtaLEtBQXpCLEVBQWdDLENBQWhDLENBQWI7QUFDQSxZQUFNd0IsSUFBSSxlQUFLQyxJQUFMLENBQVVGLE9BQU9ILE1BQVAsR0FBZ0JFLE9BQU9MLE1BQWpDLENBQVY7QUFDQSxZQUFNUyxJQUFJLGVBQUtELElBQUwsQ0FBVUgsT0FBT0YsTUFBUCxHQUFnQkcsT0FBT04sTUFBakMsQ0FBVjtBQUNBcEIsZ0JBQVFLLGlCQUFSLENBQTBCLEtBQUtDLE1BQS9CLEVBQXVDTyxHQUF2QyxFQUE0QyxDQUFDYyxDQUFELEVBQUlFLENBQUosQ0FBNUM7QUFDQSxhQUFLbEIsVUFBTCxHQUFrQixLQUFsQjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCLEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OzBCQU1Na0IsRyxFQUFLO0FBQ1RBLFVBQUlDLFlBQUosQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEM7QUFDQSxVQUFNbEIsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQSxzQkFBTW1CLEdBQU4sQ0FBVW5CLEdBQVYsRUFBZSxJQUFmLEVBQXFCLElBQXJCLEVBQTJCLEtBQUtvQixVQUFoQztBQUNBSCxVQUFJSSxHQUFKLENBQVFyQixJQUFJLENBQUosQ0FBUixFQUFnQkEsSUFBSSxDQUFKLENBQWhCLEVBQXdCLEtBQUtWLEtBQTdCLEVBQW9DLENBQXBDLEVBQXVDLGVBQUtnQyxNQUE1QyxFQUFvRCxLQUFwRDtBQUNEOztBQUVEOzs7Ozs7Ozs2QkFLUztBQUNQLGFBQU9DLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxPQURhLEVBQ0o7QUFDZmxDLGNBQU0sS0FBS0E7QUFGUSxPQUFkLHVHQUFQO0FBSUQ7OztzQkF2RVFBLEksRUFBTTtBQUNiLFVBQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixjQUFNLElBQUltQyxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUluQyxTQUFTLEtBQUtELEtBQWxCLEVBQXlCO0FBQ3ZCLFlBQU1xQyxPQUFPLEtBQUtyQyxLQUFsQjtBQUNBLGFBQUtBLEtBQUwsR0FBYUMsSUFBYjtBQUNBLGFBQUtPLFVBQUwsR0FBa0IsSUFBbEIsQ0FIdUIsQ0FHQTs7QUFFdkIsYUFBSzhCLElBQUwsQ0FBVSxjQUFWLEVBQTBCO0FBQ3hCQyxnQkFBTSxNQURrQjtBQUV4QkMsbUJBQVNILElBRmU7QUFHeEJJLG1CQUFTLEtBQUt6QztBQUhVLFNBQTFCO0FBS0Q7QUFDRjs7QUFFRDs7Ozs7d0JBSVc7QUFDVCxhQUFPLEtBQUtBLEtBQVo7QUFDRDs7Ozs7O2tCQS9Da0JGLEsiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQb2ludE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZT01XSBTaXplIG9mIHRoZSBwb2ludCBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBQb2ludCBzaGFwZSBjbGFzcy4gQSBwb2ludCBkaWZmZXJzIGZyb20gYSBjaXJjbGUgaW4gdGhhdFxuICogICAgICAgIGEgcG9pbnQncyBzaXplIGlzIGRlZmluZWQgaW4gc2NyZWVuL3BpeGVsIHNwYWNlIHdoZXJlYXNcbiAqICAgICAgICBhIGNpcmNsZSBpcyBkZWZpbmVkIGluIHdvcmxkIHNwYWNlLlxuICogQGV4dGVuZHMge0Jhc2VTaGFwZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwb2ludCBzaGFwZVxuICAgKiBAcGFyYW0gIHtQb2ludE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3NpemUgPSA1XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZVxuICAgIH1cbiAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c10pXG4gICAgdGhpcy50cmFuc2xhdGUob3B0cy54IHx8IDAsIG9wdHMueSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHBvaW50XG4gICAqIEBwYXJhbSAge251YmVyfSBzaXplIFNpemUgb2YgdGhlIHBvaW50IGluIHBpeGVsc1xuICAgKiBAcmV0dXJuIHtQaXhlbH0gICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzaXplIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgKi9cbiAgc2V0IHNpemUoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFkaXVzIG11c3QgYmUgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSAhPT0gdGhpcy5fc2l6ZSkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3NpemVcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwic2l6ZVwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl9zaXplXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHBvaW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCByZXF1aXJlcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fZ2VvbURpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSkge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5fcG9zXG4gICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX3NjYWxlXG4gICAgICBjb25zdCByb3QgPSBNYXRoLkRFR19UT19SQUQgKiB0aGlzLl9yb3REZWdcbiAgICAgIGNvbnN0IGNvc3NxciA9IE1hdGgucG93KE1hdGguY29zKHJvdCksIDIpXG4gICAgICBjb25zdCBzaW5zcXIgPSBNYXRoLnBvdyhNYXRoLnNpbihyb3QpLCAyKVxuICAgICAgY29uc3QgYXNxciA9IE1hdGgucG93KHNjYWxlWzBdICogdGhpcy5fc2l6ZSwgMilcbiAgICAgIGNvbnN0IGJzcXIgPSBNYXRoLnBvdyhzY2FsZVsxXSAqIHRoaXMuX3NpemUsIDIpXG4gICAgICBjb25zdCBBID0gTWF0aC5zcXJ0KGJzcXIgKiBzaW5zcXIgKyBhc3FyICogY29zc3FyKVxuICAgICAgY29uc3QgQiA9IE1hdGguc3FydChhc3FyICogc2luc3FyICsgYnNxciAqIGNvc3NxcilcbiAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHModGhpcy5fYWFib3gsIHBvcywgW0EsIEJdKVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gZmFsc2VcbiAgICAgIHRoaXMuX2JvdW5kc091dE9mRGF0ZSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBwb2ludCB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjb25zdCBwb3MgPSBbMCwgMF1cbiAgICBNYXQyZC5zdmQocG9zLCBudWxsLCBudWxsLCB0aGlzLl9mdWxsWGZvcm0pXG4gICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgdGhpcy5fc2l6ZSwgMCwgTWF0aC5UV09fUEksIGZhbHNlKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBjb252ZXJ0IHRoZSBzaGFwZSB0byBhIHNlcmlhbGl6YWJsZSBKU09OIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IFwiUG9pbnRcIiwgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgc2l6ZTogdGhpcy5zaXplXG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3BvaW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _polyLine = __webpack_require__(11);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Constants = {\n  MINIMUM_POINTS: 3\n};\n\nvar Poly = function (_PolyLine) {\n  _inherits(Poly, _PolyLine);\n\n  function Poly(opts) {\n    _classCallCheck(this, Poly);\n\n    var _this = _possibleConstructorReturn(this, (Poly.__proto__ || Object.getPrototypeOf(Poly)).call(this, opts));\n\n    if (_this._verts.length < Constants.MINIMUM_POINTS) {\n      throw new Error(\"Poly shapes must be initialized with an array of 2d points and contain at least 3 points\");\n    }\n    return _this;\n  }\n\n  _createClass(Poly, [{\n    key: \"removeVert\",\n    value: function removeVert(vertIndex) {\n      if (this._verts.length < Constants.MINIMUM_POINTS) {\n        throw new Error(\"Cannot remove vertex \" + vertIndex + \". It would result in a poly with < 3 points. A poly must contain at least 3 points.\");\n      }\n\n      _get(Poly.prototype.__proto__ || Object.getPrototypeOf(Poly.prototype), \"removeVert\", this).call(this, vertIndex);\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      var rtn = false;\n      if (this._verts.length >= Constants.MINIMUM_POINTS) {\n        ctx.moveTo(this._verts[0][0], this._verts[0][1]);\n        for (var i = 1; i < this._verts.length; i += 1) {\n          ctx.lineTo(this._verts[i][0], this._verts[i][1]);\n        }\n        ctx.closePath();\n        rtn = true;\n      }\n      return rtn;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign(_get(Poly.prototype.__proto__ || Object.getPrototypeOf(Poly.prototype), \"toJSON\", this).call(this), {\n        type: \"Poly\" // NOTE: this much match the name of the class\n        // This is also supplied after the super.toJSON()\n        // so that this type overrides the parent class's\n        // type\n      });\n    }\n  }]);\n\n  return Poly;\n}(_polyLine2.default);\n\nexports.default = Poly;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9seS5qcz8zNmZiIl0sIm5hbWVzIjpbIkNvbnN0YW50cyIsIk1JTklNVU1fUE9JTlRTIiwiUG9seSIsIm9wdHMiLCJfdmVydHMiLCJsZW5ndGgiLCJFcnJvciIsInZlcnRJbmRleCIsImN0eCIsInJ0biIsIm1vdmVUbyIsImkiLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJPYmplY3QiLCJhc3NpZ24iLCJ0eXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxZQUFZO0FBQ2hCQyxrQkFBZ0I7QUFEQSxDQUFsQjs7SUFJcUJDLEk7OztBQUNuQixnQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLDRHQUNWQSxJQURVOztBQUVoQixRQUFJLE1BQUtDLE1BQUwsQ0FBWUMsTUFBWixHQUFxQkwsVUFBVUMsY0FBbkMsRUFBbUQ7QUFDakQsWUFBTSxJQUFJSyxLQUFKLENBQVUsMEZBQVYsQ0FBTjtBQUNEO0FBSmU7QUFLakI7Ozs7K0JBRVVDLFMsRUFBVztBQUNwQixVQUFJLEtBQUtILE1BQUwsQ0FBWUMsTUFBWixHQUFxQkwsVUFBVUMsY0FBbkMsRUFBbUQ7QUFDakQsY0FBTSxJQUFJSyxLQUFKLDJCQUFrQ0MsU0FBbEMseUZBQU47QUFDRDs7QUFFRCw2R0FBaUJBLFNBQWpCO0FBQ0Q7OzswQkFHS0MsRyxFQUFLO0FBQ1QsVUFBSUMsTUFBTSxLQUFWO0FBQ0EsVUFBSSxLQUFLTCxNQUFMLENBQVlDLE1BQVosSUFBc0JMLFVBQVVDLGNBQXBDLEVBQW9EO0FBQ2xETyxZQUFJRSxNQUFKLENBQVcsS0FBS04sTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQVgsRUFBOEIsS0FBS0EsTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQTlCO0FBQ0EsYUFBSyxJQUFJTyxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS1AsTUFBTCxDQUFZQyxNQUFoQyxFQUF3Q00sS0FBSyxDQUE3QyxFQUFnRDtBQUM5Q0gsY0FBSUksTUFBSixDQUFXLEtBQUtSLE1BQUwsQ0FBWU8sQ0FBWixFQUFlLENBQWYsQ0FBWCxFQUE4QixLQUFLUCxNQUFMLENBQVlPLENBQVosRUFBZSxDQUFmLENBQTlCO0FBQ0Q7QUFDREgsWUFBSUssU0FBSjtBQUNBSixjQUFNLElBQU47QUFDRDtBQUNELGFBQU9BLEdBQVA7QUFDRDs7OzZCQUVRO0FBQ1AsYUFBT0ssT0FBT0MsTUFBUCxxR0FBOEI7QUFDbkNDLGNBQU0sTUFENkIsQ0FDdEI7QUFDQTtBQUNBO0FBQ0E7QUFKc0IsT0FBOUIsQ0FBUDtBQU1EOzs7Ozs7a0JBckNrQmQsSSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCBQb2x5TGluZSBmcm9tIFwiLi9wb2x5LWxpbmVcIlxuXG5jb25zdCBDb25zdGFudHMgPSB7XG4gIE1JTklNVU1fUE9JTlRTOiAzXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHkgZXh0ZW5kcyBQb2x5TGluZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCBDb25zdGFudHMuTUlOSU1VTV9QT0lOVFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHkgc2hhcGVzIG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBhcnJheSBvZiAyZCBwb2ludHMgYW5kIGNvbnRhaW4gYXQgbGVhc3QgMyBwb2ludHNcIilcbiAgICB9XG4gIH1cblxuICByZW1vdmVWZXJ0KHZlcnRJbmRleCkge1xuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCBDb25zdGFudHMuTUlOSU1VTV9QT0lOVFMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSB2ZXJ0ZXggJHt2ZXJ0SW5kZXh9LiBJdCB3b3VsZCByZXN1bHQgaW4gYSBwb2x5IHdpdGggPCAzIHBvaW50cy4gQSBwb2x5IG11c3QgY29udGFpbiBhdCBsZWFzdCAzIHBvaW50cy5gKVxuICAgIH1cblxuICAgIHN1cGVyLnJlbW92ZVZlcnQodmVydEluZGV4KVxuICB9XG5cblxuICBfZHJhdyhjdHgpIHtcbiAgICBsZXQgcnRuID0gZmFsc2VcbiAgICBpZiAodGhpcy5fdmVydHMubGVuZ3RoID49IENvbnN0YW50cy5NSU5JTVVNX1BPSU5UUykge1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLl92ZXJ0c1swXVswXSwgdGhpcy5fdmVydHNbMF1bMV0pXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX3ZlcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5fdmVydHNbaV1bMF0sIHRoaXMuX3ZlcnRzW2ldWzFdKVxuICAgICAgfVxuICAgICAgY3R4LmNsb3NlUGF0aCgpXG4gICAgICBydG4gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBydG5cbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihzdXBlci50b0pTT04oKSwge1xuICAgICAgdHlwZTogXCJQb2x5XCIgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYWxzbyBzdXBwbGllZCBhZnRlciB0aGUgc3VwZXIudG9KU09OKClcbiAgICAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IHRoaXMgdHlwZSBvdmVycmlkZXMgdGhlIHBhcmVudCBjbGFzcydzXG4gICAgICAgICAgICAgICAgICAgLy8gdHlwZVxuICAgIH0pXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9wb2x5LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 30 */
/***/ function(module, exports) {

	eval("/* eslint-disable func-names */\n\"use strict\";\n\n/**\n * Gets the pixel ratio of a specific HTML canvas 2d context\n * @param  {CanvasRenderingContext2D} canvasCtx\n * @return {number}           pixel ratio of the canvas 2d context\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPixelRatio = getPixelRatio;\nexports.makeCanvasAutoHighDPI = makeCanvasAutoHighDPI;\nfunction getPixelRatio(canvasCtx) {\n  var backingStore = canvasCtx.backingStorePixelRatio || canvasCtx.webkitBackingStorePixelRatio || canvasCtx.mozBackingStorePixelRatio || canvasCtx.msBackingStorePixelRatio || canvasCtx.oBackingStorePixelRatio || canvasCtx.backingStorePixelRatio || 1;\n\n  return (window.devicePixelRatio || 1) / backingStore;\n}\n\n/**\n * Wraps certain canvas 2d context APIs to handle\n * displays with high per-pixel ratios. This is useful\n * so that the API can be called with screen-space coordinates\n * and the wrappers modify the arguments of those APIs to properly\n * handle displays with high pixel densities\n * @param  {CanvasRenderingContext2D} canvasCtx\n * @return {number}           pixel ratio of the wrapped canvas context\n */\nfunction makeCanvasAutoHighDPI(canvasCtx) {\n  var pixelRatio = getPixelRatio(canvasCtx);\n\n  if (pixelRatio === 1) {\n    return 1;\n  }\n\n  var allRatioArgs = [\"fillRect\", \"clearRect\", \"strokeRect\",\n  // \"moveTo\",\n  // \"lineTo\",\n  // \"arcTo\",\n  // \"bezierCurveTo\",\n  \"isPointInPath\", \"isPointInStroke\"\n  // \"quadraticCurveTo\",\n  // \"rect\",\n  // \"translate\",\n  // \"createRadialGradient\",\n  // \"createLinearGradient\"\n  ];\n\n  allRatioArgs.forEach(function (funcName) {\n    canvasCtx[funcName] = function (_super) {\n      return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        args = args.map(function (a) {\n          return a * pixelRatio;\n        });\n\n        return _super.apply(this, args);\n      };\n    }(canvasCtx[funcName]);\n  });\n\n  // const ratioArgsByIndex = {\n  //   arc: [0, 1, 2]\n  // }\n\n  // Object.getOwnPropertyNames(ratioArgsByIndex).forEach(funcName => {\n  //   const value = ratioArgsByIndex[funcName]\n  //   canvasCtx[funcName] = (function(_super) {\n  //     return function(...args) {\n  //       let i = 0\n  //       let len = 0\n  //       for (i = 0, len = value.length; i < len; i += 1) {\n  //         args[value[i]] *= pixelRatio\n  //       }\n  //       return _super.apply(this, args)\n  //     }\n  //   })(canvasCtx[funcName])\n  // })\n\n  // // Stroke lineWidth adjustment\n  // canvasCtx.stroke = (function(_super) {\n  //   return function(...args) {\n  //     this.lineWidth *= pixelRatio\n  //     _super.apply(this, args)\n  //     this.lineWidth /= pixelRatio\n  //   }\n  // })(canvasCtx.stroke)\n\n  // // Text\n  // //\n  // canvasCtx.fillText = (function(_super) {\n  //   return function(...args) {\n  //     args[1] *= pixelRatio // x\n  //     args[2] *= pixelRatio // y\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m * pixelRatio) + u\n  //       }\n  //     )\n\n  //     _super.apply(this, args)\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m / pixelRatio) + u\n  //       }\n  //     )\n  //   }\n  // })(canvasCtx.fillText)\n\n  // canvasCtx.strokeText = (function(_super) {\n  //   return function(...args) {\n  //     args[1] *= pixelRatio // x\n  //     args[2] *= pixelRatio // y\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m * pixelRatio) + u\n  //       }\n  //     )\n\n  //     _super.apply(this, args)\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m / pixelRatio) + u\n  //       }\n  //     )\n  //   }\n  // })(canvasCtx.strokeText)\n\n\n  var setTransformArgs = [pixelRatio, 0, 0, pixelRatio, 0, 0];\n  canvasCtx.setTransform = function (_super) {\n    return function () {\n      _super.apply(this, setTransformArgs);\n      this.transform.apply(this, arguments);\n    };\n  }(canvasCtx.setTransform);\n\n  return pixelRatio;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2NhbnZhcy11dGlscy5qcz84MjExIl0sIm5hbWVzIjpbImdldFBpeGVsUmF0aW8iLCJtYWtlQ2FudmFzQXV0b0hpZ2hEUEkiLCJjYW52YXNDdHgiLCJiYWNraW5nU3RvcmUiLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJwaXhlbFJhdGlvIiwiYWxsUmF0aW9BcmdzIiwiZm9yRWFjaCIsImZ1bmNOYW1lIiwiX3N1cGVyIiwiYXJncyIsIm1hcCIsImEiLCJhcHBseSIsInNldFRyYW5zZm9ybUFyZ3MiLCJzZXRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztRQUtnQkEsYSxHQUFBQSxhO1FBb0JBQyxxQixHQUFBQSxxQjtBQXBCVCxTQUFTRCxhQUFULENBQXVCRSxTQUF2QixFQUFrQztBQUN2QyxNQUFNQyxlQUFlRCxVQUFVRSxzQkFBVixJQUNuQkYsVUFBVUcsNEJBRFMsSUFFbkJILFVBQVVJLHlCQUZTLElBR25CSixVQUFVSyx3QkFIUyxJQUluQkwsVUFBVU0sdUJBSlMsSUFLbkJOLFVBQVVFLHNCQUxTLElBS2lCLENBTHRDOztBQU9BLFNBQU8sQ0FBQ0ssT0FBT0MsZ0JBQVAsSUFBMkIsQ0FBNUIsSUFBaUNQLFlBQXhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVNGLHFCQUFULENBQStCQyxTQUEvQixFQUEwQztBQUMvQyxNQUFNUyxhQUFhWCxjQUFjRSxTQUFkLENBQW5COztBQUVBLE1BQUlTLGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsV0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBTUMsZUFBZSxDQUNuQixVQURtQixFQUVuQixXQUZtQixFQUduQixZQUhtQjtBQUluQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQVJtQixFQVNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkbUIsR0FBckI7O0FBaUJBQSxlQUFhQyxPQUFiLENBQXFCLG9CQUFZO0FBQy9CWCxjQUFVWSxRQUFWLElBQXVCLFVBQVNDLE1BQVQsRUFBaUI7QUFDdEMsYUFBTyxZQUFrQjtBQUFBLDBDQUFOQyxJQUFNO0FBQU5BLGNBQU07QUFBQTs7QUFDdkJBLGVBQU9BLEtBQUtDLEdBQUwsQ0FBUyxVQUFDQyxDQUFEO0FBQUEsaUJBQU9BLElBQUlQLFVBQVg7QUFBQSxTQUFULENBQVA7O0FBRUEsZUFBT0ksT0FBT0ksS0FBUCxDQUFhLElBQWIsRUFBbUJILElBQW5CLENBQVA7QUFDRCxPQUpEO0FBS0QsS0FOcUIsQ0FNbkJkLFVBQVVZLFFBQVYsQ0FObUIsQ0FBdEI7QUFPRCxHQVJEOztBQVVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsTUFBTU0sbUJBQW1CLENBQUNULFVBQUQsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CQSxVQUFuQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxDQUF6QjtBQUNBVCxZQUFVbUIsWUFBVixHQUEwQixVQUFTTixNQUFULEVBQWlCO0FBQ3pDLFdBQU8sWUFBa0I7QUFDdkJBLGFBQU9JLEtBQVAsQ0FBYSxJQUFiLEVBQW1CQyxnQkFBbkI7QUFDQSxXQUFLRSxTQUFMO0FBQ0QsS0FIRDtBQUlELEdBTHdCLENBS3RCcEIsVUFBVW1CLFlBTFksQ0FBekI7O0FBT0EsU0FBT1YsVUFBUDtBQUNEIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuLyoqXG4gKiBHZXRzIHRoZSBwaXhlbCByYXRpbyBvZiBhIHNwZWNpZmljIEhUTUwgY2FudmFzIDJkIGNvbnRleHRcbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY2FudmFzQ3R4XG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzIDJkIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oY2FudmFzQ3R4KSB7XG4gIGNvbnN0IGJhY2tpbmdTdG9yZSA9IGNhbnZhc0N0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY2FudmFzQ3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgIGNhbnZhc0N0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxXG5cbiAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZVxufVxuXG4vKipcbiAqIFdyYXBzIGNlcnRhaW4gY2FudmFzIDJkIGNvbnRleHQgQVBJcyB0byBoYW5kbGVcbiAqIGRpc3BsYXlzIHdpdGggaGlnaCBwZXItcGl4ZWwgcmF0aW9zLiBUaGlzIGlzIHVzZWZ1bFxuICogc28gdGhhdCB0aGUgQVBJIGNhbiBiZSBjYWxsZWQgd2l0aCBzY3JlZW4tc3BhY2UgY29vcmRpbmF0ZXNcbiAqIGFuZCB0aGUgd3JhcHBlcnMgbW9kaWZ5IHRoZSBhcmd1bWVudHMgb2YgdGhvc2UgQVBJcyB0byBwcm9wZXJseVxuICogaGFuZGxlIGRpc3BsYXlzIHdpdGggaGlnaCBwaXhlbCBkZW5zaXRpZXNcbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY2FudmFzQ3R4XG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICBwaXhlbCByYXRpbyBvZiB0aGUgd3JhcHBlZCBjYW52YXMgY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUNhbnZhc0F1dG9IaWdoRFBJKGNhbnZhc0N0eCkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhjYW52YXNDdHgpXG5cbiAgaWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgY29uc3QgYWxsUmF0aW9BcmdzID0gW1xuICAgIFwiZmlsbFJlY3RcIixcbiAgICBcImNsZWFyUmVjdFwiLFxuICAgIFwic3Ryb2tlUmVjdFwiLFxuICAgIC8vIFwibW92ZVRvXCIsXG4gICAgLy8gXCJsaW5lVG9cIixcbiAgICAvLyBcImFyY1RvXCIsXG4gICAgLy8gXCJiZXppZXJDdXJ2ZVRvXCIsXG4gICAgXCJpc1BvaW50SW5QYXRoXCIsXG4gICAgXCJpc1BvaW50SW5TdHJva2VcIlxuICAgIC8vIFwicXVhZHJhdGljQ3VydmVUb1wiLFxuICAgIC8vIFwicmVjdFwiLFxuICAgIC8vIFwidHJhbnNsYXRlXCIsXG4gICAgLy8gXCJjcmVhdGVSYWRpYWxHcmFkaWVudFwiLFxuICAgIC8vIFwiY3JlYXRlTGluZWFyR3JhZGllbnRcIlxuICBdXG5cbiAgYWxsUmF0aW9BcmdzLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAgIGNhbnZhc0N0eFtmdW5jTmFtZV0gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBhcmdzID0gYXJncy5tYXAoKGEpID0+IGEgKiBwaXhlbFJhdGlvKVxuXG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcbiAgICAgIH1cbiAgICB9KShjYW52YXNDdHhbZnVuY05hbWVdKVxuICB9KVxuXG4gIC8vIGNvbnN0IHJhdGlvQXJnc0J5SW5kZXggPSB7XG4gIC8vICAgYXJjOiBbMCwgMSwgMl1cbiAgLy8gfVxuXG4gIC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHJhdGlvQXJnc0J5SW5kZXgpLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAvLyAgIGNvbnN0IHZhbHVlID0gcmF0aW9BcmdzQnlJbmRleFtmdW5jTmFtZV1cbiAgLy8gICBjYW52YXNDdHhbZnVuY05hbWVdID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAvLyAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgLy8gICAgICAgbGV0IGkgPSAwXG4gIC8vICAgICAgIGxldCBsZW4gPSAwXG4gIC8vICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIC8vICAgICAgICAgYXJnc1t2YWx1ZVtpXV0gKj0gcGl4ZWxSYXRpb1xuICAvLyAgICAgICB9XG4gIC8vICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcbiAgLy8gICAgIH1cbiAgLy8gICB9KShjYW52YXNDdHhbZnVuY05hbWVdKVxuICAvLyB9KVxuXG4gIC8vIC8vIFN0cm9rZSBsaW5lV2lkdGggYWRqdXN0bWVudFxuICAvLyBjYW52YXNDdHguc3Ryb2tlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAvLyAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIC8vICAgICB0aGlzLmxpbmVXaWR0aCAqPSBwaXhlbFJhdGlvXG4gIC8vICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcbiAgLy8gICAgIHRoaXMubGluZVdpZHRoIC89IHBpeGVsUmF0aW9cbiAgLy8gICB9XG4gIC8vIH0pKGNhbnZhc0N0eC5zdHJva2UpXG5cbiAgLy8gLy8gVGV4dFxuICAvLyAvL1xuICAvLyBjYW52YXNDdHguZmlsbFRleHQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gIC8vICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgLy8gICAgIGFyZ3NbMV0gKj0gcGl4ZWxSYXRpbyAvLyB4XG4gIC8vICAgICBhcmdzWzJdICo9IHBpeGVsUmF0aW8gLy8geVxuXG4gIC8vICAgICB0aGlzLmZvbnQgPSB0aGlzLmZvbnQucmVwbGFjZShcbiAgLy8gICAgICAgLyhcXGQrKShweHxlbXxyZW18cHQpL2csXG4gIC8vICAgICAgIGZ1bmN0aW9uKHcsIG0sIHUpIHtcbiAgLy8gICAgICAgICByZXR1cm4gKG0gKiBwaXhlbFJhdGlvKSArIHVcbiAgLy8gICAgICAgfVxuICAvLyAgICAgKVxuXG4gIC8vICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcblxuICAvLyAgICAgdGhpcy5mb250ID0gdGhpcy5mb250LnJlcGxhY2UoXG4gIC8vICAgICAgIC8oXFxkKykocHh8ZW18cmVtfHB0KS9nLFxuICAvLyAgICAgICBmdW5jdGlvbih3LCBtLCB1KSB7XG4gIC8vICAgICAgICAgcmV0dXJuIChtIC8gcGl4ZWxSYXRpbykgKyB1XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIClcbiAgLy8gICB9XG4gIC8vIH0pKGNhbnZhc0N0eC5maWxsVGV4dClcblxuICAvLyBjYW52YXNDdHguc3Ryb2tlVGV4dCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgLy8gICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAvLyAgICAgYXJnc1sxXSAqPSBwaXhlbFJhdGlvIC8vIHhcbiAgLy8gICAgIGFyZ3NbMl0gKj0gcGl4ZWxSYXRpbyAvLyB5XG5cbiAgLy8gICAgIHRoaXMuZm9udCA9IHRoaXMuZm9udC5yZXBsYWNlKFxuICAvLyAgICAgICAvKFxcZCspKHB4fGVtfHJlbXxwdCkvZyxcbiAgLy8gICAgICAgZnVuY3Rpb24odywgbSwgdSkge1xuICAvLyAgICAgICAgIHJldHVybiAobSAqIHBpeGVsUmF0aW8pICsgdVxuICAvLyAgICAgICB9XG4gIC8vICAgICApXG5cbiAgLy8gICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKVxuXG4gIC8vICAgICB0aGlzLmZvbnQgPSB0aGlzLmZvbnQucmVwbGFjZShcbiAgLy8gICAgICAgLyhcXGQrKShweHxlbXxyZW18cHQpL2csXG4gIC8vICAgICAgIGZ1bmN0aW9uKHcsIG0sIHUpIHtcbiAgLy8gICAgICAgICByZXR1cm4gKG0gLyBwaXhlbFJhdGlvKSArIHVcbiAgLy8gICAgICAgfVxuICAvLyAgICAgKVxuICAvLyAgIH1cbiAgLy8gfSkoY2FudmFzQ3R4LnN0cm9rZVRleHQpXG5cblxuICBjb25zdCBzZXRUcmFuc2Zvcm1BcmdzID0gW3BpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDBdXG4gIGNhbnZhc0N0eC5zZXRUcmFuc2Zvcm0gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBzZXRUcmFuc2Zvcm1BcmdzKVxuICAgICAgdGhpcy50cmFuc2Zvcm0oLi4uYXJncylcbiAgICB9XG4gIH0pKGNhbnZhc0N0eC5zZXRUcmFuc2Zvcm0pXG5cbiAgcmV0dXJuIHBpeGVsUmF0aW9cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3V0aWwvY2FudmFzLXV0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 31 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Binds a this arg to a list of different function names.\n * This is most widely used to bind a this to member functions\n * that are used as callbacks in some fashion\n * @param  {string[]} funcNames array of member function names that are part of thisArg\n * @param  {Object} thisArg   object to bind\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bindAll = bindAll;\nfunction bindAll(funcNames, thisArg) {\n  funcNames.forEach(function (funcName) {\n    if (!thisArg[funcName]) {\n      return;\n    }\n    thisArg[funcName] = thisArg[funcName].bind(thisArg);\n  });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL3V0aWxzLmpzPzMxMzEiXSwibmFtZXMiOlsiYmluZEFsbCIsImZ1bmNOYW1lcyIsInRoaXNBcmciLCJmb3JFYWNoIiwiZnVuY05hbWUiLCJiaW5kIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7UUFPZ0JBLE8sR0FBQUEsTztBQUFULFNBQVNBLE9BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCQyxPQUE1QixFQUFxQztBQUMxQ0QsWUFBVUUsT0FBVixDQUFrQixvQkFBWTtBQUM1QixRQUFJLENBQUNELFFBQVFFLFFBQVIsQ0FBTCxFQUF3QjtBQUN0QjtBQUNEO0FBQ0RGLFlBQVFFLFFBQVIsSUFBb0JGLFFBQVFFLFFBQVIsRUFBa0JDLElBQWxCLENBQXVCSCxPQUF2QixDQUFwQjtBQUNELEdBTEQ7QUFNRCIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbi8qKlxuICogQmluZHMgYSB0aGlzIGFyZyB0byBhIGxpc3Qgb2YgZGlmZmVyZW50IGZ1bmN0aW9uIG5hbWVzLlxuICogVGhpcyBpcyBtb3N0IHdpZGVseSB1c2VkIHRvIGJpbmQgYSB0aGlzIHRvIG1lbWJlciBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIHVzZWQgYXMgY2FsbGJhY2tzIGluIHNvbWUgZmFzaGlvblxuICogQHBhcmFtICB7c3RyaW5nW119IGZ1bmNOYW1lcyBhcnJheSBvZiBtZW1iZXIgZnVuY3Rpb24gbmFtZXMgdGhhdCBhcmUgcGFydCBvZiB0aGlzQXJnXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRoaXNBcmcgICBvYmplY3QgdG8gYmluZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEFsbChmdW5jTmFtZXMsIHRoaXNBcmcpIHtcbiAgZnVuY05hbWVzLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAgIGlmICghdGhpc0FyZ1tmdW5jTmFtZV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzQXJnW2Z1bmNOYW1lXSA9IHRoaXNBcmdbZnVuY05hbWVdLmJpbmQodGhpc0FyZylcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3V0aWwvdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _aggregation2 = __webpack_require__(8);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _transform2d = __webpack_require__(12);\n\nvar _eventHandler = __webpack_require__(13);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _mat2d = __webpack_require__(5);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Camera modification event\n * @event EventedCamera#changed\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * @class Base camera class for 2d screen projections\n *        The base class is used only for the NDC to screen space trasform\n * @extends {EventHandler}\n */\nvar BaseCamera2d = function (_EventHandler) {\n  _inherits(BaseCamera2d, _EventHandler);\n\n  /**\n   * Constructs a new 2d camera\n   * @param  {AABox2d}  viewport           Initial camera viewport boundary, in pixels\n   * @param  {Vec2d}  projectionDimensions The width and height of the viewport in world coordinates\n   * @param  {Boolean} [flipY=false]       Whether world y coordinates are flipped, if false\n   *                                       the top of the viewport window is smaller in y, and the bottom\n   *                                       is larger. If true, the bottom has smaller y coords, and the top\n   *                                       larger\n   * @return {BaseCamera2d}\n   */\n  function BaseCamera2d(viewport, projectionDimensions) {\n    var flipY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, BaseCamera2d);\n\n    var _this = _possibleConstructorReturn(this, (BaseCamera2d.__proto__ || Object.getPrototypeOf(BaseCamera2d)).call(this, [\"changed\", \"changed:xform\"]));\n    // initialize modify events\n\n\n    _this._viewport = AABox2d.clone(viewport);\n    _this._projectionDimensions = _glMatrix.vec2.clone(projectionDimensions);\n    _this._yflip = flipY;\n\n    // stores the NDC space to screen space matrix\n    // NDC (normalized device coordinates) is the space\n    // where the left edge of the window is -1, the right edge is 1\n    // the top edge is -1, and the bottom edge is 1.\n    _this._screenMatrix = _mat2d2.default.create();\n\n    // this flag is dirty whenever the attributes for the\n    // ndc-to-screen projection are modified\n    _this._screenDirty = true;\n    return _this;\n  }\n\n  /**\n   * Returns true if the world Y coordinates go from negative to positive\n   * in a bottom to top fashion in screen space, false otherwise.\n   * @return {Boolean}\n   */\n\n\n  _createClass(BaseCamera2d, [{\n    key: \"isYFlipped\",\n    value: function isYFlipped() {\n      return this._yflip;\n    }\n\n    /**\n     * Sets the camera's screen-space viewport bounds\n     * @param  {AABox2d} viewport\n     * @fires  EventedCamera#changed\n     * @return {BaseCamera2d}\n     */\n\n  }, {\n    key: \"viewport\",\n    set: function set(viewport) {\n      if (!AABox2d.equals(viewport, this._viewport)) {\n        var prev = AABox2d.clone(this._viewport);\n        AABox2d.copy(this._viewport, viewport);\n        this._screenDirty = true;\n        this._worldToScreenOutdated = true;\n        this.fire(\"changed\", {\n          attr: \"viewport\",\n          prevVal: prev,\n          currVal: viewport\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets a copy of the camera's current viewport\n     * @return {AABox2d}\n     */\n    ,\n    get: function get() {\n      return AABox2d.clone(this._viewport);\n    }\n\n    /**\n     * Gets a reference to the camera's current viewport\n     * @return {AABox2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"viewportRef\",\n    get: function get() {\n      return this._viewport;\n    }\n\n    /**\n     * Gets the current NDC to screen space transform matrix\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"screenMatrix\",\n    get: function get() {\n      if (this._screenDirty) {\n        var center = [0, 0];\n        var extents = [0, 0];\n        AABox2d.getCenter(center, this._viewport);\n        AABox2d.getExtents(extents, this._viewport);\n        _mat2d2.default.set(this._screenMatrix, extents[0], 0, 0, extents[1], center[0], center[1]);\n        this._worldToScreenOutdated = true;\n        this._screenDirty = false;\n      }\n      return this._screenMatrix;\n    }\n  }]);\n\n  return BaseCamera2d;\n}(_eventHandler2.default);\n\n/**\n * @class Main 2d camera class to manage othographic 2d projections\n * @extends {BaseCamera2d}\n * @mixin {EventedTransform2d}\n */\n\n\nvar Camera2d = function (_aggregation) {\n  _inherits(Camera2d, _aggregation);\n\n  /**\n   * Creates a new Camera2d object\n   * @param  {AABox2d} viewport             The camera's viewport bounds in pixel space\n   * @param  {Vec2d} projectionDimensions The width/height of the camera's viewport in world coordinates\n   * @param  {Boolean} flipY              True if the direction from negative to positive Y coordinates\n   *                                      go from the bottom to top of the window. False means Y coords\n   *                                      from negative to positive values go from the top to the bottom\n   * @return {Camera2d}\n   */\n  function Camera2d(viewport, projectionDimensions, flipY) {\n    _classCallCheck(this, Camera2d);\n\n    var _this2 = _possibleConstructorReturn(this, (Camera2d.__proto__ || Object.getPrototypeOf(Camera2d)).call(this, viewport, projectionDimensions, flipY));\n\n    _this2._viewMatrix = _mat2d2.default.create();\n    _this2._viewDirty = true;\n    _this2._projMatrix = _mat2d2.default.create();\n    _this2._projDirty = true;\n    return _this2;\n  }\n\n  /**\n   * Sets the projection dimensions of the camera's view. This is the width/height\n   * in world space coordiantes of the camera's view.\n   * @param  {Vec2d} projectionDimensions\n   * @return {Camera2d} this\n   */\n\n\n  _createClass(Camera2d, [{\n    key: \"_localXformUpdated\",\n\n\n    /**\n     * Called when the local transform (does not include parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the view-to-screen space\n     * transformation needs updating\n     * @private\n     */\n    value: function _localXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Called when the global matrix (includes parent transforms) of the\n     * Transform2d mixin is modified. Used to be notified internally that\n     * the view-to-screen space transformation needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_globalXformUpdated\",\n    value: function _globalXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Gets the transformation matrix from world space to view/camera space\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"_matricesDirty\",\n\n\n    /**\n     * Returns true if any of the dirty flags are active\n     * @return {Boolean}\n     * @private\n     */\n    value: function _matricesDirty() {\n      return this._boundsOutOfDate || this._lxformDirty || this._xformDirty || this._viewDirty || this._projDirty || this._screenDirty;\n    }\n\n    /**\n     * Gets the transformation matrix from world space to screen space.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"projectionDimensions\",\n    set: function set(projectionDimensions) {\n      if (!_glMatrix.vec2.equals(projectionDimensions, this._projectionDimensions)) {\n        var prev = _glMatrix.vec2.clone(this._projectionDimensions);\n        AABox2d.copy(this._projectionDimensions, projectionDimensions);\n        this._viewDirty = true;\n        this._projDirty = true;\n        // this._yflip = this._projectionDimensions[3] < this._projectionDimensions[1]\n        this.fire(\"changed\", {\n          attr: \"projectionDimensions\",\n          prevVal: prev,\n          currVal: projectionDimensions\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets a copy of the camera's current projection dimensions\n     * @return {Vec2d}\n     */\n    ,\n    get: function get() {\n      return _glMatrix.vec2.clone(this._projectionDimensions);\n    }\n\n    /**\n     * Gets a reference to the camera's current projection dimensions\n     * @return {Vec2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"projectionDimensionsRef\",\n    get: function get() {\n      return this._projectionDimensions;\n    }\n  }, {\n    key: \"viewMatrix\",\n    get: function get() {\n      if (this._viewDirty || this._boundsOutOfDate || this._xformDirty || this._lxformDirty) {\n        // the matrix has been marked dirty, so recalculate\n        var pos = [0, 0];\n        var scale = [0, 0];\n        var rot = [0, 0];\n        var xform = this.globalXform;\n        _mat2d2.default.svd(pos, scale, rot, xform);\n        _mat2d2.default.fromTranslation(this._viewMatrix, _glMatrix.vec2.negate(pos, pos));\n        _mat2d2.default.rotate(this._viewMatrix, this._viewMatrix, -rot[0]);\n        _mat2d2.default.scale(this._viewMatrix, this._viewMatrix, scale);\n        _mat2d2.default.rotate(this._viewMatrix, this._viewMatrix, -rot[1]);\n        this._worldToScreenOutdated = true;\n        this._viewDirty = false;\n      }\n      return this._viewMatrix;\n    }\n\n    /**\n     * Gets the orthographic projection transformation matrix from\n     * view to NDC (normalized device coordinates) space\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"projMatrix\",\n    get: function get() {\n      if (this._projDirty) {\n        var flip = this._yflip ? -1 : 1;\n        _mat2d2.default.set(this._projMatrix, 2.0 / this._projectionDimensions[0], 0, 0, flip * 2.0 / this._projectionDimensions[1], 0, 0);\n        this._worldToScreenOutdated = true;\n        this._projDirty = false;\n      }\n      return this._projMatrix;\n    }\n  }, {\n    key: \"worldToScreenMatrix\",\n    get: function get() {\n      if (!this._worldToScreenMatrix || this._worldToScreenOutdated || this._matricesDirty()) {\n        if (!this._worldToScreenMatrix) {\n          this._worldToScreenMatrix = _mat2d2.default.create();\n        }\n        _mat2d2.default.copy(this._worldToScreenMatrix, this.viewMatrix);\n        _mat2d2.default.multiply(this._worldToScreenMatrix, this.projMatrix, this._worldToScreenMatrix);\n        _mat2d2.default.multiply(this._worldToScreenMatrix, this.screenMatrix, this._worldToScreenMatrix);\n        this._worldToScreenOutdated = false;\n        this._screenToWorldOutdated = true;\n      }\n      return this._worldToScreenMatrix;\n    }\n\n    /**\n     * Gets teh transform matrix from screen space to world space.\n     * @return {[type]} [description]\n     */\n\n  }, {\n    key: \"screenToWorldMatrix\",\n    get: function get() {\n      if (!this._screenToWorld || this._screenToWorldOutdated || this._matricesDirty()) {\n        if (!this._screenToWorld) {\n          this._screenToWorld = _mat2d2.default.create();\n        }\n        _mat2d2.default.copy(this._screenToWorld, this.worldToScreenMatrix);\n        _mat2d2.default.invert(this._screenToWorld, this._screenToWorld);\n        this._screenToWorldOutdated = false;\n      }\n      return this._screenToWorld;\n    }\n  }]);\n\n  return Camera2d;\n}((0, _aggregation3.default)(BaseCamera2d, (0, _transform2d.createEventedTransform2dMixin)(\"changed:xform\")));\n\nexports.default = Camera2d;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L2NhbWVyYTJkLmpzP2YyYWUiXSwibmFtZXMiOlsiQUFCb3gyZCIsIkJhc2VDYW1lcmEyZCIsInZpZXdwb3J0IiwicHJvamVjdGlvbkRpbWVuc2lvbnMiLCJmbGlwWSIsIl92aWV3cG9ydCIsImNsb25lIiwiX3Byb2plY3Rpb25EaW1lbnNpb25zIiwiX3lmbGlwIiwiX3NjcmVlbk1hdHJpeCIsImNyZWF0ZSIsIl9zY3JlZW5EaXJ0eSIsImVxdWFscyIsInByZXYiLCJjb3B5IiwiX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCIsImZpcmUiLCJhdHRyIiwicHJldlZhbCIsImN1cnJWYWwiLCJjZW50ZXIiLCJleHRlbnRzIiwiZ2V0Q2VudGVyIiwiZ2V0RXh0ZW50cyIsInNldCIsIkNhbWVyYTJkIiwiX3ZpZXdNYXRyaXgiLCJfdmlld0RpcnR5IiwiX3Byb2pNYXRyaXgiLCJfcHJvakRpcnR5IiwiX2JvdW5kc091dE9mRGF0ZSIsIl9seGZvcm1EaXJ0eSIsIl94Zm9ybURpcnR5IiwicG9zIiwic2NhbGUiLCJyb3QiLCJ4Zm9ybSIsImdsb2JhbFhmb3JtIiwic3ZkIiwiZnJvbVRyYW5zbGF0aW9uIiwibmVnYXRlIiwicm90YXRlIiwiZmxpcCIsIl93b3JsZFRvU2NyZWVuTWF0cml4IiwiX21hdHJpY2VzRGlydHkiLCJ2aWV3TWF0cml4IiwibXVsdGlwbHkiLCJwcm9qTWF0cml4Iiwic2NyZWVuTWF0cml4IiwiX3NjcmVlblRvV29ybGRPdXRkYXRlZCIsIl9zY3JlZW5Ub1dvcmxkIiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImludmVydCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7QUFTQTs7Ozs7SUFLTUMsWTs7O0FBQ0o7Ozs7Ozs7Ozs7QUFVQSx3QkFBWUMsUUFBWixFQUFzQkMsb0JBQXRCLEVBQTJE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QzlCLGVBQUtBLG9CQUFMLEdBQTRCLGdCQUFNakMsTUFBTixFQUE1QjtBQUNEO0FBQ0Qsd0JBQU1JLElBQU4sQ0FBVyxLQUFLNkIsb0JBQWhCLEVBQXNDLEtBQUtFLFVBQTNDO0FBQ0Esd0JBQU1DLFFBQU4sQ0FBZSxLQUFLSCxvQkFBcEIsRUFBMEMsS0FBS0ksVUFBL0MsRUFBMkQsS0FBS0osb0JBQWhFO0FBQ0Esd0JBQU1HLFFBQU4sQ0FBZSxLQUFLSCxvQkFBcEIsRUFBMEMsS0FBS0ssWUFBL0MsRUFBNkQsS0FBS0wsb0JBQWxFO0FBQ0EsYUFBSzVCLHNCQUFMLEdBQThCLEtBQTlCO0FBQ0EsYUFBS2tDLHNCQUFMLEdBQThCLElBQTlCO0FBQ0Q7QUFDRCxhQUFPLEtBQUtOLG9CQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7d0JBSTBCO0FBQ3hCLFVBQUksQ0FBQyxLQUFLTyxjQUFOLElBQXdCLEtBQUtELHNCQUE3QixJQUF1RCxLQUFLTCxjQUFMLEVBQTNELEVBQWtGO0FBQ2hGLFlBQUksQ0FBQyxLQUFLTSxjQUFWLEVBQTBCO0FBQ3hCLGVBQUtBLGNBQUwsR0FBc0IsZ0JBQU14QyxNQUFOLEVBQXRCO0FBQ0Q7QUFDRCx3QkFBTUksSUFBTixDQUFXLEtBQUtvQyxjQUFoQixFQUFnQyxLQUFLQyxtQkFBckM7QUFDQSx3QkFBTUMsTUFBTixDQUFhLEtBQUtGLGNBQWxCLEVBQWtDLEtBQUtBLGNBQXZDO0FBQ0EsYUFBS0Qsc0JBQUwsR0FBOEIsS0FBOUI7QUFDRDtBQUNELGFBQU8sS0FBS0MsY0FBWjtBQUNEOzs7O0VBOUptQywyQkFBWWpELFlBQVosRUFDcEMsZ0RBQThCLGVBQTlCLENBRG9DLEM7O2tCQUFqQndCLFEiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCB7Y3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW59IGZyb20gXCIuLi9zaGFwZXMvdHJhbnNmb3JtMmRcIlxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tIFwiLi4vdXRpbC9ldmVudC1oYW5kbGVyXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQge3ZlYzIgYXMgVmVjMmR9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG4vKipcbiAqIENhbWVyYSBtb2RpZmljYXRpb24gZXZlbnRcbiAqIEBldmVudCBFdmVudGVkQ2FtZXJhI2NoYW5nZWRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXR0ciBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgbW9kaWZpZWRcbiAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQmFzZSBjYW1lcmEgY2xhc3MgZm9yIDJkIHNjcmVlbiBwcm9qZWN0aW9uc1xuICogICAgICAgIFRoZSBiYXNlIGNsYXNzIGlzIHVzZWQgb25seSBmb3IgdGhlIE5EQyB0byBzY3JlZW4gc3BhY2UgdHJhc2Zvcm1cbiAqIEBleHRlbmRzIHtFdmVudEhhbmRsZXJ9XG4gKi9cbmNsYXNzIEJhc2VDYW1lcmEyZCBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IDJkIGNhbWVyYVxuICAgKiBAcGFyYW0gIHtBQUJveDJkfSAgdmlld3BvcnQgICAgICAgICAgIEluaXRpYWwgY2FtZXJhIHZpZXdwb3J0IGJvdW5kYXJ5LCBpbiBwaXhlbHNcbiAgICogQHBhcmFtICB7VmVjMmR9ICBwcm9qZWN0aW9uRGltZW5zaW9ucyBUaGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2ZsaXBZPWZhbHNlXSAgICAgICBXaGV0aGVyIHdvcmxkIHkgY29vcmRpbmF0ZXMgYXJlIGZsaXBwZWQsIGlmIGZhbHNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgd2luZG93IGlzIHNtYWxsZXIgaW4geSwgYW5kIHRoZSBib3R0b21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBsYXJnZXIuIElmIHRydWUsIHRoZSBib3R0b20gaGFzIHNtYWxsZXIgeSBjb29yZHMsIGFuZCB0aGUgdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFyZ2VyXG4gICAqIEByZXR1cm4ge0Jhc2VDYW1lcmEyZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZpZXdwb3J0LCBwcm9qZWN0aW9uRGltZW5zaW9ucywgZmxpcFkgPSBmYWxzZSkge1xuICAgIC8vIGluaXRpYWxpemUgbW9kaWZ5IGV2ZW50c1xuICAgIHN1cGVyKFtcImNoYW5nZWRcIiwgXCJjaGFuZ2VkOnhmb3JtXCJdKVxuXG4gICAgdGhpcy5fdmlld3BvcnQgPSBBQUJveDJkLmNsb25lKHZpZXdwb3J0KVxuICAgIHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zID0gVmVjMmQuY2xvbmUocHJvamVjdGlvbkRpbWVuc2lvbnMpXG4gICAgdGhpcy5feWZsaXAgPSBmbGlwWVxuXG4gICAgLy8gc3RvcmVzIHRoZSBOREMgc3BhY2UgdG8gc2NyZWVuIHNwYWNlIG1hdHJpeFxuICAgIC8vIE5EQyAobm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMpIGlzIHRoZSBzcGFjZVxuICAgIC8vIHdoZXJlIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHdpbmRvdyBpcyAtMSwgdGhlIHJpZ2h0IGVkZ2UgaXMgMVxuICAgIC8vIHRoZSB0b3AgZWRnZSBpcyAtMSwgYW5kIHRoZSBib3R0b20gZWRnZSBpcyAxLlxuICAgIHRoaXMuX3NjcmVlbk1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG5cbiAgICAvLyB0aGlzIGZsYWcgaXMgZGlydHkgd2hlbmV2ZXIgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZVxuICAgIC8vIG5kYy10by1zY3JlZW4gcHJvamVjdGlvbiBhcmUgbW9kaWZpZWRcbiAgICB0aGlzLl9zY3JlZW5EaXJ0eSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHdvcmxkIFkgY29vcmRpbmF0ZXMgZ28gZnJvbSBuZWdhdGl2ZSB0byBwb3NpdGl2ZVxuICAgKiBpbiBhIGJvdHRvbSB0byB0b3AgZmFzaGlvbiBpbiBzY3JlZW4gc3BhY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzWUZsaXBwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3lmbGlwXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FtZXJhJ3Mgc2NyZWVuLXNwYWNlIHZpZXdwb3J0IGJvdW5kc1xuICAgKiBAcGFyYW0gIHtBQUJveDJkfSB2aWV3cG9ydFxuICAgKiBAZmlyZXMgIEV2ZW50ZWRDYW1lcmEjY2hhbmdlZFxuICAgKiBAcmV0dXJuIHtCYXNlQ2FtZXJhMmR9XG4gICAqL1xuICBzZXQgdmlld3BvcnQodmlld3BvcnQpIHtcbiAgICBpZiAoIUFBQm94MmQuZXF1YWxzKHZpZXdwb3J0LCB0aGlzLl92aWV3cG9ydCkpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBBQUJveDJkLmNsb25lKHRoaXMuX3ZpZXdwb3J0KVxuICAgICAgQUFCb3gyZC5jb3B5KHRoaXMuX3ZpZXdwb3J0LCB2aWV3cG9ydClcbiAgICAgIHRoaXMuX3NjcmVlbkRpcnR5ID0gdHJ1ZVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZFwiLCB7XG4gICAgICAgIGF0dHI6IFwidmlld3BvcnRcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogdmlld3BvcnRcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvcHkgb2YgdGhlIGNhbWVyYSdzIGN1cnJlbnQgdmlld3BvcnRcbiAgICogQHJldHVybiB7QUFCb3gyZH1cbiAgICovXG4gIGdldCB2aWV3cG9ydCgpIHtcbiAgICByZXR1cm4gQUFCb3gyZC5jbG9uZSh0aGlzLl92aWV3cG9ydClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjYW1lcmEncyBjdXJyZW50IHZpZXdwb3J0XG4gICAqIEByZXR1cm4ge0FBQm94MmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0IHZpZXdwb3J0UmVmKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgTkRDIHRvIHNjcmVlbiBzcGFjZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IHNjcmVlbk1hdHJpeCgpIHtcbiAgICBpZiAodGhpcy5fc2NyZWVuRGlydHkpIHtcbiAgICAgIGNvbnN0IGNlbnRlciA9IFswLCAwXVxuICAgICAgY29uc3QgZXh0ZW50cyA9IFswLCAwXVxuICAgICAgQUFCb3gyZC5nZXRDZW50ZXIoY2VudGVyLCB0aGlzLl92aWV3cG9ydClcbiAgICAgIEFBQm94MmQuZ2V0RXh0ZW50cyhleHRlbnRzLCB0aGlzLl92aWV3cG9ydClcbiAgICAgIE1hdDJkLnNldCh0aGlzLl9zY3JlZW5NYXRyaXgsIGV4dGVudHNbMF0sIDAsIDAsIGV4dGVudHNbMV0sIGNlbnRlclswXSwgY2VudGVyWzFdKVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fc2NyZWVuRGlydHkgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuTWF0cml4XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgTWFpbiAyZCBjYW1lcmEgY2xhc3MgdG8gbWFuYWdlIG90aG9ncmFwaGljIDJkIHByb2plY3Rpb25zXG4gKiBAZXh0ZW5kcyB7QmFzZUNhbWVyYTJkfVxuICogQG1peGluIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYTJkIGV4dGVuZHMgYWdncmVnYXRpb24oQmFzZUNhbWVyYTJkLFxuICBjcmVhdGVFdmVudGVkVHJhbnNmb3JtMmRNaXhpbihcImNoYW5nZWQ6eGZvcm1cIikpIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDYW1lcmEyZCBvYmplY3RcbiAgICogQHBhcmFtICB7QUFCb3gyZH0gdmlld3BvcnQgICAgICAgICAgICAgVGhlIGNhbWVyYSdzIHZpZXdwb3J0IGJvdW5kcyBpbiBwaXhlbCBzcGFjZVxuICAgKiBAcGFyYW0gIHtWZWMyZH0gcHJvamVjdGlvbkRpbWVuc2lvbnMgVGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgY2FtZXJhJ3Mgdmlld3BvcnQgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gZmxpcFkgICAgICAgICAgICAgIFRydWUgaWYgdGhlIGRpcmVjdGlvbiBmcm9tIG5lZ2F0aXZlIHRvIHBvc2l0aXZlIFkgY29vcmRpbmF0ZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvIGZyb20gdGhlIGJvdHRvbSB0byB0b3Agb2YgdGhlIHdpbmRvdy4gRmFsc2UgbWVhbnMgWSBjb29yZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gbmVnYXRpdmUgdG8gcG9zaXRpdmUgdmFsdWVzIGdvIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tXG4gICAqIEByZXR1cm4ge0NhbWVyYTJkfVxuICAgKi9cbiAgY29uc3RydWN0b3Iodmlld3BvcnQsIHByb2plY3Rpb25EaW1lbnNpb25zLCBmbGlwWSkge1xuICAgIHN1cGVyKHZpZXdwb3J0LCBwcm9qZWN0aW9uRGltZW5zaW9ucywgZmxpcFkpXG5cbiAgICB0aGlzLl92aWV3TWF0cml4ID0gTWF0MmQuY3JlYXRlKClcbiAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlXG4gICAgdGhpcy5fcHJvak1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fcHJvakRpcnR5ID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb2plY3Rpb24gZGltZW5zaW9ucyBvZiB0aGUgY2FtZXJhJ3Mgdmlldy4gVGhpcyBpcyB0aGUgd2lkdGgvaGVpZ2h0XG4gICAqIGluIHdvcmxkIHNwYWNlIGNvb3JkaWFudGVzIG9mIHRoZSBjYW1lcmEncyB2aWV3LlxuICAgKiBAcGFyYW0gIHtWZWMyZH0gcHJvamVjdGlvbkRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7Q2FtZXJhMmR9IHRoaXNcbiAgICovXG4gIHNldCBwcm9qZWN0aW9uRGltZW5zaW9ucyhwcm9qZWN0aW9uRGltZW5zaW9ucykge1xuICAgIGlmICghVmVjMmQuZXF1YWxzKHByb2plY3Rpb25EaW1lbnNpb25zLCB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucykpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBWZWMyZC5jbG9uZSh0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucylcbiAgICAgIEFBQm94MmQuY29weSh0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucywgcHJvamVjdGlvbkRpbWVuc2lvbnMpXG4gICAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlXG4gICAgICB0aGlzLl9wcm9qRGlydHkgPSB0cnVlXG4gICAgICAgIC8vIHRoaXMuX3lmbGlwID0gdGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnNbM10gPCB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9uc1sxXVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZFwiLCB7XG4gICAgICAgIGF0dHI6IFwicHJvamVjdGlvbkRpbWVuc2lvbnNcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogcHJvamVjdGlvbkRpbWVuc2lvbnNcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvcHkgb2YgdGhlIGNhbWVyYSdzIGN1cnJlbnQgcHJvamVjdGlvbiBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1ZlYzJkfVxuICAgKi9cbiAgZ2V0IHByb2plY3Rpb25EaW1lbnNpb25zKCkge1xuICAgIHJldHVybiBWZWMyZC5jbG9uZSh0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjYW1lcmEncyBjdXJyZW50IHByb2plY3Rpb24gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBnZXQgcHJvamVjdGlvbkRpbWVuc2lvbnNSZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybSAoZG9lcyBub3QgaW5jbHVkZSBwYXJlbnQgdHJhbnNmb3Jtcykgb2YgdGhlIFRyYW5zZm9ybTJkXG4gICAqIG1peGluIGlzIG1vZGlmaWVkLiBVc2VkIHRvIGJlIG5vdGlmaWVkIGludGVybmFsbHkgdGhhdCB0aGUgdmlldy10by1zY3JlZW4gc3BhY2VcbiAgICogdHJhbnNmb3JtYXRpb24gbmVlZHMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2NhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGdsb2JhbCBtYXRyaXggKGluY2x1ZGVzIHBhcmVudCB0cmFuc2Zvcm1zKSBvZiB0aGVcbiAgICogVHJhbnNmb3JtMmQgbWl4aW4gaXMgbW9kaWZpZWQuIFVzZWQgdG8gYmUgbm90aWZpZWQgaW50ZXJuYWxseSB0aGF0XG4gICAqIHRoZSB2aWV3LXRvLXNjcmVlbiBzcGFjZSB0cmFuc2Zvcm1hdGlvbiBuZWVkcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dsb2JhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gd29ybGQgc3BhY2UgdG8gdmlldy9jYW1lcmEgc3BhY2VcbiAgICogQHJldHVybiB7TWF0MmR9XG4gICAqL1xuICBnZXQgdmlld01hdHJpeCgpIHtcbiAgICBpZiAodGhpcy5fdmlld0RpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSB8fCB0aGlzLl94Zm9ybURpcnR5IHx8IHRoaXMuX2x4Zm9ybURpcnR5KSB7XG4gICAgICAvLyB0aGUgbWF0cml4IGhhcyBiZWVuIG1hcmtlZCBkaXJ0eSwgc28gcmVjYWxjdWxhdGVcbiAgICAgIGNvbnN0IHBvcyA9IFswLCAwXVxuICAgICAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgICAgIGNvbnN0IHJvdCA9IFswLCAwXVxuICAgICAgY29uc3QgeGZvcm0gPSB0aGlzLmdsb2JhbFhmb3JtXG4gICAgICBNYXQyZC5zdmQocG9zLCBzY2FsZSwgcm90LCB4Zm9ybSlcbiAgICAgIE1hdDJkLmZyb21UcmFuc2xhdGlvbih0aGlzLl92aWV3TWF0cml4LCBWZWMyZC5uZWdhdGUocG9zLCBwb3MpKVxuICAgICAgTWF0MmQucm90YXRlKHRoaXMuX3ZpZXdNYXRyaXgsIHRoaXMuX3ZpZXdNYXRyaXgsIC1yb3RbMF0pXG4gICAgICBNYXQyZC5zY2FsZSh0aGlzLl92aWV3TWF0cml4LCB0aGlzLl92aWV3TWF0cml4LCBzY2FsZSlcbiAgICAgIE1hdDJkLnJvdGF0ZSh0aGlzLl92aWV3TWF0cml4LCB0aGlzLl92aWV3TWF0cml4LCAtcm90WzFdKVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdNYXRyaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZnJvbVxuICAgKiB2aWV3IHRvIE5EQyAobm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMpIHNwYWNlXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IHByb2pNYXRyaXgoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2pEaXJ0eSkge1xuICAgICAgY29uc3QgZmxpcCA9ICh0aGlzLl95ZmxpcCA/IC0xIDogMSlcbiAgICAgIE1hdDJkLnNldCh0aGlzLl9wcm9qTWF0cml4LCAyLjAgLyB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9uc1swXSwgMCwgMCwgZmxpcCAqIDIuMCAvIHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zWzFdLCAwLCAwKVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcHJvakRpcnR5ID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb2pNYXRyaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBkaXJ0eSBmbGFncyBhcmUgYWN0aXZlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWF0cmljZXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm91bmRzT3V0T2ZEYXRlIHx8IHRoaXMuX2x4Zm9ybURpcnR5IHx8IHRoaXMuX3hmb3JtRGlydHkgfHwgdGhpcy5fdmlld0RpcnR5IHx8IHRoaXMuX3Byb2pEaXJ0eSB8fCB0aGlzLl9zY3JlZW5EaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmcm9tIHdvcmxkIHNwYWNlIHRvIHNjcmVlbiBzcGFjZS5cbiAgICogQHJldHVybiB7TWF0MmR9XG4gICAqL1xuICBnZXQgd29ybGRUb1NjcmVlbk1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXggfHwgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkIHx8IHRoaXMuX21hdHJpY2VzRGlydHkoKSkge1xuICAgICAgaWYgKCF0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuICAgICAgfVxuICAgICAgTWF0MmQuY29weSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpXG4gICAgICBNYXQyZC5tdWx0aXBseSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLnByb2pNYXRyaXgsIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICBNYXQyZC5tdWx0aXBseSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLnNjcmVlbk1hdHJpeCwgdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeClcbiAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCA9IGZhbHNlXG4gICAgICB0aGlzLl9zY3JlZW5Ub1dvcmxkT3V0ZGF0ZWQgPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0ZWggdHJhbnNmb3JtIG1hdHJpeCBmcm9tIHNjcmVlbiBzcGFjZSB0byB3b3JsZCBzcGFjZS5cbiAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBnZXQgc2NyZWVuVG9Xb3JsZE1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3NjcmVlblRvV29ybGQgfHwgdGhpcy5fc2NyZWVuVG9Xb3JsZE91dGRhdGVkIHx8IHRoaXMuX21hdHJpY2VzRGlydHkoKSkge1xuICAgICAgaWYgKCF0aGlzLl9zY3JlZW5Ub1dvcmxkKSB7XG4gICAgICAgIHRoaXMuX3NjcmVlblRvV29ybGQgPSBNYXQyZC5jcmVhdGUoKVxuICAgICAgfVxuICAgICAgTWF0MmQuY29weSh0aGlzLl9zY3JlZW5Ub1dvcmxkLCB0aGlzLndvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICBNYXQyZC5pbnZlcnQodGhpcy5fc2NyZWVuVG9Xb3JsZCwgdGhpcy5fc2NyZWVuVG9Xb3JsZClcbiAgICAgIHRoaXMuX3NjcmVlblRvV29ybGRPdXRkYXRlZCA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zY3JlZW5Ub1dvcmxkXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3ZpZXcvY2FtZXJhMmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n;\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === \"object\") {\n        module.exports = factory();\n    } else {\n        root.ResizeSensor = factory();\n    }\n}(this, function () {\n\n    //Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n        return null;\n    }\n    // Only used for the dirty checking, so the event callback count is limted to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n    var requestAnimationFrame = window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        function (fn) {\n            return window.setTimeout(fn, 20);\n        };\n\n    /**\n     * Iterate over each of the provided element(s).\n     *\n     * @param {HTMLElement|HTMLElement[]} elements\n     * @param {Function}                  callback\n     */\n    function forEachElement(elements, callback){\n        var elementsType = Object.prototype.toString.call(elements);\n        var isCollectionTyped = ('[object Array]' === elementsType\n            || ('[object NodeList]' === elementsType)\n            || ('[object HTMLCollection]' === elementsType)\n            || ('[object Object]' === elementsType)\n            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools\n        );\n        var i = 0, j = elements.length;\n        if (isCollectionTyped) {\n            for (; i < j; i++) {\n                callback(elements[i]);\n            }\n        } else {\n            callback(elements);\n        }\n    }\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            var q = [];\n            this.add = function(ev) {\n                q.push(ev);\n            };\n\n            var i, j;\n            this.call = function() {\n                for (i = 0, j = q.length; i < j; i++) {\n                    q[i].call();\n                }\n            };\n\n            this.remove = function(ev) {\n                var newQueue = [];\n                for(i = 0, j = q.length; i < j; i++) {\n                    if(q[i] !== ev) newQueue.push(q[i]);\n                }\n                q = newQueue;\n            }\n\n            this.length = function() {\n                return q.length;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} element\n         * @param {String}      prop\n         * @returns {String|Number}\n         */\n        function getComputedStyle(element, prop) {\n            if (element.currentStyle) {\n                return element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\n            } else {\n                return element.style[prop];\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element.resizedAttached) {\n                element.resizedAttached = new EventQueue();\n                element.resizedAttached.add(resized);\n            } else if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.className = 'resize-sensor';\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n            element.resizeSensor.style.cssText = style;\n            element.resizeSensor.innerHTML =\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n            element.appendChild(element.resizeSensor);\n\n            if (getComputedStyle(element, 'position') == 'static') {\n                element.style.position = 'relative';\n            }\n\n            var expand = element.resizeSensor.childNodes[0];\n            var expandChild = expand.childNodes[0];\n            var shrink = element.resizeSensor.childNodes[1];\n            var dirty, rafId, newWidth, newHeight;\n            var lastWidth = element.offsetWidth;\n            var lastHeight = element.offsetHeight;\n\n            var reset = function() {\n                expandChild.style.width = '100000px';\n                expandChild.style.height = '100000px';\n\n                expand.scrollLeft = 100000;\n                expand.scrollTop = 100000;\n\n                shrink.scrollLeft = 100000;\n                shrink.scrollTop = 100000;\n            };\n\n            reset();\n\n            var onResized = function() {\n                rafId = 0;\n\n                if (!dirty) return;\n\n                lastWidth = newWidth;\n                lastHeight = newHeight;\n\n                if (element.resizedAttached) {\n                    element.resizedAttached.call();\n                }\n            };\n\n            var onScroll = function() {\n                newWidth = element.offsetWidth;\n                newHeight = element.offsetHeight;\n                dirty = newWidth != lastWidth || newHeight != lastHeight;\n\n                if (dirty && !rafId) {\n                    rafId = requestAnimationFrame(onResized);\n                }\n\n                reset();\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n        }\n\n        forEachElement(element, function(elem){\n            attachResizeEvent(elem, callback);\n        });\n\n        this.detach = function(ev) {\n            ResizeSensor.detach(element, ev);\n        };\n    };\n\n    ResizeSensor.detach = function(element, ev) {\n        forEachElement(element, function(elem){\n            if(elem.resizedAttached && typeof ev == \"function\"){\n                elem.resizedAttached.remove(ev);\n                if(elem.resizedAttached.length()) return;\n            }\n            if (elem.resizeSensor) {\n                if (elem.contains(elem.resizeSensor)) {\n                    elem.removeChild(elem.resizeSensor);\n                }\n                delete elem.resizeSensor;\n                delete elem.resizedAttached;\n            }\n        });\n    };\n\n    return ResizeSensor;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9jc3MtZWxlbWVudC1xdWVyaWVzL3NyYy9SZXNpemVTZW5zb3IuanM/MTljOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUyxRQUFRLFVBQVUsV0FBVyxrQkFBa0IsYUFBYSxvQkFBb0I7QUFDckksaURBQWlELFNBQVMsUUFBUSxnQkFBZ0I7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXG4gKiBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb24gYW5kIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllcy9ibG9iL21hc3Rlci9MSUNFTlNFLlxuICovXG47XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5SZXNpemVTZW5zb3IgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL01ha2Ugc3VyZSBpdCBkb2VzIG5vdCB0aHJvdyBpbiBhIFNTUiAoU2VydmVyIFNpZGUgUmVuZGVyaW5nKSBzaXR1YXRpb25cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gT25seSB1c2VkIGZvciB0aGUgZGlydHkgY2hlY2tpbmcsIHNvIHRoZSBldmVudCBjYWxsYmFjayBjb3VudCBpcyBsaW10ZWQgdG8gbWF4IDEgY2FsbCBwZXIgZnBzIHBlciBzZW5zb3IuXG4gICAgLy8gSW4gY29tYmluYXRpb24gd2l0aCB0aGUgZXZlbnQgYmFzZWQgcmVzaXplIHNlbnNvciB0aGlzIHNhdmVzIGNwdSB0aW1lLCBiZWNhdXNlIHRoZSBzZW5zb3IgaXMgdG9vIGZhc3QgYW5kXG4gICAgLy8gd291bGQgZ2VuZXJhdGUgdG9vIG1hbnkgdW5uZWNlc3NhcnkgZXZlbnRzLlxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgMjApO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIGVhY2ggb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxFbGVtZW50W119IGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hFbGVtZW50KGVsZW1lbnRzLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBlbGVtZW50c1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpO1xuICAgICAgICB2YXIgaXNDb2xsZWN0aW9uVHlwZWQgPSAoJ1tvYmplY3QgQXJyYXldJyA9PT0gZWxlbWVudHNUeXBlXG4gICAgICAgICAgICB8fCAoJ1tvYmplY3QgTm9kZUxpc3RdJyA9PT0gZWxlbWVudHNUeXBlKVxuICAgICAgICAgICAgfHwgKCdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScgPT09IGVsZW1lbnRzVHlwZSlcbiAgICAgICAgICAgIHx8ICgnW29iamVjdCBPYmplY3RdJyA9PT0gZWxlbWVudHNUeXBlKVxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgalF1ZXJ5ICYmIGVsZW1lbnRzIGluc3RhbmNlb2YgalF1ZXJ5KSAvL2pxdWVyeVxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgRWxlbWVudHMgJiYgZWxlbWVudHMgaW5zdGFuY2VvZiBFbGVtZW50cykgLy9tb290b29sc1xuICAgICAgICApO1xuICAgICAgICB2YXIgaSA9IDAsIGogPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlZCkge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBmb3IgZGltZW5zaW9uIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfEVsZW1lbnRzfGpRdWVyeX0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUmVzaXplU2Vuc29yID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcbiAgICAgICAgICAgIHZhciBxID0gW107XG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgcS5wdXNoKGV2KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBpLCBqO1xuICAgICAgICAgICAgdGhpcy5jYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHEubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFbaV0uY2FsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDAsIGogPSBxLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZihxW2ldICE9PSBldikgbmV3UXVldWUucHVzaChxW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcSA9IG5ld1F1ZXVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIHByb3BcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICByZXNpemVkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50LCByZXNpemVkKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQgPSBuZXcgRXZlbnRRdWV1ZSgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuY2xhc3NOYW1lID0gJ3Jlc2l6ZS1zZW5zb3InO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyc7XG4gICAgICAgICAgICB2YXIgc3R5bGVDaGlsZCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7JztcblxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3ItZXhwYW5kXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlQ2hpbGQgKyAnXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVzaXplLXNlbnNvci1zaHJpbmtcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCInICsgc3R5bGVDaGlsZCArICcgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJVwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50LnJlc2l6ZVNlbnNvcik7XG5cbiAgICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICdwb3NpdGlvbicpID09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHBhbmQgPSBlbGVtZW50LnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkID0gZXhwYW5kLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB2YXIgc2hyaW5rID0gZWxlbWVudC5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgICAgIHZhciBkaXJ0eSwgcmFmSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGFzdFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBsYXN0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoID0gJzEwMDAwMHB4JztcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAnMTAwMDAwcHgnO1xuXG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbFRvcCA9IDEwMDAwMDtcblxuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNldCgpO1xuXG4gICAgICAgICAgICB2YXIgb25SZXNpemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmFmSWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJ0eSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgbGFzdFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IG5ld0hlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5jYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGRpcnR5ID0gbmV3V2lkdGggIT0gbGFzdFdpZHRoIHx8IG5ld0hlaWdodCAhPSBsYXN0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5ICYmICFyYWZJZCkge1xuICAgICAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvblJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhZGRFdmVudChleHBhbmQsICdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgICAgICBhZGRFdmVudChzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kZXRhY2ggPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50LCBldik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFJlc2l6ZVNlbnNvci5kZXRhY2ggPSBmdW5jdGlvbihlbGVtZW50LCBldikge1xuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGlmKGVsZW0ucmVzaXplZEF0dGFjaGVkICYmIHR5cGVvZiBldiA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICAgICAgICAgIGVsZW0ucmVzaXplZEF0dGFjaGVkLnJlbW92ZShldik7XG4gICAgICAgICAgICAgICAgaWYoZWxlbS5yZXNpemVkQXR0YWNoZWQubGVuZ3RoKCkpIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLnJlc2l6ZVNlbnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLmNvbnRhaW5zKGVsZW0ucmVzaXplU2Vuc29yKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNoaWxkKGVsZW0ucmVzaXplU2Vuc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplU2Vuc29yO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtLnJlc2l6ZWRBdHRhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXNpemVTZW5zb3I7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWVsZW1lbnQtcXVlcmllcy9zcmMvUmVzaXplU2Vuc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 2x2 Matrix\n * @name mat2\n */\nvar mat2 = {};\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nmat2.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nmat2.fromValues = function(m00, m01, m10, m11) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m10;\n    out[3] = m11;\n    return out;\n};\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nmat2.set = function(out, m00, m01, m10, m11) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m10;\n    out[3] = m11;\n    return out;\n};\n\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a1 = a[1];\n        out[1] = a[2];\n        out[2] = a1;\n    } else {\n        out[0] = a[0];\n        out[1] = a[2];\n        out[2] = a[1];\n        out[3] = a[3];\n    }\n    \n    return out;\n};\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.invert = function(out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n\n        // Calculate the determinant\n        det = a0 * a3 - a2 * a1;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n    \n    out[0] =  a3 * det;\n    out[1] = -a1 * det;\n    out[2] = -a2 * det;\n    out[3] =  a0 * det;\n\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.adjoint = function(out, a) {\n    // Caching this value is nessecary if out == a\n    var a0 = a[0];\n    out[0] =  a[3];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] =  a0;\n\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2.determinant = function (a) {\n    return a[0] * a[3] - a[2] * a[1];\n};\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    return out;\n};\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nmat2.mul = mat2.multiply;\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 *  c + a2 * s;\n    out[1] = a1 *  c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    return out;\n};\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nmat2.scale = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    return out;\n};\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.fromRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = c;\n    out[1] = s;\n    out[2] = -s;\n    out[3] = c;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2} out\n */\nmat2.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = v[1];\n    return out;\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2.str = function (a) {\n    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))\n};\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix \n * @param {mat2} D the diagonal matrix \n * @param {mat2} U the upper triangular matrix \n * @param {mat2} a the input matrix to factorize\n */\n\nmat2.LDU = function (L, D, U, a) { \n    L[2] = a[2]/a[0]; \n    U[0] = a[0]; \n    U[1] = a[1]; \n    U[3] = a[3] - L[2] * U[1]; \n    return [L, D, U];       \n}; \n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nmat2.sub = mat2.subtract;\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n};\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nmat2.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nmat2.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\nmodule.exports = mat2;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzP2FkNWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTEwO1xuICAgIG91dFszXSA9IG0xMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMTA7XG4gICAgb3V0WzNdID0gbTExO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLnN1YiA9IG1hdDIuc3VidHJhY3Q7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0Mi5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 2x3 Matrix\n * @name mat2d\n * \n * @description \n * A mat2d contains six elements defined as:\n * <pre>\n * [a, c, tx,\n *  b, d, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, c, tx,\n *  b, d, ty,\n *  0, 0, 1]\n * </pre>\n * The last row is ignored so the array is shorter and operations are faster.\n */\nvar mat2d = {};\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nmat2d.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nmat2d.fromValues = function(a, b, c, d, tx, ty) {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = a;\n    out[1] = b;\n    out[2] = c;\n    out[3] = d;\n    out[4] = tx;\n    out[5] = ty;\n    return out;\n};\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nmat2d.set = function(out, a, b, c, d, tx, ty) {\n    out[0] = a;\n    out[1] = b;\n    out[2] = c;\n    out[3] = d;\n    out[4] = tx;\n    out[5] = ty;\n    return out;\n};\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.invert = function(out, a) {\n    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],\n        atx = a[4], aty = a[5];\n\n    var det = aa * ad - ab * ac;\n    if(!det){\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = ad * det;\n    out[1] = -ab * det;\n    out[2] = -ac * det;\n    out[3] = aa * det;\n    out[4] = (ac * aty - ad * atx) * det;\n    out[5] = (ab * atx - aa * aty) * det;\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2d.determinant = function (a) {\n    return a[0] * a[3] - a[1] * a[2];\n};\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    out[4] = a0 * b4 + a2 * b5 + a4;\n    out[5] = a1 * b4 + a3 * b5 + a5;\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nmat2d.mul = mat2d.multiply;\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 *  c + a2 * s;\n    out[1] = a1 *  c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nmat2d.scale = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nmat2d.translate = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = a0 * v0 + a2 * v1 + a4;\n    out[5] = a1 * v0 + a3 * v1 + a5;\n    return out;\n};\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.fromRotation = function(out, rad) {\n    var s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c;\n    out[1] = s;\n    out[2] = -s;\n    out[3] = c;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2d} out\n */\nmat2d.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = v[1];\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat2d} out\n */\nmat2d.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = v[0];\n    out[5] = v[1];\n    return out;\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2d.str = function (a) {\n    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + \n                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2d.frob = function (a) { \n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))\n}; \n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nmat2d.sub = mat2d.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nmat2d.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    return out;\n};\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nmat2d.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    return out;\n};\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2d.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2d.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));\n};\n\nmodule.exports = mat2d;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyZC5qcz9lNTljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xubWF0MmQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhO1xuICAgIG91dFsxXSA9IGI7XG4gICAgb3V0WzJdID0gYztcbiAgICBvdXRbM10gPSBkO1xuICAgIG91dFs0XSA9IHR4O1xuICAgIG91dFs1XSA9IHR5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5zZXQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIG91dFswXSA9IGE7XG4gICAgb3V0WzFdID0gYjtcbiAgICBvdXRbMl0gPSBjO1xuICAgIG91dFszXSA9IGQ7XG4gICAgb3V0WzRdID0gdHg7XG4gICAgb3V0WzVdID0gdHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSB2WzBdO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5zdWIgPSBtYXQyZC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyZC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0MmQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXQyZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 4x4 Matrix\n * @name mat4\n */\nvar mat4 = {\n  scalar: {},\n  SIMD: {},\n};\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nmat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n};\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nmat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n};\n\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nmat4.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a03 = a[3],\n            a12 = a[6], a13 = a[7],\n            a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n};\n\n/**\n * Transpose the values of a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.transpose = function(out, a) {\n    var a0, a1, a2, a3,\n        tmp01, tmp23,\n        out0, out1, out2, out3;\n\n    a0 = SIMD.Float32x4.load(a, 0);\n    a1 = SIMD.Float32x4.load(a, 4);\n    a2 = SIMD.Float32x4.load(a, 8);\n    a3 = SIMD.Float32x4.load(a, 12);\n\n    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n    SIMD.Float32x4.store(out, 0,  out0);\n    SIMD.Float32x4.store(out, 4,  out1);\n\n    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n    SIMD.Float32x4.store(out, 8,  out2);\n    SIMD.Float32x4.store(out, 12, out3);\n\n    return out;\n};\n\n/**\n * Transpse a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;\n\n/**\n * Inverts a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.invert = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n};\n\n/**\n * Inverts a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.invert = function(out, a) {\n  var row0, row1, row2, row3,\n      tmp1,\n      minor0, minor1, minor2, minor3,\n      det,\n      a0 = SIMD.Float32x4.load(a, 0),\n      a1 = SIMD.Float32x4.load(a, 4),\n      a2 = SIMD.Float32x4.load(a, 8),\n      a3 = SIMD.Float32x4.load(a, 12);\n\n  // Compute matrix adjugate\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n\n  tmp1   = SIMD.Float32x4.mul(row2, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.mul(row1, tmp1);\n  minor1 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row1, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n  minor3 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n  minor2 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row0, row1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n\n  // Compute matrix determinant\n  det   = SIMD.Float32x4.mul(row0, minor0);\n  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);\n  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);\n  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);\n  det   = SIMD.Float32x4.sub(\n               SIMD.Float32x4.add(tmp1, tmp1),\n               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));\n  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);\n  if (!det) {\n      return null;\n  }\n\n  // Compute matrix inverse\n  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));\n  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));\n  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));\n  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));\n  return out;\n}\n\n/**\n * Inverts a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;\n\n/**\n * Calculates the adjugate of a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.adjoint = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.adjoint = function(out, a) {\n  var a0, a1, a2, a3;\n  var row0, row1, row2, row3;\n  var tmp1;\n  var minor0, minor1, minor2, minor3;\n\n  var a0 = SIMD.Float32x4.load(a, 0);\n  var a1 = SIMD.Float32x4.load(a, 4);\n  var a2 = SIMD.Float32x4.load(a, 8);\n  var a3 = SIMD.Float32x4.load(a, 12);\n\n  // Transpose the source matrix.  Sort of.  Not a true transpose operation\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n\n  tmp1   = SIMD.Float32x4.mul(row2, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.mul(row1, tmp1);\n  minor1 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row1, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n  minor3 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n  minor2 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row0, row1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n\n  SIMD.Float32x4.store(out, 0,  minor0);\n  SIMD.Float32x4.store(out, 4,  minor1);\n  SIMD.Float32x4.store(out, 8,  minor2);\n  SIMD.Float32x4.store(out, 12, minor3);\n  return out;\n};\n\n/**\n * Calculates the adjugate of a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nmat4.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n};\n\n/**\n * Multiplies two mat4's explicitly using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand, must be a Float32Array\n * @param {mat4} b the second operand, must be a Float32Array\n * @returns {mat4} out\n */\nmat4.SIMD.multiply = function (out, a, b) {\n    var a0 = SIMD.Float32x4.load(a, 0);\n    var a1 = SIMD.Float32x4.load(a, 4);\n    var a2 = SIMD.Float32x4.load(a, 8);\n    var a3 = SIMD.Float32x4.load(a, 12);\n\n    var b0 = SIMD.Float32x4.load(b, 0);\n    var out0 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 0, out0);\n\n    var b1 = SIMD.Float32x4.load(b, 4);\n    var out1 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 4, out1);\n\n    var b2 = SIMD.Float32x4.load(b, 8);\n    var out2 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),\n                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 8, out2);\n\n    var b3 = SIMD.Float32x4.load(b, 12);\n    var out3 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),\n                        SIMD.Float32x4.add(\n                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),\n                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 12, out3);\n\n    return out;\n};\n\n/**\n * Multiplies two mat4's explicitly not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.scalar.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];\n    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];\n    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];\n    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n    return out;\n};\n\n/**\n * Multiplies two mat4's using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nmat4.mul = mat4.multiply;\n\n/**\n * Translate a mat4 by the given vector not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.scalar.translate = function (out, a, v) {\n    var x = v[0], y = v[1], z = v[2],\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;\n        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;\n        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n};\n\n/**\n * Translates a mat4 by the given vector using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.SIMD.translate = function (out, a, v) {\n    var a0 = SIMD.Float32x4.load(a, 0),\n        a1 = SIMD.Float32x4.load(a, 4),\n        a2 = SIMD.Float32x4.load(a, 8),\n        a3 = SIMD.Float32x4.load(a, 12),\n        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);\n\n    if (a !== out) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];\n        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];\n    }\n\n    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));\n    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));\n    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));\n\n    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));\n    SIMD.Float32x4.store(out, 12, t0);\n\n    return out;\n};\n\n/**\n * Translates a mat4 by the given vector using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.scalar.scale = function(out, a, v) {\n    var x = v[0], y = v[1], z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.SIMD.scale = function(out, a, v) {\n    var a0, a1, a2;\n    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);\n\n    a0 = SIMD.Float32x4.load(a, 0);\n    SIMD.Float32x4.store(\n        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));\n\n    a1 = SIMD.Float32x4.load(a, 4);\n    SIMD.Float32x4.store(\n        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));\n\n    a2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(\n        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));\n\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n */\nmat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.rotate = function (out, a, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t,\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23,\n        b00, b01, b02,\n        b10, b11, b12,\n        b20, b21, b22;\n\n    if (Math.abs(len) < glMatrix.EPSILON) { return null; }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateX = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[0]  = a[0];\n        out[1]  = a[1];\n        out[2]  = a[2];\n        out[3]  = a[3];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[4] = a10 * c + a20 * s;\n    out[5] = a11 * c + a21 * s;\n    out[6] = a12 * c + a22 * s;\n    out[7] = a13 * c + a23 * s;\n    out[8] = a20 * c - a10 * s;\n    out[9] = a21 * c - a11 * s;\n    out[10] = a22 * c - a12 * s;\n    out[11] = a23 * c - a13 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateX = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n      out[0]  = a[0];\n      out[1]  = a[1];\n      out[2]  = a[2];\n      out[3]  = a[3];\n      out[12] = a[12];\n      out[13] = a[13];\n      out[14] = a[14];\n      out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_1 = SIMD.Float32x4.load(a, 4);\n    var a_2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(out, 4,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));\n    SIMD.Float32x4.store(out, 8,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;\n\n/**\n * Rotates a matrix by the given angle around the Y axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateY = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4]  = a[4];\n        out[5]  = a[5];\n        out[6]  = a[6];\n        out[7]  = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c - a20 * s;\n    out[1] = a01 * c - a21 * s;\n    out[2] = a02 * c - a22 * s;\n    out[3] = a03 * c - a23 * s;\n    out[8] = a00 * s + a20 * c;\n    out[9] = a01 * s + a21 * c;\n    out[10] = a02 * s + a22 * c;\n    out[11] = a03 * s + a23 * c;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateY = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4]  = a[4];\n        out[5]  = a[5];\n        out[6]  = a[6];\n        out[7]  = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_0 = SIMD.Float32x4.load(a, 0);\n    var a_2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(out, 0,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));\n    SIMD.Float32x4.store(out, 8,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;\n\n/**\n * Rotates a matrix by the given angle around the Z axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateZ = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8]  = a[8];\n        out[9]  = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c + a10 * s;\n    out[1] = a01 * c + a11 * s;\n    out[2] = a02 * c + a12 * s;\n    out[3] = a03 * c + a13 * s;\n    out[4] = a10 * c - a00 * s;\n    out[5] = a11 * c - a01 * s;\n    out[6] = a12 * c - a02 * s;\n    out[7] = a13 * c - a03 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateZ = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8]  = a[8];\n        out[9]  = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_0 = SIMD.Float32x4.load(a, 0);\n    var a_1 = SIMD.Float32x4.load(a, 4);\n    SIMD.Float32x4.store(out, 0,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));\n    SIMD.Float32x4.store(out, 4,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nmat4.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = v[1];\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = v[2];\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.fromRotation = function(out, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t;\n\n    if (Math.abs(len) < glMatrix.EPSILON) { return null; }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = x * x * t + c;\n    out[1] = y * x * t + z * s;\n    out[2] = z * x * t - y * s;\n    out[3] = 0;\n    out[4] = x * y * t - z * s;\n    out[5] = y * y * t + c;\n    out[6] = z * y * t + x * s;\n    out[7] = 0;\n    out[8] = x * z * t + y * s;\n    out[9] = y * z * t - x * s;\n    out[10] = z * z * t + c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromXRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = 1;\n    out[1]  = 0;\n    out[2]  = 0;\n    out[3]  = 0;\n    out[4] = 0;\n    out[5] = c;\n    out[6] = s;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = -s;\n    out[10] = c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromYRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = c;\n    out[1]  = 0;\n    out[2]  = -s;\n    out[3]  = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = s;\n    out[9] = 0;\n    out[10] = c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromZRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = c;\n    out[1]  = s;\n    out[2]  = 0;\n    out[3]  = 0;\n    out[4] = -s;\n    out[5] = c;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslation = function (out, q, v) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - (yy + zz);\n    out[1] = xy + wz;\n    out[2] = xz - wy;\n    out[3] = 0;\n    out[4] = xy - wz;\n    out[5] = 1 - (xx + zz);\n    out[6] = yz + wx;\n    out[7] = 0;\n    out[8] = xz + wy;\n    out[9] = yz - wx;\n    out[10] = 1 - (xx + yy);\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nmat4.getTranslation = function (out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n};\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nmat4.getRotation = function (out, mat) {\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n  var trace = mat[0] + mat[5] + mat[10];\n  var S = 0;\n\n  if (trace > 0) { \n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (mat[6] - mat[9]) / S;\n    out[1] = (mat[8] - mat[2]) / S; \n    out[2] = (mat[1] - mat[4]) / S; \n  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { \n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\n    out[3] = (mat[6] - mat[9]) / S;\n    out[0] = 0.25 * S;\n    out[1] = (mat[1] + mat[4]) / S; \n    out[2] = (mat[8] + mat[2]) / S; \n  } else if (mat[5] > mat[10]) { \n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\n    out[3] = (mat[8] - mat[2]) / S;\n    out[0] = (mat[1] + mat[4]) / S; \n    out[1] = 0.25 * S;\n    out[2] = (mat[6] + mat[9]) / S; \n  } else { \n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\n    out[3] = (mat[1] - mat[4]) / S;\n    out[0] = (mat[8] + mat[2]) / S;\n    out[1] = (mat[6] + mat[9]) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslationScale = function (out, q, v, s) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2,\n        sx = s[0],\n        sy = s[1],\n        sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @param {vec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nmat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0], y = q[1], z = q[2], w = q[3],\n      x2 = x + x,\n      y2 = y + y,\n      z2 = z + z,\n\n      xx = x * x2,\n      xy = x * y2,\n      xz = x * z2,\n      yy = y * y2,\n      yz = y * z2,\n      zz = z * z2,\n      wx = w * x2,\n      wy = w * y2,\n      wz = w * z2,\n\n      sx = s[0],\n      sy = s[1],\n      sz = s[2],\n\n      ox = o[0],\n      oy = o[1],\n      oz = o[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);\n  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);\n  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);\n  out[15] = 1;\n\n  return out;\n};\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nmat4.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.frustum = function (out, left, right, bottom, top, near, far) {\n    var rl = 1 / (right - left),\n        tb = 1 / (top - bottom),\n        nf = 1 / (near - far);\n    out[0] = (near * 2) * rl;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = (near * 2) * tb;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = (right + left) * rl;\n    out[9] = (top + bottom) * tb;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (far * near * 2) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspective = function (out, fovy, aspect, near, far) {\n    var f = 1.0 / Math.tan(fovy / 2),\n        nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (2 * far * near) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspectiveFromFieldOfView = function (out, fov, near, far) {\n    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),\n        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),\n        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),\n        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),\n        xScale = 2.0 / (leftTan + rightTan),\n        yScale = 2.0 / (upTan + downTan);\n\n    out[0] = xScale;\n    out[1] = 0.0;\n    out[2] = 0.0;\n    out[3] = 0.0;\n    out[4] = 0.0;\n    out[5] = yScale;\n    out[6] = 0.0;\n    out[7] = 0.0;\n    out[8] = -((leftTan - rightTan) * xScale * 0.5);\n    out[9] = ((upTan - downTan) * yScale * 0.5);\n    out[10] = far / (near - far);\n    out[11] = -1.0;\n    out[12] = 0.0;\n    out[13] = 0.0;\n    out[14] = (far * near) / (near - far);\n    out[15] = 0.0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.ortho = function (out, left, right, bottom, top, near, far) {\n    var lr = 1 / (left - right),\n        bt = 1 / (bottom - top),\n        nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nmat4.lookAt = function (out, eye, center, up) {\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,\n        eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2],\n        centerx = center[0],\n        centery = center[1],\n        centerz = center[2];\n\n    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&\n        Math.abs(eyey - centery) < glMatrix.EPSILON &&\n        Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n        return mat4.identity(out);\n    }\n\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n\n    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    } else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n\n    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    } else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n\n    out[0] = x0;\n    out[1] = y0;\n    out[2] = z0;\n    out[3] = 0;\n    out[4] = x1;\n    out[5] = y1;\n    out[6] = z1;\n    out[7] = 0;\n    out[8] = x2;\n    out[9] = y2;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat4.str = function (a) {\n    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +\n                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +\n                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat4.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))\n};\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n};\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nmat4.sub = mat4.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nmat4.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n};\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nmat4.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    out[6] = a[6] + (b[6] * scale);\n    out[7] = a[7] + (b[7] * scale);\n    out[8] = a[8] + (b[8] * scale);\n    out[9] = a[9] + (b[9] * scale);\n    out[10] = a[10] + (b[10] * scale);\n    out[11] = a[11] + (b[11] * scale);\n    out[12] = a[12] + (b[12] * scale);\n    out[13] = a[13] + (b[13] * scale);\n    out[14] = a[14] + (b[14] * scale);\n    out[15] = a[15] + (b[15] * scale);\n    return out;\n};\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat4.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && \n           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && \n           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&\n           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat4.equals = function (a, b) {\n    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],\n        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], \n        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], \n        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];\n\n    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],\n        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], \n        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], \n        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&\n            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&\n            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&\n            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&\n            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&\n            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&\n            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&\n            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));\n};\n\n\n\nmodule.exports = mat4;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzPzg5OWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG52YXIgbWF0NCA9IHtcbiAgc2NhbGFyOiB7fSxcbiAgU0lNRDoge30sXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcbiAqL1xubWF0NC5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMDM7XG4gICAgb3V0WzRdID0gbTEwO1xuICAgIG91dFs1XSA9IG0xMTtcbiAgICBvdXRbNl0gPSBtMTI7XG4gICAgb3V0WzddID0gbTEzO1xuICAgIG91dFs4XSA9IG0yMDtcbiAgICBvdXRbOV0gPSBtMjE7XG4gICAgb3V0WzEwXSA9IG0yMjtcbiAgICBvdXRbMTFdID0gbTIzO1xuICAgIG91dFsxMl0gPSBtMzA7XG4gICAgb3V0WzEzXSA9IG0zMTtcbiAgICBvdXRbMTRdID0gbTMyO1xuICAgIG91dFsxNV0gPSBtMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zZXQgPSBmdW5jdGlvbihvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0wMztcbiAgICBvdXRbNF0gPSBtMTA7XG4gICAgb3V0WzVdID0gbTExO1xuICAgIG91dFs2XSA9IG0xMjtcbiAgICBvdXRbN10gPSBtMTM7XG4gICAgb3V0WzhdID0gbTIwO1xuICAgIG91dFs5XSA9IG0yMTtcbiAgICBvdXRbMTBdID0gbTIyO1xuICAgIG91dFsxMV0gPSBtMjM7XG4gICAgb3V0WzEyXSA9IG0zMDtcbiAgICBvdXRbMTNdID0gbTMxO1xuICAgIG91dFsxNF0gPSBtMzI7XG4gICAgb3V0WzE1XSA9IG0zMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NCBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDQgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCwgYTEsIGEyLCBhMyxcbiAgICAgICAgdG1wMDEsIHRtcDIzLFxuICAgICAgICBvdXQwLCBvdXQxLCBvdXQyLCBvdXQzO1xuXG4gICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAgIHRtcDAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDAsIDEsIDQsIDUpO1xuICAgIHRtcDIzID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDAsIDEsIDQsIDUpO1xuICAgIG91dDAgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDAsIDIsIDQsIDYpO1xuICAgIG91dDEgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDEsIDMsIDUsIDcpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgIG91dDApO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgIG91dDEpO1xuXG4gICAgdG1wMDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMiwgMywgNiwgNyk7XG4gICAgdG1wMjMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMiwgMywgNiwgNyk7XG4gICAgb3V0MiAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMCwgMiwgNCwgNik7XG4gICAgb3V0MyAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMSwgMywgNSwgNyk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCAgb3V0Mik7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgb3V0Myk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3BzZSBhIG1hdDQgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNwb3NlID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQudHJhbnNwb3NlIDogbWF0NC5zY2FsYXIudHJhbnNwb3NlO1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDQgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICB2YXIgcm93MCwgcm93MSwgcm93Miwgcm93MyxcbiAgICAgIHRtcDEsXG4gICAgICBtaW5vcjAsIG1pbm9yMSwgbWlub3IyLCBtaW5vcjMsXG4gICAgICBkZXQsXG4gICAgICBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCksXG4gICAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCksXG4gICAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCksXG4gICAgICBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gIC8vIENvbXB1dGUgbWF0cml4IGFkanVnYXRlXG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMCwgMSwgNCwgNSk7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMCwgMSwgNCwgNSk7XG4gIHJvdzAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzEsIDAsIDIsIDQsIDYpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3cxLCB0bXAxLCAxLCAzLCA1LCA3KTtcbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAyLCAzLCA2LCA3KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAyLCAzLCA2LCA3KTtcbiAgcm93MiA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MywgMCwgMiwgNCwgNik7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzMsIHRtcDEsIDEsIDMsIDUsIDcpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IxLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IzKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjMsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzEsIDIsIDMsIDAsIDEpLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgcm93MiAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cyLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMiwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMiwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMyk7XG5cbiAgLy8gQ29tcHV0ZSBtYXRyaXggZGV0ZXJtaW5hbnRcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgbWlub3IwKTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShkZXQsIDIsIDMsIDAsIDEpLCBkZXQpO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGRldCwgMSwgMCwgMywgMiksIGRldCk7XG4gIHRtcDEgID0gU0lNRC5GbG9hdDMyeDQucmVjaXByb2NhbEFwcHJveGltYXRpb24oZGV0KTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoXG4gICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQodG1wMSwgdG1wMSksXG4gICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBTSU1ELkZsb2F0MzJ4NC5tdWwodG1wMSwgdG1wMSkpKTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGRldCwgMCwgMCwgMCwgMCk7XG4gIGlmICghZGV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgbWF0cml4IGludmVyc2VcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IwKSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMSkpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjIpKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IzKSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDQgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaW52ZXJ0ID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQuaW52ZXJ0IDogbWF0NC5zY2FsYXIuaW52ZXJ0O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NCBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDQgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgdmFyIGEwLCBhMSwgYTIsIGEzO1xuICB2YXIgcm93MCwgcm93MSwgcm93Miwgcm93MztcbiAgdmFyIHRtcDE7XG4gIHZhciBtaW5vcjAsIG1pbm9yMSwgbWlub3IyLCBtaW5vcjM7XG5cbiAgdmFyIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgdmFyIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgdmFyIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgLy8gVHJhbnNwb3NlIHRoZSBzb3VyY2UgbWF0cml4LiAgU29ydCBvZi4gIE5vdCBhIHRydWUgdHJhbnNwb3NlIG9wZXJhdGlvblxuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDAsIDEsIDQsIDUpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDAsIDEsIDQsIDUpO1xuICByb3cwID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3cxLCAwLCAyLCA0LCA2KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MSwgdG1wMSwgMSwgMywgNSwgNyk7XG5cbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAyLCAzLCA2LCA3KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAyLCAzLCA2LCA3KTtcbiAgcm93MiA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MywgMCwgMiwgNCwgNik7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzMsIHRtcDEsIDEsIDMsIDUsIDcpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IxLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IzKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjMsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzEsIDIsIDMsIDAsIDEpLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgcm93MiAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cyLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMiwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMiwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMyk7XG5cbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCAgbWlub3IwKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCAgbWlub3IxKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCAgbWlub3IyKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgbWlub3IzKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0IHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG4gbWF0NC5hZGpvaW50ID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQuYWRqb2ludCA6IG1hdDQuc2NhbGFyLmFkam9pbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzIGV4cGxpY2l0bHkgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmQsIG11c3QgYmUgYSBGbG9hdDMyQXJyYXlcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmQsIG11c3QgYmUgYSBGbG9hdDMyQXJyYXlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgdmFyIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICB2YXIgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gICAgdmFyIGIwID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCAwKTtcbiAgICB2YXIgb3V0MCA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgb3V0MCk7XG5cbiAgICB2YXIgYjEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDQpO1xuICAgIHZhciBvdXQxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCBvdXQxKTtcblxuICAgIHZhciBiMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgOCk7XG4gICAgdmFyIG91dDIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgb3V0Mik7XG5cbiAgICB2YXIgYjMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDEyKTtcbiAgICB2YXIgb3V0MyA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBvdXQzKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQncyBleHBsaWNpdGx5IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3MgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHkgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5tdWx0aXBseSA6IG1hdDQuc2NhbGFyLm11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCksXG4gICAgICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KSxcbiAgICAgICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpLFxuICAgICAgICBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpLFxuICAgICAgICB2ZWMgPSBTSU1ELkZsb2F0MzJ4NCh2WzBdLCB2WzFdLCB2WzJdICwgMCk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07IG91dFsxXSA9IGFbMV07IG91dFsyXSA9IGFbMl07IG91dFszXSA9IGFbM107XG4gICAgICAgIG91dFs0XSA9IGFbNF07IG91dFs1XSA9IGFbNV07IG91dFs2XSA9IGFbNl07IG91dFs3XSA9IGFbN107XG4gICAgICAgIG91dFs4XSA9IGFbOF07IG91dFs5XSA9IGFbOV07IG91dFsxMF0gPSBhWzEwXTsgb3V0WzExXSA9IGFbMTFdO1xuICAgIH1cblxuICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubXVsKGEwLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMCwgMCwgMCwgMCkpO1xuICAgIGExID0gU0lNRC5GbG9hdDMyeDQubXVsKGExLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMSwgMSwgMSwgMSkpO1xuICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubXVsKGEyLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMiwgMiwgMiwgMikpO1xuXG4gICAgdmFyIHQwID0gU0lNRC5GbG9hdDMyeDQuYWRkKGEwLCBTSU1ELkZsb2F0MzJ4NC5hZGQoYTEsIFNJTUQuRmxvYXQzMng0LmFkZChhMiwgYTMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgdDApO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvciB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQudHJhbnNsYXRlIDogbWF0NC5zY2FsYXIudHJhbnNsYXRlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuc2NhbGFyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5TSU1ELnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwLCBhMSwgYTI7XG4gICAgdmFyIHZlYyA9IFNJTUQuRmxvYXQzMng0KHZbMF0sIHZbMV0sIHZbMl0sIDApO1xuXG4gICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKFxuICAgICAgICBvdXQsIDAsIFNJTUQuRmxvYXQzMng0Lm11bChhMCwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDAsIDAsIDAsIDApKSk7XG5cbiAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUoXG4gICAgICAgIG91dCwgNCwgU0lNRC5GbG9hdDMyeDQubXVsKGExLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMSwgMSwgMSwgMSkpKTtcblxuICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShcbiAgICAgICAgb3V0LCA4LCBTSU1ELkZsb2F0MzJ4NC5tdWwoYTIsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAyLCAyLCAyLCAyKSkpO1xuXG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsZSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnNjYWxlIDogbWF0NC5zY2FsYXIuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguc2luKHJhZCkpLFxuICAgICAgICBjID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5jb3MocmFkKSk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB2YXIgYV8xID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICB2YXIgYV8yID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIHMpKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgdXNpbmcgU0lNRCBpZiBhdmFpbGFiZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWCA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnJvdGF0ZVggOiBtYXQ0LnNjYWxhci5yb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5zaW4ocmFkKSksXG4gICAgICAgIGMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLmNvcyhyYWQpKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB2YXIgYV8wID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICB2YXIgYV8yID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgcyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIGMpKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgaWYgU0lNRCBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG4gbWF0NC5yb3RhdGVZID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQucm90YXRlWSA6IG1hdDQuc2NhbGFyLnJvdGF0ZVk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcyB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguc2luKHJhZCkpLFxuICAgICAgICBjID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5jb3MocmFkKSk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIGFfMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgdmFyIGFfMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgcykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBzKSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzIGlmIFNJTUQgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuIG1hdDQucm90YXRlWiA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnJvdGF0ZVogOiBtYXQ0LnNjYWxhci5yb3RhdGVaO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gdlsxXTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSB2WzJdO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdDtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICAgIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gICAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVhSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gMTtcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gLXM7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21ZUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IC1zO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gcztcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWlJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSBzO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IC1zO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xubWF0NC5nZXRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIG1hdCkge1xuICBvdXRbMF0gPSBtYXRbMTJdO1xuICBvdXRbMV0gPSBtYXRbMTNdO1xuICBvdXRbMl0gPSBtYXRbMTRdO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xubWF0NC5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIG1hdCkge1xuICAvLyBBbGdvcml0aG0gdGFrZW4gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuICB2YXIgdHJhY2UgPSBtYXRbMF0gKyBtYXRbNV0gKyBtYXRbMTBdO1xuICB2YXIgUyA9IDA7XG5cbiAgaWYgKHRyYWNlID4gMCkgeyBcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUzsgXG4gICAgb3V0WzJdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTOyBcbiAgfSBlbHNlIGlmICgobWF0WzBdID4gbWF0WzVdKSYobWF0WzBdID4gbWF0WzEwXSkpIHsgXG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMF0gLSBtYXRbNV0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUzsgXG4gICAgb3V0WzJdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTOyBcbiAgfSBlbHNlIGlmIChtYXRbNV0gPiBtYXRbMTBdKSB7IFxuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzVdIC0gbWF0WzBdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7IFxuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUzsgXG4gIH0gZWxzZSB7IFxuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzEwXSAtIG1hdFswXSAtIG1hdFs1XSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcykge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyLFxuICAgICAgICBzeCA9IHNbMF0sXG4gICAgICAgIHN5ID0gc1sxXSxcbiAgICAgICAgc3ogPSBzWzJdO1xuXG4gICAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gICAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gICAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICAgIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICAgIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG5lZ2F0aXZlT3JpZ2luKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBvIFRoZSBvcmlnaW4gdmVjdG9yIGFyb3VuZCB3aGljaCB0byBzY2FsZSBhbmQgcm90YXRlXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgIHgyID0geCArIHgsXG4gICAgICB5MiA9IHkgKyB5LFxuICAgICAgejIgPSB6ICsgeixcblxuICAgICAgeHggPSB4ICogeDIsXG4gICAgICB4eSA9IHggKiB5MixcbiAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgeXkgPSB5ICogeTIsXG4gICAgICB5eiA9IHkgKiB6MixcbiAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgd3ggPSB3ICogeDIsXG4gICAgICB3eSA9IHcgKiB5MixcbiAgICAgIHd6ID0gdyAqIHoyLFxuXG4gICAgICBzeCA9IHNbMF0sXG4gICAgICBzeSA9IHNbMV0sXG4gICAgICBzeiA9IHNbMl0sXG5cbiAgICAgIG94ID0gb1swXSxcbiAgICAgIG95ID0gb1sxXSxcbiAgICAgIG96ID0gb1syXTtcblxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0WzBdICogb3ggKyBvdXRbNF0gKiBveSArIG91dFs4XSAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXRbMV0gKiBveCArIG91dFs1XSAqIG95ICsgb3V0WzldICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dFsyXSAqIG94ICsgb3V0WzZdICogb3kgKyBvdXRbMTBdICogb3opO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZydXN0dW0gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gICAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyA9IGZ1bmN0aW9uIChvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pLFxuICAgICAgICB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcblxuICAgIG91dFswXSA9IHhTY2FsZTtcbiAgICBvdXRbMV0gPSAwLjA7XG4gICAgb3V0WzJdID0gMC4wO1xuICAgIG91dFszXSA9IDAuMDtcbiAgICBvdXRbNF0gPSAwLjA7XG4gICAgb3V0WzVdID0geVNjYWxlO1xuICAgIG91dFs2XSA9IDAuMDtcbiAgICBvdXRbN10gPSAwLjA7XG4gICAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMV0gPSAtMS4wO1xuICAgIG91dFsxMl0gPSAwLjA7XG4gICAgb3V0WzEzXSA9IDAuMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxNV0gPSAwLjA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm9ydGhvID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubG9va0F0ID0gZnVuY3Rpb24gKG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICAgIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gICAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQuc3ViID0gbWF0NC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseVNjYWxhciA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIG91dFs0XSA9IGFbNF0gKiBiO1xuICAgIG91dFs1XSA9IGFbNV0gKiBiO1xuICAgIG91dFs2XSA9IGFbNl0gKiBiO1xuICAgIG91dFs3XSA9IGFbN10gKiBiO1xuICAgIG91dFs4XSA9IGFbOF0gKiBiO1xuICAgIG91dFs5XSA9IGFbOV0gKiBiO1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gICAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICAgIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gICAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gICAgb3V0WzZdID0gYVs2XSArIChiWzZdICogc2NhbGUpO1xuICAgIG91dFs3XSA9IGFbN10gKyAoYls3XSAqIHNjYWxlKTtcbiAgICBvdXRbOF0gPSBhWzhdICsgKGJbOF0gKiBzY2FsZSk7XG4gICAgb3V0WzldID0gYVs5XSArIChiWzldICogc2NhbGUpO1xuICAgIG91dFsxMF0gPSBhWzEwXSArIChiWzEwXSAqIHNjYWxlKTtcbiAgICBvdXRbMTFdID0gYVsxMV0gKyAoYlsxMV0gKiBzY2FsZSk7XG4gICAgb3V0WzEyXSA9IGFbMTJdICsgKGJbMTJdICogc2NhbGUpO1xuICAgIG91dFsxM10gPSBhWzEzXSArIChiWzEzXSAqIHNjYWxlKTtcbiAgICBvdXRbMTRdID0gYVsxNF0gKyAoYlsxNF0gKiBzY2FsZSk7XG4gICAgb3V0WzE1XSA9IGFbMTVdICsgKGJbMTVdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0NC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgXG4gICAgICAgICAgIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgXG4gICAgICAgICAgIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmXG4gICAgICAgICAgIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQ0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwICA9IGFbMF0sICBhMSAgPSBhWzFdLCAgYTIgID0gYVsyXSwgIGEzICA9IGFbM10sXG4gICAgICAgIGE0ICA9IGFbNF0sICBhNSAgPSBhWzVdLCAgYTYgID0gYVs2XSwgIGE3ICA9IGFbN10sIFxuICAgICAgICBhOCAgPSBhWzhdLCAgYTkgID0gYVs5XSwgIGExMCA9IGFbMTBdLCBhMTEgPSBhWzExXSwgXG4gICAgICAgIGExMiA9IGFbMTJdLCBhMTMgPSBhWzEzXSwgYTE0ID0gYVsxNF0sIGExNSA9IGFbMTVdO1xuXG4gICAgdmFyIGIwICA9IGJbMF0sICBiMSAgPSBiWzFdLCAgYjIgID0gYlsyXSwgIGIzICA9IGJbM10sXG4gICAgICAgIGI0ICA9IGJbNF0sICBiNSAgPSBiWzVdLCAgYjYgID0gYls2XSwgIGI3ICA9IGJbN10sIFxuICAgICAgICBiOCAgPSBiWzhdLCAgYjkgID0gYls5XSwgIGIxMCA9IGJbMTBdLCBiMTEgPSBiWzExXSwgXG4gICAgICAgIGIxMiA9IGJbMTJdLCBiMTMgPSBiWzEzXSwgYjE0ID0gYlsxNF0sIGIxNSA9IGJbMTVdO1xuXG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpKTtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\nvar mat3 = __webpack_require__(20);\nvar vec3 = __webpack_require__(21);\nvar vec4 = __webpack_require__(22);\n\n/**\n * @class Quaternion\n * @name quat\n */\nvar quat = {};\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nquat.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nquat.rotationTo = (function() {\n    var tmpvec3 = vec3.create();\n    var xUnitVec3 = vec3.fromValues(1,0,0);\n    var yUnitVec3 = vec3.fromValues(0,1,0);\n\n    return function(out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n            return out;\n        } else if (dot > 0.999999) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            return out;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out[0] = tmpvec3[0];\n            out[1] = tmpvec3[1];\n            out[2] = tmpvec3[2];\n            out[3] = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };\n})();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local \"right\" direction\n * @param {vec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nquat.setAxes = (function() {\n    var matr = mat3.create();\n\n    return function(out, view, right, up) {\n        matr[0] = right[0];\n        matr[3] = right[1];\n        matr[6] = right[2];\n\n        matr[1] = up[0];\n        matr[4] = up[1];\n        matr[7] = up[2];\n\n        matr[2] = -view[0];\n        matr[5] = -view[1];\n        matr[8] = -view[2];\n\n        return quat.normalize(out, quat.fromMat3(out, matr));\n    };\n})();\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nquat.clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nquat.fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nquat.copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nquat.set = vec4.set;\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nquat.identity = function(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nquat.setAxisAngle = function(out, axis, rad) {\n    rad = rad * 0.5;\n    var s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n};\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {quat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nquat.getAxisAngle = function(out_axis, q) {\n    var rad = Math.acos(q[3]) * 2.0;\n    var s = Math.sin(rad / 2.0);\n    if (s != 0.0) {\n        out_axis[0] = q[0] / s;\n        out_axis[1] = q[1] / s;\n        out_axis[2] = q[2] / s;\n    } else {\n        // If s is zero, return any axis (no rotation - axis does not matter)\n        out_axis[0] = 1;\n        out_axis[1] = 0;\n        out_axis[2] = 0;\n    }\n    return rad;\n};\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nquat.add = vec4.add;\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nquat.multiply = function(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n};\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nquat.mul = quat.multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nquat.scale = vec4.scale;\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateX = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateY = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        by = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateZ = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bz = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n};\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nquat.calculateW = function (out, a) {\n    var x = a[0], y = a[1], z = a[2];\n\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n    return out;\n};\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nquat.dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nquat.lerp = vec4.lerp;\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nquat.slerp = function (out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    var        omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if ( cosom < 0.0 ) {\n        cosom = -cosom;\n        bx = - bx;\n        by = - by;\n        bz = - bz;\n        bw = - bw;\n    }\n    // calculate coefficients\n    if ( (1.0 - cosom) > 0.000001 ) {\n        // standard case (slerp)\n        omega  = Math.acos(cosom);\n        sinom  = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {        \n        // \"from\" and \"to\" quaternions are very close \n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    \n    return out;\n};\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {Number} t interpolation amount\n * @returns {quat} out\n */\nquat.sqlerp = (function () {\n  var temp1 = quat.create();\n  var temp2 = quat.create();\n  \n  return function (out, a, b, c, d, t) {\n    quat.slerp(temp1, a, d, t);\n    quat.slerp(temp2, b, c, t);\n    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));\n    \n    return out;\n  };\n}());\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nquat.invert = function(out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,\n        invDot = dot ? 1.0/dot : 0;\n    \n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0*invDot;\n    out[1] = -a1*invDot;\n    out[2] = -a2*invDot;\n    out[3] = a3*invDot;\n    return out;\n};\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nquat.conjugate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n * @function\n */\nquat.length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nquat.len = quat.length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nquat.squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nquat.sqrLen = quat.squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nquat.normalize = vec4.normalize;\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nquat.fromMat3 = function(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    var fTrace = m[0] + m[4] + m[8];\n    var fRoot;\n\n    if ( fTrace > 0.0 ) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0);  // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5/fRoot;  // 1/(4w)\n        out[0] = (m[5]-m[7])*fRoot;\n        out[1] = (m[6]-m[2])*fRoot;\n        out[2] = (m[1]-m[3])*fRoot;\n    } else {\n        // |w| <= 1/2\n        var i = 0;\n        if ( m[4] > m[0] )\n          i = 1;\n        if ( m[8] > m[i*3+i] )\n          i = 2;\n        var j = (i+1)%3;\n        var k = (i+2)%3;\n        \n        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;\n        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;\n        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;\n    }\n    \n    return out;\n};\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nquat.str = function (a) {\n    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat} a The first quaternion.\n * @param {quat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nquat.exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {quat} a The first vector.\n * @param {quat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nquat.equals = vec4.equals;\n\nmodule.exports = quat;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzP2QxMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQSxlOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0EsZTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLGU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcbnZhciBtYXQzID0gcmVxdWlyZShcIi4vbWF0My5qc1wiKTtcbnZhciB2ZWMzID0gcmVxdWlyZShcIi4vdmVjMy5qc1wiKTtcbnZhciB2ZWM0ID0gcmVxdWlyZShcIi4vdmVjNC5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxuICogQHBhcmFtICB7cXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXG4gKi9cbnF1YXQuZ2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0X2F4aXMsIHEpIHtcbiAgICB2YXIgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcbiAgICBpZiAocyAhPSAwLjApIHtcbiAgICAgICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICAgICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgICAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgICAgIG91dF9heGlzWzJdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJhZDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gcXVhdC5jcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gcXVhdC5jcmVhdGUoKTtcbiAgXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgcXVhdC5zbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgcXVhdC5zbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgcXVhdC5zbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bMV0tbVszXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXhhY3RFcXVhbHMgPSB2ZWM0LmV4YWN0RXF1YWxzO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5xdWF0LmVxdWFscyA9IHZlYzQuZXF1YWxzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(3);\n\n/**\n * @class 2 Dimensional Vector\n * @name vec2\n */\nvar vec2 = {};\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nvec2.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nvec2.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nvec2.fromValues = function(x, y) {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nvec2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nvec2.set = function(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nvec2.div = vec2.divide;\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\nvec2.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\nvec2.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\nvec2.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    return out;\n};\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nvec2.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nvec2.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nvec2.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec2.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nvec2.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nvec2.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n};\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nvec2.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x*x + y*y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nvec2.cross = function(out, a, b) {\n    var z = a[0] * b[1] - a[1] * b[0];\n    out[0] = out[1] = 0;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nvec2.random = function (out, scale) {\n    scale = scale || 1.0;\n    var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n    out[0] = Math.cos(r) * scale;\n    out[1] = Math.sin(r) * scale;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2d = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat3 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat4 = function(out, a, m) {\n    var x = a[0], \n        y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec2.forEach = (function() {\n    var vec = vec2.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 2;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec2.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec2.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1];\n    var b0 = b[0], b1 = b[1];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));\n};\n\nmodule.exports = vec2;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzPzZkZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNB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QUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNlaWwgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZmxvb3IgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJvdW5kID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 39 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"name\": \"@mapd/mapd-draw\",\n\t\"description\": \"A Utility Library for drawing and interacting with shapes using canvas\",\n\t\"version\": \"1.1.0\",\n\t\"homepage\": \"http://mapd.com\",\n\t\"bugs\": \"https://github.com/map-d/mapd-draw.js/issues\",\n\t\"main\": \"dist/mapd-draw.js\",\n\t\"author\": \"MapD Technologies\",\n\t\"license\": \"MIT\",\n\t\"engines\": {\n\t\t\"node\": \">=4.0.0\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/map-d/mapd-draw.js.git\"\n\t},\n\t\"dependencies\": {\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"css-element-queries\": \"^0.4.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"babel-core\": \"^6.10.4\",\n\t\t\"babel-loader\": \"^6.2.4\",\n\t\t\"babel-plugin-lodash\": \"^3.1.2\",\n\t\t\"babel-preset-es2015\": \"^6.9.0\",\n\t\t\"babel-preset-stage-0\": \"^6.5.0\",\n\t\t\"eslint\": \"^3.0.1\",\n\t\t\"http-server\": \"^0.9.0\",\n\t\t\"json-loader\": \"0.5.4\",\n\t\t\"webpack\": \"^1.13.1\"\n\t},\n\t\"scripts\": {\n\t\t\"build\": \"npm run build:prod; npm run build:dev\",\n\t\t\"build:prod\": \"npm run webpack\",\n\t\t\"build:dev\": \"npm run webpack:dev\",\n\t\t\"clean\": \"bash scripts/clean.sh\",\n\t\t\"eslint\": \"eslint -c ./.eslintrc.json\",\n\t\t\"lint-fix\": \"eslint --fix $(find src -name \\\"*.js\\\" ! -name '*.spec.js')\",\n\t\t\"lint\": \"eslint $(find src -name \\\"*.js\\\" ! -name '*.spec.js')\",\n\t\t\"start\": \"npm run build; http-server -p 8080 -o;\",\n\t\t\"watch:dev\": \"node node_modules/webpack/bin/webpack.js --progress --colors --watch --config webpack.dev.config.js\",\n\t\t\"webpack\": \"node node_modules/webpack/bin/webpack.js\",\n\t\t\"webpack:dev\": \"node node_modules/webpack/bin/webpack.js --config webpack.dev.config.js\",\n\t\t\"test\": \"node_modules/.bin/mocha ./test --require ./test/config --require ./test/setup\"\n\t},\n\t\"pre-commit\": [\n\t\t\"lint\"\n\t]\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vcGFja2FnZS5qc29uPzBmYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwiQG1hcGQvbWFwZC1kcmF3XCIsXG5cdFwiZGVzY3JpcHRpb25cIjogXCJBIFV0aWxpdHkgTGlicmFyeSBmb3IgZHJhd2luZyBhbmQgaW50ZXJhY3Rpbmcgd2l0aCBzaGFwZXMgdXNpbmcgY2FudmFzXCIsXG5cdFwidmVyc2lvblwiOiBcIjEuMS4wXCIsXG5cdFwiaG9tZXBhZ2VcIjogXCJodHRwOi8vbWFwZC5jb21cIixcblx0XCJidWdzXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL21hcC1kL21hcGQtZHJhdy5qcy9pc3N1ZXNcIixcblx0XCJtYWluXCI6IFwiZGlzdC9tYXBkLWRyYXcuanNcIixcblx0XCJhdXRob3JcIjogXCJNYXBEIFRlY2hub2xvZ2llc1wiLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJlbmdpbmVzXCI6IHtcblx0XHRcIm5vZGVcIjogXCI+PTQuMC4wXCJcblx0fSxcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vbWFwLWQvbWFwZC1kcmF3LmpzLmdpdFwiXG5cdH0sXG5cdFwiZGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImdsLW1hdHJpeFwiOiBcIl4yLjMuMlwiLFxuXHRcdFwiY3NzLWVsZW1lbnQtcXVlcmllc1wiOiBcIl4wLjQuMFwiXG5cdH0sXG5cdFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcblx0XHRcImJhYmVsLWNvcmVcIjogXCJeNi4xMC40XCIsXG5cdFx0XCJiYWJlbC1sb2FkZXJcIjogXCJeNi4yLjRcIixcblx0XHRcImJhYmVsLXBsdWdpbi1sb2Rhc2hcIjogXCJeMy4xLjJcIixcblx0XHRcImJhYmVsLXByZXNldC1lczIwMTVcIjogXCJeNi45LjBcIixcblx0XHRcImJhYmVsLXByZXNldC1zdGFnZS0wXCI6IFwiXjYuNS4wXCIsXG5cdFx0XCJlc2xpbnRcIjogXCJeMy4wLjFcIixcblx0XHRcImh0dHAtc2VydmVyXCI6IFwiXjAuOS4wXCIsXG5cdFx0XCJqc29uLWxvYWRlclwiOiBcIjAuNS40XCIsXG5cdFx0XCJ3ZWJwYWNrXCI6IFwiXjEuMTMuMVwiXG5cdH0sXG5cdFwic2NyaXB0c1wiOiB7XG5cdFx0XCJidWlsZFwiOiBcIm5wbSBydW4gYnVpbGQ6cHJvZDsgbnBtIHJ1biBidWlsZDpkZXZcIixcblx0XHRcImJ1aWxkOnByb2RcIjogXCJucG0gcnVuIHdlYnBhY2tcIixcblx0XHRcImJ1aWxkOmRldlwiOiBcIm5wbSBydW4gd2VicGFjazpkZXZcIixcblx0XHRcImNsZWFuXCI6IFwiYmFzaCBzY3JpcHRzL2NsZWFuLnNoXCIsXG5cdFx0XCJlc2xpbnRcIjogXCJlc2xpbnQgLWMgLi8uZXNsaW50cmMuanNvblwiLFxuXHRcdFwibGludC1maXhcIjogXCJlc2xpbnQgLS1maXggJChmaW5kIHNyYyAtbmFtZSBcXFwiKi5qc1xcXCIgISAtbmFtZSAnKi5zcGVjLmpzJylcIixcblx0XHRcImxpbnRcIjogXCJlc2xpbnQgJChmaW5kIHNyYyAtbmFtZSBcXFwiKi5qc1xcXCIgISAtbmFtZSAnKi5zcGVjLmpzJylcIixcblx0XHRcInN0YXJ0XCI6IFwibnBtIHJ1biBidWlsZDsgaHR0cC1zZXJ2ZXIgLXAgODA4MCAtbztcIixcblx0XHRcIndhdGNoOmRldlwiOiBcIm5vZGUgbm9kZV9tb2R1bGVzL3dlYnBhY2svYmluL3dlYnBhY2suanMgLS1wcm9ncmVzcyAtLWNvbG9ycyAtLXdhdGNoIC0tY29uZmlnIHdlYnBhY2suZGV2LmNvbmZpZy5qc1wiLFxuXHRcdFwid2VicGFja1wiOiBcIm5vZGUgbm9kZV9tb2R1bGVzL3dlYnBhY2svYmluL3dlYnBhY2suanNcIixcblx0XHRcIndlYnBhY2s6ZGV2XCI6IFwibm9kZSBub2RlX21vZHVsZXMvd2VicGFjay9iaW4vd2VicGFjay5qcyAtLWNvbmZpZyB3ZWJwYWNrLmRldi5jb25maWcuanNcIixcblx0XHRcInRlc3RcIjogXCJub2RlX21vZHVsZXMvLmJpbi9tb2NoYSAuL3Rlc3QgLS1yZXF1aXJlIC4vdGVzdC9jb25maWcgLS1yZXF1aXJlIC4vdGVzdC9zZXR1cFwiXG5cdH0sXG5cdFwicHJlLWNvbW1pdFwiOiBbXG5cdFx0XCJsaW50XCJcblx0XVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ])
});
;