(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MapdDraw"] = factory();
	else
		root["MapdDraw"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* eslint-disable object-curly-spacing*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleHull_2D = exports.Math = exports.Point = exports.PolyLine = exports.Poly = exports.Rect = exports.Circle = exports.Vec2d = exports.BasicStyle = exports.Mat2 = exports.Point2d = exports.Mat2d = exports.AABox2d = exports.DrawEngine = exports.ShapeBuilder = exports.version = undefined;\n\nvar _package = __webpack_require__(30);\n\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function get() {\n    return _package.version;\n  }\n});\n\nvar _glMatrix = __webpack_require__(1);\n\nObject.defineProperty(exports, \"Mat2\", {\n  enumerable: true,\n  get: function get() {\n    return _glMatrix.mat2;\n  }\n});\n\nvar _convexHull = __webpack_require__(14);\n\nObject.defineProperty(exports, \"simpleHull_2D\", {\n  enumerable: true,\n  get: function get() {\n    return _convexHull.simpleHull_2D;\n  }\n});\n\nvar _shapeBuilder = __webpack_require__(19);\n\nvar _shapeBuilder2 = _interopRequireDefault(_shapeBuilder);\n\nvar _drawEngine = __webpack_require__(13);\n\nvar _drawEngine2 = _interopRequireDefault(_drawEngine);\n\nvar _aabox2d = __webpack_require__(2);\n\nvar _AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _mat2d = __webpack_require__(4);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar _Point2d = _interopRequireWildcard(_point2d);\n\nvar _basicStyle = __webpack_require__(8);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _vec2d = __webpack_require__(9);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nvar _circle = __webpack_require__(23);\n\nvar _circle2 = _interopRequireDefault(_circle);\n\nvar _rect = __webpack_require__(15);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _poly = __webpack_require__(25);\n\nvar _poly2 = _interopRequireDefault(_poly);\n\nvar _polyLine = __webpack_require__(10);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nvar _point = __webpack_require__(24);\n\nvar _point2 = _interopRequireDefault(_point);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.ShapeBuilder = _shapeBuilder2.default;\nexports.DrawEngine = _drawEngine2.default;\nexports.AABox2d = _AABox2d;\nexports.Mat2d = _mat2d2.default;\nexports.Point2d = _Point2d;\nexports.BasicStyle = _basicStyle2.default;\nexports.Vec2d = _vec2d2.default;\nexports.Circle = _circle2.default;\nexports.Rect = _rect2.default;\nexports.Poly = _poly2.default;\nexports.PolyLine = _polyLine2.default;\nexports.Point = _point2.default;\nexports.Math = _math2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXBkLWRyYXcuanM/NGY3OSJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwibWF0MiIsInNpbXBsZUh1bGxfMkQiLCJTaGFwZUJ1aWxkZXIiLCJEcmF3RW5naW5lIiwiQUFCb3gyZCIsIk1hdDJkIiwiUG9pbnQyZCIsIkJhc2ljU3R5bGUiLCJWZWMyZCIsIkNpcmNsZSIsIlJlY3QiLCJQb2x5IiwiUG9seUxpbmUiLCJQb2ludCIsIk1hdGgiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7OztvQkFFUUEsTzs7Ozs7Ozs7O3FCQU9BQyxJOzs7Ozs7Ozs7dUJBU0FDLGE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQWREQyxZO1FBQ0FDLFU7UUFDS0MsTztRQUNMQyxLO1FBQ0tDLE87UUFFTEMsVTtRQUNBQyxLO1FBQ0FDLE07UUFDQUMsSTtRQUNBQyxJO1FBQ0FDLFE7UUFDQUMsSztRQUNBQyxJIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBvYmplY3QtY3VybHktc3BhY2luZyovXG5cInVzZSBzdHJpY3RcIlxuXG5leHBvcnQge3ZlcnNpb259IGZyb20gXCIuLi9wYWNrYWdlLmpzb25cIlxuXG5leHBvcnQgU2hhcGVCdWlsZGVyIGZyb20gXCIuL2VuZ2luZS9zaGFwZS1idWlsZGVyXCJcbmV4cG9ydCBEcmF3RW5naW5lIGZyb20gXCIuL2VuZ2luZS9kcmF3LWVuZ2luZVwiXG5leHBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuL2NvcmUvYWFib3gyZFwiXG5leHBvcnQgTWF0MmQgZnJvbSBcIi4vY29yZS9tYXQyZFwiXG5leHBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuL2NvcmUvcG9pbnQyZFwiXG5leHBvcnQge21hdDIgYXMgTWF0Mn0gZnJvbSBcImdsLW1hdHJpeFwiXG5leHBvcnQgQmFzaWNTdHlsZSBmcm9tIFwiLi9zdHlsZS9iYXNpYy1zdHlsZVwiXG5leHBvcnQgVmVjMmQgZnJvbSBcIi4vY29yZS92ZWMyZFwiXG5leHBvcnQgQ2lyY2xlIGZyb20gXCIuL3NoYXBlcy9jaXJjbGVcIlxuZXhwb3J0IFJlY3QgZnJvbSBcIi4vc2hhcGVzL3JlY3RcIlxuZXhwb3J0IFBvbHkgZnJvbSBcIi4vc2hhcGVzL3BvbHlcIlxuZXhwb3J0IFBvbHlMaW5lIGZyb20gXCIuL3NoYXBlcy9wb2x5LWxpbmVcIlxuZXhwb3J0IFBvaW50IGZyb20gXCIuL3NoYXBlcy9wb2ludFwiXG5leHBvcnQgTWF0aCBmcm9tIFwiLi9tYXRoL21hdGhcIlxuZXhwb3J0IHtzaW1wbGVIdWxsXzJEfSBmcm9tIFwiLi9tYXRoL2NvbnZleC1odWxsXCJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21hcGQtZHJhdy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/*!\n@fileoverview gl-matrix - High performance matrix and vector operations\n@author Brandon Jones\n@author Colin MacKenzie IV\n@version 2.7.0\n\nCopyright (c) 2015-2018, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n!function(t,n){if(true)module.exports=n();else if(\"function\"==typeof define&&define.amd)define([],n);else{var r=n();for(var a in r)(\"object\"==typeof exports?exports:t)[a]=r[a]}}(\"undefined\"!=typeof self?self:this,function(){return function(t){var n={};function r(a){if(n[a])return n[a].exports;var e=n[a]={i:a,l:!1,exports:{}};return t[a].call(e.exports,e,e.exports,r),e.l=!0,e.exports}return r.m=t,r.c=n,r.d=function(t,n,a){r.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},r.r=function(t){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})},r.t=function(t,n){if(1&n&&(t=r(t)),8&n)return t;if(4&n&&\"object\"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(r.r(a),Object.defineProperty(a,\"default\",{enumerable:!0,value:t}),2&n&&\"string\"!=typeof t)for(var e in t)r.d(a,e,function(n){return t[n]}.bind(null,e));return a},r.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(n,\"a\",n),n},r.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},r.p=\"\",r(r.s=10)}([function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.setMatrixArrayType=function(t){n.ARRAY_TYPE=t},n.toRadian=function(t){return t*e},n.equals=function(t,n){return Math.abs(t-n)<=a*Math.max(1,Math.abs(t),Math.abs(n))};var a=n.EPSILON=1e-6;n.ARRAY_TYPE=\"undefined\"!=typeof Float32Array?Float32Array:Array,n.RANDOM=Math.random;var e=Math.PI/180},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},n.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},n.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},n.subtract=u,n.multiply=o,n.divide=i,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t[3]=Math.ceil(n[3]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t[3]=Math.floor(n[3]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t[3]=Math.min(n[3],r[3]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t[3]=Math.max(n[3],r[3]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t[3]=Math.round(n[3]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t},n.distance=s,n.squaredDistance=c,n.length=f,n.squaredLength=M,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=-n[3],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t[3]=1/n[3],t},n.normalize=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u;o>0&&(o=1/Math.sqrt(o),t[0]=r*o,t[1]=a*o,t[2]=e*o,t[3]=u*o);return t},n.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]+t[3]*n[3]},n.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t[3]=i+a*(r[3]-i),t},n.random=function(t,n){var r,e,u,o,i,s;n=n||1;do{r=2*a.RANDOM()-1,e=2*a.RANDOM()-1,i=r*r+e*e}while(i>=1);do{u=2*a.RANDOM()-1,o=2*a.RANDOM()-1,s=u*u+o*o}while(s>=1);var c=Math.sqrt((1-i)/s);return t[0]=n*r,t[1]=n*e,t[2]=n*u*c,t[3]=n*o*c,t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3];return t[0]=r[0]*a+r[4]*e+r[8]*u+r[12]*o,t[1]=r[1]*a+r[5]*e+r[9]*u+r[13]*o,t[2]=r[2]*a+r[6]*e+r[10]*u+r[14]*o,t[3]=r[3]*a+r[7]*e+r[11]*u+r[15]*o,t},n.transformQuat=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],s=r[2],c=r[3],f=c*a+i*u-s*e,M=c*e+s*a-o*u,h=c*u+o*e-i*a,l=-o*a-i*e-s*u;return t[0]=f*c+l*-o+M*-s-h*-i,t[1]=M*c+l*-i+h*-o-f*-s,t[2]=h*c+l*-s+f*-i-M*-o,t[3]=n[3],t},n.str=function(t){return\"vec4(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\")\"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=n[0],s=n[1],c=n[2],f=n[3];return Math.abs(r-i)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(e-s)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(u-c)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(o-f)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(4);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t}function o(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t[3]=n[3]*r[3],t}function i(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t[3]=n[3]/r[3],t}function s(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return Math.sqrt(r*r+a*a+e*e+u*u)}function c(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2],u=n[3]-t[3];return r*r+a*a+e*e+u*u}function f(t){var n=t[0],r=t[1],a=t[2],e=t[3];return Math.sqrt(n*n+r*r+a*a+e*e)}function M(t){var n=t[0],r=t[1],a=t[2],e=t[3];return n*n+r*r+a*a+e*e}n.sub=u,n.mul=o,n.div=i,n.dist=s,n.sqrDist=c,n.len=f,n.sqrLen=M,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=4),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],t[3]=n[i+3],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2],n[i+3]=t[3];return n}}()},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.forEach=n.sqrLen=n.len=n.sqrDist=n.dist=n.div=n.mul=n.sub=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(3);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n},n.length=u,n.fromValues=o,n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t},n.set=function(t,n,r,a){return t[0]=n,t[1]=r,t[2]=a,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t},n.subtract=i,n.multiply=s,n.divide=c,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t[2]=Math.ceil(n[2]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t[2]=Math.floor(n[2]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t[2]=Math.min(n[2],r[2]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t[2]=Math.max(n[2],r[2]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t[2]=Math.round(n[2]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t},n.distance=f,n.squaredDistance=M,n.squaredLength=h,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t[2]=1/n[2],t},n.normalize=l,n.dot=v,n.cross=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[0],i=r[1],s=r[2];return t[0]=e*s-u*i,t[1]=u*o-a*s,t[2]=a*i-e*o,t},n.lerp=function(t,n,r,a){var e=n[0],u=n[1],o=n[2];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t[2]=o+a*(r[2]-o),t},n.hermite=function(t,n,r,a,e,u){var o=u*u,i=o*(2*u-3)+1,s=o*(u-2)+u,c=o*(u-1),f=o*(3-2*u);return t[0]=n[0]*i+r[0]*s+a[0]*c+e[0]*f,t[1]=n[1]*i+r[1]*s+a[1]*c+e[1]*f,t[2]=n[2]*i+r[2]*s+a[2]*c+e[2]*f,t},n.bezier=function(t,n,r,a,e,u){var o=1-u,i=o*o,s=u*u,c=i*o,f=3*u*i,M=3*s*o,h=s*u;return t[0]=n[0]*c+r[0]*f+a[0]*M+e[0]*h,t[1]=n[1]*c+r[1]*f+a[1]*M+e[1]*h,t[2]=n[2]*c+r[2]*f+a[2]*M+e[2]*h,t},n.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI,e=2*a.RANDOM()-1,u=Math.sqrt(1-e*e)*n;return t[0]=Math.cos(r)*u,t[1]=Math.sin(r)*u,t[2]=e*n,t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=r[3]*a+r[7]*e+r[11]*u+r[15];return o=o||1,t[0]=(r[0]*a+r[4]*e+r[8]*u+r[12])/o,t[1]=(r[1]*a+r[5]*e+r[9]*u+r[13])/o,t[2]=(r[2]*a+r[6]*e+r[10]*u+r[14])/o,t},n.transformMat3=function(t,n,r){var a=n[0],e=n[1],u=n[2];return t[0]=a*r[0]+e*r[3]+u*r[6],t[1]=a*r[1]+e*r[4]+u*r[7],t[2]=a*r[2]+e*r[5]+u*r[8],t},n.transformQuat=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=r[3],i=n[0],s=n[1],c=n[2],f=e*c-u*s,M=u*i-a*c,h=a*s-e*i,l=e*h-u*M,v=u*f-a*h,d=a*M-e*f,b=2*o;return f*=b,M*=b,h*=b,l*=2,v*=2,d*=2,t[0]=i+f+l,t[1]=s+M+v,t[2]=c+h+d,t},n.rotateX=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0],u[1]=e[1]*Math.cos(a)-e[2]*Math.sin(a),u[2]=e[1]*Math.sin(a)+e[2]*Math.cos(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.rotateY=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[2]*Math.sin(a)+e[0]*Math.cos(a),u[1]=e[1],u[2]=e[2]*Math.cos(a)-e[0]*Math.sin(a),t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.rotateZ=function(t,n,r,a){var e=[],u=[];return e[0]=n[0]-r[0],e[1]=n[1]-r[1],e[2]=n[2]-r[2],u[0]=e[0]*Math.cos(a)-e[1]*Math.sin(a),u[1]=e[0]*Math.sin(a)+e[1]*Math.cos(a),u[2]=e[2],t[0]=u[0]+r[0],t[1]=u[1]+r[1],t[2]=u[2]+r[2],t},n.angle=function(t,n){var r=o(t[0],t[1],t[2]),a=o(n[0],n[1],n[2]);l(r,r),l(a,a);var e=v(r,a);return e>1?0:e<-1?Math.PI:Math.acos(e)},n.str=function(t){return\"vec3(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\")\"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=n[0],i=n[1],s=n[2];return Math.abs(r-o)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(e-i)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(i))&&Math.abs(u-s)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(s))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(3);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function u(t){var n=t[0],r=t[1],a=t[2];return Math.sqrt(n*n+r*r+a*a)}function o(t,n,r){var e=new a.ARRAY_TYPE(3);return e[0]=t,e[1]=n,e[2]=r,e}function i(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t}function s(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t[2]=n[2]*r[2],t}function c(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t[2]=n[2]/r[2],t}function f(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return Math.sqrt(r*r+a*a+e*e)}function M(t,n){var r=n[0]-t[0],a=n[1]-t[1],e=n[2]-t[2];return r*r+a*a+e*e}function h(t){var n=t[0],r=t[1],a=t[2];return n*n+r*r+a*a}function l(t,n){var r=n[0],a=n[1],e=n[2],u=r*r+a*a+e*e;return u>0&&(u=1/Math.sqrt(u),t[0]=n[0]*u,t[1]=n[1]*u,t[2]=n[2]*u),t}function v(t,n){return t[0]*n[0]+t[1]*n[1]+t[2]*n[2]}n.sub=i,n.mul=s,n.div=c,n.dist=f,n.sqrDist=M,n.len=u,n.sqrLen=h,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=3),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],t[2]=n[i+2],u(t,t,o),n[i]=t[0],n[i+1]=t[1],n[i+2]=t[2];return n}}()},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.setAxes=n.sqlerp=n.rotationTo=n.equals=n.exactEquals=n.normalize=n.sqrLen=n.squaredLength=n.len=n.length=n.lerp=n.dot=n.scale=n.mul=n.add=n.set=n.copy=n.fromValues=n.clone=void 0,n.create=s,n.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t},n.setAxisAngle=c,n.getAxisAngle=function(t,n){var r=2*Math.acos(n[3]),e=Math.sin(r/2);e>a.EPSILON?(t[0]=n[0]/e,t[1]=n[1]/e,t[2]=n[2]/e):(t[0]=1,t[1]=0,t[2]=0);return r},n.multiply=f,n.rotateX=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+o*i,t[1]=e*s+u*i,t[2]=u*s-e*i,t[3]=o*s-a*i,t},n.rotateY=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s-u*i,t[1]=e*s+o*i,t[2]=u*s+a*i,t[3]=o*s-e*i,t},n.rotateZ=function(t,n,r){r*=.5;var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+e*i,t[1]=e*s-a*i,t[2]=u*s+o*i,t[3]=o*s-u*i,t},n.calculateW=function(t,n){var r=n[0],a=n[1],e=n[2];return t[0]=r,t[1]=a,t[2]=e,t[3]=Math.sqrt(Math.abs(1-r*r-a*a-e*e)),t},n.slerp=M,n.random=function(t){var n=a.RANDOM(),r=a.RANDOM(),e=a.RANDOM(),u=Math.sqrt(1-n),o=Math.sqrt(n);return t[0]=u*Math.sin(2*Math.PI*r),t[1]=u*Math.cos(2*Math.PI*r),t[2]=o*Math.sin(2*Math.PI*e),t[3]=o*Math.cos(2*Math.PI*e),t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*r+a*a+e*e+u*u,i=o?1/o:0;return t[0]=-r*i,t[1]=-a*i,t[2]=-e*i,t[3]=u*i,t},n.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t},n.fromMat3=h,n.fromEuler=function(t,n,r,a){var e=.5*Math.PI/180;n*=e,r*=e,a*=e;var u=Math.sin(n),o=Math.cos(n),i=Math.sin(r),s=Math.cos(r),c=Math.sin(a),f=Math.cos(a);return t[0]=u*s*f-o*i*c,t[1]=o*i*f+u*s*c,t[2]=o*s*c-u*i*f,t[3]=o*s*f+u*i*c,t},n.str=function(t){return\"quat(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\")\"};var a=i(r(0)),e=i(r(5)),u=i(r(2)),o=i(r(1));function i(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}function s(){var t=new a.ARRAY_TYPE(4);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function c(t,n,r){r*=.5;var a=Math.sin(r);return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=Math.cos(r),t}function f(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*f+o*i+e*c-u*s,t[1]=e*f+o*s+u*i-a*c,t[2]=u*f+o*c+a*s-e*i,t[3]=o*f-a*i-e*s-u*c,t}function M(t,n,r,e){var u=n[0],o=n[1],i=n[2],s=n[3],c=r[0],f=r[1],M=r[2],h=r[3],l=void 0,v=void 0,d=void 0,b=void 0,m=void 0;return(v=u*c+o*f+i*M+s*h)<0&&(v=-v,c=-c,f=-f,M=-M,h=-h),1-v>a.EPSILON?(l=Math.acos(v),d=Math.sin(l),b=Math.sin((1-e)*l)/d,m=Math.sin(e*l)/d):(b=1-e,m=e),t[0]=b*u+m*c,t[1]=b*o+m*f,t[2]=b*i+m*M,t[3]=b*s+m*h,t}function h(t,n){var r=n[0]+n[4]+n[8],a=void 0;if(r>0)a=Math.sqrt(r+1),t[3]=.5*a,a=.5/a,t[0]=(n[5]-n[7])*a,t[1]=(n[6]-n[2])*a,t[2]=(n[1]-n[3])*a;else{var e=0;n[4]>n[0]&&(e=1),n[8]>n[3*e+e]&&(e=2);var u=(e+1)%3,o=(e+2)%3;a=Math.sqrt(n[3*e+e]-n[3*u+u]-n[3*o+o]+1),t[e]=.5*a,a=.5/a,t[3]=(n[3*u+o]-n[3*o+u])*a,t[u]=(n[3*u+e]+n[3*e+u])*a,t[o]=(n[3*o+e]+n[3*e+o])*a}return t}n.clone=o.clone,n.fromValues=o.fromValues,n.copy=o.copy,n.set=o.set,n.add=o.add,n.mul=f,n.scale=o.scale,n.dot=o.dot,n.lerp=o.lerp;var l=n.length=o.length,v=(n.len=l,n.squaredLength=o.squaredLength),d=(n.sqrLen=v,n.normalize=o.normalize);n.exactEquals=o.exactEquals,n.equals=o.equals,n.rotationTo=function(){var t=u.create(),n=u.fromValues(1,0,0),r=u.fromValues(0,1,0);return function(a,e,o){var i=u.dot(e,o);return i<-.999999?(u.cross(t,n,e),u.len(t)<1e-6&&u.cross(t,r,e),u.normalize(t,t),c(a,t,Math.PI),a):i>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(u.cross(t,e,o),a[0]=t[0],a[1]=t[1],a[2]=t[2],a[3]=1+i,d(a,a))}}(),n.sqlerp=function(){var t=s(),n=s();return function(r,a,e,u,o,i){return M(t,a,o,i),M(n,e,u,i),M(r,t,n,2*i*(1-i)),r}}(),n.setAxes=function(){var t=e.create();return function(n,r,a,e){return t[0]=a[0],t[3]=a[1],t[6]=a[2],t[1]=e[0],t[4]=e[1],t[7]=e[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],d(n,h(n,t))}}()},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(16);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0);return t[0]=1,t[5]=1,t[10]=1,t[15]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(16);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},n.fromValues=function(t,n,r,e,u,o,i,s,c,f,M,h,l,v,d,b){var m=new a.ARRAY_TYPE(16);return m[0]=t,m[1]=n,m[2]=r,m[3]=e,m[4]=u,m[5]=o,m[6]=i,m[7]=s,m[8]=c,m[9]=f,m[10]=M,m[11]=h,m[12]=l,m[13]=v,m[14]=d,m[15]=b,m},n.set=function(t,n,r,a,e,u,o,i,s,c,f,M,h,l,v,d,b){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t[8]=c,t[9]=f,t[10]=M,t[11]=h,t[12]=l,t[13]=v,t[14]=d,t[15]=b,t},n.identity=e,n.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[3],u=n[6],o=n[7],i=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=r,t[6]=n[9],t[7]=n[13],t[8]=a,t[9]=u,t[11]=n[14],t[12]=e,t[13]=o,t[14]=i}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15],p=r*i-a*o,P=r*s-e*o,A=r*c-u*o,E=a*s-e*i,O=a*c-u*i,R=e*c-u*s,y=f*d-M*v,q=f*b-h*v,x=f*m-l*v,_=M*b-h*d,Y=M*m-l*d,L=h*m-l*b,S=p*L-P*Y+A*_+E*x-O*q+R*y;if(!S)return null;return S=1/S,t[0]=(i*L-s*Y+c*_)*S,t[1]=(e*Y-a*L-u*_)*S,t[2]=(d*R-b*O+m*E)*S,t[3]=(h*O-M*R-l*E)*S,t[4]=(s*x-o*L-c*q)*S,t[5]=(r*L-e*x+u*q)*S,t[6]=(b*A-v*R-m*P)*S,t[7]=(f*R-h*A+l*P)*S,t[8]=(o*Y-i*x+c*y)*S,t[9]=(a*x-r*Y-u*y)*S,t[10]=(v*O-d*A+m*p)*S,t[11]=(M*A-f*O-l*p)*S,t[12]=(i*q-o*_-s*y)*S,t[13]=(r*_-a*q+e*y)*S,t[14]=(d*P-v*E-b*p)*S,t[15]=(f*E-M*P+h*p)*S,t},n.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15];return t[0]=i*(h*m-l*b)-M*(s*m-c*b)+d*(s*l-c*h),t[1]=-(a*(h*m-l*b)-M*(e*m-u*b)+d*(e*l-u*h)),t[2]=a*(s*m-c*b)-i*(e*m-u*b)+d*(e*c-u*s),t[3]=-(a*(s*l-c*h)-i*(e*l-u*h)+M*(e*c-u*s)),t[4]=-(o*(h*m-l*b)-f*(s*m-c*b)+v*(s*l-c*h)),t[5]=r*(h*m-l*b)-f*(e*m-u*b)+v*(e*l-u*h),t[6]=-(r*(s*m-c*b)-o*(e*m-u*b)+v*(e*c-u*s)),t[7]=r*(s*l-c*h)-o*(e*l-u*h)+f*(e*c-u*s),t[8]=o*(M*m-l*d)-f*(i*m-c*d)+v*(i*l-c*M),t[9]=-(r*(M*m-l*d)-f*(a*m-u*d)+v*(a*l-u*M)),t[10]=r*(i*m-c*d)-o*(a*m-u*d)+v*(a*c-u*i),t[11]=-(r*(i*l-c*M)-o*(a*l-u*M)+f*(a*c-u*i)),t[12]=-(o*(M*b-h*d)-f*(i*b-s*d)+v*(i*h-s*M)),t[13]=r*(M*b-h*d)-f*(a*b-e*d)+v*(a*h-e*M),t[14]=-(r*(i*b-s*d)-o*(a*b-e*d)+v*(a*s-e*i)),t[15]=r*(i*h-s*M)-o*(a*h-e*M)+f*(a*s-e*i),t},n.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],s=t[7],c=t[8],f=t[9],M=t[10],h=t[11],l=t[12],v=t[13],d=t[14],b=t[15];return(n*o-r*u)*(M*b-h*d)-(n*i-a*u)*(f*b-h*v)+(n*s-e*u)*(f*d-M*v)+(r*i-a*o)*(c*b-h*l)-(r*s-e*o)*(c*d-M*l)+(a*s-e*i)*(c*v-f*l)},n.multiply=u,n.translate=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=void 0,i=void 0,s=void 0,c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=void 0,m=void 0;n===t?(t[12]=n[0]*a+n[4]*e+n[8]*u+n[12],t[13]=n[1]*a+n[5]*e+n[9]*u+n[13],t[14]=n[2]*a+n[6]*e+n[10]*u+n[14],t[15]=n[3]*a+n[7]*e+n[11]*u+n[15]):(o=n[0],i=n[1],s=n[2],c=n[3],f=n[4],M=n[5],h=n[6],l=n[7],v=n[8],d=n[9],b=n[10],m=n[11],t[0]=o,t[1]=i,t[2]=s,t[3]=c,t[4]=f,t[5]=M,t[6]=h,t[7]=l,t[8]=v,t[9]=d,t[10]=b,t[11]=m,t[12]=o*a+f*e+v*u+n[12],t[13]=i*a+M*e+d*u+n[13],t[14]=s*a+h*e+b*u+n[14],t[15]=c*a+l*e+m*u+n[15]);return t},n.scale=function(t,n,r){var a=r[0],e=r[1],u=r[2];return t[0]=n[0]*a,t[1]=n[1]*a,t[2]=n[2]*a,t[3]=n[3]*a,t[4]=n[4]*e,t[5]=n[5]*e,t[6]=n[6]*e,t[7]=n[7]*e,t[8]=n[8]*u,t[9]=n[9]*u,t[10]=n[10]*u,t[11]=n[11]*u,t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],t},n.rotate=function(t,n,r,e){var u=e[0],o=e[1],i=e[2],s=Math.sqrt(u*u+o*o+i*i),c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=void 0,m=void 0,p=void 0,P=void 0,A=void 0,E=void 0,O=void 0,R=void 0,y=void 0,q=void 0,x=void 0,_=void 0,Y=void 0,L=void 0,S=void 0,w=void 0,I=void 0;if(s<a.EPSILON)return null;u*=s=1/s,o*=s,i*=s,c=Math.sin(r),f=Math.cos(r),M=1-f,h=n[0],l=n[1],v=n[2],d=n[3],b=n[4],m=n[5],p=n[6],P=n[7],A=n[8],E=n[9],O=n[10],R=n[11],y=u*u*M+f,q=o*u*M+i*c,x=i*u*M-o*c,_=u*o*M-i*c,Y=o*o*M+f,L=i*o*M+u*c,S=u*i*M+o*c,w=o*i*M-u*c,I=i*i*M+f,t[0]=h*y+b*q+A*x,t[1]=l*y+m*q+E*x,t[2]=v*y+p*q+O*x,t[3]=d*y+P*q+R*x,t[4]=h*_+b*Y+A*L,t[5]=l*_+m*Y+E*L,t[6]=v*_+p*Y+O*L,t[7]=d*_+P*Y+R*L,t[8]=h*S+b*w+A*I,t[9]=l*S+m*w+E*I,t[10]=v*S+p*w+O*I,t[11]=d*S+P*w+R*I,n!==t&&(t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t},n.rotateX=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[4],o=n[5],i=n[6],s=n[7],c=n[8],f=n[9],M=n[10],h=n[11];n!==t&&(t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[4]=u*e+c*a,t[5]=o*e+f*a,t[6]=i*e+M*a,t[7]=s*e+h*a,t[8]=c*e-u*a,t[9]=f*e-o*a,t[10]=M*e-i*a,t[11]=h*e-s*a,t},n.rotateY=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],s=n[3],c=n[8],f=n[9],M=n[10],h=n[11];n!==t&&(t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[0]=u*e-c*a,t[1]=o*e-f*a,t[2]=i*e-M*a,t[3]=s*e-h*a,t[8]=u*a+c*e,t[9]=o*a+f*e,t[10]=i*a+M*e,t[11]=s*a+h*e,t},n.rotateZ=function(t,n,r){var a=Math.sin(r),e=Math.cos(r),u=n[0],o=n[1],i=n[2],s=n[3],c=n[4],f=n[5],M=n[6],h=n[7];n!==t&&(t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15]);return t[0]=u*e+c*a,t[1]=o*e+f*a,t[2]=i*e+M*a,t[3]=s*e+h*a,t[4]=c*e-u*a,t[5]=f*e-o*a,t[6]=M*e-i*a,t[7]=h*e-s*a,t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=n[1],t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=n[2],t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromRotation=function(t,n,r){var e=r[0],u=r[1],o=r[2],i=Math.sqrt(e*e+u*u+o*o),s=void 0,c=void 0,f=void 0;if(i<a.EPSILON)return null;return e*=i=1/i,u*=i,o*=i,s=Math.sin(n),c=Math.cos(n),f=1-c,t[0]=e*e*f+c,t[1]=u*e*f+o*s,t[2]=o*e*f-u*s,t[3]=0,t[4]=e*u*f-o*s,t[5]=u*u*f+c,t[6]=o*u*f+e*s,t[7]=0,t[8]=e*o*f+u*s,t[9]=u*o*f-e*s,t[10]=o*o*f+c,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromXRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=r,t[7]=0,t[8]=0,t[9]=-r,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromYRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=0,t[2]=-r,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=r,t[9]=0,t[10]=a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromZRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=0,t[4]=-r,t[5]=a,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.fromRotationTranslation=o,n.fromQuat2=function(t,n){var r=new a.ARRAY_TYPE(3),e=-n[0],u=-n[1],i=-n[2],s=n[3],c=n[4],f=n[5],M=n[6],h=n[7],l=e*e+u*u+i*i+s*s;l>0?(r[0]=2*(c*s+h*e+f*i-M*u)/l,r[1]=2*(f*s+h*u+M*e-c*i)/l,r[2]=2*(M*s+h*i+c*u-f*e)/l):(r[0]=2*(c*s+h*e+f*i-M*u),r[1]=2*(f*s+h*u+M*e-c*i),r[2]=2*(M*s+h*i+c*u-f*e));return o(t,n,r),t},n.getTranslation=function(t,n){return t[0]=n[12],t[1]=n[13],t[2]=n[14],t},n.getScaling=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[4],o=n[5],i=n[6],s=n[8],c=n[9],f=n[10];return t[0]=Math.sqrt(r*r+a*a+e*e),t[1]=Math.sqrt(u*u+o*o+i*i),t[2]=Math.sqrt(s*s+c*c+f*f),t},n.getRotation=function(t,n){var r=n[0]+n[5]+n[10],a=0;r>0?(a=2*Math.sqrt(r+1),t[3]=.25*a,t[0]=(n[6]-n[9])/a,t[1]=(n[8]-n[2])/a,t[2]=(n[1]-n[4])/a):n[0]>n[5]&&n[0]>n[10]?(a=2*Math.sqrt(1+n[0]-n[5]-n[10]),t[3]=(n[6]-n[9])/a,t[0]=.25*a,t[1]=(n[1]+n[4])/a,t[2]=(n[8]+n[2])/a):n[5]>n[10]?(a=2*Math.sqrt(1+n[5]-n[0]-n[10]),t[3]=(n[8]-n[2])/a,t[0]=(n[1]+n[4])/a,t[1]=.25*a,t[2]=(n[6]+n[9])/a):(a=2*Math.sqrt(1+n[10]-n[0]-n[5]),t[3]=(n[1]-n[4])/a,t[0]=(n[8]+n[2])/a,t[1]=(n[6]+n[9])/a,t[2]=.25*a);return t},n.fromRotationTranslationScale=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=n[3],s=e+e,c=u+u,f=o+o,M=e*s,h=e*c,l=e*f,v=u*c,d=u*f,b=o*f,m=i*s,p=i*c,P=i*f,A=a[0],E=a[1],O=a[2];return t[0]=(1-(v+b))*A,t[1]=(h+P)*A,t[2]=(l-p)*A,t[3]=0,t[4]=(h-P)*E,t[5]=(1-(M+b))*E,t[6]=(d+m)*E,t[7]=0,t[8]=(l+p)*O,t[9]=(d-m)*O,t[10]=(1-(M+v))*O,t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t},n.fromRotationTranslationScaleOrigin=function(t,n,r,a,e){var u=n[0],o=n[1],i=n[2],s=n[3],c=u+u,f=o+o,M=i+i,h=u*c,l=u*f,v=u*M,d=o*f,b=o*M,m=i*M,p=s*c,P=s*f,A=s*M,E=a[0],O=a[1],R=a[2],y=e[0],q=e[1],x=e[2],_=(1-(d+m))*E,Y=(l+A)*E,L=(v-P)*E,S=(l-A)*O,w=(1-(h+m))*O,I=(b+p)*O,N=(v+P)*R,g=(b-p)*R,T=(1-(h+d))*R;return t[0]=_,t[1]=Y,t[2]=L,t[3]=0,t[4]=S,t[5]=w,t[6]=I,t[7]=0,t[8]=N,t[9]=g,t[10]=T,t[11]=0,t[12]=r[0]+y-(_*y+S*q+N*x),t[13]=r[1]+q-(Y*y+w*q+g*x),t[14]=r[2]+x-(L*y+I*q+T*x),t[15]=1,t},n.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,s=e+e,c=r*o,f=a*o,M=a*i,h=e*o,l=e*i,v=e*s,d=u*o,b=u*i,m=u*s;return t[0]=1-M-v,t[1]=f+m,t[2]=h-b,t[3]=0,t[4]=f-m,t[5]=1-c-v,t[6]=l+d,t[7]=0,t[8]=h+b,t[9]=l-d,t[10]=1-c-M,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t},n.frustum=function(t,n,r,a,e,u,o){var i=1/(r-n),s=1/(e-a),c=1/(u-o);return t[0]=2*u*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=2*u*s,t[6]=0,t[7]=0,t[8]=(r+n)*i,t[9]=(e+a)*s,t[10]=(o+u)*c,t[11]=-1,t[12]=0,t[13]=0,t[14]=o*u*2*c,t[15]=0,t},n.perspective=function(t,n,r,a,e){var u=1/Math.tan(n/2),o=void 0;t[0]=u/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=u,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=e&&e!==1/0?(o=1/(a-e),t[10]=(e+a)*o,t[14]=2*e*a*o):(t[10]=-1,t[14]=-2*a);return t},n.perspectiveFromFieldOfView=function(t,n,r,a){var e=Math.tan(n.upDegrees*Math.PI/180),u=Math.tan(n.downDegrees*Math.PI/180),o=Math.tan(n.leftDegrees*Math.PI/180),i=Math.tan(n.rightDegrees*Math.PI/180),s=2/(o+i),c=2/(e+u);return t[0]=s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=c,t[6]=0,t[7]=0,t[8]=-(o-i)*s*.5,t[9]=(e-u)*c*.5,t[10]=a/(r-a),t[11]=-1,t[12]=0,t[13]=0,t[14]=a*r/(r-a),t[15]=0,t},n.ortho=function(t,n,r,a,e,u,o){var i=1/(n-r),s=1/(a-e),c=1/(u-o);return t[0]=-2*i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*c,t[11]=0,t[12]=(n+r)*i,t[13]=(e+a)*s,t[14]=(o+u)*c,t[15]=1,t},n.lookAt=function(t,n,r,u){var o=void 0,i=void 0,s=void 0,c=void 0,f=void 0,M=void 0,h=void 0,l=void 0,v=void 0,d=void 0,b=n[0],m=n[1],p=n[2],P=u[0],A=u[1],E=u[2],O=r[0],R=r[1],y=r[2];if(Math.abs(b-O)<a.EPSILON&&Math.abs(m-R)<a.EPSILON&&Math.abs(p-y)<a.EPSILON)return e(t);h=b-O,l=m-R,v=p-y,d=1/Math.sqrt(h*h+l*l+v*v),o=A*(v*=d)-E*(l*=d),i=E*(h*=d)-P*v,s=P*l-A*h,(d=Math.sqrt(o*o+i*i+s*s))?(o*=d=1/d,i*=d,s*=d):(o=0,i=0,s=0);c=l*s-v*i,f=v*o-h*s,M=h*i-l*o,(d=Math.sqrt(c*c+f*f+M*M))?(c*=d=1/d,f*=d,M*=d):(c=0,f=0,M=0);return t[0]=o,t[1]=c,t[2]=h,t[3]=0,t[4]=i,t[5]=f,t[6]=l,t[7]=0,t[8]=s,t[9]=M,t[10]=v,t[11]=0,t[12]=-(o*b+i*m+s*p),t[13]=-(c*b+f*m+M*p),t[14]=-(h*b+l*m+v*p),t[15]=1,t},n.targetTo=function(t,n,r,a){var e=n[0],u=n[1],o=n[2],i=a[0],s=a[1],c=a[2],f=e-r[0],M=u-r[1],h=o-r[2],l=f*f+M*M+h*h;l>0&&(l=1/Math.sqrt(l),f*=l,M*=l,h*=l);var v=s*h-c*M,d=c*f-i*h,b=i*M-s*f;(l=v*v+d*d+b*b)>0&&(l=1/Math.sqrt(l),v*=l,d*=l,b*=l);return t[0]=v,t[1]=d,t[2]=b,t[3]=0,t[4]=M*b-h*d,t[5]=h*v-f*b,t[6]=f*d-M*v,t[7]=0,t[8]=f,t[9]=M,t[10]=h,t[11]=0,t[12]=e,t[13]=u,t[14]=o,t[15]=1,t},n.str=function(t){return\"mat4(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\", \"+t[4]+\", \"+t[5]+\", \"+t[6]+\", \"+t[7]+\", \"+t[8]+\", \"+t[9]+\", \"+t[10]+\", \"+t[11]+\", \"+t[12]+\", \"+t[13]+\", \"+t[14]+\", \"+t[15]+\")\"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2)+Math.pow(t[9],2)+Math.pow(t[10],2)+Math.pow(t[11],2)+Math.pow(t[12],2)+Math.pow(t[13],2)+Math.pow(t[14],2)+Math.pow(t[15],2))},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t[8]=n[8]+r[8],t[9]=n[9]+r[9],t[10]=n[10]+r[10],t[11]=n[11]+r[11],t[12]=n[12]+r[12],t[13]=n[13]+r[13],t[14]=n[14]+r[14],t[15]=n[15]+r[15],t},n.subtract=i,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t[8]=n[8]*r,t[9]=n[9]*r,t[10]=n[10]*r,t[11]=n[11]*r,t[12]=n[12]*r,t[13]=n[13]*r,t[14]=n[14]*r,t[15]=n[15]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t[6]=n[6]+r[6]*a,t[7]=n[7]+r[7]*a,t[8]=n[8]+r[8]*a,t[9]=n[9]+r[9]*a,t[10]=n[10]+r[10]*a,t[11]=n[11]+r[11]*a,t[12]=n[12]+r[12]*a,t[13]=n[13]+r[13]*a,t[14]=n[14]+r[14]*a,t[15]=n[15]+r[15]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]&&t[9]===n[9]&&t[10]===n[10]&&t[11]===n[11]&&t[12]===n[12]&&t[13]===n[13]&&t[14]===n[14]&&t[15]===n[15]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=t[8],h=t[9],l=t[10],v=t[11],d=t[12],b=t[13],m=t[14],p=t[15],P=n[0],A=n[1],E=n[2],O=n[3],R=n[4],y=n[5],q=n[6],x=n[7],_=n[8],Y=n[9],L=n[10],S=n[11],w=n[12],I=n[13],N=n[14],g=n[15];return Math.abs(r-P)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(P))&&Math.abs(e-A)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(A))&&Math.abs(u-E)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(E))&&Math.abs(o-O)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(O))&&Math.abs(i-R)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(R))&&Math.abs(s-y)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(y))&&Math.abs(c-q)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(q))&&Math.abs(f-x)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(x))&&Math.abs(M-_)<=a.EPSILON*Math.max(1,Math.abs(M),Math.abs(_))&&Math.abs(h-Y)<=a.EPSILON*Math.max(1,Math.abs(h),Math.abs(Y))&&Math.abs(l-L)<=a.EPSILON*Math.max(1,Math.abs(l),Math.abs(L))&&Math.abs(v-S)<=a.EPSILON*Math.max(1,Math.abs(v),Math.abs(S))&&Math.abs(d-w)<=a.EPSILON*Math.max(1,Math.abs(d),Math.abs(w))&&Math.abs(b-I)<=a.EPSILON*Math.max(1,Math.abs(b),Math.abs(I))&&Math.abs(m-N)<=a.EPSILON*Math.max(1,Math.abs(m),Math.abs(N))&&Math.abs(p-g)<=a.EPSILON*Math.max(1,Math.abs(p),Math.abs(g))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function u(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=n[9],l=n[10],v=n[11],d=n[12],b=n[13],m=n[14],p=n[15],P=r[0],A=r[1],E=r[2],O=r[3];return t[0]=P*a+A*i+E*M+O*d,t[1]=P*e+A*s+E*h+O*b,t[2]=P*u+A*c+E*l+O*m,t[3]=P*o+A*f+E*v+O*p,P=r[4],A=r[5],E=r[6],O=r[7],t[4]=P*a+A*i+E*M+O*d,t[5]=P*e+A*s+E*h+O*b,t[6]=P*u+A*c+E*l+O*m,t[7]=P*o+A*f+E*v+O*p,P=r[8],A=r[9],E=r[10],O=r[11],t[8]=P*a+A*i+E*M+O*d,t[9]=P*e+A*s+E*h+O*b,t[10]=P*u+A*c+E*l+O*m,t[11]=P*o+A*f+E*v+O*p,P=r[12],A=r[13],E=r[14],O=r[15],t[12]=P*a+A*i+E*M+O*d,t[13]=P*e+A*s+E*h+O*b,t[14]=P*u+A*c+E*l+O*m,t[15]=P*o+A*f+E*v+O*p,t}function o(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=a+a,s=e+e,c=u+u,f=a*i,M=a*s,h=a*c,l=e*s,v=e*c,d=u*c,b=o*i,m=o*s,p=o*c;return t[0]=1-(l+d),t[1]=M+p,t[2]=h-m,t[3]=0,t[4]=M-p,t[5]=1-(f+d),t[6]=v+b,t[7]=0,t[8]=h+m,t[9]=v-b,t[10]=1-(f+l),t[11]=0,t[12]=r[0],t[13]=r[1],t[14]=r[2],t[15]=1,t}function i(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t[6]=n[6]-r[6],t[7]=n[7]-r[7],t[8]=n[8]-r[8],t[9]=n[9]-r[9],t[10]=n[10]-r[10],t[11]=n[11]-r[11],t[12]=n[12]-r[12],t[13]=n[13]-r[13],t[14]=n[14]-r[14],t[15]=n[15]-r[15],t}n.mul=u,n.sub=i},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(9);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0);return t[0]=1,t[4]=1,t[8]=1,t},n.fromMat4=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[4],t[4]=n[5],t[5]=n[6],t[6]=n[8],t[7]=n[9],t[8]=n[10],t},n.clone=function(t){var n=new a.ARRAY_TYPE(9);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[8]=t[8],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},n.fromValues=function(t,n,r,e,u,o,i,s,c){var f=new a.ARRAY_TYPE(9);return f[0]=t,f[1]=n,f[2]=r,f[3]=e,f[4]=u,f[5]=o,f[6]=i,f[7]=s,f[8]=c,f},n.set=function(t,n,r,a,e,u,o,i,s,c){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t[8]=c,t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.transpose=function(t,n){if(t===n){var r=n[1],a=n[2],e=n[5];t[1]=n[3],t[2]=n[6],t[3]=r,t[5]=n[7],t[6]=a,t[7]=e}else t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=f*o-i*c,h=-f*u+i*s,l=c*u-o*s,v=r*M+a*h+e*l;if(!v)return null;return v=1/v,t[0]=M*v,t[1]=(-f*a+e*c)*v,t[2]=(i*a-e*o)*v,t[3]=h*v,t[4]=(f*r-e*s)*v,t[5]=(-i*r+e*u)*v,t[6]=l*v,t[7]=(-c*r+a*s)*v,t[8]=(o*r-a*u)*v,t},n.adjoint=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8];return t[0]=o*f-i*c,t[1]=e*c-a*f,t[2]=a*i-e*o,t[3]=i*s-u*f,t[4]=r*f-e*s,t[5]=e*u-r*i,t[6]=u*c-o*s,t[7]=a*s-r*c,t[8]=r*o-a*u,t},n.determinant=function(t){var n=t[0],r=t[1],a=t[2],e=t[3],u=t[4],o=t[5],i=t[6],s=t[7],c=t[8];return n*(c*u-o*s)+r*(-c*e+o*i)+a*(s*e-u*i)},n.multiply=e,n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=r[0],l=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=i,t[5]=s,t[6]=h*a+l*o+c,t[7]=h*e+l*i+f,t[8]=h*u+l*s+M,t},n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=Math.sin(r),l=Math.cos(r);return t[0]=l*a+h*o,t[1]=l*e+h*i,t[2]=l*u+h*s,t[3]=l*o-h*a,t[4]=l*i-h*e,t[5]=l*s-h*u,t[6]=c,t[7]=f,t[8]=M,t},n.scale=function(t,n,r){var a=r[0],e=r[1];return t[0]=a*n[0],t[1]=a*n[1],t[2]=a*n[2],t[3]=e*n[3],t[4]=e*n[4],t[5]=e*n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=n[0],t[7]=n[1],t[8]=1,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=0,t[3]=-r,t[4]=a,t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=0,t[4]=n[1],t[5]=0,t[6]=0,t[7]=0,t[8]=1,t},n.fromMat2d=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=0,t[3]=n[2],t[4]=n[3],t[5]=0,t[6]=n[4],t[7]=n[5],t[8]=1,t},n.fromQuat=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r+r,i=a+a,s=e+e,c=r*o,f=a*o,M=a*i,h=e*o,l=e*i,v=e*s,d=u*o,b=u*i,m=u*s;return t[0]=1-M-v,t[3]=f-m,t[6]=h+b,t[1]=f+m,t[4]=1-c-v,t[7]=l-d,t[2]=h-b,t[5]=l+d,t[8]=1-c-M,t},n.normalFromMat4=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=n[6],c=n[7],f=n[8],M=n[9],h=n[10],l=n[11],v=n[12],d=n[13],b=n[14],m=n[15],p=r*i-a*o,P=r*s-e*o,A=r*c-u*o,E=a*s-e*i,O=a*c-u*i,R=e*c-u*s,y=f*d-M*v,q=f*b-h*v,x=f*m-l*v,_=M*b-h*d,Y=M*m-l*d,L=h*m-l*b,S=p*L-P*Y+A*_+E*x-O*q+R*y;if(!S)return null;return S=1/S,t[0]=(i*L-s*Y+c*_)*S,t[1]=(s*x-o*L-c*q)*S,t[2]=(o*Y-i*x+c*y)*S,t[3]=(e*Y-a*L-u*_)*S,t[4]=(r*L-e*x+u*q)*S,t[5]=(a*x-r*Y-u*y)*S,t[6]=(d*R-b*O+m*E)*S,t[7]=(b*A-v*R-m*P)*S,t[8]=(v*O-d*A+m*p)*S,t},n.projection=function(t,n,r){return t[0]=2/n,t[1]=0,t[2]=0,t[3]=0,t[4]=-2/r,t[5]=0,t[6]=-1,t[7]=1,t[8]=1,t},n.str=function(t){return\"mat3(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\", \"+t[4]+\", \"+t[5]+\", \"+t[6]+\", \"+t[7]+\", \"+t[8]+\")\"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+Math.pow(t[6],2)+Math.pow(t[7],2)+Math.pow(t[8],2))},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t[8]=n[8]+r[8],t},n.subtract=u,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t[8]=n[8]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t[6]=n[6]+r[6]*a,t[7]=n[7]+r[7]*a,t[8]=n[8]+r[8]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]&&t[8]===n[8]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=t[8],h=n[0],l=n[1],v=n[2],d=n[3],b=n[4],m=n[5],p=n[6],P=n[7],A=n[8];return Math.abs(r-h)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(h))&&Math.abs(e-l)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(l))&&Math.abs(u-v)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(v))&&Math.abs(o-d)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(d))&&Math.abs(i-b)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(b))&&Math.abs(s-m)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(m))&&Math.abs(c-p)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(p))&&Math.abs(f-P)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(P))&&Math.abs(M-A)<=a.EPSILON*Math.max(1,Math.abs(M),Math.abs(A))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=n[6],f=n[7],M=n[8],h=r[0],l=r[1],v=r[2],d=r[3],b=r[4],m=r[5],p=r[6],P=r[7],A=r[8];return t[0]=h*a+l*o+v*c,t[1]=h*e+l*i+v*f,t[2]=h*u+l*s+v*M,t[3]=d*a+b*o+m*c,t[4]=d*e+b*i+m*f,t[5]=d*u+b*s+m*M,t[6]=p*a+P*o+A*c,t[7]=p*e+P*i+A*f,t[8]=p*u+P*s+A*M,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t[6]=n[6]-r[6],t[7]=n[7]-r[7],t[8]=n[8]-r[8],t}n.mul=e,n.sub=u},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.forEach=n.sqrLen=n.sqrDist=n.dist=n.div=n.mul=n.sub=n.len=void 0,n.create=e,n.clone=function(t){var n=new a.ARRAY_TYPE(2);return n[0]=t[0],n[1]=t[1],n},n.fromValues=function(t,n){var r=new a.ARRAY_TYPE(2);return r[0]=t,r[1]=n,r},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t},n.set=function(t,n,r){return t[0]=n,t[1]=r,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t},n.subtract=u,n.multiply=o,n.divide=i,n.ceil=function(t,n){return t[0]=Math.ceil(n[0]),t[1]=Math.ceil(n[1]),t},n.floor=function(t,n){return t[0]=Math.floor(n[0]),t[1]=Math.floor(n[1]),t},n.min=function(t,n,r){return t[0]=Math.min(n[0],r[0]),t[1]=Math.min(n[1],r[1]),t},n.max=function(t,n,r){return t[0]=Math.max(n[0],r[0]),t[1]=Math.max(n[1],r[1]),t},n.round=function(t,n){return t[0]=Math.round(n[0]),t[1]=Math.round(n[1]),t},n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t},n.scaleAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t},n.distance=s,n.squaredDistance=c,n.length=f,n.squaredLength=M,n.negate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t},n.inverse=function(t,n){return t[0]=1/n[0],t[1]=1/n[1],t},n.normalize=function(t,n){var r=n[0],a=n[1],e=r*r+a*a;e>0&&(e=1/Math.sqrt(e),t[0]=n[0]*e,t[1]=n[1]*e);return t},n.dot=function(t,n){return t[0]*n[0]+t[1]*n[1]},n.cross=function(t,n,r){var a=n[0]*r[1]-n[1]*r[0];return t[0]=t[1]=0,t[2]=a,t},n.lerp=function(t,n,r,a){var e=n[0],u=n[1];return t[0]=e+a*(r[0]-e),t[1]=u+a*(r[1]-u),t},n.random=function(t,n){n=n||1;var r=2*a.RANDOM()*Math.PI;return t[0]=Math.cos(r)*n,t[1]=Math.sin(r)*n,t},n.transformMat2=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e,t[1]=r[1]*a+r[3]*e,t},n.transformMat2d=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[2]*e+r[4],t[1]=r[1]*a+r[3]*e+r[5],t},n.transformMat3=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[3]*e+r[6],t[1]=r[1]*a+r[4]*e+r[7],t},n.transformMat4=function(t,n,r){var a=n[0],e=n[1];return t[0]=r[0]*a+r[4]*e+r[12],t[1]=r[1]*a+r[5]*e+r[13],t},n.rotate=function(t,n,r,a){var e=n[0]-r[0],u=n[1]-r[1],o=Math.sin(a),i=Math.cos(a);return t[0]=e*i-u*o+r[0],t[1]=e*o+u*i+r[1],t},n.angle=function(t,n){var r=t[0],a=t[1],e=n[0],u=n[1],o=r*r+a*a;o>0&&(o=1/Math.sqrt(o));var i=e*e+u*u;i>0&&(i=1/Math.sqrt(i));var s=(r*e+a*u)*o*i;return s>1?0:s<-1?Math.PI:Math.acos(s)},n.str=function(t){return\"vec2(\"+t[0]+\", \"+t[1]+\")\"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]},n.equals=function(t,n){var r=t[0],e=t[1],u=n[0],o=n[1];return Math.abs(r-u)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(u))&&Math.abs(e-o)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(o))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(){var t=new a.ARRAY_TYPE(2);return a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0),t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t}function o(t,n,r){return t[0]=n[0]*r[0],t[1]=n[1]*r[1],t}function i(t,n,r){return t[0]=n[0]/r[0],t[1]=n[1]/r[1],t}function s(t,n){var r=n[0]-t[0],a=n[1]-t[1];return Math.sqrt(r*r+a*a)}function c(t,n){var r=n[0]-t[0],a=n[1]-t[1];return r*r+a*a}function f(t){var n=t[0],r=t[1];return Math.sqrt(n*n+r*r)}function M(t){var n=t[0],r=t[1];return n*n+r*r}n.len=f,n.sub=u,n.mul=o,n.div=i,n.dist=s,n.sqrDist=c,n.sqrLen=M,n.forEach=function(){var t=e();return function(n,r,a,e,u,o){var i=void 0,s=void 0;for(r||(r=2),a||(a=0),s=e?Math.min(e*r+a,n.length):n.length,i=a;i<s;i+=r)t[0]=n[i],t[1]=n[i+1],u(t,t,o),n[i]=t[0],n[i+1]=t[1];return n}}()},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.sqrLen=n.squaredLength=n.len=n.length=n.dot=n.mul=n.setReal=n.getReal=void 0,n.create=function(){var t=new a.ARRAY_TYPE(8);a.ARRAY_TYPE!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0);return t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(8);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n},n.fromValues=function(t,n,r,e,u,o,i,s){var c=new a.ARRAY_TYPE(8);return c[0]=t,c[1]=n,c[2]=r,c[3]=e,c[4]=u,c[5]=o,c[6]=i,c[7]=s,c},n.fromRotationTranslationValues=function(t,n,r,e,u,o,i){var s=new a.ARRAY_TYPE(8);s[0]=t,s[1]=n,s[2]=r,s[3]=e;var c=.5*u,f=.5*o,M=.5*i;return s[4]=c*e+f*r-M*n,s[5]=f*e+M*t-c*r,s[6]=M*e+c*n-f*t,s[7]=-c*t-f*n-M*r,s},n.fromRotationTranslation=i,n.fromTranslation=function(t,n){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=.5*n[0],t[5]=.5*n[1],t[6]=.5*n[2],t[7]=0,t},n.fromRotation=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},n.fromMat4=function(t,n){var r=e.create();u.getRotation(r,n);var o=new a.ARRAY_TYPE(3);return u.getTranslation(o,n),i(t,r,o),t},n.copy=s,n.identity=function(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t},n.set=function(t,n,r,a,e,u,o,i,s){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t[6]=i,t[7]=s,t},n.getDual=function(t,n){return t[0]=n[4],t[1]=n[5],t[2]=n[6],t[3]=n[7],t},n.setDual=function(t,n){return t[4]=n[0],t[5]=n[1],t[6]=n[2],t[7]=n[3],t},n.getTranslation=function(t,n){var r=n[4],a=n[5],e=n[6],u=n[7],o=-n[0],i=-n[1],s=-n[2],c=n[3];return t[0]=2*(r*c+u*o+a*s-e*i),t[1]=2*(a*c+u*i+e*o-r*s),t[2]=2*(e*c+u*s+r*i-a*o),t},n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=.5*r[0],s=.5*r[1],c=.5*r[2],f=n[4],M=n[5],h=n[6],l=n[7];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=o*i+e*c-u*s+f,t[5]=o*s+u*i-a*c+M,t[6]=o*c+a*s-e*i+h,t[7]=-a*i-e*s-u*c+l,t},n.rotateX=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateX(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateY=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateY(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateZ=function(t,n,r){var a=-n[0],u=-n[1],o=-n[2],i=n[3],s=n[4],c=n[5],f=n[6],M=n[7],h=s*i+M*a+c*o-f*u,l=c*i+M*u+f*a-s*o,v=f*i+M*o+s*u-c*a,d=M*i-s*a-c*u-f*o;return e.rotateZ(t,n,r),a=t[0],u=t[1],o=t[2],i=t[3],t[4]=h*i+d*a+l*o-v*u,t[5]=l*i+d*u+v*a-h*o,t[6]=v*i+d*o+h*u-l*a,t[7]=d*i-h*a-l*u-v*o,t},n.rotateByQuatAppend=function(t,n,r){var a=r[0],e=r[1],u=r[2],o=r[3],i=n[0],s=n[1],c=n[2],f=n[3];return t[0]=i*o+f*a+s*u-c*e,t[1]=s*o+f*e+c*a-i*u,t[2]=c*o+f*u+i*e-s*a,t[3]=f*o-i*a-s*e-c*u,i=n[4],s=n[5],c=n[6],f=n[7],t[4]=i*o+f*a+s*u-c*e,t[5]=s*o+f*e+c*a-i*u,t[6]=c*o+f*u+i*e-s*a,t[7]=f*o-i*a-s*e-c*u,t},n.rotateByQuatPrepend=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*f+o*i+e*c-u*s,t[1]=e*f+o*s+u*i-a*c,t[2]=u*f+o*c+a*s-e*i,t[3]=o*f-a*i-e*s-u*c,i=r[4],s=r[5],c=r[6],f=r[7],t[4]=a*f+o*i+e*c-u*s,t[5]=e*f+o*s+u*i-a*c,t[6]=u*f+o*c+a*s-e*i,t[7]=o*f-a*i-e*s-u*c,t},n.rotateAroundAxis=function(t,n,r,e){if(Math.abs(e)<a.EPSILON)return s(t,n);var u=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);e*=.5;var o=Math.sin(e),i=o*r[0]/u,c=o*r[1]/u,f=o*r[2]/u,M=Math.cos(e),h=n[0],l=n[1],v=n[2],d=n[3];t[0]=h*M+d*i+l*f-v*c,t[1]=l*M+d*c+v*i-h*f,t[2]=v*M+d*f+h*c-l*i,t[3]=d*M-h*i-l*c-v*f;var b=n[4],m=n[5],p=n[6],P=n[7];return t[4]=b*M+P*i+m*f-p*c,t[5]=m*M+P*c+p*i-b*f,t[6]=p*M+P*f+b*c-m*i,t[7]=P*M-b*i-m*c-p*f,t},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t[6]=n[6]+r[6],t[7]=n[7]+r[7],t},n.multiply=c,n.scale=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=n[7]*r,t},n.lerp=function(t,n,r,a){var e=1-a;f(n,r)<0&&(a=-a);return t[0]=n[0]*e+r[0]*a,t[1]=n[1]*e+r[1]*a,t[2]=n[2]*e+r[2]*a,t[3]=n[3]*e+r[3]*a,t[4]=n[4]*e+r[4]*a,t[5]=n[5]*e+r[5]*a,t[6]=n[6]*e+r[6]*a,t[7]=n[7]*e+r[7]*a,t},n.invert=function(t,n){var r=h(n);return t[0]=-n[0]/r,t[1]=-n[1]/r,t[2]=-n[2]/r,t[3]=n[3]/r,t[4]=-n[4]/r,t[5]=-n[5]/r,t[6]=-n[6]/r,t[7]=n[7]/r,t},n.conjugate=function(t,n){return t[0]=-n[0],t[1]=-n[1],t[2]=-n[2],t[3]=n[3],t[4]=-n[4],t[5]=-n[5],t[6]=-n[6],t[7]=n[7],t},n.normalize=function(t,n){var r=h(n);if(r>0){r=Math.sqrt(r);var a=n[0]/r,e=n[1]/r,u=n[2]/r,o=n[3]/r,i=n[4],s=n[5],c=n[6],f=n[7],M=a*i+e*s+u*c+o*f;t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=(i-a*M)/r,t[5]=(s-e*M)/r,t[6]=(c-u*M)/r,t[7]=(f-o*M)/r}return t},n.str=function(t){return\"quat2(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\", \"+t[4]+\", \"+t[5]+\", \"+t[6]+\", \"+t[7]+\")\"},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]&&t[6]===n[6]&&t[7]===n[7]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=t[6],f=t[7],M=n[0],h=n[1],l=n[2],v=n[3],d=n[4],b=n[5],m=n[6],p=n[7];return Math.abs(r-M)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(M))&&Math.abs(e-h)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(h))&&Math.abs(u-l)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(l))&&Math.abs(o-v)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(v))&&Math.abs(i-d)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(d))&&Math.abs(s-b)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(b))&&Math.abs(c-m)<=a.EPSILON*Math.max(1,Math.abs(c),Math.abs(m))&&Math.abs(f-p)<=a.EPSILON*Math.max(1,Math.abs(f),Math.abs(p))};var a=o(r(0)),e=o(r(3)),u=o(r(4));function o(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}function i(t,n,r){var a=.5*r[0],e=.5*r[1],u=.5*r[2],o=n[0],i=n[1],s=n[2],c=n[3];return t[0]=o,t[1]=i,t[2]=s,t[3]=c,t[4]=a*c+e*s-u*i,t[5]=e*c+u*o-a*s,t[6]=u*c+a*i-e*o,t[7]=-a*o-e*i-u*s,t}function s(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t}n.getReal=e.copy;n.setReal=e.copy;function c(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[4],s=r[5],c=r[6],f=r[7],M=n[4],h=n[5],l=n[6],v=n[7],d=r[0],b=r[1],m=r[2],p=r[3];return t[0]=a*p+o*d+e*m-u*b,t[1]=e*p+o*b+u*d-a*m,t[2]=u*p+o*m+a*b-e*d,t[3]=o*p-a*d-e*b-u*m,t[4]=a*f+o*i+e*c-u*s+M*p+v*d+h*m-l*b,t[5]=e*f+o*s+u*i-a*c+h*p+v*b+l*d-M*m,t[6]=u*f+o*c+a*s-e*i+l*p+v*m+M*b-h*d,t[7]=o*f-a*i-e*s-u*c+v*p-M*d-h*b-l*m,t}n.mul=c;var f=n.dot=e.dot;var M=n.length=e.length,h=(n.len=M,n.squaredLength=e.squaredLength);n.sqrLen=h},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(6);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0,t[4]=0,t[5]=0);return t[0]=1,t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(6);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[4]=t[4],n[5]=t[5],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=0,t[5]=0,t},n.fromValues=function(t,n,r,e,u,o){var i=new a.ARRAY_TYPE(6);return i[0]=t,i[1]=n,i[2]=r,i[3]=e,i[4]=u,i[5]=o,i},n.set=function(t,n,r,a,e,u,o){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t[4]=u,t[5]=o,t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=n[4],i=n[5],s=r*u-a*e;if(!s)return null;return s=1/s,t[0]=u*s,t[1]=-a*s,t[2]=-e*s,t[3]=r*s,t[4]=(e*i-u*o)*s,t[5]=(a*o-r*i)*s,t},n.determinant=function(t){return t[0]*t[3]-t[1]*t[2]},n.multiply=e,n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=Math.sin(r),f=Math.cos(r);return t[0]=a*f+u*c,t[1]=e*f+o*c,t[2]=a*-c+u*f,t[3]=e*-c+o*f,t[4]=i,t[5]=s,t},n.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1];return t[0]=a*c,t[1]=e*c,t[2]=u*f,t[3]=o*f,t[4]=i,t[5]=s,t},n.translate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1];return t[0]=a,t[1]=e,t[2]=u,t[3]=o,t[4]=a*c+u*f+i,t[5]=e*c+o*f+s,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t[4]=0,t[5]=0,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t[4]=0,t[5]=0,t},n.fromTranslation=function(t,n){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t[4]=n[0],t[5]=n[1],t},n.str=function(t){return\"mat2d(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\", \"+t[4]+\", \"+t[5]+\")\"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2)+Math.pow(t[4],2)+Math.pow(t[5],2)+1)},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t[4]=n[4]+r[4],t[5]=n[5]+r[5],t},n.subtract=u,n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t[4]=n[4]*r,t[5]=n[5]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t[4]=n[4]+r[4]*a,t[5]=n[5]+r[5]*a,t},n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]&&t[4]===n[4]&&t[5]===n[5]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=t[4],s=t[5],c=n[0],f=n[1],M=n[2],h=n[3],l=n[4],v=n[5];return Math.abs(r-c)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(c))&&Math.abs(e-f)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(f))&&Math.abs(u-M)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(M))&&Math.abs(o-h)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(h))&&Math.abs(i-l)<=a.EPSILON*Math.max(1,Math.abs(i),Math.abs(l))&&Math.abs(s-v)<=a.EPSILON*Math.max(1,Math.abs(s),Math.abs(v))};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=n[4],s=n[5],c=r[0],f=r[1],M=r[2],h=r[3],l=r[4],v=r[5];return t[0]=a*c+u*f,t[1]=e*c+o*f,t[2]=a*M+u*h,t[3]=e*M+o*h,t[4]=a*l+u*v+i,t[5]=e*l+o*v+s,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t[4]=n[4]-r[4],t[5]=n[5]-r[5],t}n.mul=e,n.sub=u},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.sub=n.mul=void 0,n.create=function(){var t=new a.ARRAY_TYPE(4);a.ARRAY_TYPE!=Float32Array&&(t[1]=0,t[2]=0);return t[0]=1,t[3]=1,t},n.clone=function(t){var n=new a.ARRAY_TYPE(4);return n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n},n.copy=function(t,n){return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t},n.identity=function(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=1,t},n.fromValues=function(t,n,r,e){var u=new a.ARRAY_TYPE(4);return u[0]=t,u[1]=n,u[2]=r,u[3]=e,u},n.set=function(t,n,r,a,e){return t[0]=n,t[1]=r,t[2]=a,t[3]=e,t},n.transpose=function(t,n){if(t===n){var r=n[1];t[1]=n[2],t[2]=r}else t[0]=n[0],t[1]=n[2],t[2]=n[1],t[3]=n[3];return t},n.invert=function(t,n){var r=n[0],a=n[1],e=n[2],u=n[3],o=r*u-e*a;if(!o)return null;return o=1/o,t[0]=u*o,t[1]=-a*o,t[2]=-e*o,t[3]=r*o,t},n.adjoint=function(t,n){var r=n[0];return t[0]=n[3],t[1]=-n[1],t[2]=-n[2],t[3]=r,t},n.determinant=function(t){return t[0]*t[3]-t[2]*t[1]},n.multiply=e,n.rotate=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=Math.sin(r),s=Math.cos(r);return t[0]=a*s+u*i,t[1]=e*s+o*i,t[2]=a*-i+u*s,t[3]=e*-i+o*s,t},n.scale=function(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1];return t[0]=a*i,t[1]=e*i,t[2]=u*s,t[3]=o*s,t},n.fromRotation=function(t,n){var r=Math.sin(n),a=Math.cos(n);return t[0]=a,t[1]=r,t[2]=-r,t[3]=a,t},n.fromScaling=function(t,n){return t[0]=n[0],t[1]=0,t[2]=0,t[3]=n[1],t},n.str=function(t){return\"mat2(\"+t[0]+\", \"+t[1]+\", \"+t[2]+\", \"+t[3]+\")\"},n.frob=function(t){return Math.sqrt(Math.pow(t[0],2)+Math.pow(t[1],2)+Math.pow(t[2],2)+Math.pow(t[3],2))},n.LDU=function(t,n,r,a){return t[2]=a[2]/a[0],r[0]=a[0],r[1]=a[1],r[3]=a[3]-t[2]*r[1],[t,n,r]},n.add=function(t,n,r){return t[0]=n[0]+r[0],t[1]=n[1]+r[1],t[2]=n[2]+r[2],t[3]=n[3]+r[3],t},n.subtract=u,n.exactEquals=function(t,n){return t[0]===n[0]&&t[1]===n[1]&&t[2]===n[2]&&t[3]===n[3]},n.equals=function(t,n){var r=t[0],e=t[1],u=t[2],o=t[3],i=n[0],s=n[1],c=n[2],f=n[3];return Math.abs(r-i)<=a.EPSILON*Math.max(1,Math.abs(r),Math.abs(i))&&Math.abs(e-s)<=a.EPSILON*Math.max(1,Math.abs(e),Math.abs(s))&&Math.abs(u-c)<=a.EPSILON*Math.max(1,Math.abs(u),Math.abs(c))&&Math.abs(o-f)<=a.EPSILON*Math.max(1,Math.abs(o),Math.abs(f))},n.multiplyScalar=function(t,n,r){return t[0]=n[0]*r,t[1]=n[1]*r,t[2]=n[2]*r,t[3]=n[3]*r,t},n.multiplyScalarAndAdd=function(t,n,r,a){return t[0]=n[0]+r[0]*a,t[1]=n[1]+r[1]*a,t[2]=n[2]+r[2]*a,t[3]=n[3]+r[3]*a,t};var a=function(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}(r(0));function e(t,n,r){var a=n[0],e=n[1],u=n[2],o=n[3],i=r[0],s=r[1],c=r[2],f=r[3];return t[0]=a*i+u*s,t[1]=e*i+o*s,t[2]=a*c+u*f,t[3]=e*c+o*f,t}function u(t,n,r){return t[0]=n[0]-r[0],t[1]=n[1]-r[1],t[2]=n[2]-r[2],t[3]=n[3]-r[3],t}n.mul=e,n.sub=u},function(t,n,r){\"use strict\";Object.defineProperty(n,\"__esModule\",{value:!0}),n.vec4=n.vec3=n.vec2=n.quat2=n.quat=n.mat4=n.mat3=n.mat2d=n.mat2=n.glMatrix=void 0;var a=l(r(0)),e=l(r(9)),u=l(r(8)),o=l(r(5)),i=l(r(4)),s=l(r(3)),c=l(r(7)),f=l(r(6)),M=l(r(2)),h=l(r(1));function l(t){if(t&&t.__esModule)return t;var n={};if(null!=t)for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r]);return n.default=t,n}n.glMatrix=a,n.mat2=e,n.mat2d=u,n.mat3=o,n.mat4=i,n.quat=s,n.quat2=c,n.vec2=f,n.vec3=M,n.vec4=h}])});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvZGlzdC9nbC1tYXRyaXguanM/NGE1MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSwyQkFBd0UsMkRBQTJELEtBQUssVUFBVSw2REFBNkQsK0NBQStDLG1CQUFtQixTQUFTLGNBQWMsNEJBQTRCLFlBQVkscUJBQXFCLDJEQUEyRCx1Q0FBdUMscUNBQXFDLG9CQUFvQixFQUFFLGlCQUFpQiw0RkFBNEYsZUFBZSx3Q0FBd0MsU0FBUyxFQUFFLG1CQUFtQiw4QkFBOEIscURBQXFELDBCQUEwQiw2Q0FBNkMsc0JBQXNCLDZEQUE2RCxZQUFZLGVBQWUsU0FBUyxpQkFBaUIsaUNBQWlDLGlCQUFpQixZQUFZLFVBQVUsc0JBQXNCLG1CQUFtQixpREFBaUQsa0JBQWtCLGtCQUFrQixhQUFhLHNDQUFzQyxTQUFTLG1DQUFtQyxlQUFlLHdCQUF3QixXQUFXLHdCQUF3Qiw2REFBNkQscUJBQXFCLHNGQUFzRixrQkFBa0IsaUJBQWlCLGFBQWEsc0NBQXNDLFNBQVMsb0dBQW9HLDBCQUEwQixpREFBaUQsZ0NBQWdDLDBCQUEwQixxQ0FBcUMsc0JBQXNCLGlEQUFpRCwyQkFBMkIscUNBQXFDLHVCQUF1QixxRUFBcUUsMkRBQTJELDZGQUE2Rix1QkFBdUIsaUdBQWlHLHVCQUF1Qiw2R0FBNkcsdUJBQXVCLDZHQUE2Ryx1QkFBdUIsaUdBQWlHLHlCQUF5Qix5REFBeUQsaUNBQWlDLDZFQUE2RSxzRkFBc0YscURBQXFELHlCQUF5Qix5REFBeUQsMkJBQTJCLGtEQUFrRCw0REFBNEQsU0FBUyxxQkFBcUIsK0NBQStDLDBCQUEwQixnQ0FBZ0MsaUZBQWlGLHdCQUF3QixnQkFBZ0IsT0FBTyxHQUFHLDRDQUE0QyxZ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d0YsMkZBQTJGLGtCQUFrQixtR0FBbUcsZ0JBQWdCLGlCQUFpQixhQUFhLHNDQUFzQyxTQUFTLHlDQUF5QywwQkFBMEIsNENBQTRDLHVCQUF1QixxQkFBcUIsMEJBQTBCLGlEQUFpRCxzQkFBc0IsaURBQWlELHdCQUF3QixxQ0FBcUMsZ0NBQWdDLDBCQUEwQixxQ0FBcUMsMkJBQTJCLHFDQUFxQywyQkFBMkIsVUFBVSxXQUFXLGlCQUFpQiw2Q0FBNkMsU0FBUyx3QkFBd0IsMENBQTBDLGtCQUFrQixxREFBcUQseUJBQXlCLFdBQVcsZ0RBQWdELDJCQUEyQiwyQkFBMkIsdUNBQXVDLDREQUE0RCwrREFBK0QseUJBQXlCLDhDQUE4Qyw2Q0FBNkMsOEJBQThCLGdDQUFnQyxzQ0FBc0MsNkJBQTZCLDJDQUEyQyxtQkFBbUIscURBQXFELG9CQUFvQixzRkFBc0YseUJBQXlCLHNFQUFzRSx1QkFBdUIscUVBQXFFLDBDQUEwQywwREFBMEQsd0JBQXdCLDREQUE0RCw4UEFBOFAsa0NBQWtDLHlEQUF5RCwwQ0FBMEMsOEVBQThFLGtCQUFrQiw0QkFBNEIsU0FBUyxpRkFBaUYscUJBQXFCLE9BQU8sa0JBQWtCLDREQUE0RCw2REFBNkQsa0JBQWtCLHFFQUFxRSxnQkFBZ0IsaUJBQWlCLGFBQWEsc0NBQXNDLFNBQVMscUZBQXFGLHdHQUF3RyxjQUFjLDRCQUE0QixTQUFTLGlGQUFpRixxQkFBcUIsZ0dBQWdHLEdBQUciLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbkBhdXRob3IgQnJhbmRvbiBKb25lc1xuQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbkB2ZXJzaW9uIDIuNy4wXG5cbkNvcHlyaWdodCAoYykgMjAxNS0yMDE4LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cbiFmdW5jdGlvbih0LG4pe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPW4oKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sbik7ZWxzZXt2YXIgcj1uKCk7Zm9yKHZhciBhIGluIHIpKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHM6dClbYV09clthXX19KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbih0KXt2YXIgbj17fTtmdW5jdGlvbiByKGEpe2lmKG5bYV0pcmV0dXJuIG5bYV0uZXhwb3J0czt2YXIgZT1uW2FdPXtpOmEsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gdFthXS5jYWxsKGUuZXhwb3J0cyxlLGUuZXhwb3J0cyxyKSxlLmw9ITAsZS5leHBvcnRzfXJldHVybiByLm09dCxyLmM9bixyLmQ9ZnVuY3Rpb24odCxuLGEpe3Iubyh0LG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxuLHtlbnVtZXJhYmxlOiEwLGdldDphfSl9LHIucj1mdW5jdGlvbih0KXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24odCxuKXtpZigxJm4mJih0PXIodCkpLDgmbilyZXR1cm4gdDtpZig0Jm4mJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIGE9T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIoYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImbiYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciBlIGluIHQpci5kKGEsZSxmdW5jdGlvbihuKXtyZXR1cm4gdFtuXX0uYmluZChudWxsLGUpKTtyZXR1cm4gYX0sci5uPWZ1bmN0aW9uKHQpe3ZhciBuPXQmJnQuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiB0LmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIHR9O3JldHVybiByLmQobixcImFcIixuKSxufSxyLm89ZnVuY3Rpb24odCxuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbil9LHIucD1cIlwiLHIoci5zPTEwKX0oW2Z1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnNldE1hdHJpeEFycmF5VHlwZT1mdW5jdGlvbih0KXtuLkFSUkFZX1RZUEU9dH0sbi50b1JhZGlhbj1mdW5jdGlvbih0KXtyZXR1cm4gdCplfSxuLmVxdWFscz1mdW5jdGlvbih0LG4pe3JldHVybiBNYXRoLmFicyh0LW4pPD1hKk1hdGgubWF4KDEsTWF0aC5hYnModCksTWF0aC5hYnMobikpfTt2YXIgYT1uLkVQU0lMT049MWUtNjtuLkFSUkFZX1RZUEU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIEZsb2F0MzJBcnJheT9GbG9hdDMyQXJyYXk6QXJyYXksbi5SQU5ET009TWF0aC5yYW5kb207dmFyIGU9TWF0aC5QSS8xODB9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLmZvckVhY2g9bi5zcXJMZW49bi5sZW49bi5zcXJEaXN0PW4uZGlzdD1uLmRpdj1uLm11bD1uLnN1Yj12b2lkIDAsbi5jcmVhdGU9ZSxuLmNsb25lPWZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIG5bMF09dFswXSxuWzFdPXRbMV0sblsyXT10WzJdLG5bM109dFszXSxufSxuLmZyb21WYWx1ZXM9ZnVuY3Rpb24odCxuLHIsZSl7dmFyIHU9bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gdVswXT10LHVbMV09bix1WzJdPXIsdVszXT1lLHV9LG4uY29weT1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdH0sbi5zZXQ9ZnVuY3Rpb24odCxuLHIsYSxlKXtyZXR1cm4gdFswXT1uLHRbMV09cix0WzJdPWEsdFszXT1lLHR9LG4uYWRkPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0sdFsxXT1uWzFdK3JbMV0sdFsyXT1uWzJdK3JbMl0sdFszXT1uWzNdK3JbM10sdH0sbi5zdWJ0cmFjdD11LG4ubXVsdGlwbHk9byxuLmRpdmlkZT1pLG4uY2VpbD1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPU1hdGguY2VpbChuWzBdKSx0WzFdPU1hdGguY2VpbChuWzFdKSx0WzJdPU1hdGguY2VpbChuWzJdKSx0WzNdPU1hdGguY2VpbChuWzNdKSx0fSxuLmZsb29yPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09TWF0aC5mbG9vcihuWzBdKSx0WzFdPU1hdGguZmxvb3IoblsxXSksdFsyXT1NYXRoLmZsb29yKG5bMl0pLHRbM109TWF0aC5mbG9vcihuWzNdKSx0fSxuLm1pbj1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09TWF0aC5taW4oblswXSxyWzBdKSx0WzFdPU1hdGgubWluKG5bMV0sclsxXSksdFsyXT1NYXRoLm1pbihuWzJdLHJbMl0pLHRbM109TWF0aC5taW4oblszXSxyWzNdKSx0fSxuLm1heD1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09TWF0aC5tYXgoblswXSxyWzBdKSx0WzFdPU1hdGgubWF4KG5bMV0sclsxXSksdFsyXT1NYXRoLm1heChuWzJdLHJbMl0pLHRbM109TWF0aC5tYXgoblszXSxyWzNdKSx0fSxuLnJvdW5kPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09TWF0aC5yb3VuZChuWzBdKSx0WzFdPU1hdGgucm91bmQoblsxXSksdFsyXT1NYXRoLnJvdW5kKG5bMl0pLHRbM109TWF0aC5yb3VuZChuWzNdKSx0fSxuLnNjYWxlPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdKnIsdFsxXT1uWzFdKnIsdFsyXT1uWzJdKnIsdFszXT1uWzNdKnIsdH0sbi5zY2FsZUFuZEFkZD1mdW5jdGlvbih0LG4scixhKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0qYSx0WzFdPW5bMV0rclsxXSphLHRbMl09blsyXStyWzJdKmEsdFszXT1uWzNdK3JbM10qYSx0fSxuLmRpc3RhbmNlPXMsbi5zcXVhcmVkRGlzdGFuY2U9YyxuLmxlbmd0aD1mLG4uc3F1YXJlZExlbmd0aD1NLG4ubmVnYXRlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09LW5bMF0sdFsxXT0tblsxXSx0WzJdPS1uWzJdLHRbM109LW5bM10sdH0sbi5pbnZlcnNlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09MS9uWzBdLHRbMV09MS9uWzFdLHRbMl09MS9uWzJdLHRbM109MS9uWzNdLHR9LG4ubm9ybWFsaXplPWZ1bmN0aW9uKHQsbil7dmFyIHI9blswXSxhPW5bMV0sZT1uWzJdLHU9blszXSxvPXIqcithKmErZSplK3UqdTtvPjAmJihvPTEvTWF0aC5zcXJ0KG8pLHRbMF09cipvLHRbMV09YSpvLHRbMl09ZSpvLHRbM109dSpvKTtyZXR1cm4gdH0sbi5kb3Q9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXSpuWzBdK3RbMV0qblsxXSt0WzJdKm5bMl0rdFszXSpuWzNdfSxuLmxlcnA9ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9blswXSx1PW5bMV0sbz1uWzJdLGk9blszXTtyZXR1cm4gdFswXT1lK2EqKHJbMF0tZSksdFsxXT11K2EqKHJbMV0tdSksdFsyXT1vK2EqKHJbMl0tbyksdFszXT1pK2EqKHJbM10taSksdH0sbi5yYW5kb209ZnVuY3Rpb24odCxuKXt2YXIgcixlLHUsbyxpLHM7bj1ufHwxO2Rve3I9MiphLlJBTkRPTSgpLTEsZT0yKmEuUkFORE9NKCktMSxpPXIqcitlKmV9d2hpbGUoaT49MSk7ZG97dT0yKmEuUkFORE9NKCktMSxvPTIqYS5SQU5ET00oKS0xLHM9dSp1K28qb313aGlsZShzPj0xKTt2YXIgYz1NYXRoLnNxcnQoKDEtaSkvcyk7cmV0dXJuIHRbMF09bipyLHRbMV09biplLHRbMl09bip1KmMsdFszXT1uKm8qYyx0fSxuLnRyYW5zZm9ybU1hdDQ9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM107cmV0dXJuIHRbMF09clswXSphK3JbNF0qZStyWzhdKnUrclsxMl0qbyx0WzFdPXJbMV0qYStyWzVdKmUrcls5XSp1K3JbMTNdKm8sdFsyXT1yWzJdKmErcls2XSplK3JbMTBdKnUrclsxNF0qbyx0WzNdPXJbM10qYStyWzddKmUrclsxMV0qdStyWzE1XSpvLHR9LG4udHJhbnNmb3JtUXVhdD1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89clswXSxpPXJbMV0scz1yWzJdLGM9clszXSxmPWMqYStpKnUtcyplLE09YyplK3MqYS1vKnUsaD1jKnUrbyplLWkqYSxsPS1vKmEtaSplLXMqdTtyZXR1cm4gdFswXT1mKmMrbCotbytNKi1zLWgqLWksdFsxXT1NKmMrbCotaStoKi1vLWYqLXMsdFsyXT1oKmMrbCotcytmKi1pLU0qLW8sdFszXT1uWzNdLHR9LG4uc3RyPWZ1bmN0aW9uKHQpe3JldHVyblwidmVjNChcIit0WzBdK1wiLCBcIit0WzFdK1wiLCBcIit0WzJdK1wiLCBcIit0WzNdK1wiKVwifSxuLmV4YWN0RXF1YWxzPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09PT1uWzBdJiZ0WzFdPT09blsxXSYmdFsyXT09PW5bMl0mJnRbM109PT1uWzNdfSxuLmVxdWFscz1mdW5jdGlvbih0LG4pe3ZhciByPXRbMF0sZT10WzFdLHU9dFsyXSxvPXRbM10saT1uWzBdLHM9blsxXSxjPW5bMl0sZj1uWzNdO3JldHVybiBNYXRoLmFicyhyLWkpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhyKSxNYXRoLmFicyhpKSkmJk1hdGguYWJzKGUtcyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGUpLE1hdGguYWJzKHMpKSYmTWF0aC5hYnModS1jKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModSksTWF0aC5hYnMoYykpJiZNYXRoLmFicyhvLWYpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvKSxNYXRoLmFicyhmKSl9O3ZhciBhPWZ1bmN0aW9uKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgbj17fTtpZihudWxsIT10KWZvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYobltyXT10W3JdKTtyZXR1cm4gbi5kZWZhdWx0PXQsbn0ocigwKSk7ZnVuY3Rpb24gZSgpe3ZhciB0PW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYodFswXT0wLHRbMV09MCx0WzJdPTAsdFszXT0wKSx0fWZ1bmN0aW9uIHUodCxuLHIpe3JldHVybiB0WzBdPW5bMF0tclswXSx0WzFdPW5bMV0tclsxXSx0WzJdPW5bMl0tclsyXSx0WzNdPW5bM10tclszXSx0fWZ1bmN0aW9uIG8odCxuLHIpe3JldHVybiB0WzBdPW5bMF0qclswXSx0WzFdPW5bMV0qclsxXSx0WzJdPW5bMl0qclsyXSx0WzNdPW5bM10qclszXSx0fWZ1bmN0aW9uIGkodCxuLHIpe3JldHVybiB0WzBdPW5bMF0vclswXSx0WzFdPW5bMV0vclsxXSx0WzJdPW5bMl0vclsyXSx0WzNdPW5bM10vclszXSx0fWZ1bmN0aW9uIHModCxuKXt2YXIgcj1uWzBdLXRbMF0sYT1uWzFdLXRbMV0sZT1uWzJdLXRbMl0sdT1uWzNdLXRbM107cmV0dXJuIE1hdGguc3FydChyKnIrYSphK2UqZSt1KnUpfWZ1bmN0aW9uIGModCxuKXt2YXIgcj1uWzBdLXRbMF0sYT1uWzFdLXRbMV0sZT1uWzJdLXRbMl0sdT1uWzNdLXRbM107cmV0dXJuIHIqcithKmErZSplK3UqdX1mdW5jdGlvbiBmKHQpe3ZhciBuPXRbMF0scj10WzFdLGE9dFsyXSxlPXRbM107cmV0dXJuIE1hdGguc3FydChuKm4rcipyK2EqYStlKmUpfWZ1bmN0aW9uIE0odCl7dmFyIG49dFswXSxyPXRbMV0sYT10WzJdLGU9dFszXTtyZXR1cm4gbipuK3IqcithKmErZSplfW4uc3ViPXUsbi5tdWw9byxuLmRpdj1pLG4uZGlzdD1zLG4uc3FyRGlzdD1jLG4ubGVuPWYsbi5zcXJMZW49TSxuLmZvckVhY2g9ZnVuY3Rpb24oKXt2YXIgdD1lKCk7cmV0dXJuIGZ1bmN0aW9uKG4scixhLGUsdSxvKXt2YXIgaT12b2lkIDAscz12b2lkIDA7Zm9yKHJ8fChyPTQpLGF8fChhPTApLHM9ZT9NYXRoLm1pbihlKnIrYSxuLmxlbmd0aCk6bi5sZW5ndGgsaT1hO2k8cztpKz1yKXRbMF09bltpXSx0WzFdPW5baSsxXSx0WzJdPW5baSsyXSx0WzNdPW5baSszXSx1KHQsdCxvKSxuW2ldPXRbMF0sbltpKzFdPXRbMV0sbltpKzJdPXRbMl0sbltpKzNdPXRbM107cmV0dXJuIG59fSgpfSxmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5mb3JFYWNoPW4uc3FyTGVuPW4ubGVuPW4uc3FyRGlzdD1uLmRpc3Q9bi5kaXY9bi5tdWw9bi5zdWI9dm9pZCAwLG4uY3JlYXRlPWUsbi5jbG9uZT1mdW5jdGlvbih0KXt2YXIgbj1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiBuWzBdPXRbMF0sblsxXT10WzFdLG5bMl09dFsyXSxufSxuLmxlbmd0aD11LG4uZnJvbVZhbHVlcz1vLG4uY29weT1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0fSxuLnNldD1mdW5jdGlvbih0LG4scixhKXtyZXR1cm4gdFswXT1uLHRbMV09cix0WzJdPWEsdH0sbi5hZGQ9ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPW5bMF0rclswXSx0WzFdPW5bMV0rclsxXSx0WzJdPW5bMl0rclsyXSx0fSxuLnN1YnRyYWN0PWksbi5tdWx0aXBseT1zLG4uZGl2aWRlPWMsbi5jZWlsPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09TWF0aC5jZWlsKG5bMF0pLHRbMV09TWF0aC5jZWlsKG5bMV0pLHRbMl09TWF0aC5jZWlsKG5bMl0pLHR9LG4uZmxvb3I9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT1NYXRoLmZsb29yKG5bMF0pLHRbMV09TWF0aC5mbG9vcihuWzFdKSx0WzJdPU1hdGguZmxvb3IoblsyXSksdH0sbi5taW49ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPU1hdGgubWluKG5bMF0sclswXSksdFsxXT1NYXRoLm1pbihuWzFdLHJbMV0pLHRbMl09TWF0aC5taW4oblsyXSxyWzJdKSx0fSxuLm1heD1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09TWF0aC5tYXgoblswXSxyWzBdKSx0WzFdPU1hdGgubWF4KG5bMV0sclsxXSksdFsyXT1NYXRoLm1heChuWzJdLHJbMl0pLHR9LG4ucm91bmQ9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT1NYXRoLnJvdW5kKG5bMF0pLHRbMV09TWF0aC5yb3VuZChuWzFdKSx0WzJdPU1hdGgucm91bmQoblsyXSksdH0sbi5zY2FsZT1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyLHR9LG4uc2NhbGVBbmRBZGQ9ZnVuY3Rpb24odCxuLHIsYSl7cmV0dXJuIHRbMF09blswXStyWzBdKmEsdFsxXT1uWzFdK3JbMV0qYSx0WzJdPW5bMl0rclsyXSphLHR9LG4uZGlzdGFuY2U9ZixuLnNxdWFyZWREaXN0YW5jZT1NLG4uc3F1YXJlZExlbmd0aD1oLG4ubmVnYXRlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09LW5bMF0sdFsxXT0tblsxXSx0WzJdPS1uWzJdLHR9LG4uaW52ZXJzZT1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPTEvblswXSx0WzFdPTEvblsxXSx0WzJdPTEvblsyXSx0fSxuLm5vcm1hbGl6ZT1sLG4uZG90PXYsbi5jcm9zcz1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89clswXSxpPXJbMV0scz1yWzJdO3JldHVybiB0WzBdPWUqcy11KmksdFsxXT11Km8tYSpzLHRbMl09YSppLWUqbyx0fSxuLmxlcnA9ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9blswXSx1PW5bMV0sbz1uWzJdO3JldHVybiB0WzBdPWUrYSooclswXS1lKSx0WzFdPXUrYSooclsxXS11KSx0WzJdPW8rYSooclsyXS1vKSx0fSxuLmhlcm1pdGU9ZnVuY3Rpb24odCxuLHIsYSxlLHUpe3ZhciBvPXUqdSxpPW8qKDIqdS0zKSsxLHM9byoodS0yKSt1LGM9byoodS0xKSxmPW8qKDMtMip1KTtyZXR1cm4gdFswXT1uWzBdKmkrclswXSpzK2FbMF0qYytlWzBdKmYsdFsxXT1uWzFdKmkrclsxXSpzK2FbMV0qYytlWzFdKmYsdFsyXT1uWzJdKmkrclsyXSpzK2FbMl0qYytlWzJdKmYsdH0sbi5iZXppZXI9ZnVuY3Rpb24odCxuLHIsYSxlLHUpe3ZhciBvPTEtdSxpPW8qbyxzPXUqdSxjPWkqbyxmPTMqdSppLE09MypzKm8saD1zKnU7cmV0dXJuIHRbMF09blswXSpjK3JbMF0qZithWzBdKk0rZVswXSpoLHRbMV09blsxXSpjK3JbMV0qZithWzFdKk0rZVsxXSpoLHRbMl09blsyXSpjK3JbMl0qZithWzJdKk0rZVsyXSpoLHR9LG4ucmFuZG9tPWZ1bmN0aW9uKHQsbil7bj1ufHwxO3ZhciByPTIqYS5SQU5ET00oKSpNYXRoLlBJLGU9MiphLlJBTkRPTSgpLTEsdT1NYXRoLnNxcnQoMS1lKmUpKm47cmV0dXJuIHRbMF09TWF0aC5jb3MocikqdSx0WzFdPU1hdGguc2luKHIpKnUsdFsyXT1lKm4sdH0sbi50cmFuc2Zvcm1NYXQ0PWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1yWzNdKmErcls3XSplK3JbMTFdKnUrclsxNV07cmV0dXJuIG89b3x8MSx0WzBdPShyWzBdKmErcls0XSplK3JbOF0qdStyWzEyXSkvbyx0WzFdPShyWzFdKmErcls1XSplK3JbOV0qdStyWzEzXSkvbyx0WzJdPShyWzJdKmErcls2XSplK3JbMTBdKnUrclsxNF0pL28sdH0sbi50cmFuc2Zvcm1NYXQzPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl07cmV0dXJuIHRbMF09YSpyWzBdK2UqclszXSt1KnJbNl0sdFsxXT1hKnJbMV0rZSpyWzRdK3Uqcls3XSx0WzJdPWEqclsyXStlKnJbNV0rdSpyWzhdLHR9LG4udHJhbnNmb3JtUXVhdD1mdW5jdGlvbih0LG4scil7dmFyIGE9clswXSxlPXJbMV0sdT1yWzJdLG89clszXSxpPW5bMF0scz1uWzFdLGM9blsyXSxmPWUqYy11KnMsTT11KmktYSpjLGg9YSpzLWUqaSxsPWUqaC11Kk0sdj11KmYtYSpoLGQ9YSpNLWUqZixiPTIqbztyZXR1cm4gZio9YixNKj1iLGgqPWIsbCo9Mix2Kj0yLGQqPTIsdFswXT1pK2YrbCx0WzFdPXMrTSt2LHRbMl09YytoK2QsdH0sbi5yb3RhdGVYPWZ1bmN0aW9uKHQsbixyLGEpe3ZhciBlPVtdLHU9W107cmV0dXJuIGVbMF09blswXS1yWzBdLGVbMV09blsxXS1yWzFdLGVbMl09blsyXS1yWzJdLHVbMF09ZVswXSx1WzFdPWVbMV0qTWF0aC5jb3MoYSktZVsyXSpNYXRoLnNpbihhKSx1WzJdPWVbMV0qTWF0aC5zaW4oYSkrZVsyXSpNYXRoLmNvcyhhKSx0WzBdPXVbMF0rclswXSx0WzFdPXVbMV0rclsxXSx0WzJdPXVbMl0rclsyXSx0fSxuLnJvdGF0ZVk9ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9W10sdT1bXTtyZXR1cm4gZVswXT1uWzBdLXJbMF0sZVsxXT1uWzFdLXJbMV0sZVsyXT1uWzJdLXJbMl0sdVswXT1lWzJdKk1hdGguc2luKGEpK2VbMF0qTWF0aC5jb3MoYSksdVsxXT1lWzFdLHVbMl09ZVsyXSpNYXRoLmNvcyhhKS1lWzBdKk1hdGguc2luKGEpLHRbMF09dVswXStyWzBdLHRbMV09dVsxXStyWzFdLHRbMl09dVsyXStyWzJdLHR9LG4ucm90YXRlWj1mdW5jdGlvbih0LG4scixhKXt2YXIgZT1bXSx1PVtdO3JldHVybiBlWzBdPW5bMF0tclswXSxlWzFdPW5bMV0tclsxXSxlWzJdPW5bMl0tclsyXSx1WzBdPWVbMF0qTWF0aC5jb3MoYSktZVsxXSpNYXRoLnNpbihhKSx1WzFdPWVbMF0qTWF0aC5zaW4oYSkrZVsxXSpNYXRoLmNvcyhhKSx1WzJdPWVbMl0sdFswXT11WzBdK3JbMF0sdFsxXT11WzFdK3JbMV0sdFsyXT11WzJdK3JbMl0sdH0sbi5hbmdsZT1mdW5jdGlvbih0LG4pe3ZhciByPW8odFswXSx0WzFdLHRbMl0pLGE9byhuWzBdLG5bMV0sblsyXSk7bChyLHIpLGwoYSxhKTt2YXIgZT12KHIsYSk7cmV0dXJuIGU+MT8wOmU8LTE/TWF0aC5QSTpNYXRoLmFjb3MoZSl9LG4uc3RyPWZ1bmN0aW9uKHQpe3JldHVyblwidmVjMyhcIit0WzBdK1wiLCBcIit0WzFdK1wiLCBcIit0WzJdK1wiKVwifSxuLmV4YWN0RXF1YWxzPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09PT1uWzBdJiZ0WzFdPT09blsxXSYmdFsyXT09PW5bMl19LG4uZXF1YWxzPWZ1bmN0aW9uKHQsbil7dmFyIHI9dFswXSxlPXRbMV0sdT10WzJdLG89blswXSxpPW5bMV0scz1uWzJdO3JldHVybiBNYXRoLmFicyhyLW8pPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhyKSxNYXRoLmFicyhvKSkmJk1hdGguYWJzKGUtaSk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGUpLE1hdGguYWJzKGkpKSYmTWF0aC5hYnModS1zKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModSksTWF0aC5hYnMocykpfTt2YXIgYT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49e307aWYobnVsbCE9dClmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG4uZGVmYXVsdD10LG59KHIoMCkpO2Z1bmN0aW9uIGUoKXt2YXIgdD1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiBhLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHRbMF09MCx0WzFdPTAsdFsyXT0wKSx0fWZ1bmN0aW9uIHUodCl7dmFyIG49dFswXSxyPXRbMV0sYT10WzJdO3JldHVybiBNYXRoLnNxcnQobipuK3IqcithKmEpfWZ1bmN0aW9uIG8odCxuLHIpe3ZhciBlPW5ldyBhLkFSUkFZX1RZUEUoMyk7cmV0dXJuIGVbMF09dCxlWzFdPW4sZVsyXT1yLGV9ZnVuY3Rpb24gaSh0LG4scil7cmV0dXJuIHRbMF09blswXS1yWzBdLHRbMV09blsxXS1yWzFdLHRbMl09blsyXS1yWzJdLHR9ZnVuY3Rpb24gcyh0LG4scil7cmV0dXJuIHRbMF09blswXSpyWzBdLHRbMV09blsxXSpyWzFdLHRbMl09blsyXSpyWzJdLHR9ZnVuY3Rpb24gYyh0LG4scil7cmV0dXJuIHRbMF09blswXS9yWzBdLHRbMV09blsxXS9yWzFdLHRbMl09blsyXS9yWzJdLHR9ZnVuY3Rpb24gZih0LG4pe3ZhciByPW5bMF0tdFswXSxhPW5bMV0tdFsxXSxlPW5bMl0tdFsyXTtyZXR1cm4gTWF0aC5zcXJ0KHIqcithKmErZSplKX1mdW5jdGlvbiBNKHQsbil7dmFyIHI9blswXS10WzBdLGE9blsxXS10WzFdLGU9blsyXS10WzJdO3JldHVybiByKnIrYSphK2UqZX1mdW5jdGlvbiBoKHQpe3ZhciBuPXRbMF0scj10WzFdLGE9dFsyXTtyZXR1cm4gbipuK3IqcithKmF9ZnVuY3Rpb24gbCh0LG4pe3ZhciByPW5bMF0sYT1uWzFdLGU9blsyXSx1PXIqcithKmErZSplO3JldHVybiB1PjAmJih1PTEvTWF0aC5zcXJ0KHUpLHRbMF09blswXSp1LHRbMV09blsxXSp1LHRbMl09blsyXSp1KSx0fWZ1bmN0aW9uIHYodCxuKXtyZXR1cm4gdFswXSpuWzBdK3RbMV0qblsxXSt0WzJdKm5bMl19bi5zdWI9aSxuLm11bD1zLG4uZGl2PWMsbi5kaXN0PWYsbi5zcXJEaXN0PU0sbi5sZW49dSxuLnNxckxlbj1oLG4uZm9yRWFjaD1mdW5jdGlvbigpe3ZhciB0PWUoKTtyZXR1cm4gZnVuY3Rpb24obixyLGEsZSx1LG8pe3ZhciBpPXZvaWQgMCxzPXZvaWQgMDtmb3Iocnx8KHI9MyksYXx8KGE9MCkscz1lP01hdGgubWluKGUqcithLG4ubGVuZ3RoKTpuLmxlbmd0aCxpPWE7aTxzO2krPXIpdFswXT1uW2ldLHRbMV09bltpKzFdLHRbMl09bltpKzJdLHUodCx0LG8pLG5baV09dFswXSxuW2krMV09dFsxXSxuW2krMl09dFsyXTtyZXR1cm4gbn19KCl9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnNldEF4ZXM9bi5zcWxlcnA9bi5yb3RhdGlvblRvPW4uZXF1YWxzPW4uZXhhY3RFcXVhbHM9bi5ub3JtYWxpemU9bi5zcXJMZW49bi5zcXVhcmVkTGVuZ3RoPW4ubGVuPW4ubGVuZ3RoPW4ubGVycD1uLmRvdD1uLnNjYWxlPW4ubXVsPW4uYWRkPW4uc2V0PW4uY29weT1uLmZyb21WYWx1ZXM9bi5jbG9uZT12b2lkIDAsbi5jcmVhdGU9cyxuLmlkZW50aXR5PWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPTAsdFsxXT0wLHRbMl09MCx0WzNdPTEsdH0sbi5zZXRBeGlzQW5nbGU9YyxuLmdldEF4aXNBbmdsZT1mdW5jdGlvbih0LG4pe3ZhciByPTIqTWF0aC5hY29zKG5bM10pLGU9TWF0aC5zaW4oci8yKTtlPmEuRVBTSUxPTj8odFswXT1uWzBdL2UsdFsxXT1uWzFdL2UsdFsyXT1uWzJdL2UpOih0WzBdPTEsdFsxXT0wLHRbMl09MCk7cmV0dXJuIHJ9LG4ubXVsdGlwbHk9ZixuLnJvdGF0ZVg9ZnVuY3Rpb24odCxuLHIpe3IqPS41O3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT1NYXRoLnNpbihyKSxzPU1hdGguY29zKHIpO3JldHVybiB0WzBdPWEqcytvKmksdFsxXT1lKnMrdSppLHRbMl09dSpzLWUqaSx0WzNdPW8qcy1hKmksdH0sbi5yb3RhdGVZPWZ1bmN0aW9uKHQsbixyKXtyKj0uNTt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9TWF0aC5zaW4ocikscz1NYXRoLmNvcyhyKTtyZXR1cm4gdFswXT1hKnMtdSppLHRbMV09ZSpzK28qaSx0WzJdPXUqcythKmksdFszXT1vKnMtZSppLHR9LG4ucm90YXRlWj1mdW5jdGlvbih0LG4scil7cio9LjU7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89blszXSxpPU1hdGguc2luKHIpLHM9TWF0aC5jb3Mocik7cmV0dXJuIHRbMF09YSpzK2UqaSx0WzFdPWUqcy1hKmksdFsyXT11KnMrbyppLHRbM109bypzLXUqaSx0fSxuLmNhbGN1bGF0ZVc9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPW5bMl07cmV0dXJuIHRbMF09cix0WzFdPWEsdFsyXT1lLHRbM109TWF0aC5zcXJ0KE1hdGguYWJzKDEtcipyLWEqYS1lKmUpKSx0fSxuLnNsZXJwPU0sbi5yYW5kb209ZnVuY3Rpb24odCl7dmFyIG49YS5SQU5ET00oKSxyPWEuUkFORE9NKCksZT1hLlJBTkRPTSgpLHU9TWF0aC5zcXJ0KDEtbiksbz1NYXRoLnNxcnQobik7cmV0dXJuIHRbMF09dSpNYXRoLnNpbigyKk1hdGguUEkqciksdFsxXT11Kk1hdGguY29zKDIqTWF0aC5QSSpyKSx0WzJdPW8qTWF0aC5zaW4oMipNYXRoLlBJKmUpLHRbM109bypNYXRoLmNvcygyKk1hdGguUEkqZSksdH0sbi5pbnZlcnQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPW5bMl0sdT1uWzNdLG89cipyK2EqYStlKmUrdSp1LGk9bz8xL286MDtyZXR1cm4gdFswXT0tcippLHRbMV09LWEqaSx0WzJdPS1lKmksdFszXT11KmksdH0sbi5jb25qdWdhdGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT0tblswXSx0WzFdPS1uWzFdLHRbMl09LW5bMl0sdFszXT1uWzNdLHR9LG4uZnJvbU1hdDM9aCxuLmZyb21FdWxlcj1mdW5jdGlvbih0LG4scixhKXt2YXIgZT0uNSpNYXRoLlBJLzE4MDtuKj1lLHIqPWUsYSo9ZTt2YXIgdT1NYXRoLnNpbihuKSxvPU1hdGguY29zKG4pLGk9TWF0aC5zaW4ocikscz1NYXRoLmNvcyhyKSxjPU1hdGguc2luKGEpLGY9TWF0aC5jb3MoYSk7cmV0dXJuIHRbMF09dSpzKmYtbyppKmMsdFsxXT1vKmkqZit1KnMqYyx0WzJdPW8qcypjLXUqaSpmLHRbM109bypzKmYrdSppKmMsdH0sbi5zdHI9ZnVuY3Rpb24odCl7cmV0dXJuXCJxdWF0KFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIsIFwiK3RbMl0rXCIsIFwiK3RbM10rXCIpXCJ9O3ZhciBhPWkocigwKSksZT1pKHIoNSkpLHU9aShyKDIpKSxvPWkocigxKSk7ZnVuY3Rpb24gaSh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49e307aWYobnVsbCE9dClmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG4uZGVmYXVsdD10LG59ZnVuY3Rpb24gcygpe3ZhciB0PW5ldyBhLkFSUkFZX1RZUEUoNCk7cmV0dXJuIGEuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYodFswXT0wLHRbMV09MCx0WzJdPTApLHRbM109MSx0fWZ1bmN0aW9uIGModCxuLHIpe3IqPS41O3ZhciBhPU1hdGguc2luKHIpO3JldHVybiB0WzBdPWEqblswXSx0WzFdPWEqblsxXSx0WzJdPWEqblsyXSx0WzNdPU1hdGguY29zKHIpLHR9ZnVuY3Rpb24gZih0LG4scil7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89blszXSxpPXJbMF0scz1yWzFdLGM9clsyXSxmPXJbM107cmV0dXJuIHRbMF09YSpmK28qaStlKmMtdSpzLHRbMV09ZSpmK28qcyt1KmktYSpjLHRbMl09dSpmK28qYythKnMtZSppLHRbM109bypmLWEqaS1lKnMtdSpjLHR9ZnVuY3Rpb24gTSh0LG4scixlKXt2YXIgdT1uWzBdLG89blsxXSxpPW5bMl0scz1uWzNdLGM9clswXSxmPXJbMV0sTT1yWzJdLGg9clszXSxsPXZvaWQgMCx2PXZvaWQgMCxkPXZvaWQgMCxiPXZvaWQgMCxtPXZvaWQgMDtyZXR1cm4odj11KmMrbypmK2kqTStzKmgpPDAmJih2PS12LGM9LWMsZj0tZixNPS1NLGg9LWgpLDEtdj5hLkVQU0lMT04/KGw9TWF0aC5hY29zKHYpLGQ9TWF0aC5zaW4obCksYj1NYXRoLnNpbigoMS1lKSpsKS9kLG09TWF0aC5zaW4oZSpsKS9kKTooYj0xLWUsbT1lKSx0WzBdPWIqdSttKmMsdFsxXT1iKm8rbSpmLHRbMl09YippK20qTSx0WzNdPWIqcyttKmgsdH1mdW5jdGlvbiBoKHQsbil7dmFyIHI9blswXStuWzRdK25bOF0sYT12b2lkIDA7aWYocj4wKWE9TWF0aC5zcXJ0KHIrMSksdFszXT0uNSphLGE9LjUvYSx0WzBdPShuWzVdLW5bN10pKmEsdFsxXT0obls2XS1uWzJdKSphLHRbMl09KG5bMV0tblszXSkqYTtlbHNle3ZhciBlPTA7bls0XT5uWzBdJiYoZT0xKSxuWzhdPm5bMyplK2VdJiYoZT0yKTt2YXIgdT0oZSsxKSUzLG89KGUrMiklMzthPU1hdGguc3FydChuWzMqZStlXS1uWzMqdSt1XS1uWzMqbytvXSsxKSx0W2VdPS41KmEsYT0uNS9hLHRbM109KG5bMyp1K29dLW5bMypvK3VdKSphLHRbdV09KG5bMyp1K2VdK25bMyplK3VdKSphLHRbb109KG5bMypvK2VdK25bMyplK29dKSphfXJldHVybiB0fW4uY2xvbmU9by5jbG9uZSxuLmZyb21WYWx1ZXM9by5mcm9tVmFsdWVzLG4uY29weT1vLmNvcHksbi5zZXQ9by5zZXQsbi5hZGQ9by5hZGQsbi5tdWw9ZixuLnNjYWxlPW8uc2NhbGUsbi5kb3Q9by5kb3Qsbi5sZXJwPW8ubGVycDt2YXIgbD1uLmxlbmd0aD1vLmxlbmd0aCx2PShuLmxlbj1sLG4uc3F1YXJlZExlbmd0aD1vLnNxdWFyZWRMZW5ndGgpLGQ9KG4uc3FyTGVuPXYsbi5ub3JtYWxpemU9by5ub3JtYWxpemUpO24uZXhhY3RFcXVhbHM9by5leGFjdEVxdWFscyxuLmVxdWFscz1vLmVxdWFscyxuLnJvdGF0aW9uVG89ZnVuY3Rpb24oKXt2YXIgdD11LmNyZWF0ZSgpLG49dS5mcm9tVmFsdWVzKDEsMCwwKSxyPXUuZnJvbVZhbHVlcygwLDEsMCk7cmV0dXJuIGZ1bmN0aW9uKGEsZSxvKXt2YXIgaT11LmRvdChlLG8pO3JldHVybiBpPC0uOTk5OTk5Pyh1LmNyb3NzKHQsbixlKSx1Lmxlbih0KTwxZS02JiZ1LmNyb3NzKHQscixlKSx1Lm5vcm1hbGl6ZSh0LHQpLGMoYSx0LE1hdGguUEkpLGEpOmk+Ljk5OTk5OT8oYVswXT0wLGFbMV09MCxhWzJdPTAsYVszXT0xLGEpOih1LmNyb3NzKHQsZSxvKSxhWzBdPXRbMF0sYVsxXT10WzFdLGFbMl09dFsyXSxhWzNdPTEraSxkKGEsYSkpfX0oKSxuLnNxbGVycD1mdW5jdGlvbigpe3ZhciB0PXMoKSxuPXMoKTtyZXR1cm4gZnVuY3Rpb24ocixhLGUsdSxvLGkpe3JldHVybiBNKHQsYSxvLGkpLE0obixlLHUsaSksTShyLHQsbiwyKmkqKDEtaSkpLHJ9fSgpLG4uc2V0QXhlcz1mdW5jdGlvbigpe3ZhciB0PWUuY3JlYXRlKCk7cmV0dXJuIGZ1bmN0aW9uKG4scixhLGUpe3JldHVybiB0WzBdPWFbMF0sdFszXT1hWzFdLHRbNl09YVsyXSx0WzFdPWVbMF0sdFs0XT1lWzFdLHRbN109ZVsyXSx0WzJdPS1yWzBdLHRbNV09LXJbMV0sdFs4XT0tclsyXSxkKG4saChuLHQpKX19KCl9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN1Yj1uLm11bD12b2lkIDAsbi5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgYS5BUlJBWV9UWVBFKDE2KTthLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHRbMV09MCx0WzJdPTAsdFszXT0wLHRbNF09MCx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCk7cmV0dXJuIHRbMF09MSx0WzVdPTEsdFsxMF09MSx0WzE1XT0xLHR9LG4uY2xvbmU9ZnVuY3Rpb24odCl7dmFyIG49bmV3IGEuQVJSQVlfVFlQRSgxNik7cmV0dXJuIG5bMF09dFswXSxuWzFdPXRbMV0sblsyXT10WzJdLG5bM109dFszXSxuWzRdPXRbNF0sbls1XT10WzVdLG5bNl09dFs2XSxuWzddPXRbN10sbls4XT10WzhdLG5bOV09dFs5XSxuWzEwXT10WzEwXSxuWzExXT10WzExXSxuWzEyXT10WzEyXSxuWzEzXT10WzEzXSxuWzE0XT10WzE0XSxuWzE1XT10WzE1XSxufSxuLmNvcHk9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT1uWzBdLHRbMV09blsxXSx0WzJdPW5bMl0sdFszXT1uWzNdLHRbNF09bls0XSx0WzVdPW5bNV0sdFs2XT1uWzZdLHRbN109bls3XSx0WzhdPW5bOF0sdFs5XT1uWzldLHRbMTBdPW5bMTBdLHRbMTFdPW5bMTFdLHRbMTJdPW5bMTJdLHRbMTNdPW5bMTNdLHRbMTRdPW5bMTRdLHRbMTVdPW5bMTVdLHR9LG4uZnJvbVZhbHVlcz1mdW5jdGlvbih0LG4scixlLHUsbyxpLHMsYyxmLE0saCxsLHYsZCxiKXt2YXIgbT1uZXcgYS5BUlJBWV9UWVBFKDE2KTtyZXR1cm4gbVswXT10LG1bMV09bixtWzJdPXIsbVszXT1lLG1bNF09dSxtWzVdPW8sbVs2XT1pLG1bN109cyxtWzhdPWMsbVs5XT1mLG1bMTBdPU0sbVsxMV09aCxtWzEyXT1sLG1bMTNdPXYsbVsxNF09ZCxtWzE1XT1iLG19LG4uc2V0PWZ1bmN0aW9uKHQsbixyLGEsZSx1LG8saSxzLGMsZixNLGgsbCx2LGQsYil7cmV0dXJuIHRbMF09bix0WzFdPXIsdFsyXT1hLHRbM109ZSx0WzRdPXUsdFs1XT1vLHRbNl09aSx0WzddPXMsdFs4XT1jLHRbOV09Zix0WzEwXT1NLHRbMTFdPWgsdFsxMl09bCx0WzEzXT12LHRbMTRdPWQsdFsxNV09Yix0fSxuLmlkZW50aXR5PWUsbi50cmFuc3Bvc2U9ZnVuY3Rpb24odCxuKXtpZih0PT09bil7dmFyIHI9blsxXSxhPW5bMl0sZT1uWzNdLHU9bls2XSxvPW5bN10saT1uWzExXTt0WzFdPW5bNF0sdFsyXT1uWzhdLHRbM109blsxMl0sdFs0XT1yLHRbNl09bls5XSx0WzddPW5bMTNdLHRbOF09YSx0WzldPXUsdFsxMV09blsxNF0sdFsxMl09ZSx0WzEzXT1vLHRbMTRdPWl9ZWxzZSB0WzBdPW5bMF0sdFsxXT1uWzRdLHRbMl09bls4XSx0WzNdPW5bMTJdLHRbNF09blsxXSx0WzVdPW5bNV0sdFs2XT1uWzldLHRbN109blsxM10sdFs4XT1uWzJdLHRbOV09bls2XSx0WzEwXT1uWzEwXSx0WzExXT1uWzE0XSx0WzEyXT1uWzNdLHRbMTNdPW5bN10sdFsxNF09blsxMV0sdFsxNV09blsxNV07cmV0dXJuIHR9LG4uaW52ZXJ0PWZ1bmN0aW9uKHQsbil7dmFyIHI9blswXSxhPW5bMV0sZT1uWzJdLHU9blszXSxvPW5bNF0saT1uWzVdLHM9bls2XSxjPW5bN10sZj1uWzhdLE09bls5XSxoPW5bMTBdLGw9blsxMV0sdj1uWzEyXSxkPW5bMTNdLGI9blsxNF0sbT1uWzE1XSxwPXIqaS1hKm8sUD1yKnMtZSpvLEE9cipjLXUqbyxFPWEqcy1lKmksTz1hKmMtdSppLFI9ZSpjLXUqcyx5PWYqZC1NKnYscT1mKmItaCp2LHg9ZiptLWwqdixfPU0qYi1oKmQsWT1NKm0tbCpkLEw9aCptLWwqYixTPXAqTC1QKlkrQSpfK0UqeC1PKnErUip5O2lmKCFTKXJldHVybiBudWxsO3JldHVybiBTPTEvUyx0WzBdPShpKkwtcypZK2MqXykqUyx0WzFdPShlKlktYSpMLXUqXykqUyx0WzJdPShkKlItYipPK20qRSkqUyx0WzNdPShoKk8tTSpSLWwqRSkqUyx0WzRdPShzKngtbypMLWMqcSkqUyx0WzVdPShyKkwtZSp4K3UqcSkqUyx0WzZdPShiKkEtdipSLW0qUCkqUyx0WzddPShmKlItaCpBK2wqUCkqUyx0WzhdPShvKlktaSp4K2MqeSkqUyx0WzldPShhKngtcipZLXUqeSkqUyx0WzEwXT0odipPLWQqQSttKnApKlMsdFsxMV09KE0qQS1mKk8tbCpwKSpTLHRbMTJdPShpKnEtbypfLXMqeSkqUyx0WzEzXT0ocipfLWEqcStlKnkpKlMsdFsxNF09KGQqUC12KkUtYipwKSpTLHRbMTVdPShmKkUtTSpQK2gqcCkqUyx0fSxuLmFkam9pbnQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPW5bMl0sdT1uWzNdLG89bls0XSxpPW5bNV0scz1uWzZdLGM9bls3XSxmPW5bOF0sTT1uWzldLGg9blsxMF0sbD1uWzExXSx2PW5bMTJdLGQ9blsxM10sYj1uWzE0XSxtPW5bMTVdO3JldHVybiB0WzBdPWkqKGgqbS1sKmIpLU0qKHMqbS1jKmIpK2QqKHMqbC1jKmgpLHRbMV09LShhKihoKm0tbCpiKS1NKihlKm0tdSpiKStkKihlKmwtdSpoKSksdFsyXT1hKihzKm0tYypiKS1pKihlKm0tdSpiKStkKihlKmMtdSpzKSx0WzNdPS0oYSoocypsLWMqaCktaSooZSpsLXUqaCkrTSooZSpjLXUqcykpLHRbNF09LShvKihoKm0tbCpiKS1mKihzKm0tYypiKSt2KihzKmwtYypoKSksdFs1XT1yKihoKm0tbCpiKS1mKihlKm0tdSpiKSt2KihlKmwtdSpoKSx0WzZdPS0ocioocyptLWMqYiktbyooZSptLXUqYikrdiooZSpjLXUqcykpLHRbN109cioocypsLWMqaCktbyooZSpsLXUqaCkrZiooZSpjLXUqcyksdFs4XT1vKihNKm0tbCpkKS1mKihpKm0tYypkKSt2KihpKmwtYypNKSx0WzldPS0ociooTSptLWwqZCktZiooYSptLXUqZCkrdiooYSpsLXUqTSkpLHRbMTBdPXIqKGkqbS1jKmQpLW8qKGEqbS11KmQpK3YqKGEqYy11KmkpLHRbMTFdPS0ociooaSpsLWMqTSktbyooYSpsLXUqTSkrZiooYSpjLXUqaSkpLHRbMTJdPS0obyooTSpiLWgqZCktZiooaSpiLXMqZCkrdiooaSpoLXMqTSkpLHRbMTNdPXIqKE0qYi1oKmQpLWYqKGEqYi1lKmQpK3YqKGEqaC1lKk0pLHRbMTRdPS0ociooaSpiLXMqZCktbyooYSpiLWUqZCkrdiooYSpzLWUqaSkpLHRbMTVdPXIqKGkqaC1zKk0pLW8qKGEqaC1lKk0pK2YqKGEqcy1lKmkpLHR9LG4uZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24odCl7dmFyIG49dFswXSxyPXRbMV0sYT10WzJdLGU9dFszXSx1PXRbNF0sbz10WzVdLGk9dFs2XSxzPXRbN10sYz10WzhdLGY9dFs5XSxNPXRbMTBdLGg9dFsxMV0sbD10WzEyXSx2PXRbMTNdLGQ9dFsxNF0sYj10WzE1XTtyZXR1cm4obipvLXIqdSkqKE0qYi1oKmQpLShuKmktYSp1KSooZipiLWgqdikrKG4qcy1lKnUpKihmKmQtTSp2KSsocippLWEqbykqKGMqYi1oKmwpLShyKnMtZSpvKSooYypkLU0qbCkrKGEqcy1lKmkpKihjKnYtZipsKX0sbi5tdWx0aXBseT11LG4udHJhbnNsYXRlPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1yWzBdLGU9clsxXSx1PXJbMl0sbz12b2lkIDAsaT12b2lkIDAscz12b2lkIDAsYz12b2lkIDAsZj12b2lkIDAsTT12b2lkIDAsaD12b2lkIDAsbD12b2lkIDAsdj12b2lkIDAsZD12b2lkIDAsYj12b2lkIDAsbT12b2lkIDA7bj09PXQ/KHRbMTJdPW5bMF0qYStuWzRdKmUrbls4XSp1K25bMTJdLHRbMTNdPW5bMV0qYStuWzVdKmUrbls5XSp1K25bMTNdLHRbMTRdPW5bMl0qYStuWzZdKmUrblsxMF0qdStuWzE0XSx0WzE1XT1uWzNdKmErbls3XSplK25bMTFdKnUrblsxNV0pOihvPW5bMF0saT1uWzFdLHM9blsyXSxjPW5bM10sZj1uWzRdLE09bls1XSxoPW5bNl0sbD1uWzddLHY9bls4XSxkPW5bOV0sYj1uWzEwXSxtPW5bMTFdLHRbMF09byx0WzFdPWksdFsyXT1zLHRbM109Yyx0WzRdPWYsdFs1XT1NLHRbNl09aCx0WzddPWwsdFs4XT12LHRbOV09ZCx0WzEwXT1iLHRbMTFdPW0sdFsxMl09byphK2YqZSt2KnUrblsxMl0sdFsxM109aSphK00qZStkKnUrblsxM10sdFsxNF09cyphK2gqZStiKnUrblsxNF0sdFsxNV09YyphK2wqZSttKnUrblsxNV0pO3JldHVybiB0fSxuLnNjYWxlPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1yWzBdLGU9clsxXSx1PXJbMl07cmV0dXJuIHRbMF09blswXSphLHRbMV09blsxXSphLHRbMl09blsyXSphLHRbM109blszXSphLHRbNF09bls0XSplLHRbNV09bls1XSplLHRbNl09bls2XSplLHRbN109bls3XSplLHRbOF09bls4XSp1LHRbOV09bls5XSp1LHRbMTBdPW5bMTBdKnUsdFsxMV09blsxMV0qdSx0WzEyXT1uWzEyXSx0WzEzXT1uWzEzXSx0WzE0XT1uWzE0XSx0WzE1XT1uWzE1XSx0fSxuLnJvdGF0ZT1mdW5jdGlvbih0LG4scixlKXt2YXIgdT1lWzBdLG89ZVsxXSxpPWVbMl0scz1NYXRoLnNxcnQodSp1K28qbytpKmkpLGM9dm9pZCAwLGY9dm9pZCAwLE09dm9pZCAwLGg9dm9pZCAwLGw9dm9pZCAwLHY9dm9pZCAwLGQ9dm9pZCAwLGI9dm9pZCAwLG09dm9pZCAwLHA9dm9pZCAwLFA9dm9pZCAwLEE9dm9pZCAwLEU9dm9pZCAwLE89dm9pZCAwLFI9dm9pZCAwLHk9dm9pZCAwLHE9dm9pZCAwLHg9dm9pZCAwLF89dm9pZCAwLFk9dm9pZCAwLEw9dm9pZCAwLFM9dm9pZCAwLHc9dm9pZCAwLEk9dm9pZCAwO2lmKHM8YS5FUFNJTE9OKXJldHVybiBudWxsO3UqPXM9MS9zLG8qPXMsaSo9cyxjPU1hdGguc2luKHIpLGY9TWF0aC5jb3MociksTT0xLWYsaD1uWzBdLGw9blsxXSx2PW5bMl0sZD1uWzNdLGI9bls0XSxtPW5bNV0scD1uWzZdLFA9bls3XSxBPW5bOF0sRT1uWzldLE89blsxMF0sUj1uWzExXSx5PXUqdSpNK2YscT1vKnUqTStpKmMseD1pKnUqTS1vKmMsXz11Km8qTS1pKmMsWT1vKm8qTStmLEw9aSpvKk0rdSpjLFM9dSppKk0rbypjLHc9byppKk0tdSpjLEk9aSppKk0rZix0WzBdPWgqeStiKnErQSp4LHRbMV09bCp5K20qcStFKngsdFsyXT12KnkrcCpxK08qeCx0WzNdPWQqeStQKnErUip4LHRbNF09aCpfK2IqWStBKkwsdFs1XT1sKl8rbSpZK0UqTCx0WzZdPXYqXytwKlkrTypMLHRbN109ZCpfK1AqWStSKkwsdFs4XT1oKlMrYip3K0EqSSx0WzldPWwqUyttKncrRSpJLHRbMTBdPXYqUytwKncrTypJLHRbMTFdPWQqUytQKncrUipJLG4hPT10JiYodFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pO3JldHVybiB0fSxuLnJvdGF0ZVg9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPU1hdGguc2luKHIpLGU9TWF0aC5jb3MociksdT1uWzRdLG89bls1XSxpPW5bNl0scz1uWzddLGM9bls4XSxmPW5bOV0sTT1uWzEwXSxoPW5bMTFdO24hPT10JiYodFswXT1uWzBdLHRbMV09blsxXSx0WzJdPW5bMl0sdFszXT1uWzNdLHRbMTJdPW5bMTJdLHRbMTNdPW5bMTNdLHRbMTRdPW5bMTRdLHRbMTVdPW5bMTVdKTtyZXR1cm4gdFs0XT11KmUrYyphLHRbNV09byplK2YqYSx0WzZdPWkqZStNKmEsdFs3XT1zKmUraCphLHRbOF09YyplLXUqYSx0WzldPWYqZS1vKmEsdFsxMF09TSplLWkqYSx0WzExXT1oKmUtcyphLHR9LG4ucm90YXRlWT1mdW5jdGlvbih0LG4scil7dmFyIGE9TWF0aC5zaW4ociksZT1NYXRoLmNvcyhyKSx1PW5bMF0sbz1uWzFdLGk9blsyXSxzPW5bM10sYz1uWzhdLGY9bls5XSxNPW5bMTBdLGg9blsxMV07biE9PXQmJih0WzRdPW5bNF0sdFs1XT1uWzVdLHRbNl09bls2XSx0WzddPW5bN10sdFsxMl09blsxMl0sdFsxM109blsxM10sdFsxNF09blsxNF0sdFsxNV09blsxNV0pO3JldHVybiB0WzBdPXUqZS1jKmEsdFsxXT1vKmUtZiphLHRbMl09aSplLU0qYSx0WzNdPXMqZS1oKmEsdFs4XT11KmErYyplLHRbOV09byphK2YqZSx0WzEwXT1pKmErTSplLHRbMTFdPXMqYStoKmUsdH0sbi5yb3RhdGVaPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1NYXRoLnNpbihyKSxlPU1hdGguY29zKHIpLHU9blswXSxvPW5bMV0saT1uWzJdLHM9blszXSxjPW5bNF0sZj1uWzVdLE09bls2XSxoPW5bN107biE9PXQmJih0WzhdPW5bOF0sdFs5XT1uWzldLHRbMTBdPW5bMTBdLHRbMTFdPW5bMTFdLHRbMTJdPW5bMTJdLHRbMTNdPW5bMTNdLHRbMTRdPW5bMTRdLHRbMTVdPW5bMTVdKTtyZXR1cm4gdFswXT11KmUrYyphLHRbMV09byplK2YqYSx0WzJdPWkqZStNKmEsdFszXT1zKmUraCphLHRbNF09YyplLXUqYSx0WzVdPWYqZS1vKmEsdFs2XT1NKmUtaSphLHRbN109aCplLXMqYSx0fSxuLmZyb21UcmFuc2xhdGlvbj1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09MSx0WzExXT0wLHRbMTJdPW5bMF0sdFsxM109blsxXSx0WzE0XT1uWzJdLHRbMTVdPTEsdH0sbi5mcm9tU2NhbGluZz1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09blsxXSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09blsyXSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdH0sbi5mcm9tUm90YXRpb249ZnVuY3Rpb24odCxuLHIpe3ZhciBlPXJbMF0sdT1yWzFdLG89clsyXSxpPU1hdGguc3FydChlKmUrdSp1K28qbykscz12b2lkIDAsYz12b2lkIDAsZj12b2lkIDA7aWYoaTxhLkVQU0lMT04pcmV0dXJuIG51bGw7cmV0dXJuIGUqPWk9MS9pLHUqPWksbyo9aSxzPU1hdGguc2luKG4pLGM9TWF0aC5jb3MobiksZj0xLWMsdFswXT1lKmUqZitjLHRbMV09dSplKmYrbypzLHRbMl09byplKmYtdSpzLHRbM109MCx0WzRdPWUqdSpmLW8qcyx0WzVdPXUqdSpmK2MsdFs2XT1vKnUqZitlKnMsdFs3XT0wLHRbOF09ZSpvKmYrdSpzLHRbOV09dSpvKmYtZSpzLHRbMTBdPW8qbypmK2MsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xLHR9LG4uZnJvbVhSb3RhdGlvbj1mdW5jdGlvbih0LG4pe3ZhciByPU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIHRbMF09MSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTAsdFs1XT1hLHRbNl09cix0WzddPTAsdFs4XT0wLHRbOV09LXIsdFsxMF09YSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdH0sbi5mcm9tWVJvdGF0aW9uPWZ1bmN0aW9uKHQsbil7dmFyIHI9TWF0aC5zaW4obiksYT1NYXRoLmNvcyhuKTtyZXR1cm4gdFswXT1hLHRbMV09MCx0WzJdPS1yLHRbM109MCx0WzRdPTAsdFs1XT0xLHRbNl09MCx0WzddPTAsdFs4XT1yLHRbOV09MCx0WzEwXT1hLHRbMTFdPTAsdFsxMl09MCx0WzEzXT0wLHRbMTRdPTAsdFsxNV09MSx0fSxuLmZyb21aUm90YXRpb249ZnVuY3Rpb24odCxuKXt2YXIgcj1NYXRoLnNpbihuKSxhPU1hdGguY29zKG4pO3JldHVybiB0WzBdPWEsdFsxXT1yLHRbMl09MCx0WzNdPTAsdFs0XT0tcix0WzVdPWEsdFs2XT0wLHRbN109MCx0WzhdPTAsdFs5XT0wLHRbMTBdPTEsdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xLHR9LG4uZnJvbVJvdGF0aW9uVHJhbnNsYXRpb249byxuLmZyb21RdWF0Mj1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBhLkFSUkFZX1RZUEUoMyksZT0tblswXSx1PS1uWzFdLGk9LW5bMl0scz1uWzNdLGM9bls0XSxmPW5bNV0sTT1uWzZdLGg9bls3XSxsPWUqZSt1KnUraSppK3MqcztsPjA/KHJbMF09MiooYypzK2gqZStmKmktTSp1KS9sLHJbMV09MiooZipzK2gqdStNKmUtYyppKS9sLHJbMl09MiooTSpzK2gqaStjKnUtZiplKS9sKTooclswXT0yKihjKnMraCplK2YqaS1NKnUpLHJbMV09MiooZipzK2gqdStNKmUtYyppKSxyWzJdPTIqKE0qcytoKmkrYyp1LWYqZSkpO3JldHVybiBvKHQsbixyKSx0fSxuLmdldFRyYW5zbGF0aW9uPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blsxMl0sdFsxXT1uWzEzXSx0WzJdPW5bMTRdLHR9LG4uZ2V0U2NhbGluZz1mdW5jdGlvbih0LG4pe3ZhciByPW5bMF0sYT1uWzFdLGU9blsyXSx1PW5bNF0sbz1uWzVdLGk9bls2XSxzPW5bOF0sYz1uWzldLGY9blsxMF07cmV0dXJuIHRbMF09TWF0aC5zcXJ0KHIqcithKmErZSplKSx0WzFdPU1hdGguc3FydCh1KnUrbypvK2kqaSksdFsyXT1NYXRoLnNxcnQocypzK2MqYytmKmYpLHR9LG4uZ2V0Um90YXRpb249ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdK25bNV0rblsxMF0sYT0wO3I+MD8oYT0yKk1hdGguc3FydChyKzEpLHRbM109LjI1KmEsdFswXT0obls2XS1uWzldKS9hLHRbMV09KG5bOF0tblsyXSkvYSx0WzJdPShuWzFdLW5bNF0pL2EpOm5bMF0+bls1XSYmblswXT5uWzEwXT8oYT0yKk1hdGguc3FydCgxK25bMF0tbls1XS1uWzEwXSksdFszXT0obls2XS1uWzldKS9hLHRbMF09LjI1KmEsdFsxXT0oblsxXStuWzRdKS9hLHRbMl09KG5bOF0rblsyXSkvYSk6bls1XT5uWzEwXT8oYT0yKk1hdGguc3FydCgxK25bNV0tblswXS1uWzEwXSksdFszXT0obls4XS1uWzJdKS9hLHRbMF09KG5bMV0rbls0XSkvYSx0WzFdPS4yNSphLHRbMl09KG5bNl0rbls5XSkvYSk6KGE9MipNYXRoLnNxcnQoMStuWzEwXS1uWzBdLW5bNV0pLHRbM109KG5bMV0tbls0XSkvYSx0WzBdPShuWzhdK25bMl0pL2EsdFsxXT0obls2XStuWzldKS9hLHRbMl09LjI1KmEpO3JldHVybiB0fSxuLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGU9ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9blswXSx1PW5bMV0sbz1uWzJdLGk9blszXSxzPWUrZSxjPXUrdSxmPW8rbyxNPWUqcyxoPWUqYyxsPWUqZix2PXUqYyxkPXUqZixiPW8qZixtPWkqcyxwPWkqYyxQPWkqZixBPWFbMF0sRT1hWzFdLE89YVsyXTtyZXR1cm4gdFswXT0oMS0oditiKSkqQSx0WzFdPShoK1ApKkEsdFsyXT0obC1wKSpBLHRbM109MCx0WzRdPShoLVApKkUsdFs1XT0oMS0oTStiKSkqRSx0WzZdPShkK20pKkUsdFs3XT0wLHRbOF09KGwrcCkqTyx0WzldPShkLW0pKk8sdFsxMF09KDEtKE0rdikpKk8sdFsxMV09MCx0WzEyXT1yWzBdLHRbMTNdPXJbMV0sdFsxNF09clsyXSx0WzE1XT0xLHR9LG4uZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbj1mdW5jdGlvbih0LG4scixhLGUpe3ZhciB1PW5bMF0sbz1uWzFdLGk9blsyXSxzPW5bM10sYz11K3UsZj1vK28sTT1pK2ksaD11KmMsbD11KmYsdj11Kk0sZD1vKmYsYj1vKk0sbT1pKk0scD1zKmMsUD1zKmYsQT1zKk0sRT1hWzBdLE89YVsxXSxSPWFbMl0seT1lWzBdLHE9ZVsxXSx4PWVbMl0sXz0oMS0oZCttKSkqRSxZPShsK0EpKkUsTD0odi1QKSpFLFM9KGwtQSkqTyx3PSgxLShoK20pKSpPLEk9KGIrcCkqTyxOPSh2K1ApKlIsZz0oYi1wKSpSLFQ9KDEtKGgrZCkpKlI7cmV0dXJuIHRbMF09Xyx0WzFdPVksdFsyXT1MLHRbM109MCx0WzRdPVMsdFs1XT13LHRbNl09SSx0WzddPTAsdFs4XT1OLHRbOV09Zyx0WzEwXT1ULHRbMTFdPTAsdFsxMl09clswXSt5LShfKnkrUypxK04qeCksdFsxM109clsxXStxLShZKnkrdypxK2cqeCksdFsxNF09clsyXSt4LShMKnkrSSpxK1QqeCksdFsxNV09MSx0fSxuLmZyb21RdWF0PWZ1bmN0aW9uKHQsbil7dmFyIHI9blswXSxhPW5bMV0sZT1uWzJdLHU9blszXSxvPXIrcixpPWErYSxzPWUrZSxjPXIqbyxmPWEqbyxNPWEqaSxoPWUqbyxsPWUqaSx2PWUqcyxkPXUqbyxiPXUqaSxtPXUqcztyZXR1cm4gdFswXT0xLU0tdix0WzFdPWYrbSx0WzJdPWgtYix0WzNdPTAsdFs0XT1mLW0sdFs1XT0xLWMtdix0WzZdPWwrZCx0WzddPTAsdFs4XT1oK2IsdFs5XT1sLWQsdFsxMF09MS1jLU0sdFsxMV09MCx0WzEyXT0wLHRbMTNdPTAsdFsxNF09MCx0WzE1XT0xLHR9LG4uZnJ1c3R1bT1mdW5jdGlvbih0LG4scixhLGUsdSxvKXt2YXIgaT0xLyhyLW4pLHM9MS8oZS1hKSxjPTEvKHUtbyk7cmV0dXJuIHRbMF09Mip1KmksdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09Mip1KnMsdFs2XT0wLHRbN109MCx0WzhdPShyK24pKmksdFs5XT0oZSthKSpzLHRbMTBdPShvK3UpKmMsdFsxMV09LTEsdFsxMl09MCx0WzEzXT0wLHRbMTRdPW8qdSoyKmMsdFsxNV09MCx0fSxuLnBlcnNwZWN0aXZlPWZ1bmN0aW9uKHQsbixyLGEsZSl7dmFyIHU9MS9NYXRoLnRhbihuLzIpLG89dm9pZCAwO3RbMF09dS9yLHRbMV09MCx0WzJdPTAsdFszXT0wLHRbNF09MCx0WzVdPXUsdFs2XT0wLHRbN109MCx0WzhdPTAsdFs5XT0wLHRbMTFdPS0xLHRbMTJdPTAsdFsxM109MCx0WzE1XT0wLG51bGwhPWUmJmUhPT0xLzA/KG89MS8oYS1lKSx0WzEwXT0oZSthKSpvLHRbMTRdPTIqZSphKm8pOih0WzEwXT0tMSx0WzE0XT0tMiphKTtyZXR1cm4gdH0sbi5wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldz1mdW5jdGlvbih0LG4scixhKXt2YXIgZT1NYXRoLnRhbihuLnVwRGVncmVlcypNYXRoLlBJLzE4MCksdT1NYXRoLnRhbihuLmRvd25EZWdyZWVzKk1hdGguUEkvMTgwKSxvPU1hdGgudGFuKG4ubGVmdERlZ3JlZXMqTWF0aC5QSS8xODApLGk9TWF0aC50YW4obi5yaWdodERlZ3JlZXMqTWF0aC5QSS8xODApLHM9Mi8obytpKSxjPTIvKGUrdSk7cmV0dXJuIHRbMF09cyx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTAsdFs1XT1jLHRbNl09MCx0WzddPTAsdFs4XT0tKG8taSkqcyouNSx0WzldPShlLXUpKmMqLjUsdFsxMF09YS8oci1hKSx0WzExXT0tMSx0WzEyXT0wLHRbMTNdPTAsdFsxNF09YSpyLyhyLWEpLHRbMTVdPTAsdH0sbi5vcnRobz1mdW5jdGlvbih0LG4scixhLGUsdSxvKXt2YXIgaT0xLyhuLXIpLHM9MS8oYS1lKSxjPTEvKHUtbyk7cmV0dXJuIHRbMF09LTIqaSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPTAsdFs1XT0tMipzLHRbNl09MCx0WzddPTAsdFs4XT0wLHRbOV09MCx0WzEwXT0yKmMsdFsxMV09MCx0WzEyXT0obityKSppLHRbMTNdPShlK2EpKnMsdFsxNF09KG8rdSkqYyx0WzE1XT0xLHR9LG4ubG9va0F0PWZ1bmN0aW9uKHQsbixyLHUpe3ZhciBvPXZvaWQgMCxpPXZvaWQgMCxzPXZvaWQgMCxjPXZvaWQgMCxmPXZvaWQgMCxNPXZvaWQgMCxoPXZvaWQgMCxsPXZvaWQgMCx2PXZvaWQgMCxkPXZvaWQgMCxiPW5bMF0sbT1uWzFdLHA9blsyXSxQPXVbMF0sQT11WzFdLEU9dVsyXSxPPXJbMF0sUj1yWzFdLHk9clsyXTtpZihNYXRoLmFicyhiLU8pPGEuRVBTSUxPTiYmTWF0aC5hYnMobS1SKTxhLkVQU0lMT04mJk1hdGguYWJzKHAteSk8YS5FUFNJTE9OKXJldHVybiBlKHQpO2g9Yi1PLGw9bS1SLHY9cC15LGQ9MS9NYXRoLnNxcnQoaCpoK2wqbCt2KnYpLG89QSoodio9ZCktRSoobCo9ZCksaT1FKihoKj1kKS1QKnYscz1QKmwtQSpoLChkPU1hdGguc3FydChvKm8raSppK3MqcykpPyhvKj1kPTEvZCxpKj1kLHMqPWQpOihvPTAsaT0wLHM9MCk7Yz1sKnMtdippLGY9dipvLWgqcyxNPWgqaS1sKm8sKGQ9TWF0aC5zcXJ0KGMqYytmKmYrTSpNKSk/KGMqPWQ9MS9kLGYqPWQsTSo9ZCk6KGM9MCxmPTAsTT0wKTtyZXR1cm4gdFswXT1vLHRbMV09Yyx0WzJdPWgsdFszXT0wLHRbNF09aSx0WzVdPWYsdFs2XT1sLHRbN109MCx0WzhdPXMsdFs5XT1NLHRbMTBdPXYsdFsxMV09MCx0WzEyXT0tKG8qYitpKm0rcypwKSx0WzEzXT0tKGMqYitmKm0rTSpwKSx0WzE0XT0tKGgqYitsKm0rdipwKSx0WzE1XT0xLHR9LG4udGFyZ2V0VG89ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9blswXSx1PW5bMV0sbz1uWzJdLGk9YVswXSxzPWFbMV0sYz1hWzJdLGY9ZS1yWzBdLE09dS1yWzFdLGg9by1yWzJdLGw9ZipmK00qTStoKmg7bD4wJiYobD0xL01hdGguc3FydChsKSxmKj1sLE0qPWwsaCo9bCk7dmFyIHY9cypoLWMqTSxkPWMqZi1pKmgsYj1pKk0tcypmOyhsPXYqditkKmQrYipiKT4wJiYobD0xL01hdGguc3FydChsKSx2Kj1sLGQqPWwsYio9bCk7cmV0dXJuIHRbMF09dix0WzFdPWQsdFsyXT1iLHRbM109MCx0WzRdPU0qYi1oKmQsdFs1XT1oKnYtZipiLHRbNl09ZipkLU0qdix0WzddPTAsdFs4XT1mLHRbOV09TSx0WzEwXT1oLHRbMTFdPTAsdFsxMl09ZSx0WzEzXT11LHRbMTRdPW8sdFsxNV09MSx0fSxuLnN0cj1mdW5jdGlvbih0KXtyZXR1cm5cIm1hdDQoXCIrdFswXStcIiwgXCIrdFsxXStcIiwgXCIrdFsyXStcIiwgXCIrdFszXStcIiwgXCIrdFs0XStcIiwgXCIrdFs1XStcIiwgXCIrdFs2XStcIiwgXCIrdFs3XStcIiwgXCIrdFs4XStcIiwgXCIrdFs5XStcIiwgXCIrdFsxMF0rXCIsIFwiK3RbMTFdK1wiLCBcIit0WzEyXStcIiwgXCIrdFsxM10rXCIsIFwiK3RbMTRdK1wiLCBcIit0WzE1XStcIilcIn0sbi5mcm9iPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codFswXSwyKStNYXRoLnBvdyh0WzFdLDIpK01hdGgucG93KHRbMl0sMikrTWF0aC5wb3codFszXSwyKStNYXRoLnBvdyh0WzRdLDIpK01hdGgucG93KHRbNV0sMikrTWF0aC5wb3codFs2XSwyKStNYXRoLnBvdyh0WzddLDIpK01hdGgucG93KHRbOF0sMikrTWF0aC5wb3codFs5XSwyKStNYXRoLnBvdyh0WzEwXSwyKStNYXRoLnBvdyh0WzExXSwyKStNYXRoLnBvdyh0WzEyXSwyKStNYXRoLnBvdyh0WzEzXSwyKStNYXRoLnBvdyh0WzE0XSwyKStNYXRoLnBvdyh0WzE1XSwyKSl9LG4uYWRkPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0sdFsxXT1uWzFdK3JbMV0sdFsyXT1uWzJdK3JbMl0sdFszXT1uWzNdK3JbM10sdFs0XT1uWzRdK3JbNF0sdFs1XT1uWzVdK3JbNV0sdFs2XT1uWzZdK3JbNl0sdFs3XT1uWzddK3JbN10sdFs4XT1uWzhdK3JbOF0sdFs5XT1uWzldK3JbOV0sdFsxMF09blsxMF0rclsxMF0sdFsxMV09blsxMV0rclsxMV0sdFsxMl09blsxMl0rclsxMl0sdFsxM109blsxM10rclsxM10sdFsxNF09blsxNF0rclsxNF0sdFsxNV09blsxNV0rclsxNV0sdH0sbi5zdWJ0cmFjdD1pLG4ubXVsdGlwbHlTY2FsYXI9ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPW5bMF0qcix0WzFdPW5bMV0qcix0WzJdPW5bMl0qcix0WzNdPW5bM10qcix0WzRdPW5bNF0qcix0WzVdPW5bNV0qcix0WzZdPW5bNl0qcix0WzddPW5bN10qcix0WzhdPW5bOF0qcix0WzldPW5bOV0qcix0WzEwXT1uWzEwXSpyLHRbMTFdPW5bMTFdKnIsdFsxMl09blsxMl0qcix0WzEzXT1uWzEzXSpyLHRbMTRdPW5bMTRdKnIsdFsxNV09blsxNV0qcix0fSxuLm11bHRpcGx5U2NhbGFyQW5kQWRkPWZ1bmN0aW9uKHQsbixyLGEpe3JldHVybiB0WzBdPW5bMF0rclswXSphLHRbMV09blsxXStyWzFdKmEsdFsyXT1uWzJdK3JbMl0qYSx0WzNdPW5bM10rclszXSphLHRbNF09bls0XStyWzRdKmEsdFs1XT1uWzVdK3JbNV0qYSx0WzZdPW5bNl0rcls2XSphLHRbN109bls3XStyWzddKmEsdFs4XT1uWzhdK3JbOF0qYSx0WzldPW5bOV0rcls5XSphLHRbMTBdPW5bMTBdK3JbMTBdKmEsdFsxMV09blsxMV0rclsxMV0qYSx0WzEyXT1uWzEyXStyWzEyXSphLHRbMTNdPW5bMTNdK3JbMTNdKmEsdFsxNF09blsxNF0rclsxNF0qYSx0WzE1XT1uWzE1XStyWzE1XSphLHR9LG4uZXhhY3RFcXVhbHM9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT09PW5bMF0mJnRbMV09PT1uWzFdJiZ0WzJdPT09blsyXSYmdFszXT09PW5bM10mJnRbNF09PT1uWzRdJiZ0WzVdPT09bls1XSYmdFs2XT09PW5bNl0mJnRbN109PT1uWzddJiZ0WzhdPT09bls4XSYmdFs5XT09PW5bOV0mJnRbMTBdPT09blsxMF0mJnRbMTFdPT09blsxMV0mJnRbMTJdPT09blsxMl0mJnRbMTNdPT09blsxM10mJnRbMTRdPT09blsxNF0mJnRbMTVdPT09blsxNV19LG4uZXF1YWxzPWZ1bmN0aW9uKHQsbil7dmFyIHI9dFswXSxlPXRbMV0sdT10WzJdLG89dFszXSxpPXRbNF0scz10WzVdLGM9dFs2XSxmPXRbN10sTT10WzhdLGg9dFs5XSxsPXRbMTBdLHY9dFsxMV0sZD10WzEyXSxiPXRbMTNdLG09dFsxNF0scD10WzE1XSxQPW5bMF0sQT1uWzFdLEU9blsyXSxPPW5bM10sUj1uWzRdLHk9bls1XSxxPW5bNl0seD1uWzddLF89bls4XSxZPW5bOV0sTD1uWzEwXSxTPW5bMTFdLHc9blsxMl0sST1uWzEzXSxOPW5bMTRdLGc9blsxNV07cmV0dXJuIE1hdGguYWJzKHItUCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHIpLE1hdGguYWJzKFApKSYmTWF0aC5hYnMoZS1BKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZSksTWF0aC5hYnMoQSkpJiZNYXRoLmFicyh1LUUpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh1KSxNYXRoLmFicyhFKSkmJk1hdGguYWJzKG8tTyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKG8pLE1hdGguYWJzKE8pKSYmTWF0aC5hYnMoaS1SKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoaSksTWF0aC5hYnMoUikpJiZNYXRoLmFicyhzLXkpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhzKSxNYXRoLmFicyh5KSkmJk1hdGguYWJzKGMtcSk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGMpLE1hdGguYWJzKHEpKSYmTWF0aC5hYnMoZi14KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZiksTWF0aC5hYnMoeCkpJiZNYXRoLmFicyhNLV8pPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhNKSxNYXRoLmFicyhfKSkmJk1hdGguYWJzKGgtWSk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGgpLE1hdGguYWJzKFkpKSYmTWF0aC5hYnMobC1MKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobCksTWF0aC5hYnMoTCkpJiZNYXRoLmFicyh2LVMpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyh2KSxNYXRoLmFicyhTKSkmJk1hdGguYWJzKGQtdyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGQpLE1hdGguYWJzKHcpKSYmTWF0aC5hYnMoYi1JKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYiksTWF0aC5hYnMoSSkpJiZNYXRoLmFicyhtLU4pPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhtKSxNYXRoLmFicyhOKSkmJk1hdGguYWJzKHAtZyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHApLE1hdGguYWJzKGcpKX07dmFyIGE9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBuPXt9O2lmKG51bGwhPXQpZm9yKHZhciByIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscikmJihuW3JdPXRbcl0pO3JldHVybiBuLmRlZmF1bHQ9dCxufShyKDApKTtmdW5jdGlvbiBlKHQpe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0wLHRbNV09MSx0WzZdPTAsdFs3XT0wLHRbOF09MCx0WzldPTAsdFsxMF09MSx0WzExXT0wLHRbMTJdPTAsdFsxM109MCx0WzE0XT0wLHRbMTVdPTEsdH1mdW5jdGlvbiB1KHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9bls0XSxzPW5bNV0sYz1uWzZdLGY9bls3XSxNPW5bOF0saD1uWzldLGw9blsxMF0sdj1uWzExXSxkPW5bMTJdLGI9blsxM10sbT1uWzE0XSxwPW5bMTVdLFA9clswXSxBPXJbMV0sRT1yWzJdLE89clszXTtyZXR1cm4gdFswXT1QKmErQSppK0UqTStPKmQsdFsxXT1QKmUrQSpzK0UqaCtPKmIsdFsyXT1QKnUrQSpjK0UqbCtPKm0sdFszXT1QKm8rQSpmK0UqditPKnAsUD1yWzRdLEE9cls1XSxFPXJbNl0sTz1yWzddLHRbNF09UCphK0EqaStFKk0rTypkLHRbNV09UCplK0EqcytFKmgrTypiLHRbNl09UCp1K0EqYytFKmwrTyptLHRbN109UCpvK0EqZitFKnYrTypwLFA9cls4XSxBPXJbOV0sRT1yWzEwXSxPPXJbMTFdLHRbOF09UCphK0EqaStFKk0rTypkLHRbOV09UCplK0EqcytFKmgrTypiLHRbMTBdPVAqdStBKmMrRSpsK08qbSx0WzExXT1QKm8rQSpmK0UqditPKnAsUD1yWzEyXSxBPXJbMTNdLEU9clsxNF0sTz1yWzE1XSx0WzEyXT1QKmErQSppK0UqTStPKmQsdFsxM109UCplK0EqcytFKmgrTypiLHRbMTRdPVAqdStBKmMrRSpsK08qbSx0WzE1XT1QKm8rQSpmK0UqditPKnAsdH1mdW5jdGlvbiBvKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9YSthLHM9ZStlLGM9dSt1LGY9YSppLE09YSpzLGg9YSpjLGw9ZSpzLHY9ZSpjLGQ9dSpjLGI9byppLG09bypzLHA9bypjO3JldHVybiB0WzBdPTEtKGwrZCksdFsxXT1NK3AsdFsyXT1oLW0sdFszXT0wLHRbNF09TS1wLHRbNV09MS0oZitkKSx0WzZdPXYrYix0WzddPTAsdFs4XT1oK20sdFs5XT12LWIsdFsxMF09MS0oZitsKSx0WzExXT0wLHRbMTJdPXJbMF0sdFsxM109clsxXSx0WzE0XT1yWzJdLHRbMTVdPTEsdH1mdW5jdGlvbiBpKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdLXJbMF0sdFsxXT1uWzFdLXJbMV0sdFsyXT1uWzJdLXJbMl0sdFszXT1uWzNdLXJbM10sdFs0XT1uWzRdLXJbNF0sdFs1XT1uWzVdLXJbNV0sdFs2XT1uWzZdLXJbNl0sdFs3XT1uWzddLXJbN10sdFs4XT1uWzhdLXJbOF0sdFs5XT1uWzldLXJbOV0sdFsxMF09blsxMF0tclsxMF0sdFsxMV09blsxMV0tclsxMV0sdFsxMl09blsxMl0tclsxMl0sdFsxM109blsxM10tclsxM10sdFsxNF09blsxNF0tclsxNF0sdFsxNV09blsxNV0tclsxNV0sdH1uLm11bD11LG4uc3ViPWl9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN1Yj1uLm11bD12b2lkIDAsbi5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgYS5BUlJBWV9UWVBFKDkpO2EuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYodFsxXT0wLHRbMl09MCx0WzNdPTAsdFs1XT0wLHRbNl09MCx0WzddPTApO3JldHVybiB0WzBdPTEsdFs0XT0xLHRbOF09MSx0fSxuLmZyb21NYXQ0PWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdLHRbM109bls0XSx0WzRdPW5bNV0sdFs1XT1uWzZdLHRbNl09bls4XSx0WzddPW5bOV0sdFs4XT1uWzEwXSx0fSxuLmNsb25lPWZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBhLkFSUkFZX1RZUEUoOSk7cmV0dXJuIG5bMF09dFswXSxuWzFdPXRbMV0sblsyXT10WzJdLG5bM109dFszXSxuWzRdPXRbNF0sbls1XT10WzVdLG5bNl09dFs2XSxuWzddPXRbN10sbls4XT10WzhdLG59LG4uY29weT1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFs0XT1uWzRdLHRbNV09bls1XSx0WzZdPW5bNl0sdFs3XT1uWzddLHRbOF09bls4XSx0fSxuLmZyb21WYWx1ZXM9ZnVuY3Rpb24odCxuLHIsZSx1LG8saSxzLGMpe3ZhciBmPW5ldyBhLkFSUkFZX1RZUEUoOSk7cmV0dXJuIGZbMF09dCxmWzFdPW4sZlsyXT1yLGZbM109ZSxmWzRdPXUsZls1XT1vLGZbNl09aSxmWzddPXMsZls4XT1jLGZ9LG4uc2V0PWZ1bmN0aW9uKHQsbixyLGEsZSx1LG8saSxzLGMpe3JldHVybiB0WzBdPW4sdFsxXT1yLHRbMl09YSx0WzNdPWUsdFs0XT11LHRbNV09byx0WzZdPWksdFs3XT1zLHRbOF09Yyx0fSxuLmlkZW50aXR5PWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0xLHRbNV09MCx0WzZdPTAsdFs3XT0wLHRbOF09MSx0fSxuLnRyYW5zcG9zZT1mdW5jdGlvbih0LG4pe2lmKHQ9PT1uKXt2YXIgcj1uWzFdLGE9blsyXSxlPW5bNV07dFsxXT1uWzNdLHRbMl09bls2XSx0WzNdPXIsdFs1XT1uWzddLHRbNl09YSx0WzddPWV9ZWxzZSB0WzBdPW5bMF0sdFsxXT1uWzNdLHRbMl09bls2XSx0WzNdPW5bMV0sdFs0XT1uWzRdLHRbNV09bls3XSx0WzZdPW5bMl0sdFs3XT1uWzVdLHRbOF09bls4XTtyZXR1cm4gdH0sbi5pbnZlcnQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPW5bMl0sdT1uWzNdLG89bls0XSxpPW5bNV0scz1uWzZdLGM9bls3XSxmPW5bOF0sTT1mKm8taSpjLGg9LWYqdStpKnMsbD1jKnUtbypzLHY9cipNK2EqaCtlKmw7aWYoIXYpcmV0dXJuIG51bGw7cmV0dXJuIHY9MS92LHRbMF09TSp2LHRbMV09KC1mKmErZSpjKSp2LHRbMl09KGkqYS1lKm8pKnYsdFszXT1oKnYsdFs0XT0oZipyLWUqcykqdix0WzVdPSgtaSpyK2UqdSkqdix0WzZdPWwqdix0WzddPSgtYypyK2Eqcykqdix0WzhdPShvKnItYSp1KSp2LHR9LG4uYWRqb2ludD1mdW5jdGlvbih0LG4pe3ZhciByPW5bMF0sYT1uWzFdLGU9blsyXSx1PW5bM10sbz1uWzRdLGk9bls1XSxzPW5bNl0sYz1uWzddLGY9bls4XTtyZXR1cm4gdFswXT1vKmYtaSpjLHRbMV09ZSpjLWEqZix0WzJdPWEqaS1lKm8sdFszXT1pKnMtdSpmLHRbNF09cipmLWUqcyx0WzVdPWUqdS1yKmksdFs2XT11KmMtbypzLHRbN109YSpzLXIqYyx0WzhdPXIqby1hKnUsdH0sbi5kZXRlcm1pbmFudD1mdW5jdGlvbih0KXt2YXIgbj10WzBdLHI9dFsxXSxhPXRbMl0sZT10WzNdLHU9dFs0XSxvPXRbNV0saT10WzZdLHM9dFs3XSxjPXRbOF07cmV0dXJuIG4qKGMqdS1vKnMpK3IqKC1jKmUrbyppKSthKihzKmUtdSppKX0sbi5tdWx0aXBseT1lLG4udHJhbnNsYXRlPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9bls0XSxzPW5bNV0sYz1uWzZdLGY9bls3XSxNPW5bOF0saD1yWzBdLGw9clsxXTtyZXR1cm4gdFswXT1hLHRbMV09ZSx0WzJdPXUsdFszXT1vLHRbNF09aSx0WzVdPXMsdFs2XT1oKmErbCpvK2MsdFs3XT1oKmUrbCppK2YsdFs4XT1oKnUrbCpzK00sdH0sbi5yb3RhdGU9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT1uWzRdLHM9bls1XSxjPW5bNl0sZj1uWzddLE09bls4XSxoPU1hdGguc2luKHIpLGw9TWF0aC5jb3Mocik7cmV0dXJuIHRbMF09bCphK2gqbyx0WzFdPWwqZStoKmksdFsyXT1sKnUraCpzLHRbM109bCpvLWgqYSx0WzRdPWwqaS1oKmUsdFs1XT1sKnMtaCp1LHRbNl09Yyx0WzddPWYsdFs4XT1NLHR9LG4uc2NhbGU9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPXJbMF0sZT1yWzFdO3JldHVybiB0WzBdPWEqblswXSx0WzFdPWEqblsxXSx0WzJdPWEqblsyXSx0WzNdPWUqblszXSx0WzRdPWUqbls0XSx0WzVdPWUqbls1XSx0WzZdPW5bNl0sdFs3XT1uWzddLHRbOF09bls4XSx0fSxuLmZyb21UcmFuc2xhdGlvbj1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTAsdFs0XT0xLHRbNV09MCx0WzZdPW5bMF0sdFs3XT1uWzFdLHRbOF09MSx0fSxuLmZyb21Sb3RhdGlvbj1mdW5jdGlvbih0LG4pe3ZhciByPU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIHRbMF09YSx0WzFdPXIsdFsyXT0wLHRbM109LXIsdFs0XT1hLHRbNV09MCx0WzZdPTAsdFs3XT0wLHRbOF09MSx0fSxuLmZyb21TY2FsaW5nPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPW5bMV0sdFs1XT0wLHRbNl09MCx0WzddPTAsdFs4XT0xLHR9LG4uZnJvbU1hdDJkPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT0wLHRbM109blsyXSx0WzRdPW5bM10sdFs1XT0wLHRbNl09bls0XSx0WzddPW5bNV0sdFs4XT0xLHR9LG4uZnJvbVF1YXQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPW5bMl0sdT1uWzNdLG89cityLGk9YSthLHM9ZStlLGM9cipvLGY9YSpvLE09YSppLGg9ZSpvLGw9ZSppLHY9ZSpzLGQ9dSpvLGI9dSppLG09dSpzO3JldHVybiB0WzBdPTEtTS12LHRbM109Zi1tLHRbNl09aCtiLHRbMV09ZittLHRbNF09MS1jLXYsdFs3XT1sLWQsdFsyXT1oLWIsdFs1XT1sK2QsdFs4XT0xLWMtTSx0fSxuLm5vcm1hbEZyb21NYXQ0PWZ1bmN0aW9uKHQsbil7dmFyIHI9blswXSxhPW5bMV0sZT1uWzJdLHU9blszXSxvPW5bNF0saT1uWzVdLHM9bls2XSxjPW5bN10sZj1uWzhdLE09bls5XSxoPW5bMTBdLGw9blsxMV0sdj1uWzEyXSxkPW5bMTNdLGI9blsxNF0sbT1uWzE1XSxwPXIqaS1hKm8sUD1yKnMtZSpvLEE9cipjLXUqbyxFPWEqcy1lKmksTz1hKmMtdSppLFI9ZSpjLXUqcyx5PWYqZC1NKnYscT1mKmItaCp2LHg9ZiptLWwqdixfPU0qYi1oKmQsWT1NKm0tbCpkLEw9aCptLWwqYixTPXAqTC1QKlkrQSpfK0UqeC1PKnErUip5O2lmKCFTKXJldHVybiBudWxsO3JldHVybiBTPTEvUyx0WzBdPShpKkwtcypZK2MqXykqUyx0WzFdPShzKngtbypMLWMqcSkqUyx0WzJdPShvKlktaSp4K2MqeSkqUyx0WzNdPShlKlktYSpMLXUqXykqUyx0WzRdPShyKkwtZSp4K3UqcSkqUyx0WzVdPShhKngtcipZLXUqeSkqUyx0WzZdPShkKlItYipPK20qRSkqUyx0WzddPShiKkEtdipSLW0qUCkqUyx0WzhdPSh2Kk8tZCpBK20qcCkqUyx0fSxuLnByb2plY3Rpb249ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPTIvbix0WzFdPTAsdFsyXT0wLHRbM109MCx0WzRdPS0yL3IsdFs1XT0wLHRbNl09LTEsdFs3XT0xLHRbOF09MSx0fSxuLnN0cj1mdW5jdGlvbih0KXtyZXR1cm5cIm1hdDMoXCIrdFswXStcIiwgXCIrdFsxXStcIiwgXCIrdFsyXStcIiwgXCIrdFszXStcIiwgXCIrdFs0XStcIiwgXCIrdFs1XStcIiwgXCIrdFs2XStcIiwgXCIrdFs3XStcIiwgXCIrdFs4XStcIilcIn0sbi5mcm9iPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codFswXSwyKStNYXRoLnBvdyh0WzFdLDIpK01hdGgucG93KHRbMl0sMikrTWF0aC5wb3codFszXSwyKStNYXRoLnBvdyh0WzRdLDIpK01hdGgucG93KHRbNV0sMikrTWF0aC5wb3codFs2XSwyKStNYXRoLnBvdyh0WzddLDIpK01hdGgucG93KHRbOF0sMikpfSxuLmFkZD1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09blswXStyWzBdLHRbMV09blsxXStyWzFdLHRbMl09blsyXStyWzJdLHRbM109blszXStyWzNdLHRbNF09bls0XStyWzRdLHRbNV09bls1XStyWzVdLHRbNl09bls2XStyWzZdLHRbN109bls3XStyWzddLHRbOF09bls4XStyWzhdLHR9LG4uc3VidHJhY3Q9dSxuLm11bHRpcGx5U2NhbGFyPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdKnIsdFsxXT1uWzFdKnIsdFsyXT1uWzJdKnIsdFszXT1uWzNdKnIsdFs0XT1uWzRdKnIsdFs1XT1uWzVdKnIsdFs2XT1uWzZdKnIsdFs3XT1uWzddKnIsdFs4XT1uWzhdKnIsdH0sbi5tdWx0aXBseVNjYWxhckFuZEFkZD1mdW5jdGlvbih0LG4scixhKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0qYSx0WzFdPW5bMV0rclsxXSphLHRbMl09blsyXStyWzJdKmEsdFszXT1uWzNdK3JbM10qYSx0WzRdPW5bNF0rcls0XSphLHRbNV09bls1XStyWzVdKmEsdFs2XT1uWzZdK3JbNl0qYSx0WzddPW5bN10rcls3XSphLHRbOF09bls4XStyWzhdKmEsdH0sbi5leGFjdEVxdWFscz1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPT09blswXSYmdFsxXT09PW5bMV0mJnRbMl09PT1uWzJdJiZ0WzNdPT09blszXSYmdFs0XT09PW5bNF0mJnRbNV09PT1uWzVdJiZ0WzZdPT09bls2XSYmdFs3XT09PW5bN10mJnRbOF09PT1uWzhdfSxuLmVxdWFscz1mdW5jdGlvbih0LG4pe3ZhciByPXRbMF0sZT10WzFdLHU9dFsyXSxvPXRbM10saT10WzRdLHM9dFs1XSxjPXRbNl0sZj10WzddLE09dFs4XSxoPW5bMF0sbD1uWzFdLHY9blsyXSxkPW5bM10sYj1uWzRdLG09bls1XSxwPW5bNl0sUD1uWzddLEE9bls4XTtyZXR1cm4gTWF0aC5hYnMoci1oKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMociksTWF0aC5hYnMoaCkpJiZNYXRoLmFicyhlLWwpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhlKSxNYXRoLmFicyhsKSkmJk1hdGguYWJzKHUtdik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHUpLE1hdGguYWJzKHYpKSYmTWF0aC5hYnMoby1kKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobyksTWF0aC5hYnMoZCkpJiZNYXRoLmFicyhpLWIpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhpKSxNYXRoLmFicyhiKSkmJk1hdGguYWJzKHMtbSk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHMpLE1hdGguYWJzKG0pKSYmTWF0aC5hYnMoYy1wKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYyksTWF0aC5hYnMocCkpJiZNYXRoLmFicyhmLVApPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmKSxNYXRoLmFicyhQKSkmJk1hdGguYWJzKE0tQSk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKE0pLE1hdGguYWJzKEEpKX07dmFyIGE9ZnVuY3Rpb24odCl7aWYodCYmdC5fX2VzTW9kdWxlKXJldHVybiB0O3ZhciBuPXt9O2lmKG51bGwhPXQpZm9yKHZhciByIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQscikmJihuW3JdPXRbcl0pO3JldHVybiBuLmRlZmF1bHQ9dCxufShyKDApKTtmdW5jdGlvbiBlKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9bls0XSxzPW5bNV0sYz1uWzZdLGY9bls3XSxNPW5bOF0saD1yWzBdLGw9clsxXSx2PXJbMl0sZD1yWzNdLGI9cls0XSxtPXJbNV0scD1yWzZdLFA9cls3XSxBPXJbOF07cmV0dXJuIHRbMF09aCphK2wqbyt2KmMsdFsxXT1oKmUrbCppK3YqZix0WzJdPWgqdStsKnMrdipNLHRbM109ZCphK2IqbyttKmMsdFs0XT1kKmUrYippK20qZix0WzVdPWQqdStiKnMrbSpNLHRbNl09cCphK1AqbytBKmMsdFs3XT1wKmUrUCppK0EqZix0WzhdPXAqdStQKnMrQSpNLHR9ZnVuY3Rpb24gdSh0LG4scil7cmV0dXJuIHRbMF09blswXS1yWzBdLHRbMV09blsxXS1yWzFdLHRbMl09blsyXS1yWzJdLHRbM109blszXS1yWzNdLHRbNF09bls0XS1yWzRdLHRbNV09bls1XS1yWzVdLHRbNl09bls2XS1yWzZdLHRbN109bls3XS1yWzddLHRbOF09bls4XS1yWzhdLHR9bi5tdWw9ZSxuLnN1Yj11fSxmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5mb3JFYWNoPW4uc3FyTGVuPW4uc3FyRGlzdD1uLmRpc3Q9bi5kaXY9bi5tdWw9bi5zdWI9bi5sZW49dm9pZCAwLG4uY3JlYXRlPWUsbi5jbG9uZT1mdW5jdGlvbih0KXt2YXIgbj1uZXcgYS5BUlJBWV9UWVBFKDIpO3JldHVybiBuWzBdPXRbMF0sblsxXT10WzFdLG59LG4uZnJvbVZhbHVlcz1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBhLkFSUkFZX1RZUEUoMik7cmV0dXJuIHJbMF09dCxyWzFdPW4scn0sbi5jb3B5PWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdH0sbi5zZXQ9ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPW4sdFsxXT1yLHR9LG4uYWRkPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0sdFsxXT1uWzFdK3JbMV0sdH0sbi5zdWJ0cmFjdD11LG4ubXVsdGlwbHk9byxuLmRpdmlkZT1pLG4uY2VpbD1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPU1hdGguY2VpbChuWzBdKSx0WzFdPU1hdGguY2VpbChuWzFdKSx0fSxuLmZsb29yPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09TWF0aC5mbG9vcihuWzBdKSx0WzFdPU1hdGguZmxvb3IoblsxXSksdH0sbi5taW49ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPU1hdGgubWluKG5bMF0sclswXSksdFsxXT1NYXRoLm1pbihuWzFdLHJbMV0pLHR9LG4ubWF4PWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1NYXRoLm1heChuWzBdLHJbMF0pLHRbMV09TWF0aC5tYXgoblsxXSxyWzFdKSx0fSxuLnJvdW5kPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09TWF0aC5yb3VuZChuWzBdKSx0WzFdPU1hdGgucm91bmQoblsxXSksdH0sbi5zY2FsZT1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09blswXSpyLHRbMV09blsxXSpyLHR9LG4uc2NhbGVBbmRBZGQ9ZnVuY3Rpb24odCxuLHIsYSl7cmV0dXJuIHRbMF09blswXStyWzBdKmEsdFsxXT1uWzFdK3JbMV0qYSx0fSxuLmRpc3RhbmNlPXMsbi5zcXVhcmVkRGlzdGFuY2U9YyxuLmxlbmd0aD1mLG4uc3F1YXJlZExlbmd0aD1NLG4ubmVnYXRlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09LW5bMF0sdFsxXT0tblsxXSx0fSxuLmludmVyc2U9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT0xL25bMF0sdFsxXT0xL25bMV0sdH0sbi5ub3JtYWxpemU9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPXIqcithKmE7ZT4wJiYoZT0xL01hdGguc3FydChlKSx0WzBdPW5bMF0qZSx0WzFdPW5bMV0qZSk7cmV0dXJuIHR9LG4uZG90PWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF0qblswXSt0WzFdKm5bMV19LG4uY3Jvc3M9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPW5bMF0qclsxXS1uWzFdKnJbMF07cmV0dXJuIHRbMF09dFsxXT0wLHRbMl09YSx0fSxuLmxlcnA9ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9blswXSx1PW5bMV07cmV0dXJuIHRbMF09ZSthKihyWzBdLWUpLHRbMV09dSthKihyWzFdLXUpLHR9LG4ucmFuZG9tPWZ1bmN0aW9uKHQsbil7bj1ufHwxO3ZhciByPTIqYS5SQU5ET00oKSpNYXRoLlBJO3JldHVybiB0WzBdPU1hdGguY29zKHIpKm4sdFsxXT1NYXRoLnNpbihyKSpuLHR9LG4udHJhbnNmb3JtTWF0Mj1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV07cmV0dXJuIHRbMF09clswXSphK3JbMl0qZSx0WzFdPXJbMV0qYStyWzNdKmUsdH0sbi50cmFuc2Zvcm1NYXQyZD1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV07cmV0dXJuIHRbMF09clswXSphK3JbMl0qZStyWzRdLHRbMV09clsxXSphK3JbM10qZStyWzVdLHR9LG4udHJhbnNmb3JtTWF0Mz1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV07cmV0dXJuIHRbMF09clswXSphK3JbM10qZStyWzZdLHRbMV09clsxXSphK3JbNF0qZStyWzddLHR9LG4udHJhbnNmb3JtTWF0ND1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV07cmV0dXJuIHRbMF09clswXSphK3JbNF0qZStyWzEyXSx0WzFdPXJbMV0qYStyWzVdKmUrclsxM10sdH0sbi5yb3RhdGU9ZnVuY3Rpb24odCxuLHIsYSl7dmFyIGU9blswXS1yWzBdLHU9blsxXS1yWzFdLG89TWF0aC5zaW4oYSksaT1NYXRoLmNvcyhhKTtyZXR1cm4gdFswXT1lKmktdSpvK3JbMF0sdFsxXT1lKm8rdSppK3JbMV0sdH0sbi5hbmdsZT1mdW5jdGlvbih0LG4pe3ZhciByPXRbMF0sYT10WzFdLGU9blswXSx1PW5bMV0sbz1yKnIrYSphO28+MCYmKG89MS9NYXRoLnNxcnQobykpO3ZhciBpPWUqZSt1KnU7aT4wJiYoaT0xL01hdGguc3FydChpKSk7dmFyIHM9KHIqZSthKnUpKm8qaTtyZXR1cm4gcz4xPzA6czwtMT9NYXRoLlBJOk1hdGguYWNvcyhzKX0sbi5zdHI9ZnVuY3Rpb24odCl7cmV0dXJuXCJ2ZWMyKFwiK3RbMF0rXCIsIFwiK3RbMV0rXCIpXCJ9LG4uZXhhY3RFcXVhbHM9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT09PW5bMF0mJnRbMV09PT1uWzFdfSxuLmVxdWFscz1mdW5jdGlvbih0LG4pe3ZhciByPXRbMF0sZT10WzFdLHU9blswXSxvPW5bMV07cmV0dXJuIE1hdGguYWJzKHItdSk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHIpLE1hdGguYWJzKHUpKSYmTWF0aC5hYnMoZS1vKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoZSksTWF0aC5hYnMobykpfTt2YXIgYT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49e307aWYobnVsbCE9dClmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG4uZGVmYXVsdD10LG59KHIoMCkpO2Z1bmN0aW9uIGUoKXt2YXIgdD1uZXcgYS5BUlJBWV9UWVBFKDIpO3JldHVybiBhLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHRbMF09MCx0WzFdPTApLHR9ZnVuY3Rpb24gdSh0LG4scil7cmV0dXJuIHRbMF09blswXS1yWzBdLHRbMV09blsxXS1yWzFdLHR9ZnVuY3Rpb24gbyh0LG4scil7cmV0dXJuIHRbMF09blswXSpyWzBdLHRbMV09blsxXSpyWzFdLHR9ZnVuY3Rpb24gaSh0LG4scil7cmV0dXJuIHRbMF09blswXS9yWzBdLHRbMV09blsxXS9yWzFdLHR9ZnVuY3Rpb24gcyh0LG4pe3ZhciByPW5bMF0tdFswXSxhPW5bMV0tdFsxXTtyZXR1cm4gTWF0aC5zcXJ0KHIqcithKmEpfWZ1bmN0aW9uIGModCxuKXt2YXIgcj1uWzBdLXRbMF0sYT1uWzFdLXRbMV07cmV0dXJuIHIqcithKmF9ZnVuY3Rpb24gZih0KXt2YXIgbj10WzBdLHI9dFsxXTtyZXR1cm4gTWF0aC5zcXJ0KG4qbityKnIpfWZ1bmN0aW9uIE0odCl7dmFyIG49dFswXSxyPXRbMV07cmV0dXJuIG4qbityKnJ9bi5sZW49ZixuLnN1Yj11LG4ubXVsPW8sbi5kaXY9aSxuLmRpc3Q9cyxuLnNxckRpc3Q9YyxuLnNxckxlbj1NLG4uZm9yRWFjaD1mdW5jdGlvbigpe3ZhciB0PWUoKTtyZXR1cm4gZnVuY3Rpb24obixyLGEsZSx1LG8pe3ZhciBpPXZvaWQgMCxzPXZvaWQgMDtmb3Iocnx8KHI9MiksYXx8KGE9MCkscz1lP01hdGgubWluKGUqcithLG4ubGVuZ3RoKTpuLmxlbmd0aCxpPWE7aTxzO2krPXIpdFswXT1uW2ldLHRbMV09bltpKzFdLHUodCx0LG8pLG5baV09dFswXSxuW2krMV09dFsxXTtyZXR1cm4gbn19KCl9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnNxckxlbj1uLnNxdWFyZWRMZW5ndGg9bi5sZW49bi5sZW5ndGg9bi5kb3Q9bi5tdWw9bi5zZXRSZWFsPW4uZ2V0UmVhbD12b2lkIDAsbi5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgYS5BUlJBWV9UWVBFKDgpO2EuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYodFswXT0wLHRbMV09MCx0WzJdPTAsdFs0XT0wLHRbNV09MCx0WzZdPTAsdFs3XT0wKTtyZXR1cm4gdFszXT0xLHR9LG4uY2xvbmU9ZnVuY3Rpb24odCl7dmFyIG49bmV3IGEuQVJSQVlfVFlQRSg4KTtyZXR1cm4gblswXT10WzBdLG5bMV09dFsxXSxuWzJdPXRbMl0sblszXT10WzNdLG5bNF09dFs0XSxuWzVdPXRbNV0sbls2XT10WzZdLG5bN109dFs3XSxufSxuLmZyb21WYWx1ZXM9ZnVuY3Rpb24odCxuLHIsZSx1LG8saSxzKXt2YXIgYz1uZXcgYS5BUlJBWV9UWVBFKDgpO3JldHVybiBjWzBdPXQsY1sxXT1uLGNbMl09cixjWzNdPWUsY1s0XT11LGNbNV09byxjWzZdPWksY1s3XT1zLGN9LG4uZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXM9ZnVuY3Rpb24odCxuLHIsZSx1LG8saSl7dmFyIHM9bmV3IGEuQVJSQVlfVFlQRSg4KTtzWzBdPXQsc1sxXT1uLHNbMl09cixzWzNdPWU7dmFyIGM9LjUqdSxmPS41Km8sTT0uNSppO3JldHVybiBzWzRdPWMqZStmKnItTSpuLHNbNV09ZiplK00qdC1jKnIsc1s2XT1NKmUrYypuLWYqdCxzWzddPS1jKnQtZipuLU0qcixzfSxuLmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uPWksbi5mcm9tVHJhbnNsYXRpb249ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFswXT0wLHRbMV09MCx0WzJdPTAsdFszXT0xLHRbNF09LjUqblswXSx0WzVdPS41Km5bMV0sdFs2XT0uNSpuWzJdLHRbN109MCx0fSxuLmZyb21Sb3RhdGlvbj1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFs0XT0wLHRbNV09MCx0WzZdPTAsdFs3XT0wLHR9LG4uZnJvbU1hdDQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1lLmNyZWF0ZSgpO3UuZ2V0Um90YXRpb24ocixuKTt2YXIgbz1uZXcgYS5BUlJBWV9UWVBFKDMpO3JldHVybiB1LmdldFRyYW5zbGF0aW9uKG8sbiksaSh0LHIsbyksdH0sbi5jb3B5PXMsbi5pZGVudGl0eT1mdW5jdGlvbih0KXtyZXR1cm4gdFswXT0wLHRbMV09MCx0WzJdPTAsdFszXT0xLHRbNF09MCx0WzVdPTAsdFs2XT0wLHRbN109MCx0fSxuLnNldD1mdW5jdGlvbih0LG4scixhLGUsdSxvLGkscyl7cmV0dXJuIHRbMF09bix0WzFdPXIsdFsyXT1hLHRbM109ZSx0WzRdPXUsdFs1XT1vLHRbNl09aSx0WzddPXMsdH0sbi5nZXREdWFsPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09bls0XSx0WzFdPW5bNV0sdFsyXT1uWzZdLHRbM109bls3XSx0fSxuLnNldER1YWw9ZnVuY3Rpb24odCxuKXtyZXR1cm4gdFs0XT1uWzBdLHRbNV09blsxXSx0WzZdPW5bMl0sdFs3XT1uWzNdLHR9LG4uZ2V0VHJhbnNsYXRpb249ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzRdLGE9bls1XSxlPW5bNl0sdT1uWzddLG89LW5bMF0saT0tblsxXSxzPS1uWzJdLGM9blszXTtyZXR1cm4gdFswXT0yKihyKmMrdSpvK2Eqcy1lKmkpLHRbMV09MiooYSpjK3UqaStlKm8tcipzKSx0WzJdPTIqKGUqYyt1KnMrcippLWEqbyksdH0sbi50cmFuc2xhdGU9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT0uNSpyWzBdLHM9LjUqclsxXSxjPS41KnJbMl0sZj1uWzRdLE09bls1XSxoPW5bNl0sbD1uWzddO3JldHVybiB0WzBdPWEsdFsxXT1lLHRbMl09dSx0WzNdPW8sdFs0XT1vKmkrZSpjLXUqcytmLHRbNV09bypzK3UqaS1hKmMrTSx0WzZdPW8qYythKnMtZSppK2gsdFs3XT0tYSppLWUqcy11KmMrbCx0fSxuLnJvdGF0ZVg9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPS1uWzBdLHU9LW5bMV0sbz0tblsyXSxpPW5bM10scz1uWzRdLGM9bls1XSxmPW5bNl0sTT1uWzddLGg9cyppK00qYStjKm8tZip1LGw9YyppK00qdStmKmEtcypvLHY9ZippK00qbytzKnUtYyphLGQ9TSppLXMqYS1jKnUtZipvO3JldHVybiBlLnJvdGF0ZVgodCxuLHIpLGE9dFswXSx1PXRbMV0sbz10WzJdLGk9dFszXSx0WzRdPWgqaStkKmErbCpvLXYqdSx0WzVdPWwqaStkKnUrdiphLWgqbyx0WzZdPXYqaStkKm8raCp1LWwqYSx0WzddPWQqaS1oKmEtbCp1LXYqbyx0fSxuLnJvdGF0ZVk9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPS1uWzBdLHU9LW5bMV0sbz0tblsyXSxpPW5bM10scz1uWzRdLGM9bls1XSxmPW5bNl0sTT1uWzddLGg9cyppK00qYStjKm8tZip1LGw9YyppK00qdStmKmEtcypvLHY9ZippK00qbytzKnUtYyphLGQ9TSppLXMqYS1jKnUtZipvO3JldHVybiBlLnJvdGF0ZVkodCxuLHIpLGE9dFswXSx1PXRbMV0sbz10WzJdLGk9dFszXSx0WzRdPWgqaStkKmErbCpvLXYqdSx0WzVdPWwqaStkKnUrdiphLWgqbyx0WzZdPXYqaStkKm8raCp1LWwqYSx0WzddPWQqaS1oKmEtbCp1LXYqbyx0fSxuLnJvdGF0ZVo9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPS1uWzBdLHU9LW5bMV0sbz0tblsyXSxpPW5bM10scz1uWzRdLGM9bls1XSxmPW5bNl0sTT1uWzddLGg9cyppK00qYStjKm8tZip1LGw9YyppK00qdStmKmEtcypvLHY9ZippK00qbytzKnUtYyphLGQ9TSppLXMqYS1jKnUtZipvO3JldHVybiBlLnJvdGF0ZVoodCxuLHIpLGE9dFswXSx1PXRbMV0sbz10WzJdLGk9dFszXSx0WzRdPWgqaStkKmErbCpvLXYqdSx0WzVdPWwqaStkKnUrdiphLWgqbyx0WzZdPXYqaStkKm8raCp1LWwqYSx0WzddPWQqaS1oKmEtbCp1LXYqbyx0fSxuLnJvdGF0ZUJ5UXVhdEFwcGVuZD1mdW5jdGlvbih0LG4scil7dmFyIGE9clswXSxlPXJbMV0sdT1yWzJdLG89clszXSxpPW5bMF0scz1uWzFdLGM9blsyXSxmPW5bM107cmV0dXJuIHRbMF09aSpvK2YqYStzKnUtYyplLHRbMV09cypvK2YqZStjKmEtaSp1LHRbMl09YypvK2YqdStpKmUtcyphLHRbM109ZipvLWkqYS1zKmUtYyp1LGk9bls0XSxzPW5bNV0sYz1uWzZdLGY9bls3XSx0WzRdPWkqbytmKmErcyp1LWMqZSx0WzVdPXMqbytmKmUrYyphLWkqdSx0WzZdPWMqbytmKnUraSplLXMqYSx0WzddPWYqby1pKmEtcyplLWMqdSx0fSxuLnJvdGF0ZUJ5UXVhdFByZXBlbmQ9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT1yWzBdLHM9clsxXSxjPXJbMl0sZj1yWzNdO3JldHVybiB0WzBdPWEqZitvKmkrZSpjLXUqcyx0WzFdPWUqZitvKnMrdSppLWEqYyx0WzJdPXUqZitvKmMrYSpzLWUqaSx0WzNdPW8qZi1hKmktZSpzLXUqYyxpPXJbNF0scz1yWzVdLGM9cls2XSxmPXJbN10sdFs0XT1hKmYrbyppK2UqYy11KnMsdFs1XT1lKmYrbypzK3UqaS1hKmMsdFs2XT11KmYrbypjK2Eqcy1lKmksdFs3XT1vKmYtYSppLWUqcy11KmMsdH0sbi5yb3RhdGVBcm91bmRBeGlzPWZ1bmN0aW9uKHQsbixyLGUpe2lmKE1hdGguYWJzKGUpPGEuRVBTSUxPTilyZXR1cm4gcyh0LG4pO3ZhciB1PU1hdGguc3FydChyWzBdKnJbMF0rclsxXSpyWzFdK3JbMl0qclsyXSk7ZSo9LjU7dmFyIG89TWF0aC5zaW4oZSksaT1vKnJbMF0vdSxjPW8qclsxXS91LGY9bypyWzJdL3UsTT1NYXRoLmNvcyhlKSxoPW5bMF0sbD1uWzFdLHY9blsyXSxkPW5bM107dFswXT1oKk0rZCppK2wqZi12KmMsdFsxXT1sKk0rZCpjK3YqaS1oKmYsdFsyXT12Kk0rZCpmK2gqYy1sKmksdFszXT1kKk0taCppLWwqYy12KmY7dmFyIGI9bls0XSxtPW5bNV0scD1uWzZdLFA9bls3XTtyZXR1cm4gdFs0XT1iKk0rUCppK20qZi1wKmMsdFs1XT1tKk0rUCpjK3AqaS1iKmYsdFs2XT1wKk0rUCpmK2IqYy1tKmksdFs3XT1QKk0tYippLW0qYy1wKmYsdH0sbi5hZGQ9ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPW5bMF0rclswXSx0WzFdPW5bMV0rclsxXSx0WzJdPW5bMl0rclsyXSx0WzNdPW5bM10rclszXSx0WzRdPW5bNF0rcls0XSx0WzVdPW5bNV0rcls1XSx0WzZdPW5bNl0rcls2XSx0WzddPW5bN10rcls3XSx0fSxuLm11bHRpcGx5PWMsbi5zY2FsZT1mdW5jdGlvbih0LG4scil7cmV0dXJuIHRbMF09blswXSpyLHRbMV09blsxXSpyLHRbMl09blsyXSpyLHRbM109blszXSpyLHRbNF09bls0XSpyLHRbNV09bls1XSpyLHRbNl09bls2XSpyLHRbN109bls3XSpyLHR9LG4ubGVycD1mdW5jdGlvbih0LG4scixhKXt2YXIgZT0xLWE7ZihuLHIpPDAmJihhPS1hKTtyZXR1cm4gdFswXT1uWzBdKmUrclswXSphLHRbMV09blsxXSplK3JbMV0qYSx0WzJdPW5bMl0qZStyWzJdKmEsdFszXT1uWzNdKmUrclszXSphLHRbNF09bls0XSplK3JbNF0qYSx0WzVdPW5bNV0qZStyWzVdKmEsdFs2XT1uWzZdKmUrcls2XSphLHRbN109bls3XSplK3JbN10qYSx0fSxuLmludmVydD1mdW5jdGlvbih0LG4pe3ZhciByPWgobik7cmV0dXJuIHRbMF09LW5bMF0vcix0WzFdPS1uWzFdL3IsdFsyXT0tblsyXS9yLHRbM109blszXS9yLHRbNF09LW5bNF0vcix0WzVdPS1uWzVdL3IsdFs2XT0tbls2XS9yLHRbN109bls3XS9yLHR9LG4uY29uanVnYXRlPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09LW5bMF0sdFsxXT0tblsxXSx0WzJdPS1uWzJdLHRbM109blszXSx0WzRdPS1uWzRdLHRbNV09LW5bNV0sdFs2XT0tbls2XSx0WzddPW5bN10sdH0sbi5ub3JtYWxpemU9ZnVuY3Rpb24odCxuKXt2YXIgcj1oKG4pO2lmKHI+MCl7cj1NYXRoLnNxcnQocik7dmFyIGE9blswXS9yLGU9blsxXS9yLHU9blsyXS9yLG89blszXS9yLGk9bls0XSxzPW5bNV0sYz1uWzZdLGY9bls3XSxNPWEqaStlKnMrdSpjK28qZjt0WzBdPWEsdFsxXT1lLHRbMl09dSx0WzNdPW8sdFs0XT0oaS1hKk0pL3IsdFs1XT0ocy1lKk0pL3IsdFs2XT0oYy11Kk0pL3IsdFs3XT0oZi1vKk0pL3J9cmV0dXJuIHR9LG4uc3RyPWZ1bmN0aW9uKHQpe3JldHVyblwicXVhdDIoXCIrdFswXStcIiwgXCIrdFsxXStcIiwgXCIrdFsyXStcIiwgXCIrdFszXStcIiwgXCIrdFs0XStcIiwgXCIrdFs1XStcIiwgXCIrdFs2XStcIiwgXCIrdFs3XStcIilcIn0sbi5leGFjdEVxdWFscz1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPT09blswXSYmdFsxXT09PW5bMV0mJnRbMl09PT1uWzJdJiZ0WzNdPT09blszXSYmdFs0XT09PW5bNF0mJnRbNV09PT1uWzVdJiZ0WzZdPT09bls2XSYmdFs3XT09PW5bN119LG4uZXF1YWxzPWZ1bmN0aW9uKHQsbil7dmFyIHI9dFswXSxlPXRbMV0sdT10WzJdLG89dFszXSxpPXRbNF0scz10WzVdLGM9dFs2XSxmPXRbN10sTT1uWzBdLGg9blsxXSxsPW5bMl0sdj1uWzNdLGQ9bls0XSxiPW5bNV0sbT1uWzZdLHA9bls3XTtyZXR1cm4gTWF0aC5hYnMoci1NKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMociksTWF0aC5hYnMoTSkpJiZNYXRoLmFicyhlLWgpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhlKSxNYXRoLmFicyhoKSkmJk1hdGguYWJzKHUtbCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHUpLE1hdGguYWJzKGwpKSYmTWF0aC5hYnMoby12KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobyksTWF0aC5hYnModikpJiZNYXRoLmFicyhpLWQpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhpKSxNYXRoLmFicyhkKSkmJk1hdGguYWJzKHMtYik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHMpLE1hdGguYWJzKGIpKSYmTWF0aC5hYnMoYy1tKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMoYyksTWF0aC5hYnMobSkpJiZNYXRoLmFicyhmLXApPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhmKSxNYXRoLmFicyhwKSl9O3ZhciBhPW8ocigwKSksZT1vKHIoMykpLHU9byhyKDQpKTtmdW5jdGlvbiBvKHQpe2lmKHQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgbj17fTtpZihudWxsIT10KWZvcih2YXIgciBpbiB0KU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LHIpJiYobltyXT10W3JdKTtyZXR1cm4gbi5kZWZhdWx0PXQsbn1mdW5jdGlvbiBpKHQsbixyKXt2YXIgYT0uNSpyWzBdLGU9LjUqclsxXSx1PS41KnJbMl0sbz1uWzBdLGk9blsxXSxzPW5bMl0sYz1uWzNdO3JldHVybiB0WzBdPW8sdFsxXT1pLHRbMl09cyx0WzNdPWMsdFs0XT1hKmMrZSpzLXUqaSx0WzVdPWUqYyt1Km8tYSpzLHRbNl09dSpjK2EqaS1lKm8sdFs3XT0tYSpvLWUqaS11KnMsdH1mdW5jdGlvbiBzKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPW5bMV0sdFsyXT1uWzJdLHRbM109blszXSx0WzRdPW5bNF0sdFs1XT1uWzVdLHRbNl09bls2XSx0WzddPW5bN10sdH1uLmdldFJlYWw9ZS5jb3B5O24uc2V0UmVhbD1lLmNvcHk7ZnVuY3Rpb24gYyh0LG4scil7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89blszXSxpPXJbNF0scz1yWzVdLGM9cls2XSxmPXJbN10sTT1uWzRdLGg9bls1XSxsPW5bNl0sdj1uWzddLGQ9clswXSxiPXJbMV0sbT1yWzJdLHA9clszXTtyZXR1cm4gdFswXT1hKnArbypkK2UqbS11KmIsdFsxXT1lKnArbypiK3UqZC1hKm0sdFsyXT11KnArbyptK2EqYi1lKmQsdFszXT1vKnAtYSpkLWUqYi11Km0sdFs0XT1hKmYrbyppK2UqYy11KnMrTSpwK3YqZCtoKm0tbCpiLHRbNV09ZSpmK28qcyt1KmktYSpjK2gqcCt2KmIrbCpkLU0qbSx0WzZdPXUqZitvKmMrYSpzLWUqaStsKnArdiptK00qYi1oKmQsdFs3XT1vKmYtYSppLWUqcy11KmMrdipwLU0qZC1oKmItbCptLHR9bi5tdWw9Yzt2YXIgZj1uLmRvdD1lLmRvdDt2YXIgTT1uLmxlbmd0aD1lLmxlbmd0aCxoPShuLmxlbj1NLG4uc3F1YXJlZExlbmd0aD1lLnNxdWFyZWRMZW5ndGgpO24uc3FyTGVuPWh9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnN1Yj1uLm11bD12b2lkIDAsbi5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgYS5BUlJBWV9UWVBFKDYpO2EuQVJSQVlfVFlQRSE9RmxvYXQzMkFycmF5JiYodFsxXT0wLHRbMl09MCx0WzRdPTAsdFs1XT0wKTtyZXR1cm4gdFswXT0xLHRbM109MSx0fSxuLmNsb25lPWZ1bmN0aW9uKHQpe3ZhciBuPW5ldyBhLkFSUkFZX1RZUEUoNik7cmV0dXJuIG5bMF09dFswXSxuWzFdPXRbMV0sblsyXT10WzJdLG5bM109dFszXSxuWzRdPXRbNF0sbls1XT10WzVdLG59LG4uY29weT1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdFs0XT1uWzRdLHRbNV09bls1XSx0fSxuLmlkZW50aXR5PWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdPTEsdFsxXT0wLHRbMl09MCx0WzNdPTEsdFs0XT0wLHRbNV09MCx0fSxuLmZyb21WYWx1ZXM9ZnVuY3Rpb24odCxuLHIsZSx1LG8pe3ZhciBpPW5ldyBhLkFSUkFZX1RZUEUoNik7cmV0dXJuIGlbMF09dCxpWzFdPW4saVsyXT1yLGlbM109ZSxpWzRdPXUsaVs1XT1vLGl9LG4uc2V0PWZ1bmN0aW9uKHQsbixyLGEsZSx1LG8pe3JldHVybiB0WzBdPW4sdFsxXT1yLHRbMl09YSx0WzNdPWUsdFs0XT11LHRbNV09byx0fSxuLmludmVydD1mdW5jdGlvbih0LG4pe3ZhciByPW5bMF0sYT1uWzFdLGU9blsyXSx1PW5bM10sbz1uWzRdLGk9bls1XSxzPXIqdS1hKmU7aWYoIXMpcmV0dXJuIG51bGw7cmV0dXJuIHM9MS9zLHRbMF09dSpzLHRbMV09LWEqcyx0WzJdPS1lKnMsdFszXT1yKnMsdFs0XT0oZSppLXUqbykqcyx0WzVdPShhKm8tcippKSpzLHR9LG4uZGV0ZXJtaW5hbnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRbMF0qdFszXS10WzFdKnRbMl19LG4ubXVsdGlwbHk9ZSxuLnJvdGF0ZT1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89blszXSxpPW5bNF0scz1uWzVdLGM9TWF0aC5zaW4ociksZj1NYXRoLmNvcyhyKTtyZXR1cm4gdFswXT1hKmYrdSpjLHRbMV09ZSpmK28qYyx0WzJdPWEqLWMrdSpmLHRbM109ZSotYytvKmYsdFs0XT1pLHRbNV09cyx0fSxuLnNjYWxlPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9bls0XSxzPW5bNV0sYz1yWzBdLGY9clsxXTtyZXR1cm4gdFswXT1hKmMsdFsxXT1lKmMsdFsyXT11KmYsdFszXT1vKmYsdFs0XT1pLHRbNV09cyx0fSxuLnRyYW5zbGF0ZT1mdW5jdGlvbih0LG4scil7dmFyIGE9blswXSxlPW5bMV0sdT1uWzJdLG89blszXSxpPW5bNF0scz1uWzVdLGM9clswXSxmPXJbMV07cmV0dXJuIHRbMF09YSx0WzFdPWUsdFsyXT11LHRbM109byx0WzRdPWEqYyt1KmYraSx0WzVdPWUqYytvKmYrcyx0fSxuLmZyb21Sb3RhdGlvbj1mdW5jdGlvbih0LG4pe3ZhciByPU1hdGguc2luKG4pLGE9TWF0aC5jb3Mobik7cmV0dXJuIHRbMF09YSx0WzFdPXIsdFsyXT0tcix0WzNdPWEsdFs0XT0wLHRbNV09MCx0fSxuLmZyb21TY2FsaW5nPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPTAsdFsyXT0wLHRbM109blsxXSx0WzRdPTAsdFs1XT0wLHR9LG4uZnJvbVRyYW5zbGF0aW9uPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09MSx0WzFdPTAsdFsyXT0wLHRbM109MSx0WzRdPW5bMF0sdFs1XT1uWzFdLHR9LG4uc3RyPWZ1bmN0aW9uKHQpe3JldHVyblwibWF0MmQoXCIrdFswXStcIiwgXCIrdFsxXStcIiwgXCIrdFsyXStcIiwgXCIrdFszXStcIiwgXCIrdFs0XStcIiwgXCIrdFs1XStcIilcIn0sbi5mcm9iPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codFswXSwyKStNYXRoLnBvdyh0WzFdLDIpK01hdGgucG93KHRbMl0sMikrTWF0aC5wb3codFszXSwyKStNYXRoLnBvdyh0WzRdLDIpK01hdGgucG93KHRbNV0sMikrMSl9LG4uYWRkPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0sdFsxXT1uWzFdK3JbMV0sdFsyXT1uWzJdK3JbMl0sdFszXT1uWzNdK3JbM10sdFs0XT1uWzRdK3JbNF0sdFs1XT1uWzVdK3JbNV0sdH0sbi5zdWJ0cmFjdD11LG4ubXVsdGlwbHlTY2FsYXI9ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPW5bMF0qcix0WzFdPW5bMV0qcix0WzJdPW5bMl0qcix0WzNdPW5bM10qcix0WzRdPW5bNF0qcix0WzVdPW5bNV0qcix0fSxuLm11bHRpcGx5U2NhbGFyQW5kQWRkPWZ1bmN0aW9uKHQsbixyLGEpe3JldHVybiB0WzBdPW5bMF0rclswXSphLHRbMV09blsxXStyWzFdKmEsdFsyXT1uWzJdK3JbMl0qYSx0WzNdPW5bM10rclszXSphLHRbNF09bls0XStyWzRdKmEsdFs1XT1uWzVdK3JbNV0qYSx0fSxuLmV4YWN0RXF1YWxzPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09PT1uWzBdJiZ0WzFdPT09blsxXSYmdFsyXT09PW5bMl0mJnRbM109PT1uWzNdJiZ0WzRdPT09bls0XSYmdFs1XT09PW5bNV19LG4uZXF1YWxzPWZ1bmN0aW9uKHQsbil7dmFyIHI9dFswXSxlPXRbMV0sdT10WzJdLG89dFszXSxpPXRbNF0scz10WzVdLGM9blswXSxmPW5bMV0sTT1uWzJdLGg9blszXSxsPW5bNF0sdj1uWzVdO3JldHVybiBNYXRoLmFicyhyLWMpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhyKSxNYXRoLmFicyhjKSkmJk1hdGguYWJzKGUtZik8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGUpLE1hdGguYWJzKGYpKSYmTWF0aC5hYnModS1NKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnModSksTWF0aC5hYnMoTSkpJiZNYXRoLmFicyhvLWgpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhvKSxNYXRoLmFicyhoKSkmJk1hdGguYWJzKGktbCk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKGkpLE1hdGguYWJzKGwpKSYmTWF0aC5hYnMocy12KTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMocyksTWF0aC5hYnModikpfTt2YXIgYT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49e307aWYobnVsbCE9dClmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG4uZGVmYXVsdD10LG59KHIoMCkpO2Z1bmN0aW9uIGUodCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT1uWzRdLHM9bls1XSxjPXJbMF0sZj1yWzFdLE09clsyXSxoPXJbM10sbD1yWzRdLHY9cls1XTtyZXR1cm4gdFswXT1hKmMrdSpmLHRbMV09ZSpjK28qZix0WzJdPWEqTSt1KmgsdFszXT1lKk0rbypoLHRbNF09YSpsK3UqditpLHRbNV09ZSpsK28qditzLHR9ZnVuY3Rpb24gdSh0LG4scil7cmV0dXJuIHRbMF09blswXS1yWzBdLHRbMV09blsxXS1yWzFdLHRbMl09blsyXS1yWzJdLHRbM109blszXS1yWzNdLHRbNF09bls0XS1yWzRdLHRbNV09bls1XS1yWzVdLHR9bi5tdWw9ZSxuLnN1Yj11fSxmdW5jdGlvbih0LG4scil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbi5zdWI9bi5tdWw9dm9pZCAwLG4uY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGEuQVJSQVlfVFlQRSg0KTthLkFSUkFZX1RZUEUhPUZsb2F0MzJBcnJheSYmKHRbMV09MCx0WzJdPTApO3JldHVybiB0WzBdPTEsdFszXT0xLHR9LG4uY2xvbmU9ZnVuY3Rpb24odCl7dmFyIG49bmV3IGEuQVJSQVlfVFlQRSg0KTtyZXR1cm4gblswXT10WzBdLG5bMV09dFsxXSxuWzJdPXRbMl0sblszXT10WzNdLG59LG4uY29weT1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPW5bMF0sdFsxXT1uWzFdLHRbMl09blsyXSx0WzNdPW5bM10sdH0sbi5pZGVudGl0eT1mdW5jdGlvbih0KXtyZXR1cm4gdFswXT0xLHRbMV09MCx0WzJdPTAsdFszXT0xLHR9LG4uZnJvbVZhbHVlcz1mdW5jdGlvbih0LG4scixlKXt2YXIgdT1uZXcgYS5BUlJBWV9UWVBFKDQpO3JldHVybiB1WzBdPXQsdVsxXT1uLHVbMl09cix1WzNdPWUsdX0sbi5zZXQ9ZnVuY3Rpb24odCxuLHIsYSxlKXtyZXR1cm4gdFswXT1uLHRbMV09cix0WzJdPWEsdFszXT1lLHR9LG4udHJhbnNwb3NlPWZ1bmN0aW9uKHQsbil7aWYodD09PW4pe3ZhciByPW5bMV07dFsxXT1uWzJdLHRbMl09cn1lbHNlIHRbMF09blswXSx0WzFdPW5bMl0sdFsyXT1uWzFdLHRbM109blszXTtyZXR1cm4gdH0sbi5pbnZlcnQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdLGE9blsxXSxlPW5bMl0sdT1uWzNdLG89cip1LWUqYTtpZighbylyZXR1cm4gbnVsbDtyZXR1cm4gbz0xL28sdFswXT11Km8sdFsxXT0tYSpvLHRbMl09LWUqbyx0WzNdPXIqbyx0fSxuLmFkam9pbnQ9ZnVuY3Rpb24odCxuKXt2YXIgcj1uWzBdO3JldHVybiB0WzBdPW5bM10sdFsxXT0tblsxXSx0WzJdPS1uWzJdLHRbM109cix0fSxuLmRldGVybWluYW50PWZ1bmN0aW9uKHQpe3JldHVybiB0WzBdKnRbM10tdFsyXSp0WzFdfSxuLm11bHRpcGx5PWUsbi5yb3RhdGU9ZnVuY3Rpb24odCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT1NYXRoLnNpbihyKSxzPU1hdGguY29zKHIpO3JldHVybiB0WzBdPWEqcyt1KmksdFsxXT1lKnMrbyppLHRbMl09YSotaSt1KnMsdFszXT1lKi1pK28qcyx0fSxuLnNjYWxlPWZ1bmN0aW9uKHQsbixyKXt2YXIgYT1uWzBdLGU9blsxXSx1PW5bMl0sbz1uWzNdLGk9clswXSxzPXJbMV07cmV0dXJuIHRbMF09YSppLHRbMV09ZSppLHRbMl09dSpzLHRbM109bypzLHR9LG4uZnJvbVJvdGF0aW9uPWZ1bmN0aW9uKHQsbil7dmFyIHI9TWF0aC5zaW4obiksYT1NYXRoLmNvcyhuKTtyZXR1cm4gdFswXT1hLHRbMV09cix0WzJdPS1yLHRbM109YSx0fSxuLmZyb21TY2FsaW5nPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHRbMF09blswXSx0WzFdPTAsdFsyXT0wLHRbM109blsxXSx0fSxuLnN0cj1mdW5jdGlvbih0KXtyZXR1cm5cIm1hdDIoXCIrdFswXStcIiwgXCIrdFsxXStcIiwgXCIrdFsyXStcIiwgXCIrdFszXStcIilcIn0sbi5mcm9iPWZ1bmN0aW9uKHQpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codFswXSwyKStNYXRoLnBvdyh0WzFdLDIpK01hdGgucG93KHRbMl0sMikrTWF0aC5wb3codFszXSwyKSl9LG4uTERVPWZ1bmN0aW9uKHQsbixyLGEpe3JldHVybiB0WzJdPWFbMl0vYVswXSxyWzBdPWFbMF0sclsxXT1hWzFdLHJbM109YVszXS10WzJdKnJbMV0sW3QsbixyXX0sbi5hZGQ9ZnVuY3Rpb24odCxuLHIpe3JldHVybiB0WzBdPW5bMF0rclswXSx0WzFdPW5bMV0rclsxXSx0WzJdPW5bMl0rclsyXSx0WzNdPW5bM10rclszXSx0fSxuLnN1YnRyYWN0PXUsbi5leGFjdEVxdWFscz1mdW5jdGlvbih0LG4pe3JldHVybiB0WzBdPT09blswXSYmdFsxXT09PW5bMV0mJnRbMl09PT1uWzJdJiZ0WzNdPT09blszXX0sbi5lcXVhbHM9ZnVuY3Rpb24odCxuKXt2YXIgcj10WzBdLGU9dFsxXSx1PXRbMl0sbz10WzNdLGk9blswXSxzPW5bMV0sYz1uWzJdLGY9blszXTtyZXR1cm4gTWF0aC5hYnMoci1pKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMociksTWF0aC5hYnMoaSkpJiZNYXRoLmFicyhlLXMpPD1hLkVQU0lMT04qTWF0aC5tYXgoMSxNYXRoLmFicyhlKSxNYXRoLmFicyhzKSkmJk1hdGguYWJzKHUtYyk8PWEuRVBTSUxPTipNYXRoLm1heCgxLE1hdGguYWJzKHUpLE1hdGguYWJzKGMpKSYmTWF0aC5hYnMoby1mKTw9YS5FUFNJTE9OKk1hdGgubWF4KDEsTWF0aC5hYnMobyksTWF0aC5hYnMoZikpfSxuLm11bHRpcGx5U2NhbGFyPWZ1bmN0aW9uKHQsbixyKXtyZXR1cm4gdFswXT1uWzBdKnIsdFsxXT1uWzFdKnIsdFsyXT1uWzJdKnIsdFszXT1uWzNdKnIsdH0sbi5tdWx0aXBseVNjYWxhckFuZEFkZD1mdW5jdGlvbih0LG4scixhKXtyZXR1cm4gdFswXT1uWzBdK3JbMF0qYSx0WzFdPW5bMV0rclsxXSphLHRbMl09blsyXStyWzJdKmEsdFszXT1uWzNdK3JbM10qYSx0fTt2YXIgYT1mdW5jdGlvbih0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49e307aWYobnVsbCE9dClmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG4uZGVmYXVsdD10LG59KHIoMCkpO2Z1bmN0aW9uIGUodCxuLHIpe3ZhciBhPW5bMF0sZT1uWzFdLHU9blsyXSxvPW5bM10saT1yWzBdLHM9clsxXSxjPXJbMl0sZj1yWzNdO3JldHVybiB0WzBdPWEqaSt1KnMsdFsxXT1lKmkrbypzLHRbMl09YSpjK3UqZix0WzNdPWUqYytvKmYsdH1mdW5jdGlvbiB1KHQsbixyKXtyZXR1cm4gdFswXT1uWzBdLXJbMF0sdFsxXT1uWzFdLXJbMV0sdFsyXT1uWzJdLXJbMl0sdFszXT1uWzNdLXJbM10sdH1uLm11bD1lLG4uc3ViPXV9LGZ1bmN0aW9uKHQsbixyKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkobixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuLnZlYzQ9bi52ZWMzPW4udmVjMj1uLnF1YXQyPW4ucXVhdD1uLm1hdDQ9bi5tYXQzPW4ubWF0MmQ9bi5tYXQyPW4uZ2xNYXRyaXg9dm9pZCAwO3ZhciBhPWwocigwKSksZT1sKHIoOSkpLHU9bChyKDgpKSxvPWwocig1KSksaT1sKHIoNCkpLHM9bChyKDMpKSxjPWwocig3KSksZj1sKHIoNikpLE09bChyKDIpKSxoPWwocigxKSk7ZnVuY3Rpb24gbCh0KXtpZih0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49e307aWYobnVsbCE9dClmb3IodmFyIHIgaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxyKSYmKG5bcl09dFtyXSk7cmV0dXJuIG4uZGVmYXVsdD10LG59bi5nbE1hdHJpeD1hLG4ubWF0Mj1lLG4ubWF0MmQ9dSxuLm1hdDM9byxuLm1hdDQ9aSxuLnF1YXQ9cyxuLnF1YXQyPWMsbi52ZWMyPWYsbi52ZWMzPU0sbi52ZWM0PWh9XSl9KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9kaXN0L2dsLW1hdHJpeC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MAXY = exports.MAXX = exports.MINY = exports.MINX = undefined;\nexports.set = set;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.initEmpty = initEmpty;\nexports.initInfinity = initInfinity;\nexports.initSizeFromOrigin = initSizeFromOrigin;\nexports.initSizeFromLocation = initSizeFromLocation;\nexports.initCenterExtents = initCenterExtents;\nexports.isEmpty = isEmpty;\nexports.isInfinite = isInfinite;\nexports.equals = equals;\nexports.getSize = getSize;\nexports.getExtents = getExtents;\nexports.getCenter = getCenter;\nexports.expand = expand;\nexports.area = area;\nexports.hull = hull;\nexports.intersection = intersection;\nexports.overlaps = overlaps;\nexports.contains = contains;\nexports.containsPt = containsPt;\nexports.encapsulatePt = encapsulatePt;\nexports.translate = translate;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\n\nvar _glMatrix = __webpack_require__(1);\n\nvar MINX = exports.MINX = 0;\nvar MINY = exports.MINY = 1;\nvar MAXX = exports.MAXX = 2;\nvar MAXY = exports.MAXY = 3;\n\nvar Constants = {\n  BOX_SIDES: 4\n\n  /**\n   * Sets the boundaries of an existing 2d axis-aligned bounding box\n   * If arguments are not supplied, the aabox is initialized as empty.\n   * @param {AABox2d} out  AAbox2d to set\n   * @param {Number} [minx = Infinity] Minimum x-axis value\n   * @param {Number} [miny = Infinity] Minimum y-axis value\n   * @param {Number} [maxx = -Infinity] Maximum x-axis value\n   * @param {Number} [maxy = -Infinity] Maximum y-axis value\n   * @return {AABox2d}    bounds referenced by out arg\n   */\n};function set(out, minx, miny, maxx, maxy) {\n  out[MINX] = typeof minx === \"number\" ? minx : Infinity;\n  out[MINY] = typeof miny === \"number\" ? miny : Infinity;\n  out[MAXX] = typeof maxx === \"number\" ? maxx : -Infinity;\n  out[MAXY] = typeof maxy === \"number\" ? maxy : -Infinity;\n  return out;\n}\n\n/**\n * Creates a new 2d axis-aligned bounding box object\n * with optional boundaries. If boundaries are not supplied,\n * the aabox is initialized as empty.\n * @param  {Number} [minx = Infinity] Minimum x-axis value\n * @param  {Number} [miny = Infinity] Minimum y-axis value\n * @param  {Number} [maxx = -Infinity] Maximum x-axis value\n * @param  {Number} [maxy = -Infinity] Maximum y-axis value\n * @return {AABox2d}      New AABox2d object\n */\nfunction create(minx, miny, maxx, maxy) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(Constants.BOX_SIDES);\n  return set(out, minx, miny, maxx, maxy);\n}\n\n/**\n * Creates a new 2d axis-aligned bounding box with boundaries copied\n * from an existing aabox.\n * @param  {AABox2d} box existing bounds to copy boundaries from\n * @return {AABox2d}     new AABox2d object\n */\nfunction clone(box) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(Constants.BOX_SIDES);\n  out[MINX] = box[MINX];\n  out[MINY] = box[MINY];\n  out[MAXX] = box[MAXX];\n  out[MAXY] = box[MAXY];\n  return out;\n}\n\n/**\n * Copies the boundaries from one existing aabox to another.\n * @param  {AABox2d} out bounds to copy to\n * @param  {AABox2d} box bounds to copy from\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction copy(out, box) {\n  out[MINX] = box[MINX];\n  out[MINY] = box[MINY];\n  out[MAXX] = box[MAXX];\n  out[MAXY] = box[MAXY];\n  return out;\n}\n\n/**\n * Re-initializes an existing aabox as empty.\n * An aabox is empty if the minimum value in either of\n * its dimensions exceeds its respective max value.\n * In this case, the minumums will be set to +Infinity\n * and the maximums to -Infinity\n * @param  {AABox2d} out existing bounds to re-initialize as empty\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction initEmpty(out) {\n  out[MINX] = Infinity;\n  out[MINY] = Infinity;\n  out[MAXX] = -Infinity;\n  out[MAXY] = -Infinity;\n  return out;\n}\n\n/**\n * Re-initializes an existing aabox to infinity, ultimately encompassing\n * all numeric values.\n * @param  {AABox2d} out existing bounds to initialize to infinity\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction initInfinity(out) {\n  out[MINX] = -Infinity;\n  out[MINY] = -Infinity;\n  out[MAXX] = Infinity;\n  out[MAXY] = Infinity;\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its top-left corner set to be the origin ([0, 0]),\n * an extends outwards in each dimension by its respective size.\n *   minx: 0\n *   miny: 0\n *   maxx: sizes[x]\n *   maxy: sizes[y]\n * @param  {AABox2d} out   existing bounds to re-initialize\n * @param  {Vec2d} sizes   new width/height of the bounds\n * @return {AABox2d}       bounds referenced by out arg\n */\nfunction initSizeFromOrigin(out, sizes) {\n  if (sizes[0] < 0) {\n    out[MINX] = -sizes[0];\n    out[MAXX] = 0;\n  } else {\n    out[MINX] = 0;\n    out[MAXX] = sizes[0];\n  }\n  if (sizes[1] < 0) {\n    out[MINY] = -sizes[1];\n    out[MAXY] = 0;\n  } else {\n    out[MINY] = 0;\n    out[MAXY] = sizes[1];\n  }\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its top-left corner set to be an existing pt and with\n * bounds extending outwards in each dimension by its respective size.\n *   minx: pt[x]\n *   miny: pt[y]\n *   maxx: pt[x] + sizes[x]\n *   maxy: pt[y] + sizes[y]\n * @param  {AABox2d} out   existing bounds to re-initialize\n * @param  {Point2d} pt    new position of the top-left corner of the bounds\n * @param  {Vec2d} sizes   new width/height of the bounds\n * @return {AABox2d}       bounds referenced by out arg\n */\nfunction initSizeFromLocation(out, pt, sizes) {\n  for (var i = 0; i < 2; i += 1) {\n    if (sizes[i] < 0) {\n      out[i] = pt[i] - sizes[i];\n      out[i + 2] = pt[i];\n    } else {\n      out[i] = pt[i];\n      out[i + 2] = pt[i] + sizes[i];\n    }\n  }\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its center set to a specific pt and with bounds\n * extending outward in each dimension so that the aabox's width and height are a\n * specific size\n * @param  {AABox2d} out    existing bounds to re-initialize\n * @param  {Point2d} center new center of the bounds\n * @param  {Vec2d} sizes  new width/height of the bounds\n * @return {AABox2d}        bounds referenced by out arg\n */\nfunction initCenterExtents(out, center, sizes) {\n  for (var i = 0; i < 2; i += 1) {\n    if (sizes[i] < 0) {\n      out[i] = center[i] + sizes[i];\n      out[i + 2] = center[i] - sizes[i];\n    } else {\n      out[i] = center[i] - sizes[i];\n      out[i + 2] = center[i] + sizes[i];\n    }\n  }\n  return out;\n}\n\n/**\n * Returns true if the aabox is empty\n * @param  {AABox2d}  box\n * @return {Boolean}     true if box is empty, false otherwise\n */\nfunction isEmpty(box) {\n  return box[MINX] > box[MAXX] || box[MINY] > box[MAXY];\n}\n\n/**\n * Returns true if an aabox is infinite in either dimension\n * @param  {AABox2d}  box Existing aabox to check\n * @return {Boolean}     True if box extends to +/- inifinity in either dimension, false otherwise\n */\nfunction isInfinite(box) {\n  return !isFinite(box[MINX]) || !isFinite(box[MINY]) || !isFinite(box[MAXX]) || !isFinite(box[MAXY]);\n}\n\n/**\n * Returns true if one aabox approximately equals another\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   true if a ~= b\n */\nfunction equals(a, b) {\n  var a0 = a[0];\n  var a1 = a[1];\n  var a2 = a[2];\n  var a3 = a[3];\n  var b0 = b[0];\n  var b1 = b[1];\n  var b2 = b[2];\n  var b3 = b[3];\n  return Math.abs(a0 - b0) <= _glMatrix.glMatrix.EPSILON && Math.abs(a1 - b1) <= _glMatrix.glMatrix.EPSILON && Math.abs(a2 - b2) <= _glMatrix.glMatrix.EPSILON && Math.abs(a3 - b3) <= _glMatrix.glMatrix.EPSILON;\n}\n\n/**\n * Returns the width/height of an existing aabox\n * @param  {Vec2d} out 2d vector to store the width/height of an existing aabox\n * @param  {AABox2d} box bounds to extract the width/height from\n * @return {Vec2d}     vector referenced by the out arg\n */\nfunction getSize(out, box) {\n  return _glMatrix.vec2.set(out, box[MAXX] - box[MINX], box[MAXY] - box[MINY]);\n}\n\n/**\n * Returns the extents of an existing aabox.\n * Extents is the size of a bounds in each dimension starting at the center\n * of the bounds. (i.e. extents = [width / 2, height / 2])\n * @param  {Vec2d} out 2d vector to store the extents of an existing aabox\n * @param  {AABox2d} box bounds to extract the extents from\n * @return {Vec2d}     vector referenced by the out arg\n */\nfunction getExtents(out, box) {\n  getSize(out, box);\n  return _glMatrix.vec2.scale(out, out, 0.5); // eslint-disable-line no-magic-numbers\n}\n\n/**\n * Returns the center of an existing aabox\n * @param  {Point2d} out point to store the center of an existing bounds\n * @param  {AABox2d} box bounds to extract the center from\n * @return {Point2d}     point referenced by the out arg\n */\nfunction getCenter(out, box) {\n  getExtents(out, box);\n  out[MINX] += box[MINX];\n  out[MINY] += box[MINY];\n  return out;\n}\n\n/**\n * Expands an existing aabox by a specified size in each dimension.\n * @param  {AABox2d} out        bounds to store the resulting operation in\n * @param  {AABox2d} box        starting bounds to expand\n * @param  {Vec2d} expandSize   size to expand in each dimension\n * @return {AABox2d}            bounds referenced by the out arg\n */\nfunction expand(out, box, expandSize) {\n  out[MINX] = box[MINX] - expandSize[0];\n  out[MAXX] = box[MAXX] + expandSize[0];\n  out[MINY] = box[MINY] - expandSize[1];\n  out[MAXY] = box[MAXY] + expandSize[1];\n}\n\n/**\n * Computes the area of an existing aabox\n * @param  {AABox2d} box\n * @return {Number}     area of the bounds\n */\nfunction area(box) {\n  return (box[MAXX] - box[MINX]) * (box[MAXY] - box[MINY]);\n}\n\n/**\n * Calculates the hull of two aaboxes. The hull is the smallest bounds that contains\n * both of the aaboxes\n * @param  {AABox2d} out bounds to store the resulting operation in\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction hull(out, a, b) {\n  return create(Math.min(a[MINX], b[MINX]), Math.min(a[MINY], b[MINY]), Math.max(a[MAXX], b[MAXX]), Math.max(a[MAXY], b[MAXY]));\n}\n\n/**\n * Calculates the intersection of two existing bounds.\n * @param  {AABox2d} out bounds to store the resulting operation in\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction intersection(out, a, b) {\n  var boxToUse = out;\n  if (out === a) {\n    boxToUse = create();\n  }\n\n  var minindex = MINX;\n  var maxindex = MAXX;\n  for (; minindex <= MINY; minindex += 1, maxindex += 1) {\n    if (a[maxindex] < b[minindex] || a[minindex] > b[maxindex]) {\n      break;\n    }\n\n    boxToUse[minindex] = Math.max(a[minindex], b[minindex]);\n    boxToUse[maxindex] = Math.min(a[maxindex], b[maxindex]);\n  }\n\n  if (minindex !== MINY + 1) {\n    initEmpty(boxToUse);\n  }\n\n  if (out === a) {\n    copy(out, boxToUse);\n  }\n\n  return out;\n}\n\n/**\n * Returns true if one bounds overlaps another in any way (non-inclusive).\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   Returns true if a overlaps b, false otherwise\n */\nfunction overlaps(a, b) {\n  return !(a[MAXX] <= b[MINX] || a[MINX] >= b[MAXX] || a[MAXY] <= b[MINY] || a[MINY] >= b[MAXY]);\n}\n\n/**\n * Returns true if one bounds full contains another (inclusive).\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   true if a fully contains b.\n */\nfunction contains(a, b) {\n  return !(b[MINX] < a[MINX] || b[MAXX] > a[MAXX] || b[MINY] < a[MINY] || b[MAXY] > a[MAXY]);\n}\n\n/**\n * Returns true if an existing bounds contains a specific point (inclusive)\n * @param  {AABox2d} box\n * @param  {Point2d} pt\n * @return {Boolean}     Returns true if pt is inside of box, false otherwise\n */\nfunction containsPt(box, pt) {\n  return pt[MINX] >= box[MINX] && pt[MINX] <= box[MAXX] && pt[MINY] >= box[MINY] && pt[MINY] <= box[MAXY];\n}\n\n/**\n * Extends an existing bounds so that it would contain a specific point\n * @param  {AABox2d} out Bounds containing the operation result\n * @param  {AABox2d} box Starting bounds to possibly extend\n * @param  {Point2d} pt  Point to encapsulate in box\n * @return {AAbox2d}     bounds referenced by out arg\n */\nfunction encapsulatePt(out, box, pt) {\n  if (out !== box) {\n    copy(out, box);\n  }\n  if (isEmpty(box)) {\n    out[MINX] = pt[MINX];\n    out[MAXX] = pt[MINX];\n    out[MINY] = pt[MINY];\n    out[MAXY] = pt[MINY];\n  } else {\n    if (pt[MINX] < out[MINX]) {\n      out[MINX] = pt[MINX];\n    } else if (pt[MINX] > out[MAXX]) {\n      out[MAXX] = pt[MINX];\n    }\n\n    if (pt[MINY] < out[MINY]) {\n      out[MINY] = pt[MINY];\n    } else if (pt[MINY] > out[MAXY]) {\n      out[MAXY] = pt[MINY];\n    }\n  }\n  return out;\n}\n\n/**\n * Translates an existing bounds by a specified offset it each dimension\n * @param  {AABox2d} out bounds resulting from the operation\n * @param  {AABox2d} box starting bounds\n * @param  {Vec2d} pos   translation in each dimension\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction translate(out, box, pos) {\n  out[MINX] = box[MINX] + pos[0];\n  out[MINY] = box[MINY] + pos[1];\n  out[MAXX] = box[MAXX] + pos[0];\n  out[MAXY] = box[MAXY] + pos[1];\n}\n\nfunction transform(out, box, mat, xformFunc) {\n  var boxToUse = out;\n  if (out === box) {\n    boxToUse = create();\n  }\n  initEmpty(boxToUse);\n\n  var pt1 = _glMatrix.vec2.set(_glMatrix.vec2.create(), box[MINX], box[MINY]);\n  var pt2 = _glMatrix.vec2.create();\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINX] = box[MAXX];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINY] = box[MAXY];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINX] = box[MINX];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  if (out === box) {\n    copy(out, boxToUse);\n  }\n  return out;\n}\n\n/**\n * Transforms an existing bounds by a 2x2 matrix\n * @param  {AABox2d} out bounds to contain the operation result\n * @param  {AABox2d} box bounds to transform\n * @param  {Mat2} mat 2x2 matrix transformation\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction transformMat2(out, box, mat) {\n  return transform(out, box, mat, _glMatrix.vec2.transformMat2);\n}\n\n/**\n * Transforms an existing bounds by a 2x3 matrix.\n * A 2x3 matrix is a 2x2 matrix with a translation component.\n * @param  {AABox2d} out bounds to hold the operation result\n * @param  {AABox2d} box bounds to transform\n * @param  {Mat2d} mat   2x3 matrix\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction transformMat2d(out, box, mat) {\n  return transform(out, box, mat, _glMatrix.vec2.transformMat2d);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL2FhYm94MmQuanM/MDZlMCJdLCJuYW1lcyI6WyJzZXQiLCJjcmVhdGUiLCJjbG9uZSIsImNvcHkiLCJpbml0RW1wdHkiLCJpbml0SW5maW5pdHkiLCJpbml0U2l6ZUZyb21PcmlnaW4iLCJpbml0U2l6ZUZyb21Mb2NhdGlvbiIsImluaXRDZW50ZXJFeHRlbnRzIiwiaXNFbXB0eSIsImlzSW5maW5pdGUiLCJlcXVhbHMiLCJnZXRTaXplIiwiZ2V0RXh0ZW50cyIsImdldENlbnRlciIsImV4cGFuZCIsImFyZWEiLCJodWxsIiwiaW50ZXJzZWN0aW9uIiwib3ZlcmxhcHMiLCJjb250YWlucyIsImNvbnRhaW5zUHQiLCJlbmNhcHN1bGF0ZVB0IiwidHJhbnNsYXRlIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwiTUlOWCIsIk1JTlkiLCJNQVhYIiwiTUFYWSIsIkNvbnN0YW50cyIsIkJPWF9TSURFUyIsIm91dCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJJbmZpbml0eSIsImdsTWF0cml4IiwiQVJSQVlfVFlQRSIsImJveCIsInNpemVzIiwicHQiLCJpIiwiY2VudGVyIiwiaXNGaW5pdGUiLCJhIiwiYiIsImEwIiwiYTEiLCJhMiIsImEzIiwiYjAiLCJiMSIsImIyIiwiYjMiLCJNYXRoIiwiYWJzIiwiRVBTSUxPTiIsIlZlYzJkIiwic2NhbGUiLCJleHBhbmRTaXplIiwibWluIiwibWF4IiwiYm94VG9Vc2UiLCJtaW5pbmRleCIsIm1heGluZGV4IiwicG9zIiwidHJhbnNmb3JtIiwibWF0IiwieGZvcm1GdW5jIiwicHQxIiwicHQyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O1FBdUJnQkEsRyxHQUFBQSxHO1FBa0JBQyxNLEdBQUFBLE07UUFXQUMsSyxHQUFBQSxLO1FBZUFDLEksR0FBQUEsSTtRQWlCQUMsUyxHQUFBQSxTO1FBY0FDLFksR0FBQUEsWTtRQW1CQUMsa0IsR0FBQUEsa0I7UUE4QkFDLG9C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QUFjMEMsUUFBZCxFQUF3QkEsUUFBeEIsRUFBa0NRLEdBQWxDO0FBQ0EsTUFBSXhDLFFBQVFRLEdBQVosRUFBaUI7QUFDZnJDLFNBQUs2QixHQUFMLEVBQVVnQyxRQUFWO0FBQ0Q7QUFDRCxTQUFPaEMsR0FBUDtBQUNEOztBQUVEOzs7Ozs7O0FBT08sU0FBU1IsYUFBVCxDQUF1QlEsR0FBdkIsRUFBNEJRLEdBQTVCLEVBQWlDNkIsR0FBakMsRUFBc0M7QUFDM0MsU0FBT0QsVUFBVXBDLEdBQVYsRUFBZVEsR0FBZixFQUFvQjZCLEdBQXBCLEVBQXlCVixlQUFNbkMsYUFBL0IsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNDLGNBQVQsQ0FBd0JPLEdBQXhCLEVBQTZCUSxHQUE3QixFQUFrQzZCLEdBQWxDLEVBQXVDO0FBQzVDLFNBQU9ELFVBQVVwQyxHQUFWLEVBQWVRLEdBQWYsRUFBb0I2QixHQUFwQixFQUF5QlYsZUFBTWxDLGNBQS9CLENBQVA7QUFDRCIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IHtnbE1hdHJpeCwgdmVjMiBhcyBWZWMyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbmV4cG9ydCBjb25zdCBNSU5YID0gMFxuZXhwb3J0IGNvbnN0IE1JTlkgPSAxXG5leHBvcnQgY29uc3QgTUFYWCA9IDJcbmV4cG9ydCBjb25zdCBNQVhZID0gM1xuXG5jb25zdCBDb25zdGFudHMgPSB7XG4gIEJPWF9TSURFUzogNFxufVxuXG4vKipcbiAqIFNldHMgdGhlIGJvdW5kYXJpZXMgb2YgYW4gZXhpc3RpbmcgMmQgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveFxuICogSWYgYXJndW1lbnRzIGFyZSBub3Qgc3VwcGxpZWQsIHRoZSBhYWJveCBpcyBpbml0aWFsaXplZCBhcyBlbXB0eS5cbiAqIEBwYXJhbSB7QUFCb3gyZH0gb3V0ICBBQWJveDJkIHRvIHNldFxuICogQHBhcmFtIHtOdW1iZXJ9IFttaW54ID0gSW5maW5pdHldIE1pbmltdW0geC1heGlzIHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gW21pbnkgPSBJbmZpbml0eV0gTWluaW11bSB5LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4eCA9IC1JbmZpbml0eV0gTWF4aW11bSB4LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4eSA9IC1JbmZpbml0eV0gTWF4aW11bSB5LWF4aXMgdmFsdWVcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG1pbngsIG1pbnksIG1heHgsIG1heHkpIHtcbiAgb3V0W01JTlhdID0gdHlwZW9mIG1pbnggPT09IFwibnVtYmVyXCIgPyBtaW54IDogSW5maW5pdHlcbiAgb3V0W01JTlldID0gdHlwZW9mIG1pbnkgPT09IFwibnVtYmVyXCIgPyBtaW55IDogSW5maW5pdHlcbiAgb3V0W01BWFhdID0gdHlwZW9mIG1heHggPT09IFwibnVtYmVyXCIgPyBtYXh4IDogLUluZmluaXR5XG4gIG91dFtNQVhZXSA9IHR5cGVvZiBtYXh5ID09PSBcIm51bWJlclwiID8gbWF4eSA6IC1JbmZpbml0eVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyAyZCBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9iamVjdFxuICogd2l0aCBvcHRpb25hbCBib3VuZGFyaWVzLiBJZiBib3VuZGFyaWVzIGFyZSBub3Qgc3VwcGxpZWQsXG4gKiB0aGUgYWFib3ggaXMgaW5pdGlhbGl6ZWQgYXMgZW1wdHkuXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttaW54ID0gSW5maW5pdHldIE1pbmltdW0geC1heGlzIHZhbHVlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttaW55ID0gSW5maW5pdHldIE1pbmltdW0geS1heGlzIHZhbHVlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXh4ID0gLUluZmluaXR5XSBNYXhpbXVtIHgtYXhpcyB2YWx1ZVxuICogQHBhcmFtICB7TnVtYmVyfSBbbWF4eSA9IC1JbmZpbml0eV0gTWF4aW11bSB5LWF4aXMgdmFsdWVcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICAgTmV3IEFBQm94MmQgb2JqZWN0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUobWlueCwgbWlueSwgbWF4eCwgbWF4eSkge1xuICBjb25zdCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRShDb25zdGFudHMuQk9YX1NJREVTKVxuICByZXR1cm4gc2V0KG91dCwgbWlueCwgbWlueSwgbWF4eCwgbWF4eSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IDJkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggd2l0aCBib3VuZGFyaWVzIGNvcGllZFxuICogZnJvbSBhbiBleGlzdGluZyBhYWJveC5cbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBleGlzdGluZyBib3VuZHMgdG8gY29weSBib3VuZGFyaWVzIGZyb21cbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBuZXcgQUFCb3gyZCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGJveCkge1xuICBjb25zdCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRShDb25zdGFudHMuQk9YX1NJREVTKVxuICBvdXRbTUlOWF0gPSBib3hbTUlOWF1cbiAgb3V0W01JTlldID0gYm94W01JTlldXG4gIG91dFtNQVhYXSA9IGJveFtNQVhYXVxuICBvdXRbTUFYWV0gPSBib3hbTUFYWV1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIENvcGllcyB0aGUgYm91bmRhcmllcyBmcm9tIG9uZSBleGlzdGluZyBhYWJveCB0byBhbm90aGVyLlxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGJvdW5kcyB0byBjb3B5IHRvXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggYm91bmRzIHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBib3gpIHtcbiAgb3V0W01JTlhdID0gYm94W01JTlhdXG4gIG91dFtNSU5ZXSA9IGJveFtNSU5ZXVxuICBvdXRbTUFYWF0gPSBib3hbTUFYWF1cbiAgb3V0W01BWFldID0gYm94W01BWFldXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSZS1pbml0aWFsaXplcyBhbiBleGlzdGluZyBhYWJveCBhcyBlbXB0eS5cbiAqIEFuIGFhYm94IGlzIGVtcHR5IGlmIHRoZSBtaW5pbXVtIHZhbHVlIGluIGVpdGhlciBvZlxuICogaXRzIGRpbWVuc2lvbnMgZXhjZWVkcyBpdHMgcmVzcGVjdGl2ZSBtYXggdmFsdWUuXG4gKiBJbiB0aGlzIGNhc2UsIHRoZSBtaW51bXVtcyB3aWxsIGJlIHNldCB0byArSW5maW5pdHlcbiAqIGFuZCB0aGUgbWF4aW11bXMgdG8gLUluZmluaXR5XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgZXhpc3RpbmcgYm91bmRzIHRvIHJlLWluaXRpYWxpemUgYXMgZW1wdHlcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0RW1wdHkob3V0KSB7XG4gIG91dFtNSU5YXSA9IEluZmluaXR5XG4gIG91dFtNSU5ZXSA9IEluZmluaXR5XG4gIG91dFtNQVhYXSA9IC1JbmZpbml0eVxuICBvdXRbTUFYWV0gPSAtSW5maW5pdHlcbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJlLWluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHRvIGluZmluaXR5LCB1bHRpbWF0ZWx5IGVuY29tcGFzc2luZ1xuICogYWxsIG51bWVyaWMgdmFsdWVzLlxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGV4aXN0aW5nIGJvdW5kcyB0byBpbml0aWFsaXplIHRvIGluZmluaXR5XG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEluZmluaXR5KG91dCkge1xuICBvdXRbTUlOWF0gPSAtSW5maW5pdHlcbiAgb3V0W01JTlldID0gLUluZmluaXR5XG4gIG91dFtNQVhYXSA9IEluZmluaXR5XG4gIG91dFtNQVhZXSA9IEluZmluaXR5XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBleGlzdGluZyBhYWJveCB3aXRoIGl0cyB0b3AtbGVmdCBjb3JuZXIgc2V0IHRvIGJlIHRoZSBvcmlnaW4gKFswLCAwXSksXG4gKiBhbiBleHRlbmRzIG91dHdhcmRzIGluIGVhY2ggZGltZW5zaW9uIGJ5IGl0cyByZXNwZWN0aXZlIHNpemUuXG4gKiAgIG1pbng6IDBcbiAqICAgbWlueTogMFxuICogICBtYXh4OiBzaXplc1t4XVxuICogICBtYXh5OiBzaXplc1t5XVxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0ICAgZXhpc3RpbmcgYm91bmRzIHRvIHJlLWluaXRpYWxpemVcbiAqIEBwYXJhbSAge1ZlYzJkfSBzaXplcyAgIG5ldyB3aWR0aC9oZWlnaHQgb2YgdGhlIGJvdW5kc1xuICogQHJldHVybiB7QUFCb3gyZH0gICAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFNpemVGcm9tT3JpZ2luKG91dCwgc2l6ZXMpIHtcbiAgaWYgKHNpemVzWzBdIDwgMCkge1xuICAgIG91dFtNSU5YXSA9IC1zaXplc1swXVxuICAgIG91dFtNQVhYXSA9IDBcbiAgfSBlbHNlIHtcbiAgICBvdXRbTUlOWF0gPSAwXG4gICAgb3V0W01BWFhdID0gc2l6ZXNbMF1cbiAgfVxuICBpZiAoc2l6ZXNbMV0gPCAwKSB7XG4gICAgb3V0W01JTlldID0gLXNpemVzWzFdXG4gICAgb3V0W01BWFldID0gMFxuICB9IGVsc2Uge1xuICAgIG91dFtNSU5ZXSA9IDBcbiAgICBvdXRbTUFYWV0gPSBzaXplc1sxXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBleGlzdGluZyBhYWJveCB3aXRoIGl0cyB0b3AtbGVmdCBjb3JuZXIgc2V0IHRvIGJlIGFuIGV4aXN0aW5nIHB0IGFuZCB3aXRoXG4gKiBib3VuZHMgZXh0ZW5kaW5nIG91dHdhcmRzIGluIGVhY2ggZGltZW5zaW9uIGJ5IGl0cyByZXNwZWN0aXZlIHNpemUuXG4gKiAgIG1pbng6IHB0W3hdXG4gKiAgIG1pbnk6IHB0W3ldXG4gKiAgIG1heHg6IHB0W3hdICsgc2l6ZXNbeF1cbiAqICAgbWF4eTogcHRbeV0gKyBzaXplc1t5XVxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0ICAgZXhpc3RpbmcgYm91bmRzIHRvIHJlLWluaXRpYWxpemVcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0ICAgIG5ldyBwb3NpdGlvbiBvZiB0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBib3VuZHNcbiAqIEBwYXJhbSAge1ZlYzJkfSBzaXplcyAgIG5ldyB3aWR0aC9oZWlnaHQgb2YgdGhlIGJvdW5kc1xuICogQHJldHVybiB7QUFCb3gyZH0gICAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdFNpemVGcm9tTG9jYXRpb24ob3V0LCBwdCwgc2l6ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpICs9IDEpIHtcbiAgICBpZiAoc2l6ZXNbaV0gPCAwKSB7XG4gICAgICBvdXRbaV0gPSBwdFtpXSAtIHNpemVzW2ldXG4gICAgICBvdXRbaSArIDJdID0gcHRbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0W2ldID0gcHRbaV1cbiAgICAgIG91dFtpICsgMl0gPSBwdFtpXSArIHNpemVzW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBleGlzdGluZyBhYWJveCB3aXRoIGl0cyBjZW50ZXIgc2V0IHRvIGEgc3BlY2lmaWMgcHQgYW5kIHdpdGggYm91bmRzXG4gKiBleHRlbmRpbmcgb3V0d2FyZCBpbiBlYWNoIGRpbWVuc2lvbiBzbyB0aGF0IHRoZSBhYWJveCdzIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGFcbiAqIHNwZWNpZmljIHNpemVcbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCAgICBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZVxuICogQHBhcmFtICB7UG9pbnQyZH0gY2VudGVyIG5ldyBjZW50ZXIgb2YgdGhlIGJvdW5kc1xuICogQHBhcmFtICB7VmVjMmR9IHNpemVzICBuZXcgd2lkdGgvaGVpZ2h0IG9mIHRoZSBib3VuZHNcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0Q2VudGVyRXh0ZW50cyhvdXQsIGNlbnRlciwgc2l6ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyOyBpICs9IDEpIHtcbiAgICBpZiAoc2l6ZXNbaV0gPCAwKSB7XG4gICAgICBvdXRbaV0gPSBjZW50ZXJbaV0gKyBzaXplc1tpXVxuICAgICAgb3V0W2kgKyAyXSA9IGNlbnRlcltpXSAtIHNpemVzW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFtpXSA9IGNlbnRlcltpXSAtIHNpemVzW2ldXG4gICAgICBvdXRbaSArIDJdID0gY2VudGVyW2ldICsgc2l6ZXNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYWFib3ggaXMgZW1wdHlcbiAqIEBwYXJhbSAge0FBQm94MmR9ICBib3hcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICB0cnVlIGlmIGJveCBpcyBlbXB0eSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5KGJveCkge1xuICByZXR1cm4gKGJveFtNSU5YXSA+IGJveFtNQVhYXSB8fCBib3hbTUlOWV0gPiBib3hbTUFYWV0pXG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGFhYm94IGlzIGluZmluaXRlIGluIGVpdGhlciBkaW1lbnNpb25cbiAqIEBwYXJhbSAge0FBQm94MmR9ICBib3ggRXhpc3RpbmcgYWFib3ggdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlIGlmIGJveCBleHRlbmRzIHRvICsvLSBpbmlmaW5pdHkgaW4gZWl0aGVyIGRpbWVuc2lvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0luZmluaXRlKGJveCkge1xuICByZXR1cm4gIWlzRmluaXRlKGJveFtNSU5YXSkgfHwgIWlzRmluaXRlKGJveFtNSU5ZXSkgfHwgIWlzRmluaXRlKGJveFtNQVhYXSkgfHwgIWlzRmluaXRlKGJveFtNQVhZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb25lIGFhYm94IGFwcHJveGltYXRlbHkgZXF1YWxzIGFub3RoZXJcbiAqIEBwYXJhbSAge0FBQm94MmR9IGFcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgdHJ1ZSBpZiBhIH49IGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIGNvbnN0IGEwID0gYVswXVxuICBjb25zdCBhMSA9IGFbMV1cbiAgY29uc3QgYTIgPSBhWzJdXG4gIGNvbnN0IGEzID0gYVszXVxuICBjb25zdCBiMCA9IGJbMF1cbiAgY29uc3QgYjEgPSBiWzFdXG4gIGNvbnN0IGIyID0gYlsyXVxuICBjb25zdCBiMyA9IGJbM11cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHdpZHRoL2hlaWdodCBvZiBhbiBleGlzdGluZyBhYWJveFxuICogQHBhcmFtICB7VmVjMmR9IG91dCAyZCB2ZWN0b3IgdG8gc3RvcmUgdGhlIHdpZHRoL2hlaWdodCBvZiBhbiBleGlzdGluZyBhYWJveFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGJvdW5kcyB0byBleHRyYWN0IHRoZSB3aWR0aC9oZWlnaHQgZnJvbVxuICogQHJldHVybiB7VmVjMmR9ICAgICB2ZWN0b3IgcmVmZXJlbmNlZCBieSB0aGUgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6ZShvdXQsIGJveCkge1xuICByZXR1cm4gVmVjMmQuc2V0KG91dCwgYm94W01BWFhdIC0gYm94W01JTlhdLCBib3hbTUFYWV0gLSBib3hbTUlOWV0pXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXh0ZW50cyBvZiBhbiBleGlzdGluZyBhYWJveC5cbiAqIEV4dGVudHMgaXMgdGhlIHNpemUgb2YgYSBib3VuZHMgaW4gZWFjaCBkaW1lbnNpb24gc3RhcnRpbmcgYXQgdGhlIGNlbnRlclxuICogb2YgdGhlIGJvdW5kcy4gKGkuZS4gZXh0ZW50cyA9IFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdKVxuICogQHBhcmFtICB7VmVjMmR9IG91dCAyZCB2ZWN0b3IgdG8gc3RvcmUgdGhlIGV4dGVudHMgb2YgYW4gZXhpc3RpbmcgYWFib3hcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBib3VuZHMgdG8gZXh0cmFjdCB0aGUgZXh0ZW50cyBmcm9tXG4gKiBAcmV0dXJuIHtWZWMyZH0gICAgIHZlY3RvciByZWZlcmVuY2VkIGJ5IHRoZSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFeHRlbnRzKG91dCwgYm94KSB7XG4gIGdldFNpemUob3V0LCBib3gpXG4gIHJldHVybiBWZWMyZC5zY2FsZShvdXQsIG91dCwgMC41KSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjZW50ZXIgb2YgYW4gZXhpc3RpbmcgYWFib3hcbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBwb2ludCB0byBzdG9yZSB0aGUgY2VudGVyIG9mIGFuIGV4aXN0aW5nIGJvdW5kc1xuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGJvdW5kcyB0byBleHRyYWN0IHRoZSBjZW50ZXIgZnJvbVxuICogQHJldHVybiB7UG9pbnQyZH0gICAgIHBvaW50IHJlZmVyZW5jZWQgYnkgdGhlIG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRlcihvdXQsIGJveCkge1xuICBnZXRFeHRlbnRzKG91dCwgYm94KVxuICBvdXRbTUlOWF0gKz0gYm94W01JTlhdXG4gIG91dFtNSU5ZXSArPSBib3hbTUlOWV1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEV4cGFuZHMgYW4gZXhpc3RpbmcgYWFib3ggYnkgYSBzcGVjaWZpZWQgc2l6ZSBpbiBlYWNoIGRpbWVuc2lvbi5cbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCAgICAgICAgYm91bmRzIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgb3BlcmF0aW9uIGluXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggICAgICAgIHN0YXJ0aW5nIGJvdW5kcyB0byBleHBhbmRcbiAqIEBwYXJhbSAge1ZlYzJkfSBleHBhbmRTaXplICAgc2l6ZSB0byBleHBhbmQgaW4gZWFjaCBkaW1lbnNpb25cbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICAgICAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgdGhlIG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZChvdXQsIGJveCwgZXhwYW5kU2l6ZSkge1xuICBvdXRbTUlOWF0gPSBib3hbTUlOWF0gLSBleHBhbmRTaXplWzBdXG4gIG91dFtNQVhYXSA9IGJveFtNQVhYXSArIGV4cGFuZFNpemVbMF1cbiAgb3V0W01JTlldID0gYm94W01JTlldIC0gZXhwYW5kU2l6ZVsxXVxuICBvdXRbTUFYWV0gPSBib3hbTUFYWV0gKyBleHBhbmRTaXplWzFdXG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGFyZWEgb2YgYW4gZXhpc3RpbmcgYWFib3hcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveFxuICogQHJldHVybiB7TnVtYmVyfSAgICAgYXJlYSBvZiB0aGUgYm91bmRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcmVhKGJveCkge1xuICByZXR1cm4gKGJveFtNQVhYXSAtIGJveFtNSU5YXSkgKiAoYm94W01BWFldIC0gYm94W01JTlldKVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGh1bGwgb2YgdHdvIGFhYm94ZXMuIFRoZSBodWxsIGlzIHRoZSBzbWFsbGVzdCBib3VuZHMgdGhhdCBjb250YWluc1xuICogYm90aCBvZiB0aGUgYWFib3hlc1xuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGJvdW5kcyB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIG9wZXJhdGlvbiBpblxuICogQHBhcmFtICB7QUFCb3gyZH0gYVxuICogQHBhcmFtICB7QUFCb3gyZH0gYlxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh1bGwob3V0LCBhLCBiKSB7XG4gIHJldHVybiBjcmVhdGUoTWF0aC5taW4oYVtNSU5YXSwgYltNSU5YXSksIE1hdGgubWluKGFbTUlOWV0sIGJbTUlOWV0pLCBNYXRoLm1heChhW01BWFhdLCBiW01BWFhdKSwgTWF0aC5tYXgoYVtNQVhZXSwgYltNQVhZXSkpXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBleGlzdGluZyBib3VuZHMuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgb3BlcmF0aW9uIGluXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBhXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBiXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKG91dCwgYSwgYikge1xuICBsZXQgYm94VG9Vc2UgPSBvdXRcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGJveFRvVXNlID0gY3JlYXRlKClcbiAgfVxuXG4gIGxldCBtaW5pbmRleCA9IE1JTlhcbiAgbGV0IG1heGluZGV4ID0gTUFYWFxuICBmb3IgKDsgbWluaW5kZXggPD0gTUlOWTsgbWluaW5kZXggKz0gMSwgbWF4aW5kZXggKz0gMSkge1xuICAgIGlmIChhW21heGluZGV4XSA8IGJbbWluaW5kZXhdIHx8IGFbbWluaW5kZXhdID4gYlttYXhpbmRleF0pIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgYm94VG9Vc2VbbWluaW5kZXhdID0gTWF0aC5tYXgoYVttaW5pbmRleF0sIGJbbWluaW5kZXhdKVxuICAgIGJveFRvVXNlW21heGluZGV4XSA9IE1hdGgubWluKGFbbWF4aW5kZXhdLCBiW21heGluZGV4XSlcbiAgfVxuXG4gIGlmIChtaW5pbmRleCAhPT0gTUlOWSArIDEpIHtcbiAgICBpbml0RW1wdHkoYm94VG9Vc2UpXG4gIH1cblxuICBpZiAob3V0ID09PSBhKSB7XG4gICAgY29weShvdXQsIGJveFRvVXNlKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvbmUgYm91bmRzIG92ZXJsYXBzIGFub3RoZXIgaW4gYW55IHdheSAobm9uLWluY2x1c2l2ZSkuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBhXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgIFJldHVybnMgdHJ1ZSBpZiBhIG92ZXJsYXBzIGIsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gb3ZlcmxhcHMoYSwgYikge1xuICByZXR1cm4gIShhW01BWFhdIDw9IGJbTUlOWF0gfHwgYVtNSU5YXSA+PSBiW01BWFhdIHx8IGFbTUFYWV0gPD0gYltNSU5ZXSB8fCBhW01JTlldID49IGJbTUFYWV0pXG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9uZSBib3VuZHMgZnVsbCBjb250YWlucyBhbm90aGVyIChpbmNsdXNpdmUpLlxuICogQHBhcmFtICB7QUFCb3gyZH0gYVxuICogQHBhcmFtICB7QUFCb3gyZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIGlmIGEgZnVsbHkgY29udGFpbnMgYi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgcmV0dXJuICEoYltNSU5YXSA8IGFbTUlOWF0gfHwgYltNQVhYXSA+IGFbTUFYWF0gfHwgYltNSU5ZXSA8IGFbTUlOWV0gfHwgYltNQVhZXSA+IGFbTUFYWV0pXG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIGV4aXN0aW5nIGJvdW5kcyBjb250YWlucyBhIHNwZWNpZmljIHBvaW50IChpbmNsdXNpdmUpXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3hcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0XG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgUmV0dXJucyB0cnVlIGlmIHB0IGlzIGluc2lkZSBvZiBib3gsIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNQdChib3gsIHB0KSB7XG4gIHJldHVybiAocHRbTUlOWF0gPj0gYm94W01JTlhdICYmIHB0W01JTlhdIDw9IGJveFtNQVhYXSAmJiBwdFtNSU5ZXSA+PSBib3hbTUlOWV0gJiYgcHRbTUlOWV0gPD0gYm94W01BWFldKVxufVxuXG4vKipcbiAqIEV4dGVuZHMgYW4gZXhpc3RpbmcgYm91bmRzIHNvIHRoYXQgaXQgd291bGQgY29udGFpbiBhIHNwZWNpZmljIHBvaW50XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgQm91bmRzIGNvbnRhaW5pbmcgdGhlIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBTdGFydGluZyBib3VuZHMgdG8gcG9zc2libHkgZXh0ZW5kXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdCAgUG9pbnQgdG8gZW5jYXBzdWxhdGUgaW4gYm94XG4gKiBAcmV0dXJuIHtBQWJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jYXBzdWxhdGVQdChvdXQsIGJveCwgcHQpIHtcbiAgaWYgKG91dCAhPT0gYm94KSB7XG4gICAgY29weShvdXQsIGJveClcbiAgfVxuICBpZiAoaXNFbXB0eShib3gpKSB7XG4gICAgb3V0W01JTlhdID0gcHRbTUlOWF1cbiAgICBvdXRbTUFYWF0gPSBwdFtNSU5YXVxuICAgIG91dFtNSU5ZXSA9IHB0W01JTlldXG4gICAgb3V0W01BWFldID0gcHRbTUlOWV1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHRbTUlOWF0gPCBvdXRbTUlOWF0pIHtcbiAgICAgIG91dFtNSU5YXSA9IHB0W01JTlhdXG4gICAgfSBlbHNlIGlmIChwdFtNSU5YXSA+IG91dFtNQVhYXSkge1xuICAgICAgb3V0W01BWFhdID0gcHRbTUlOWF1cbiAgICB9XG5cbiAgICBpZiAocHRbTUlOWV0gPCBvdXRbTUlOWV0pIHtcbiAgICAgIG91dFtNSU5ZXSA9IHB0W01JTlldXG4gICAgfSBlbHNlIGlmIChwdFtNSU5ZXSA+IG91dFtNQVhZXSkge1xuICAgICAgb3V0W01BWFldID0gcHRbTUlOWV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgYW4gZXhpc3RpbmcgYm91bmRzIGJ5IGEgc3BlY2lmaWVkIG9mZnNldCBpdCBlYWNoIGRpbWVuc2lvblxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGJvdW5kcyByZXN1bHRpbmcgZnJvbSB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggc3RhcnRpbmcgYm91bmRzXG4gKiBAcGFyYW0gIHtWZWMyZH0gcG9zICAgdHJhbnNsYXRpb24gaW4gZWFjaCBkaW1lbnNpb25cbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBib3gsIHBvcykge1xuICBvdXRbTUlOWF0gPSBib3hbTUlOWF0gKyBwb3NbMF1cbiAgb3V0W01JTlldID0gYm94W01JTlldICsgcG9zWzFdXG4gIG91dFtNQVhYXSA9IGJveFtNQVhYXSArIHBvc1swXVxuICBvdXRbTUFYWV0gPSBib3hbTUFYWV0gKyBwb3NbMV1cbn1cblxuZnVuY3Rpb24gdHJhbnNmb3JtKG91dCwgYm94LCBtYXQsIHhmb3JtRnVuYykge1xuICBsZXQgYm94VG9Vc2UgPSBvdXRcbiAgaWYgKG91dCA9PT0gYm94KSB7XG4gICAgYm94VG9Vc2UgPSBjcmVhdGUoKVxuICB9XG4gIGluaXRFbXB0eShib3hUb1VzZSlcblxuICBjb25zdCBwdDEgPSBWZWMyZC5zZXQoVmVjMmQuY3JlYXRlKCksIGJveFtNSU5YXSwgYm94W01JTlldKVxuICBjb25zdCBwdDIgPSBWZWMyZC5jcmVhdGUoKVxuICB4Zm9ybUZ1bmMocHQyLCBwdDEsIG1hdClcbiAgZW5jYXBzdWxhdGVQdChib3hUb1VzZSwgYm94VG9Vc2UsIHB0MilcbiAgcHQxW01JTlhdID0gYm94W01BWFhdXG4gIHhmb3JtRnVuYyhwdDIsIHB0MSwgbWF0KVxuICBlbmNhcHN1bGF0ZVB0KGJveFRvVXNlLCBib3hUb1VzZSwgcHQyKVxuICBwdDFbTUlOWV0gPSBib3hbTUFYWV1cbiAgeGZvcm1GdW5jKHB0MiwgcHQxLCBtYXQpXG4gIGVuY2Fwc3VsYXRlUHQoYm94VG9Vc2UsIGJveFRvVXNlLCBwdDIpXG4gIHB0MVtNSU5YXSA9IGJveFtNSU5YXVxuICB4Zm9ybUZ1bmMocHQyLCBwdDEsIG1hdClcbiAgZW5jYXBzdWxhdGVQdChib3hUb1VzZSwgYm94VG9Vc2UsIHB0MilcbiAgaWYgKG91dCA9PT0gYm94KSB7XG4gICAgY29weShvdXQsIGJveFRvVXNlKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGV4aXN0aW5nIGJvdW5kcyBieSBhIDJ4MiBtYXRyaXhcbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBib3VuZHMgdG8gY29udGFpbiB0aGUgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGJvdW5kcyB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSAge01hdDJ9IG1hdCAyeDIgbWF0cml4IHRyYW5zZm9ybWF0aW9uXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGJveCwgbWF0KSB7XG4gIHJldHVybiB0cmFuc2Zvcm0ob3V0LCBib3gsIG1hdCwgVmVjMmQudHJhbnNmb3JtTWF0Milcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIGV4aXN0aW5nIGJvdW5kcyBieSBhIDJ4MyBtYXRyaXguXG4gKiBBIDJ4MyBtYXRyaXggaXMgYSAyeDIgbWF0cml4IHdpdGggYSB0cmFuc2xhdGlvbiBjb21wb25lbnQuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHRvIGhvbGQgdGhlIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBib3VuZHMgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0gIHtNYXQyZH0gbWF0ICAgMngzIG1hdHJpeFxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgYm94LCBtYXQpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybShvdXQsIGJveCwgbWF0LCBWZWMyZC50cmFuc2Zvcm1NYXQyZClcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvYWFib3gyZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqrDist = exports.dist = undefined;\nexports.set = set;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.initFromValues = initFromValues;\nexports.addVec2 = addVec2;\nexports.sub = sub;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\nexports.str = str;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.lerp = lerp;\nexports.equals = equals;\nexports.exactEquals = exactEquals;\n\nvar _glMatrix = __webpack_require__(1);\n\nvar X = 0;\nvar Y = 1;\n\n/**\n * Sets the coordinates of a 2D point\n * @param {Point2d} out Point to set\n * @param {Number} [x = 0]   X coordinate\n * @param {Number} [y = 0]   Y coordinate\n * @return {Point2d}    Point referenced by out arg\n */\nfunction set(out) {\n  var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  out[X] = x;\n  out[Y] = y;\n  return out;\n}\n\n/**\n * Creates a new Point2d object\n * @param  {Number} [x = 0] X coordinate\n * @param  {Number} [y = 0] Y coordinate\n * @return {Point2d}\n */\nfunction create() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(2);\n  return set(out, x, y);\n}\n\n/**\n * Creates a new Point2d object with coordinates initialized from an existing point.\n * @param  {Point2d} p\n * @return {Point2d}\n */\nfunction clone(p) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(2);\n  out[X] = p[X];\n  out[Y] = p[Y];\n  return out;\n}\n\n/**\n * Copies the coordinates of one point to another.\n * @param  {Point2d} out The point to copy to\n * @param  {Point2d} p   The point to copy from\n * @return {Point2d}     Point referenced by out arg\n */\nfunction copy(out, p) {\n  out[X] = p[X];\n  out[Y] = p[Y];\n  return out;\n}\n\n/**\n * Creates a new point from coordinates\n * @param  {Number} x X coordinate\n * @param  {Number} y Y coordinate\n * @return {Point2d}   New point\n */\nfunction initFromValues(x, y) {\n  return create(x, y);\n}\n\n/**\n * Adds a 2d offset to an existing point\n * @param {Point2d} out Point receiving the operation result\n * @param {Point2d} pt  Existing point\n * @param {Vec2d} v   Vector describing the offset\n * @return {Point2d}   Point referenced by out arg\n */\nfunction addVec2(out, pt, v) {\n  return _glMatrix.vec2.add(out, pt, v);\n}\n\n/**\n * Calculates the difference between two points\n * @param  {Vec2d} out Vector receiving operation result\n * @param  {Point2d} pt1\n * @param  {Point2d} pt2\n * @return {Vec2d}     Vector referenced by out arg\n */\nfunction sub(out, pt1, pt2) {\n  return _glMatrix.vec2.sub(out, pt1, pt2);\n}\n\n/**\n * Performs an 2x2 matrix multiplication on a point\n * @param  {Point2d} out Point receiving operation result\n * @param  {Point2d} p\n * @param  {Mat2} m 2x2 matrix\n * @return {Point2d}     Point referenced by out arg\n */\nfunction transformMat2(out, p, m) {\n  return _glMatrix.vec2.transformMat2(out, p, m);\n}\n\n/**\n * Performs a 2x3 matrix multiplication on a point.\n * A 2x3 matrix is ultimately a 2x2 matrix with a\n * translation component\n * @param  {Point2d} out Point receiving operation result\n * @param  {Point2d} p\n * @param  {Mat2d} m   2x3 matrix\n * @return {Point2d}     Point referenced by out arg\n */\nfunction transformMat2d(out, p, m) {\n  return _glMatrix.vec2.transformMat2d(out, p, m);\n}\n\n/**\n * Creates a string representation of a point\n * @param  {Point2d} p\n * @return {string}\n */\nfunction str(p) {\n  return \"point2d(\" + p[0] + \" , \" + p[1] + \")\";\n}\n\n/**\n * Computes the distance between two 2d points\n * @param  {Point2d} p1\n * @param  {Point2d} p2\n * @return {Number}\n */\nfunction distance(p1, p2) {\n  return _glMatrix.vec2.distance(p1, p2);\n}\n\nvar dist = exports.dist = distance;\n\n/**\n * Returns the squared distance between two points.\n * This is a cheaper operation than the true distance\n * calculation.\n * @param  {Point2d} p1\n * @param  {Point2d} p2\n * @return {Number}    distance^2\n */\nfunction squaredDistance(p1, p2) {\n  return _glMatrix.vec2.squaredDistance(p1, p2);\n}\n\nvar sqrDist = exports.sqrDist = squaredDistance;\n\n/**\n * Calculates the point linearly interpolated\n * between two points according to the relative operator t\n * [t == 0 = p1 & t == 1 = p2]\n * @param  {Point2d} out Point receiving result of operation\n * @param  {Point2d} p1  Start point (t = 0)\n * @param  {Point2d} p2  End point (t = 1)\n * @param  {[type]} t   Interpolate parameter [0, 1]\n * @return {Point2d}     Point referenced by out arg\n */\nfunction lerp(out, p1, p2, t) {\n  return _glMatrix.vec2.lerp(out, p1, p2, t);\n}\n\n/**\n * Returns whether two points are relatively equal\n * @param  {Point2d} a\n * @param  {Point2d} b\n * @return {Boolean}   Returns true if two point are relatively equal, false otherwise\n */\nfunction equals(a, b) {\n  return _glMatrix.vec2.equals(a, b);\n}\n\n/**\n * Returns whether two points are exactly equal.\n * @param  {Point2d} a\n * @param  {Point2d} b\n * @return {Boolean}   Returns true if the two points are exactly equal, false otherwise\n */\nfunction exactEquals(a, b) {\n  return _glMatrix.vec2.exactEquals(a, b);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL3BvaW50MmQuanM/NzNlMyJdLCJuYW1lcyI6WyJzZXQiLCJjcmVhdGUiLCJjbG9uZSIsImNvcHkiLCJpbml0RnJvbVZhbHVlcyIsImFkZFZlYzIiLCJzdWIiLCJ0cmFuc2Zvcm1NYXQyIiwidHJhbnNmb3JtTWF0MmQiLCJzdHIiLCJkaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZSIsImxlcnAiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsIlgiLCJZIiwib3V0IiwieCIsInkiLCJnbE1hdHJpeCIsIkFSUkFZX1RZUEUiLCJwIiwicHQiLCJ2IiwiVmVjMiIsImFkZCIsInB0MSIsInB0MiIsIm0iLCJwMSIsInAyIiwiZGlzdCIsInNxckRpc3QiLCJ0IiwiYSIsImIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7UUFjZ0JBLEcsR0FBQUEsRztRQVlBQyxNLEdBQUFBLE07UUFVQUMsSyxHQUFBQSxLO1FBYUFDLEksR0FBQUEsSTtRQVlBQyxjLEdBQUFBLGM7UUFXQUMsTyxHQUFBQSxPO1FBV0FDLEcsR0FBQUEsRztRQVdBQyxhLEdBQUFBLGE7UUFhQUMsYyxHQUFBQSxjO1FBU0FDLEcsR0FBQUEsRztRQVVBQyxRLEdBQUFBLFE7UUFjQUMsZSxHQUFBQSxlO1FBZ0JBQyxJLEdBQUFBLEk7UUFVQUMsTSxHQUFBQSxNO1FBVUFDLFcsR0FBQUEsVzs7QUE5S2hCOztBQUVBLElBQU1DLElBQUksQ0FBVjtBQUNBLElBQU1DLElBQUksQ0FBVjs7QUFFQTs7Ozs7OztBQU9PLFNBQVNoQixHQUFULENBQWFpQixHQUFiLEVBQWdDO0FBQUEsTUFBZEMsQ0FBYyx1RUFBVixDQUFVO0FBQUEsTUFBUEMsQ0FBTyx1RUFBSCxDQUFHOztBQUNyQ0YsTUFBSUYsQ0FBSixJQUFTRyxDQUFUO0FBQ0FELE1BQUlELENBQUosSUFBU0csQ0FBVDtBQUNBLFNBQU9GLEdBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTU8sU0FBU2hCLE1BQVQsR0FBOEI7QUFBQSxNQUFkaUIs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QW5CLEVBQXNCO0FBQzNCLFNBQU9YLGVBQUtaLE1BQUwsQ0FBWXNCLENBQVosRUFBZUMsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1PLFNBQVN0QixXQUFULENBQXFCcUIsQ0FBckIsRUFBd0JDLENBQXhCLEVBQTJCO0FBQ2hDLFNBQU9YLGVBQUtYLFdBQUwsQ0FBaUJxQixDQUFqQixFQUFvQkMsQ0FBcEIsQ0FBUDtBQUNEIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQge2dsTWF0cml4LCB2ZWMyIGFzIFZlYzJ9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5jb25zdCBYID0gMFxuY29uc3QgWSA9IDFcblxuLyoqXG4gKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiBhIDJEIHBvaW50XG4gKiBAcGFyYW0ge1BvaW50MmR9IG91dCBQb2ludCB0byBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbeCA9IDBdICAgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3kgPSAwXSAgIFkgY29vcmRpbmF0ZVxuICogQHJldHVybiB7UG9pbnQyZH0gICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4ID0gMCwgeSA9IDApIHtcbiAgb3V0W1hdID0geFxuICBvdXRbWV0gPSB5XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBvaW50MmQgb2JqZWN0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt4ID0gMF0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt5ID0gMF0gWSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludDJkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHggPSAwLCB5ID0gMCkge1xuICBjb25zdCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKVxuICByZXR1cm4gc2V0KG91dCwgeCwgeSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBvaW50MmQgb2JqZWN0IHdpdGggY29vcmRpbmF0ZXMgaW5pdGlhbGl6ZWQgZnJvbSBhbiBleGlzdGluZyBwb2ludC5cbiAqIEBwYXJhbSAge1BvaW50MmR9IHBcbiAqIEByZXR1cm4ge1BvaW50MmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShwKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpXG4gIG91dFtYXSA9IHBbWF1cbiAgb3V0W1ldID0gcFtZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjb29yZGluYXRlcyBvZiBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBUaGUgcG9pbnQgdG8gY29weSB0b1xuICogQHBhcmFtICB7UG9pbnQyZH0gcCAgIFRoZSBwb2ludCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBQb2ludCByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBwKSB7XG4gIG91dFtYXSA9IHBbWF1cbiAgb3V0W1ldID0gcFtZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwb2ludCBmcm9tIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggWCBjb29yZGluYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgWSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgIE5ldyBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEZyb21WYWx1ZXMoeCwgeSkge1xuICByZXR1cm4gY3JlYXRlKHgsIHkpXG59XG5cbi8qKlxuICogQWRkcyBhIDJkIG9mZnNldCB0byBhbiBleGlzdGluZyBwb2ludFxuICogQHBhcmFtIHtQb2ludDJkfSBvdXQgUG9pbnQgcmVjZWl2aW5nIHRoZSBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1BvaW50MmR9IHB0ICBFeGlzdGluZyBwb2ludFxuICogQHBhcmFtIHtWZWMyZH0gdiAgIFZlY3RvciBkZXNjcmliaW5nIHRoZSBvZmZzZXRcbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRWZWMyKG91dCwgcHQsIHYpIHtcbiAgcmV0dXJuIFZlYzIuYWRkKG91dCwgcHQsIHYpXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSAge1ZlYzJkfSBvdXQgVmVjdG9yIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdDFcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0MlxuICogQHJldHVybiB7VmVjMmR9ICAgICBWZWN0b3IgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWIob3V0LCBwdDEsIHB0Mikge1xuICByZXR1cm4gVmVjMi5zdWIob3V0LCBwdDEsIHB0Milcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhbiAyeDIgbWF0cml4IG11bHRpcGxpY2F0aW9uIG9uIGEgcG9pbnRcbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBQb2ludCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtICB7UG9pbnQyZH0gcFxuICogQHBhcmFtICB7TWF0Mn0gbSAyeDIgbWF0cml4XG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgcCwgbSkge1xuICByZXR1cm4gVmVjMi50cmFuc2Zvcm1NYXQyKG91dCwgcCwgbSlcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIDJ4MyBtYXRyaXggbXVsdGlwbGljYXRpb24gb24gYSBwb2ludC5cbiAqIEEgMngzIG1hdHJpeCBpcyB1bHRpbWF0ZWx5IGEgMngyIG1hdHJpeCB3aXRoIGFcbiAqIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IFBvaW50IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwXG4gKiBAcGFyYW0gIHtNYXQyZH0gbSAgIDJ4MyBtYXRyaXhcbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBQb2ludCByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgcCwgbSkge1xuICByZXR1cm4gVmVjMi50cmFuc2Zvcm1NYXQyZChvdXQsIHAsIG0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHBvaW50XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIocCkge1xuICByZXR1cm4gYHBvaW50MmQoJHtwWzBdfSAsICR7cFsxXX0pYFxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byAyZCBwb2ludHNcbiAqIEBwYXJhbSAge1BvaW50MmR9IHAxXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBWZWMyLmRpc3RhbmNlKHAxLCBwMilcbn1cblxuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICogVGhpcyBpcyBhIGNoZWFwZXIgb3BlcmF0aW9uIHRoYW4gdGhlIHRydWUgZGlzdGFuY2VcbiAqIGNhbGN1bGF0aW9uLlxuICogQHBhcmFtICB7UG9pbnQyZH0gcDFcbiAqIEBwYXJhbSAge1BvaW50MmR9IHAyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIGRpc3RhbmNlXjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIFZlYzIuc3F1YXJlZERpc3RhbmNlKHAxLCBwMilcbn1cblxuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBsaW5lYXJseSBpbnRlcnBvbGF0ZWRcbiAqIGJldHdlZW4gdHdvIHBvaW50cyBhY2NvcmRpbmcgdG8gdGhlIHJlbGF0aXZlIG9wZXJhdG9yIHRcbiAqIFt0ID09IDAgPSBwMSAmIHQgPT0gMSA9IHAyXVxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IFBvaW50IHJlY2VpdmluZyByZXN1bHQgb2Ygb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwMSAgU3RhcnQgcG9pbnQgKHQgPSAwKVxuICogQHBhcmFtICB7UG9pbnQyZH0gcDIgIEVuZCBwb2ludCAodCA9IDEpXG4gKiBAcGFyYW0gIHtbdHlwZV19IHQgICBJbnRlcnBvbGF0ZSBwYXJhbWV0ZXIgWzAsIDFdXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiBWZWMyLmxlcnAob3V0LCBwMSwgcDIsIHQpXG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHR3byBwb2ludHMgYXJlIHJlbGF0aXZlbHkgZXF1YWxcbiAqIEBwYXJhbSAge1BvaW50MmR9IGFcbiAqIEBwYXJhbSAge1BvaW50MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIHR3byBwb2ludCBhcmUgcmVsYXRpdmVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gVmVjMi5lcXVhbHMoYSwgYilcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdHdvIHBvaW50cyBhcmUgZXhhY3RseSBlcXVhbC5cbiAqIEBwYXJhbSAge1BvaW50MmR9IGFcbiAqIEBwYXJhbSAge1BvaW50MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcG9pbnRzIGFyZSBleGFjdGx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIFZlYzIuZXhhY3RFcXVhbHMoYSwgYilcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvcG9pbnQyZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _glMatrix = __webpack_require__(1);\n\n/**\n * Singular value decomposition\n * See: http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation\n */\n\n/**\n * Calculates the singular value decomposition to extract the\n * scale, rotation, and translation from a 2x3 matrix.\n * Any matrix built by affine transformations can be decomposed\n * into a rotation*scale*rotation*translation\n * See: http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation\n * @param  {Vec2d} outTranslate Vector to hold the translation components\n * @param  {Vec2d} outScale     Vector to hold the x,y scale components\n * @param  {Vec2d} outRotate    Vector to hold the rotation components\n * @param  {Mat2d} mat          Matrix to decompose\n */\n_glMatrix.mat2d.svd = function (outTranslate, outScale, outRotate, mat) {\n  if (outTranslate) {\n    outTranslate[0] = mat[4];\n    outTranslate[1] = mat[5];\n  }\n  if (outScale || outRotate) {\n    var E = (mat[0] + mat[3]) / 2.0;\n    var F = (mat[0] - mat[3]) / 2.0;\n    var G = (mat[1] + mat[2]) / 2.0;\n    var H = (mat[1] - mat[2]) / 2.0;\n    if (outScale) {\n      var Q = Math.sqrt(E * E + H * H);\n      var R = Math.sqrt(F * F + G * G);\n      outScale[0] = Q + R;\n      outScale[1] = Q - R;\n    }\n    if (outRotate) {\n      var a1 = Math.atan2(G, F);\n      var a2 = Math.atan2(H, E);\n      outRotate[0] = (a2 - a1) / 2.0;\n      outRotate[1] = (a2 + a1) / 2.0;\n    }\n  }\n};\n\nexports.default = _glMatrix.mat2d;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL21hdDJkLmpzPzY0YTUiXSwibmFtZXMiOlsiTWF0MmQiLCJzdmQiLCJvdXRUcmFuc2xhdGUiLCJvdXRTY2FsZSIsIm91dFJvdGF0ZSIsIm1hdCIsIkUiLCJGIiwiRyIsIkgiLCJRIiwiTWF0aCIsInNxcnQiLCJSIiwiYTEiLCJhdGFuMiIsImEyIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7O0FBRUE7O0FBRUE7Ozs7O0FBS0M7Ozs7Ozs7Ozs7O0FBV0RBLGdCQUFNQyxHQUFOLEdBQVksVUFBQ0MsWUFBRCxFQUFlQyxRQUFmLEVBQXlCQyxTQUF6QixFQUFvQ0MsR0FBcEMsRUFBNEM7QUFDdEQsTUFBSUgsWUFBSixFQUFrQjtBQUNoQkEsaUJBQWEsQ0FBYixJQUFrQkcsSUFBSSxDQUFKLENBQWxCO0FBQ0FILGlCQUFhLENBQWIsSUFBa0JHLElBQUksQ0FBSixDQUFsQjtBQUNEO0FBQ0QsTUFBSUYsWUFBWUMsU0FBaEIsRUFBMkI7QUFDekIsUUFBTUUsSUFBSSxDQUFDRCxJQUFJLENBQUosSUFBU0EsSUFBSSxDQUFKLENBQVYsSUFBb0IsR0FBOUI7QUFDQSxRQUFNRSxJQUFJLENBQUNGLElBQUksQ0FBSixJQUFTQSxJQUFJLENBQUosQ0FBVixJQUFvQixHQUE5QjtBQUNBLFFBQU1HLElBQUksQ0FBQ0gsSUFBSSxDQUFKLElBQVNBLElBQUksQ0FBSixDQUFWLElBQW9CLEdBQTlCO0FBQ0EsUUFBTUksSUFBSSxDQUFDSixJQUFJLENBQUosSUFBU0EsSUFBSSxDQUFKLENBQVYsSUFBb0IsR0FBOUI7QUFDQSxRQUFJRixRQUFKLEVBQWM7QUFDWixVQUFNTyxJQUFJQyxLQUFLQyxJQUFMLENBQVVOLElBQUlBLENBQUosR0FBUUcsSUFBSUEsQ0FBdEIsQ0FBVjtBQUNBLFVBQU1JLElBQUlGLEtBQUtDLElBQUwsQ0FBVUwsSUFBSUEsQ0FBSixHQUFRQyxJQUFJQSxDQUF0QixDQUFWO0FBQ0FMLGVBQVMsQ0FBVCxJQUFjTyxJQUFJRyxDQUFsQjtBQUNBVixlQUFTLENBQVQsSUFBY08sSUFBSUcsQ0FBbEI7QUFDRDtBQUNELFFBQUlULFNBQUosRUFBZTtBQUNiLFVBQU1VLEtBQUtILEtBQUtJLEtBQUwsQ0FBV1AsQ0FBWCxFQUFjRCxDQUFkLENBQVg7QUFDQSxVQUFNUyxLQUFLTCxLQUFLSSxLQUFMLENBQVdOLENBQVgsRUFBY0gsQ0FBZCxDQUFYO0FBQ0FGLGdCQUFVLENBQVYsSUFBZSxDQUFDWSxLQUFLRixFQUFOLElBQVksR0FBM0I7QUFDQVYsZ0JBQVUsQ0FBVixJQUFlLENBQUNZLEtBQUtGLEVBQU4sSUFBWSxHQUEzQjtBQUNEO0FBQ0Y7QUFDRixDQXZCRDs7a0JBeUJlZCxlIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQge21hdDJkIGFzIE1hdDJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuLyoqXG4gKiBTaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uXG4gKiBTZWU6IGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NjE2NzQvZGVjb21wb3NlLWEtMmQtYXJiaXRyYXJ5LXRyYW5zZm9ybS1pbnRvLW9ubHktc2NhbGluZy1hbmQtcm90YXRpb25cbiAqL1xuXG4gLyoqXG4gICogQ2FsY3VsYXRlcyB0aGUgc2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvbiB0byBleHRyYWN0IHRoZVxuICAqIHNjYWxlLCByb3RhdGlvbiwgYW5kIHRyYW5zbGF0aW9uIGZyb20gYSAyeDMgbWF0cml4LlxuICAqIEFueSBtYXRyaXggYnVpbHQgYnkgYWZmaW5lIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgZGVjb21wb3NlZFxuICAqIGludG8gYSByb3RhdGlvbipzY2FsZSpyb3RhdGlvbip0cmFuc2xhdGlvblxuICAqIFNlZTogaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzg2MTY3NC9kZWNvbXBvc2UtYS0yZC1hcmJpdHJhcnktdHJhbnNmb3JtLWludG8tb25seS1zY2FsaW5nLWFuZC1yb3RhdGlvblxuICAqIEBwYXJhbSAge1ZlYzJkfSBvdXRUcmFuc2xhdGUgVmVjdG9yIHRvIGhvbGQgdGhlIHRyYW5zbGF0aW9uIGNvbXBvbmVudHNcbiAgKiBAcGFyYW0gIHtWZWMyZH0gb3V0U2NhbGUgICAgIFZlY3RvciB0byBob2xkIHRoZSB4LHkgc2NhbGUgY29tcG9uZW50c1xuICAqIEBwYXJhbSAge1ZlYzJkfSBvdXRSb3RhdGUgICAgVmVjdG9yIHRvIGhvbGQgdGhlIHJvdGF0aW9uIGNvbXBvbmVudHNcbiAgKiBAcGFyYW0gIHtNYXQyZH0gbWF0ICAgICAgICAgIE1hdHJpeCB0byBkZWNvbXBvc2VcbiAgKi9cbk1hdDJkLnN2ZCA9IChvdXRUcmFuc2xhdGUsIG91dFNjYWxlLCBvdXRSb3RhdGUsIG1hdCkgPT4ge1xuICBpZiAob3V0VHJhbnNsYXRlKSB7XG4gICAgb3V0VHJhbnNsYXRlWzBdID0gbWF0WzRdXG4gICAgb3V0VHJhbnNsYXRlWzFdID0gbWF0WzVdXG4gIH1cbiAgaWYgKG91dFNjYWxlIHx8IG91dFJvdGF0ZSkge1xuICAgIGNvbnN0IEUgPSAobWF0WzBdICsgbWF0WzNdKSAvIDIuMFxuICAgIGNvbnN0IEYgPSAobWF0WzBdIC0gbWF0WzNdKSAvIDIuMFxuICAgIGNvbnN0IEcgPSAobWF0WzFdICsgbWF0WzJdKSAvIDIuMFxuICAgIGNvbnN0IEggPSAobWF0WzFdIC0gbWF0WzJdKSAvIDIuMFxuICAgIGlmIChvdXRTY2FsZSkge1xuICAgICAgY29uc3QgUSA9IE1hdGguc3FydChFICogRSArIEggKiBIKVxuICAgICAgY29uc3QgUiA9IE1hdGguc3FydChGICogRiArIEcgKiBHKVxuICAgICAgb3V0U2NhbGVbMF0gPSBRICsgUlxuICAgICAgb3V0U2NhbGVbMV0gPSBRIC0gUlxuICAgIH1cbiAgICBpZiAob3V0Um90YXRlKSB7XG4gICAgICBjb25zdCBhMSA9IE1hdGguYXRhbjIoRywgRilcbiAgICAgIGNvbnN0IGEyID0gTWF0aC5hdGFuMihILCBFKVxuICAgICAgb3V0Um90YXRlWzBdID0gKGEyIC0gYTEpIC8gMi4wXG4gICAgICBvdXRSb3RhdGVbMV0gPSAoYTIgKyBhMSkgLyAyLjBcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTWF0MmRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvbWF0MmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar EPS = 1e-5;\nvar quarter = 0.25;\nvar half = 0.5;\nvar two = 2;\n\nMath.QUATER_PI = quarter * Math.PI;\nMath.HALF_PI = half * Math.PI;\nMath.HALF_NPI = -half * Math.PI;\nMath.TWO_PI = two * Math.PI;\nMath.NPI = -Math.PI;\nMath.NQUATER_PI = quarter * Math.NPI;\nMath.NHALF_PI = half * Math.NPI;\nMath.NTWO_PI = two * Math.NPI;\nMath.INV_PI = 1 / Math.PI;\nMath.RAD_TO_DEG = 180 / Math.PI;\nMath.DEG_TO_RAD = Math.PI / 180;\n\n// this could be useful to tweak in your app, depends on your world resolution\nMath.EPS = EPS;\n\n/**\n * Clamp f to be between a min and max.\n * @param {Number} f\n * @param {Number} minv\n * @param {Number} maxv\n * @return {Number}\n */\nfunction clamp(f, minv, maxv) {\n  return f < minv ? minv : f > maxv ? maxv : f;\n}\n\n/**\n * Clamp f to be between 0 and 1.\n * @param {Number} f\n * @return {Number}\n */\nfunction clamp01(f) {\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\n/**\n * Linearly interpolate (or extrapolate) between @c f1 and @c f2 by @c t percent.\n * @param {Number} f1\n * @param {Number} f2\n * @param {Number} t\n * @return {Number}\n */\nfunction lerp(f1, f2, t) {\n  return f1 * (1 - t) + f2 * t;\n}\n\nMath.clamp = clamp;\nMath.clamp01 = clamp01;\nMath.lerp = lerp;\n\nexports.default = Math;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRoL21hdGguanM/MDU5NiJdLCJuYW1lcyI6WyJFUFMiLCJxdWFydGVyIiwiaGFsZiIsInR3byIsIk1hdGgiLCJRVUFURVJfUEkiLCJQSSIsIkhBTEZfUEkiLCJIQUxGX05QSSIsIlRXT19QSSIsIk5QSSIsIk5RVUFURVJfUEkiLCJOSEFMRl9QSSIsIk5UV09fUEkiLCJJTlZfUEkiLCJSQURfVE9fREVHIiwiREVHX1RPX1JBRCIsImNsYW1wIiwiZiIsIm1pbnYiLCJtYXh2IiwiY2xhbXAwMSIsImxlcnAiLCJmMSIsImYyIiwidCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFNQSxNQUFNLElBQVo7QUFDQSxJQUFNQyxVQUFVLElBQWhCO0FBQ0EsSUFBTUMsT0FBTyxHQUFiO0FBQ0EsSUFBTUMsTUFBTSxDQUFaOztBQUVBQyxLQUFLQyxTQUFMLEdBQWlCSixVQUFVRyxLQUFLRSxFQUFoQztBQUNBRixLQUFLRyxPQUFMLEdBQWVMLE9BQU9FLEtBQUtFLEVBQTNCO0FBQ0FGLEtBQUtJLFFBQUwsR0FBZ0IsQ0FBQ04sSUFBRCxHQUFRRSxLQUFLRSxFQUE3QjtBQUNBRixLQUFLSyxNQUFMLEdBQWNOLE1BQU1DLEtBQUtFLEVBQXpCO0FBQ0FGLEtBQUtNLEdBQUwsR0FBVyxDQUFDTixLQUFLRSxFQUFqQjtBQUNBRixLQUFLTyxVQUFMLEdBQWtCVixVQUFVRyxLQUFLTSxHQUFqQztBQUNBTixLQUFLUSxRQUFMLEdBQWdCVixPQUFPRSxLQUFLTSxHQUE1QjtBQUNBTixLQUFLUyxPQUFMLEdBQWVWLE1BQU1DLEtBQUtNLEdBQTFCO0FBQ0FOLEtBQUtVLE1BQUwsR0FBYyxJQUFJVixLQUFLRSxFQUF2QjtBQUNBRixLQUFLVyxVQUFMLEdBQWtCLE1BQU1YLEtBQUtFLEVBQTdCO0FBQ0FGLEtBQUtZLFVBQUwsR0FBa0JaLEtBQUtFLEVBQUwsR0FBVSxHQUE1Qjs7QUFFQTtBQUNBRixLQUFLSixHQUFMLEdBQVdBLEdBQVg7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTaUIsS0FBVCxDQUFlQyxDQUFmLEVBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEI7QUFDNUIsU0FBT0YsSUFBSUMsSUFBSixHQUFXQSxJQUFYLEdBQW1CRCxJQUFJRSxJQUFKLEdBQVdBLElBQVgsR0FBa0JGLENBQTVDO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsU0FBU0csT0FBVCxDQUFpQkgsQ0FBakIsRUFBb0I7QUFDbEIsU0FBT0EsSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFhQSxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVlBLENBQWhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTSSxJQUFULENBQWNDLEVBQWQsRUFBa0JDLEVBQWxCLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QixTQUFPRixNQUFNLElBQUlFLENBQVYsSUFBZUQsS0FBS0MsQ0FBM0I7QUFDRDs7QUFFRHJCLEtBQUthLEtBQUwsR0FBYUEsS0FBYjtBQUNBYixLQUFLaUIsT0FBTCxHQUFlQSxPQUFmO0FBQ0FqQixLQUFLa0IsSUFBTCxHQUFZQSxJQUFaOztrQkFFZWxCLEkiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVQUyA9IDFlLTVcbmNvbnN0IHF1YXJ0ZXIgPSAwLjI1XG5jb25zdCBoYWxmID0gMC41XG5jb25zdCB0d28gPSAyXG5cbk1hdGguUVVBVEVSX1BJID0gcXVhcnRlciAqIE1hdGguUElcbk1hdGguSEFMRl9QSSA9IGhhbGYgKiBNYXRoLlBJXG5NYXRoLkhBTEZfTlBJID0gLWhhbGYgKiBNYXRoLlBJXG5NYXRoLlRXT19QSSA9IHR3byAqIE1hdGguUElcbk1hdGguTlBJID0gLU1hdGguUElcbk1hdGguTlFVQVRFUl9QSSA9IHF1YXJ0ZXIgKiBNYXRoLk5QSVxuTWF0aC5OSEFMRl9QSSA9IGhhbGYgKiBNYXRoLk5QSVxuTWF0aC5OVFdPX1BJID0gdHdvICogTWF0aC5OUElcbk1hdGguSU5WX1BJID0gMSAvIE1hdGguUElcbk1hdGguUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUElcbk1hdGguREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODBcblxuLy8gdGhpcyBjb3VsZCBiZSB1c2VmdWwgdG8gdHdlYWsgaW4geW91ciBhcHAsIGRlcGVuZHMgb24geW91ciB3b3JsZCByZXNvbHV0aW9uXG5NYXRoLkVQUyA9IEVQU1xuXG4vKipcbiAqIENsYW1wIGYgdG8gYmUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4LlxuICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW52XG4gKiBAcGFyYW0ge051bWJlcn0gbWF4dlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcChmLCBtaW52LCBtYXh2KSB7XG4gIHJldHVybiBmIDwgbWludiA/IG1pbnYgOiAoZiA+IG1heHYgPyBtYXh2IDogZilcbn1cblxuLyoqXG4gKiBDbGFtcCBmIHRvIGJlIGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wMDEoZikge1xuICByZXR1cm4gZiA8IDAgPyAwIDogKGYgPiAxID8gMSA6IGYpXG59XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGUgKG9yIGV4dHJhcG9sYXRlKSBiZXR3ZWVuIEBjIGYxIGFuZCBAYyBmMiBieSBAYyB0IHBlcmNlbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gZjFcbiAqIEBwYXJhbSB7TnVtYmVyfSBmMlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbGVycChmMSwgZjIsIHQpIHtcbiAgcmV0dXJuIGYxICogKDEgLSB0KSArIGYyICogdFxufVxuXG5NYXRoLmNsYW1wID0gY2xhbXBcbk1hdGguY2xhbXAwMSA9IGNsYW1wMDFcbk1hdGgubGVycCA9IGxlcnBcblxuZXhwb3J0IGRlZmF1bHQgTWF0aFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbWF0aC9tYXRoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _fillStyle = __webpack_require__(17);\n\nvar _fillStyle2 = _interopRequireDefault(_fillStyle);\n\nvar _strokeStyle = __webpack_require__(18);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nvar _transform2d = __webpack_require__(11);\n\nvar _transform2d2 = _interopRequireDefault(_transform2d);\n\nvar _aggregation2 = __webpack_require__(7);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _basicStyle = __webpack_require__(8);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _eventHandler = __webpack_require__(12);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} CoreShapeOptions\n * @property {number} [zIndex=0] Z index draw order of the shape. Lower numbers get drawn before larger numbers\n */\n\n/**\n * Shape geom modification event\n * @event Shape#geomChanged\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * Shape modification event\n * @event EventedShape#changed\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * @class Defines the core functionality for all shapes\n * @extends {EventHandler}\n */\nvar CoreBaseShape = function (_EventHandler) {\n  _inherits(CoreBaseShape, _EventHandler);\n\n  /**\n   * Creates new core functionality for a shape\n   * @param  {CoreShapeOptions} [opts]\n   * @return {CoreBaseShape}\n   */\n  function CoreBaseShape(opts) {\n    _classCallCheck(this, CoreBaseShape);\n\n    var _this = _possibleConstructorReturn(this, (CoreBaseShape.__proto__ || Object.getPrototypeOf(CoreBaseShape)).call(this, [\"changed:xform\", \"changed:style\", \"changed:order\", \"changed:visibility\", \"changed:geom\"]));\n\n    _this._aabox = AABox2d.create();\n    _this._zIndex = opts && opts.zIndex ? opts.zIndex : 0;\n    _this._visible = true;\n    _this._geomDirty = false;\n\n    _this._fullXform = _glMatrix.mat2d.create();\n    return _this;\n  }\n\n  /**\n   * Sets the z index (back to front draw order) of the shape\n   * @param  {number} zIndex\n   * @fires  EventedShape#changed\n   * @return {CoreBaseShape}        this\n   */\n\n\n  _createClass(CoreBaseShape, [{\n    key: \"zIndex\",\n    set: function set(zIndex) {\n      if (!Number.isInteger(zIndex)) {\n        throw new Error(\"zIndex must be an integer\");\n      }\n      if (zIndex !== this._zIndex) {\n        var prev = this._zIndex;\n        this._zIndex = zIndex;\n        this.fire(\"changed:order\", {\n          attr: \"zIndex\",\n          prevVal: prev,\n          currVal: this._zIndex\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current z index (i.e. draw/layer order) of the shape\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._zIndex;\n    }\n\n    /**\n     * Gets a reference to the current axis-aligned bounding box of the\n     * shape\n     * @return {AABox2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"aabox\",\n    get: function get() {\n      this._updateAABox();\n      return this._aabox;\n    }\n\n    /**\n     * Sets the visibility of the shape\n     * @param  {Boolean} visible If true, the shape is considered visible\n     * @fires  EventedShape#changed\n     * @return {CoreBaseShape}         this\n     * @throws {Error} If argument is not a boolean type\n     */\n\n  }, {\n    key: \"visible\",\n    set: function set(visible) {\n      if (typeof visible !== \"boolean\") {\n        throw new Error(\"visible must be a boolean\");\n      }\n\n      if (visible !== this._visible) {\n        this._visible = visible;\n        this.fire(\"changed:visibility\", {\n          attr: \"visible\",\n          prevVal: !this._visible,\n          currVal: this._visible\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets the current visibility of the shape\n     * @return {boolean}\n     */\n    ,\n    get: function get() {\n      return this._visible;\n    }\n  }]);\n\n  return CoreBaseShape;\n}(_eventHandler2.default);\n\n/**\n * @class Defines the basic functionality of all shapes. This includes\n *        mixing in from EventedTransform2d so that affine transformations\n *        can be applied to the shape. Also includes mixing in fill and stroke\n *        properties so that the shape's renderable properties can be modified.\n * @extends {CoreBaseShape}\n * @mixin {EventedTransform2d}\n * @mixin {EventedFillStyle}\n * @mixin {EventedStrokeStyle}\n */\n\n\nvar BaseShape = function (_aggregation) {\n  _inherits(BaseShape, _aggregation);\n\n  /**\n   * Creates new basic functionality (including transform, fill style, and stroke style properties)\n   * for a shape\n   * @param  {object} opts\n   * @return {BaseShape}\n   */\n  function BaseShape(opts) {\n    _classCallCheck(this, BaseShape);\n\n    var _this2 = _possibleConstructorReturn(this, (BaseShape.__proto__ || Object.getPrototypeOf(BaseShape)).call(this, opts));\n\n    _this2._stateStack = [];\n    return _this2;\n  }\n\n  /**\n   * Saves the current state of the shape so that it can be restored later.\n   * @return {BaseShape} this\n   */\n\n\n  _createClass(BaseShape, [{\n    key: \"save\",\n    value: function save() {\n      // Currently only the state of the fill/stroke style properties\n      // and the z index are saved. May want to expand this to include\n      // all modifiable properties (i.e. transform props and visibility prop)\n      var state = new _basicStyle2.default();\n      _basicStyle2.default.copyBasicStyle(this, state);\n      state.zIndex = this.zIndex;\n      this._stateStack.push(state);\n      return this;\n    }\n\n    /**\n     * Pops a saved state from the top of the saved state stack\n     * @return {BaseShape} this\n     */\n\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      // Currently only restores the state of the fill/stroke style properties\n      // and the z index. May want to expand this to include\n      // all modifiable properties (i.e. transform props and visibility prop)\n      var state = this._stateStack.pop();\n      if (state) {\n        _basicStyle2.default.copyBasicStyle(state, this);\n        this.zIndex = state.zIndex;\n      }\n      return this;\n    }\n\n    /**\n     * Gets the visibility of the shape\n     * @return {boolean}\n     * @override\n     */\n\n  }, {\n    key: \"getGlobalDimensions\",\n\n\n    /**\n     * Gets the width/height of the shape after the parent transforms are applied\n     * @return {Vec2d} Width/Height of the shape after all parent transforms applied\n     */\n    value: function getGlobalDimensions() {\n      var scale = [0, 0];\n      _glMatrix.mat2d.svd(null, scale, null, this.globalXform);\n      scale[0] *= this.width;\n      scale[1] *= this.height;\n      return scale;\n    }\n\n    /**\n     * Returns true the shape contains a screen/world space point\n     * @param  {Point2d} screenPt           The point to check in screen/pixel space\n     * @param  {Poitn2d} worldPt            The point to check in world space\n     * @param  {Mat2d} worldToScreenMatrix  The transform matrix from world to screen space\n     * @param  {CanvasRenderingContext2D} ctx The 2d rendering context\n     * @return {boolean}                    True if the shape contains the point, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtn = false;\n      var aabox = this.aabox;\n\n      // Check if the point is contained by the shape's bounds first\n      if (this.visible && AABox2d.containsPt(aabox, worldPt)) {\n        // re-draw the shape (invisible) so that we can use canvas's\n        // isPointInPath/isPointInStroke api calls. Doing that\n        // as this should be compatible across all browsers\n        ctx.save();\n        ctx.setTransform(this._fullXform[0], this._fullXform[1], this._fullXform[2], this._fullXform[3], this._fullXform[4], this._fullXform[5]);\n        ctx.beginPath();\n        this._draw(ctx);\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineWidth = this.strokeWidth + 5; // eslint-disable-line no-magic-numbers\n        ctx.dashPattern = [];\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n        if (this.isFillVisible() && ctx.isPointInPath(screenPt[0], screenPt[1]) || this.isStrokeVisible() && ctx.isPointInStroke(screenPt[0], screenPt[1])) {\n          rtn = true;\n        }\n        ctx.restore();\n      }\n      return rtn;\n    }\n\n    /**\n     * Debug function to draw the bounds of the shape\n     * @param  {CanvasRenderingContext2D} ctx                 2d rendering context\n     * @param  {Mat2d} worldToScreenMatrix Transform from world to screen space\n     * @param  {StrokeStyle} boundsStrokeStyle   The stroke style to use to render the bounds\n     */\n\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      ctx.save();\n      ctx.setTransform(worldToScreenMatrix[0], worldToScreenMatrix[1], worldToScreenMatrix[2], worldToScreenMatrix[3], worldToScreenMatrix[4], worldToScreenMatrix[5]);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      var aabox = this.aabox;\n      AABox2d.getCenter(center, aabox);\n      AABox2d.getExtents(extents, aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    /**\n     * Called when the local transform (does not include parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the shape's bounds needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_localXformUpdated\",\n    value: function _localXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Called when the global transform (includes parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the shape's bounds needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_globalXformUpdated\",\n    value: function _globalXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Renders the shape using a 2d rendering context\n     * @param  {CanvasRenderingContext2d} ctx                 2d rendering context\n     * @param  {Mat2d} worldToScreenMatrix Transform from world to screen space,\n     *                                     usually provided by a camera\n     * @param  {DrawStyleState} styleState Manages the current state of the fill/stroke style attrs\n     *                                     of the 2d rendering context. This is self-managed to minimize\n     *                                     context state switches\n     * @param  {boolean} [doFill=null]     If provided, used to manually override whether to fill the\n     *                                     shape.\n     * @param  {boolean} [doStroke=null]   If provided, used to manually override whether to stroke the\n     *                                     shape.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      var doFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var doStroke = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n      this.transformCtx(ctx, this._fullXform, worldToScreenMatrix);\n\n      ctx.beginPath();\n\n      var rtn = this._draw(ctx);\n      if (rtn || typeof rtn === \"undefined\") {\n        if (this.isFillVisible() && (doFill === null || Boolean(doFill))) {\n          styleState.setFillStyle(ctx, this);\n          ctx.fill();\n        }\n\n        if (this.isStrokeVisible() && (doStroke === null || Boolean(doStroke))) {\n          styleState.setStrokeStyle(ctx, this);\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * Copies the fill/stroke style from one BasicStyle object to this shape\n     * @param {BasicStyle} newStyle The style to copy from.\n     * @return {BaseShape} this\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(newStyle) {\n      _basicStyle2.default.copyBasicStyle(newStyle, this);\n      return this;\n    }\n\n    /**\n     * Returns a JSON object containing the properties of this shape\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var state = this; // eslint-disable-line consistent-this\n      if (this._stateStack && this._stateStack.length) {\n        state = this._stateStack[0];\n      }\n      return Object.assign({\n        // type: this.constructor.name,\n        // NOTE: I wanted to use the above call, which would keep the type\n        // consistent with the name of the class, but this isn't always\n        // the case, as was found out a few times when trying to add\n        // this to immerse\n        visible: this.visible,\n        zIndex: state.zIndex\n      }, _basicStyle2.default.toJSON(state), _transform2d2.default.toJSON(this));\n    }\n\n    /**\n     * Compares two shapes, usually used to sort the shapes for drawing\n     * @param  {BaseShape} shape1\n     * @param  {BaseShape} shape2\n     * @return {number}        Returns < 0 if shape1 < shape2, > 0 if shape1 > shape2, 0 if shape1 === shape2\n     */\n\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return this._visible && (this.isFillVisible() || this.isStrokeVisible());\n    }\n  }], [{\n    key: \"shapeCompare\",\n    value: function shapeCompare(shape1, shape2) {\n      var zIndex1 = shape1.zIndex;\n      var zIndex2 = shape2.zIndex;\n      if (zIndex1 < zIndex2) {\n        return -1;\n      } else if (zIndex1 > zIndex2) {\n        return 1;\n      }\n\n      var rtn = _fillStyle2.default.compareFillStyle(shape1, shape2);\n      if (!rtn) {\n        rtn = _strokeStyle2.default.compareStrokeStyle(shape1, shape2);\n      }\n\n      return rtn;\n    }\n  }]);\n\n  return BaseShape;\n}((0, _aggregation3.default)(CoreBaseShape, (0, _transform2d.createEventedTransform2dMixin)(\"changed:xform\"), (0, _fillStyle.createEventedFillStyleMixin)(\"changed:style\"), (0, _strokeStyle.createEventedStrokeStyleMixin)(\"changed:style\")));\n\nexports.default = BaseShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvYmFzZS1zaGFwZS5qcz9iYmVhIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJDb3JlQmFzZVNoYXBlIiwib3B0cyIsIl9hYWJveCIsImNyZWF0ZSIsIl96SW5kZXgiLCJ6SW5kZXgiLCJfdmlzaWJsZSIsIl9nZW9tRGlydHkiLCJfZnVsbFhmb3JtIiwiTWF0MmQiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJFcnJvciIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwiX3VwZGF0ZUFBQm94IiwidmlzaWJsZSIsIkV2ZW50SGFuZGxlciIsIkJhc2VTaGFwZSIsIl9zdGF0ZVN0YWNrIiwic3RhdGUiLCJCYXNpY1N0eWxlIiwiY29weUJhc2ljU3R5bGUiLCJwdXNoIiwicG9wIiwic2NhbGUiLCJzdmQiLCJnbG9iYWxYZm9ybSIsIndpZHRoIiwiaGVpZ2h0Iiwic2NyZWVuUHQiLCJ3b3JsZFB0Iiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImN0eCIsInJ0biIsImFhYm94IiwiY29udGFpbnNQdCIsInNhdmUiLCJzZXRUcmFuc2Zvcm0iLCJiZWdpblBhdGgiLCJfZHJhdyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlV2lkdGgiLCJkYXNoUGF0dGVybiIsInN0cm9rZSIsImlzRmlsbFZpc2libGUiLCJpc1BvaW50SW5QYXRoIiwiaXNTdHJva2VWaXNpYmxlIiwiaXNQb2ludEluU3Ryb2tlIiwicmVzdG9yZSIsImJvdW5kc1N0cm9rZVN0eWxlIiwic2V0U3Ryb2tlQ3R4IiwiY2VudGVyIiwiZXh0ZW50cyIsImdldENlbnRlciIsImdldEV4dGVudHMiLCJyZWN0IiwiX2JvdW5kc091dE9mRGF0ZSIsInN0eWxlU3RhdGUiLCJkb0ZpbGwiLCJkb1N0cm9rZSIsInRyYW5zZm9ybUN0eCIsIkJvb2xlYW4iLCJzZXRGaWxsU3R5bGUiLCJmaWxsIiwic2V0U3Ryb2tlU3R5bGUiLCJuZXdTdHlsZSIsImxlbmd0aCIsIk9iamVjdCIsImFzc2lnbiIsInRvSlNPTiIsIlRyYW5zZm9ybTJkIiwic2hhcGUxIiwic2hhcGUyIiwiekluZGV4MSIsInpJbmRleDIiLCJGaWxsU3R5bGUiLCJjb21wYXJlRmlsbFN0eWxlIiwiU3Ryb2tlU3R5bGUiLCJjb21wYXJlU3Ryb2tlU3R5bGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7QUFLQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7OztBQVNBOzs7O0lBSU1DLGE7OztBQUNKOzs7OztBQUtBLHlCQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsOEhBQ1YsQ0FBQyxlQUFELEVBQWtCLGVBQWxCLEVBQW1DLGVBQW5DLEVBQW9ELG9CQUFwRCxFQUEwRSxjQUExRSxDQURVOztBQUVoQixVQUFLQyxNQUFMLEdBQWNILFFBQVFJLE1BQVIsRUFBZDtBQUNBLFVBQUtDLE9BQUwsR0FBZ0JILFFBQVFBLEtBQUtJLE1BQWQsR0FBd0JKLEtBQUtJLE1BQTdCLEdBQXNDLENBQXJEO0FBQ0EsVUFBS0MsUUFBTCxHQUFnQixJQUFoQjtBQUNBLFVBQUtDLFVBQUwsR0FBa0IsS0FBbEI7O0FBRUEsVUFBS0MsVUFBTCxHQUFrQkMsZ0JBQU1OLE1BQU4sRUFBbEI7QUFQZ0I7QUFRakI7O0FBRUQ7Ozs7Ozs7Ozs7c0JBTVdFLE0sRUFBUTtBQUNqQixVQUFJLENBQUNLLE9BQU9DLFNBQVAsQ0FBaUJOLE1BQWpCLENBQUwsRUFBK0I7QUFDN0IsY0FBTSxJQUFJTyxLQUFKLENBQVUsMkJBQVYsQ0FBTjtBQUNEO0FBQ0QsVUFBSVAsV0FBVyxLQUFLRCxPQUFwQixFQUE2QjtBQUMzQixZQUFNUyxPQUFPLEtBQUtULE9BQWxCO0FBQ0EsYUFBS0EsT0FBTCxHQUFlQyxNQUFmO0FBQ0EsYUFBS1MsSUFBTCxDQUFVLGVBQVYsRUFBMkI7QUFDekJDLGdCQUFNLFFB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QUFVRixPQUFPeEUsTUFBdkI7QUFDQSxVQUFJeUUsVUFBVUMsT0FBZCxFQUF1QjtBQUNyQixlQUFPLENBQUMsQ0FBUjtBQUNELE9BRkQsTUFFTyxJQUFJRCxVQUFVQyxPQUFkLEVBQXVCO0FBQzVCLGVBQU8sQ0FBUDtBQUNEOztBQUVELFVBQUkxQyxNQUFNMkMsb0JBQVVDLGdCQUFWLENBQTJCTCxNQUEzQixFQUFtQ0MsTUFBbkMsQ0FBVjtBQUNBLFVBQUksQ0FBQ3hDLEdBQUwsRUFBVTtBQUNSQSxjQUFNNkMsc0JBQVlDLGtCQUFaLENBQStCUCxNQUEvQixFQUF1Q0MsTUFBdkMsQ0FBTjtBQUNEOztBQUVELGFBQU94QyxHQUFQO0FBQ0Q7Ozs7RUF0T29DLDJCQUFZckMsYUFBWixFQUNyQyxnREFBOEIsZUFBOUIsQ0FEcUMsRUFDVyw0Q0FBNEIsZUFBNUIsQ0FEWCxFQUVyQyxnREFBOEIsZUFBOUIsQ0FGcUMsQzs7a0JBQWxCcUIsUyIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCBGaWxsU3R5bGUsIHtjcmVhdGVFdmVudGVkRmlsbFN0eWxlTWl4aW59IGZyb20gXCIuLi9zdHlsZS9maWxsLXN0eWxlXCJcbmltcG9ydCBTdHJva2VTdHlsZSwge2NyZWF0ZUV2ZW50ZWRTdHJva2VTdHlsZU1peGlufSBmcm9tIFwiLi4vc3R5bGUvc3Ryb2tlLXN0eWxlXCJcbmltcG9ydCBUcmFuc2Zvcm0yZCwge2NyZWF0ZUV2ZW50ZWRUcmFuc2Zvcm0yZE1peGlufSBmcm9tIFwiLi90cmFuc2Zvcm0yZFwiXG5pbXBvcnQgYWdncmVnYXRpb24gZnJvbSBcIi4uL3V0aWwvYWdncmVnYXRpb25cIlxuaW1wb3J0IEJhc2ljU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2Jhc2ljLXN0eWxlXCJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSBcIi4uL3V0aWwvZXZlbnQtaGFuZGxlclwiXG5pbXBvcnQge21hdDJkIGFzIE1hdDJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDb3JlU2hhcGVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3pJbmRleD0wXSBaIGluZGV4IGRyYXcgb3JkZXIgb2YgdGhlIHNoYXBlLiBMb3dlciBudW1iZXJzIGdldCBkcmF3biBiZWZvcmUgbGFyZ2VyIG51bWJlcnNcbiAqL1xuXG4vKipcbiAqIFNoYXBlIGdlb20gbW9kaWZpY2F0aW9uIGV2ZW50XG4gKiBAZXZlbnQgU2hhcGUjZ2VvbUNoYW5nZWRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXR0ciBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgbW9kaWZpZWRcbiAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBTaGFwZSBtb2RpZmljYXRpb24gZXZlbnRcbiAqIEBldmVudCBFdmVudGVkU2hhcGUjY2hhbmdlZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBtb2RpZmllZFxuICogQHByb3BlcnR5IHt9IHByZXZWYWwgUHJldmlvdXMgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwcmlvciB0byBtb2RpZmljYXRpb25cbiAqIEBwcm9wZXJ0eSB7fSBjdXJyVmFsIFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcG9zdCBtb2RpZmljYXRpb25cbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBEZWZpbmVzIHRoZSBjb3JlIGZ1bmN0aW9uYWxpdHkgZm9yIGFsbCBzaGFwZXNcbiAqIEBleHRlbmRzIHtFdmVudEhhbmRsZXJ9XG4gKi9cbmNsYXNzIENvcmVCYXNlU2hhcGUgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBuZXcgY29yZSBmdW5jdGlvbmFsaXR5IGZvciBhIHNoYXBlXG4gICAqIEBwYXJhbSAge0NvcmVTaGFwZU9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJuIHtDb3JlQmFzZVNoYXBlfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKFtcImNoYW5nZWQ6eGZvcm1cIiwgXCJjaGFuZ2VkOnN0eWxlXCIsIFwiY2hhbmdlZDpvcmRlclwiLCBcImNoYW5nZWQ6dmlzaWJpbGl0eVwiLCBcImNoYW5nZWQ6Z2VvbVwiXSlcbiAgICB0aGlzLl9hYWJveCA9IEFBQm94MmQuY3JlYXRlKClcbiAgICB0aGlzLl96SW5kZXggPSAob3B0cyAmJiBvcHRzLnpJbmRleCkgPyBvcHRzLnpJbmRleCA6IDBcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZVxuICAgIHRoaXMuX2dlb21EaXJ0eSA9IGZhbHNlXG5cbiAgICB0aGlzLl9mdWxsWGZvcm0gPSBNYXQyZC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHogaW5kZXggKGJhY2sgdG8gZnJvbnQgZHJhdyBvcmRlcikgb2YgdGhlIHNoYXBlXG4gICAqIEBwYXJhbSAge251bWJlcn0gekluZGV4XG4gICAqIEBmaXJlcyAgRXZlbnRlZFNoYXBlI2NoYW5nZWRcbiAgICogQHJldHVybiB7Q29yZUJhc2VTaGFwZX0gICAgICAgIHRoaXNcbiAgICovXG4gIHNldCB6SW5kZXgoekluZGV4KSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHpJbmRleCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInpJbmRleCBtdXN0IGJlIGFuIGludGVnZXJcIilcbiAgICB9XG4gICAgaWYgKHpJbmRleCAhPT0gdGhpcy5fekluZGV4KSB7XG4gICAgICBjb25zdCBwcmV2ID0gdGhpcy5fekluZGV4XG4gICAgICB0aGlzLl96SW5kZXggPSB6SW5kZXhcbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6b3JkZXJcIiwge1xuICAgICAgICBhdHRyOiBcInpJbmRleFwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl96SW5kZXhcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB6IGluZGV4IChpLmUuIGRyYXcvbGF5ZXIgb3JkZXIpIG9mIHRoZSBzaGFwZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgekluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLl96SW5kZXhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgdGhlXG4gICAqIHNoYXBlXG4gICAqIEByZXR1cm4ge0FBQm94MmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0IGFhYm94KCkge1xuICAgIHRoaXMuX3VwZGF0ZUFBQm94KClcbiAgICByZXR1cm4gdGhpcy5fYWFib3hcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSB2aXNpYmxlIElmIHRydWUsIHRoZSBzaGFwZSBpcyBjb25zaWRlcmVkIHZpc2libGVcbiAgICogQGZpcmVzICBFdmVudGVkU2hhcGUjY2hhbmdlZFxuICAgKiBAcmV0dXJuIHtDb3JlQmFzZVNoYXBlfSAgICAgICAgIHRoaXNcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGFyZ3VtZW50IGlzIG5vdCBhIGJvb2xlYW4gdHlwZVxuICAgKi9cbiAgc2V0IHZpc2libGUodmlzaWJsZSkge1xuICAgIGlmICh0eXBlb2YgdmlzaWJsZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInZpc2libGUgbXVzdCBiZSBhIGJvb2xlYW5cIilcbiAgICB9XG5cbiAgICBpZiAodmlzaWJsZSAhPT0gdGhpcy5fdmlzaWJsZSkge1xuICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGVcbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6dmlzaWJpbGl0eVwiLCB7XG4gICAgICAgIGF0dHI6IFwidmlzaWJsZVwiLFxuICAgICAgICBwcmV2VmFsOiAhdGhpcy5fdmlzaWJsZSxcbiAgICAgICAgY3VyclZhbDogdGhpcy5fdmlzaWJsZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmlzaWJpbGl0eSBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlXG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgRGVmaW5lcyB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0eSBvZiBhbGwgc2hhcGVzLiBUaGlzIGluY2x1ZGVzXG4gKiAgICAgICAgbWl4aW5nIGluIGZyb20gRXZlbnRlZFRyYW5zZm9ybTJkIHNvIHRoYXQgYWZmaW5lIHRyYW5zZm9ybWF0aW9uc1xuICogICAgICAgIGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBzaGFwZS4gQWxzbyBpbmNsdWRlcyBtaXhpbmcgaW4gZmlsbCBhbmQgc3Ryb2tlXG4gKiAgICAgICAgcHJvcGVydGllcyBzbyB0aGF0IHRoZSBzaGFwZSdzIHJlbmRlcmFibGUgcHJvcGVydGllcyBjYW4gYmUgbW9kaWZpZWQuXG4gKiBAZXh0ZW5kcyB7Q29yZUJhc2VTaGFwZX1cbiAqIEBtaXhpbiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICogQG1peGluIHtFdmVudGVkRmlsbFN0eWxlfVxuICogQG1peGluIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2VTaGFwZSBleHRlbmRzIGFnZ3JlZ2F0aW9uKENvcmVCYXNlU2hhcGUsXG4gIGNyZWF0ZUV2ZW50ZWRUcmFuc2Zvcm0yZE1peGluKFwiY2hhbmdlZDp4Zm9ybVwiKSwgY3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGluKFwiY2hhbmdlZDpzdHlsZVwiKSxcbiAgY3JlYXRlRXZlbnRlZFN0cm9rZVN0eWxlTWl4aW4oXCJjaGFuZ2VkOnN0eWxlXCIpKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IGJhc2ljIGZ1bmN0aW9uYWxpdHkgKGluY2x1ZGluZyB0cmFuc2Zvcm0sIGZpbGwgc3R5bGUsIGFuZCBzdHJva2Ugc3R5bGUgcHJvcGVydGllcylcbiAgICogZm9yIGEgc2hhcGVcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRzXG4gICAqIEByZXR1cm4ge0Jhc2VTaGFwZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3N0YXRlU3RhY2sgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzaGFwZSBzbyB0aGF0IGl0IGNhbiBiZSByZXN0b3JlZCBsYXRlci5cbiAgICogQHJldHVybiB7QmFzZVNoYXBlfSB0aGlzXG4gICAqL1xuICBzYXZlKCkge1xuICAgIC8vIEN1cnJlbnRseSBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlsbC9zdHJva2Ugc3R5bGUgcHJvcGVydGllc1xuICAgIC8vIGFuZCB0aGUgeiBpbmRleCBhcmUgc2F2ZWQuIE1heSB3YW50IHRvIGV4cGFuZCB0aGlzIHRvIGluY2x1ZGVcbiAgICAvLyBhbGwgbW9kaWZpYWJsZSBwcm9wZXJ0aWVzIChpLmUuIHRyYW5zZm9ybSBwcm9wcyBhbmQgdmlzaWJpbGl0eSBwcm9wKVxuICAgIGNvbnN0IHN0YXRlID0gbmV3IEJhc2ljU3R5bGUoKVxuICAgIEJhc2ljU3R5bGUuY29weUJhc2ljU3R5bGUodGhpcywgc3RhdGUpXG4gICAgc3RhdGUuekluZGV4ID0gdGhpcy56SW5kZXhcbiAgICB0aGlzLl9zdGF0ZVN0YWNrLnB1c2goc3RhdGUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3BzIGEgc2F2ZWQgc3RhdGUgZnJvbSB0aGUgdG9wIG9mIHRoZSBzYXZlZCBzdGF0ZSBzdGFja1xuICAgKiBAcmV0dXJuIHtCYXNlU2hhcGV9IHRoaXNcbiAgICovXG4gIHJlc3RvcmUoKSB7XG4gICAgLy8gQ3VycmVudGx5IG9ubHkgcmVzdG9yZXMgdGhlIHN0YXRlIG9mIHRoZSBmaWxsL3N0cm9rZSBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgLy8gYW5kIHRoZSB6IGluZGV4LiBNYXkgd2FudCB0byBleHBhbmQgdGhpcyB0byBpbmNsdWRlXG4gICAgLy8gYWxsIG1vZGlmaWFibGUgcHJvcGVydGllcyAoaS5lLiB0cmFuc2Zvcm0gcHJvcHMgYW5kIHZpc2liaWxpdHkgcHJvcClcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlU3RhY2sucG9wKClcbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIEJhc2ljU3R5bGUuY29weUJhc2ljU3R5bGUoc3RhdGUsIHRoaXMpXG4gICAgICB0aGlzLnpJbmRleCA9IHN0YXRlLnpJbmRleFxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGUgJiYgKHRoaXMuaXNGaWxsVmlzaWJsZSgpIHx8IHRoaXMuaXNTdHJva2VWaXNpYmxlKCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBzaGFwZSBhZnRlciB0aGUgcGFyZW50IHRyYW5zZm9ybXMgYXJlIGFwcGxpZWRcbiAgICogQHJldHVybiB7VmVjMmR9IFdpZHRoL0hlaWdodCBvZiB0aGUgc2hhcGUgYWZ0ZXIgYWxsIHBhcmVudCB0cmFuc2Zvcm1zIGFwcGxpZWRcbiAgICovXG4gIGdldEdsb2JhbERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgICBNYXQyZC5zdmQobnVsbCwgc2NhbGUsIG51bGwsIHRoaXMuZ2xvYmFsWGZvcm0pXG4gICAgc2NhbGVbMF0gKj0gdGhpcy53aWR0aFxuICAgIHNjYWxlWzFdICo9IHRoaXMuaGVpZ2h0XG4gICAgcmV0dXJuIHNjYWxlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHRoZSBzaGFwZSBjb250YWlucyBhIHNjcmVlbi93b3JsZCBzcGFjZSBwb2ludFxuICAgKiBAcGFyYW0gIHtQb2ludDJkfSBzY3JlZW5QdCAgICAgICAgICAgVGhlIHBvaW50IHRvIGNoZWNrIGluIHNjcmVlbi9waXhlbCBzcGFjZVxuICAgKiBAcGFyYW0gIHtQb2l0bjJkfSB3b3JsZFB0ICAgICAgICAgICAgVGhlIHBvaW50IHRvIGNoZWNrIGluIHdvcmxkIHNwYWNlXG4gICAqIEBwYXJhbSAge01hdDJkfSB3b3JsZFRvU2NyZWVuTWF0cml4ICBUaGUgdHJhbnNmb3JtIG1hdHJpeCBmcm9tIHdvcmxkIHRvIHNjcmVlbiBzcGFjZVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCBUaGUgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgIFRydWUgaWYgdGhlIHNoYXBlIGNvbnRhaW5zIHRoZSBwb2ludCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAqL1xuICBjb250YWluc1BvaW50KHNjcmVlblB0LCB3b3JsZFB0LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBjdHgpIHtcbiAgICAvLyBTaG91bGQgd2UgdXBkYXRlIGhlcmUsIG9yIGlzIGl0IHNhZmUgdG9cbiAgICAvLyBzYXkgdGhhdCB0aGlzIGlzIHN0YXRlZnVsLCBtZWFuaW5nIGEgcmVuZGVyXG4gICAgLy8gc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgYmVmb3JlaGFuZCB3aGljaFxuICAgIC8vIHdvdWxkJ3ZlIHVwZGF0ZWQgaXRzIHN0YXRlXG4gICAgbGV0IHJ0biA9IGZhbHNlXG4gICAgY29uc3QgYWFib3ggPSB0aGlzLmFhYm94XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgcG9pbnQgaXMgY29udGFpbmVkIGJ5IHRoZSBzaGFwZSdzIGJvdW5kcyBmaXJzdFxuICAgIGlmICh0aGlzLnZpc2libGUgJiYgQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCB3b3JsZFB0KSkge1xuICAgICAgLy8gcmUtZHJhdyB0aGUgc2hhcGUgKGludmlzaWJsZSkgc28gdGhhdCB3ZSBjYW4gdXNlIGNhbnZhcydzXG4gICAgICAvLyBpc1BvaW50SW5QYXRoL2lzUG9pbnRJblN0cm9rZSBhcGkgY2FsbHMuIERvaW5nIHRoYXRcbiAgICAgIC8vIGFzIHRoaXMgc2hvdWxkIGJlIGNvbXBhdGlibGUgYWNyb3NzIGFsbCBicm93c2Vyc1xuICAgICAgY3R4LnNhdmUoKVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSh0aGlzLl9mdWxsWGZvcm1bMF0sIHRoaXMuX2Z1bGxYZm9ybVsxXSwgdGhpcy5fZnVsbFhmb3JtWzJdLCB0aGlzLl9mdWxsWGZvcm1bM10sIHRoaXMuX2Z1bGxYZm9ybVs0XSwgdGhpcy5fZnVsbFhmb3JtWzVdKVxuICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICB0aGlzLl9kcmF3KGN0eClcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmdiYSgwLDAsMCwwKVwiXG4gICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aCArIDUgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICBjdHguZGFzaFBhdHRlcm4gPSBbXVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICBpZiAoKHRoaXMuaXNGaWxsVmlzaWJsZSgpICYmIGN0eC5pc1BvaW50SW5QYXRoKHNjcmVlblB0WzBdLCBzY3JlZW5QdFsxXSkpIHx8XG4gICAgICAgICh0aGlzLmlzU3Ryb2tlVmlzaWJsZSgpICYmIGN0eC5pc1BvaW50SW5TdHJva2Uoc2NyZWVuUHRbMF0sIHNjcmVlblB0WzFdKSkpIHtcbiAgICAgICAgcnRuID0gdHJ1ZVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cbiAgICByZXR1cm4gcnRuXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgZnVuY3Rpb24gdG8gZHJhdyB0aGUgYm91bmRzIG9mIHRoZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgICAgICAgICAgICAgICAgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7TWF0MmR9IHdvcmxkVG9TY3JlZW5NYXRyaXggVHJhbnNmb3JtIGZyb20gd29ybGQgdG8gc2NyZWVuIHNwYWNlXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBib3VuZHNTdHJva2VTdHlsZSAgIFRoZSBzdHJva2Ugc3R5bGUgdG8gdXNlIHRvIHJlbmRlciB0aGUgYm91bmRzXG4gICAqL1xuICByZW5kZXJCb3VuZHMoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBib3VuZHNTdHJva2VTdHlsZSkge1xuICAgIGN0eC5zYXZlKClcbiAgICBjdHguc2V0VHJhbnNmb3JtKHdvcmxkVG9TY3JlZW5NYXRyaXhbMF0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbMV0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbMl0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbM10sIHdvcmxkVG9TY3JlZW5NYXRyaXhbNF0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbNV0pXG4gICAgYm91bmRzU3Ryb2tlU3R5bGUuc2V0U3Ryb2tlQ3R4KGN0eClcbiAgICBjb25zdCBjZW50ZXIgPSBbMCwgMF1cbiAgICBjb25zdCBleHRlbnRzID0gWzAsIDBdXG4gICAgY29uc3QgYWFib3ggPSB0aGlzLmFhYm94XG4gICAgQUFCb3gyZC5nZXRDZW50ZXIoY2VudGVyLCBhYWJveClcbiAgICBBQUJveDJkLmdldEV4dGVudHMoZXh0ZW50cywgYWFib3gpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LnJlY3QoY2VudGVyWzBdIC0gZXh0ZW50c1swXSwgY2VudGVyWzFdIC0gZXh0ZW50c1sxXSwgZXh0ZW50c1swXSAqIDIsIGV4dGVudHNbMV0gKiAyKVxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjdHguc3Ryb2tlKClcbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybSAoZG9lcyBub3QgaW5jbHVkZSBwYXJlbnQgdHJhbnNmb3Jtcykgb2YgdGhlIFRyYW5zZm9ybTJkXG4gICAqIG1peGluIGlzIG1vZGlmaWVkLiBVc2VkIHRvIGJlIG5vdGlmaWVkIGludGVybmFsbHkgdGhhdCB0aGUgc2hhcGUncyBib3VuZHMgbmVlZHMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2NhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGdsb2JhbCB0cmFuc2Zvcm0gKGluY2x1ZGVzIHBhcmVudCB0cmFuc2Zvcm1zKSBvZiB0aGUgVHJhbnNmb3JtMmRcbiAgICogbWl4aW4gaXMgbW9kaWZpZWQuIFVzZWQgdG8gYmUgbm90aWZpZWQgaW50ZXJuYWxseSB0aGF0IHRoZSBzaGFwZSdzIGJvdW5kcyBuZWVkcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dsb2JhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2hhcGUgdXNpbmcgYSAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAgICAgICAgICAgICAgICAgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7TWF0MmR9IHdvcmxkVG9TY3JlZW5NYXRyaXggVHJhbnNmb3JtIGZyb20gd29ybGQgdG8gc2NyZWVuIHNwYWNlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c3VhbGx5IHByb3ZpZGVkIGJ5IGEgY2FtZXJhXG4gICAqIEBwYXJhbSAge0RyYXdTdHlsZVN0YXRlfSBzdHlsZVN0YXRlIE1hbmFnZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlIGF0dHJzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSAyZCByZW5kZXJpbmcgY29udGV4dC4gVGhpcyBpcyBzZWxmLW1hbmFnZWQgdG8gbWluaW1pemVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCBzdGF0ZSBzd2l0Y2hlc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbZG9GaWxsPW51bGxdICAgICBJZiBwcm92aWRlZCwgdXNlZCB0byBtYW51YWxseSBvdmVycmlkZSB3aGV0aGVyIHRvIGZpbGwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbZG9TdHJva2U9bnVsbF0gICBJZiBwcm92aWRlZCwgdXNlZCB0byBtYW51YWxseSBvdmVycmlkZSB3aGV0aGVyIHRvIHN0cm9rZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuXG4gICAqL1xuICByZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBzdHlsZVN0YXRlLCBkb0ZpbGwgPSBudWxsLCBkb1N0cm9rZSA9IG51bGwpIHtcbiAgICB0aGlzLnRyYW5zZm9ybUN0eChjdHgsIHRoaXMuX2Z1bGxYZm9ybSwgd29ybGRUb1NjcmVlbk1hdHJpeClcblxuICAgIGN0eC5iZWdpblBhdGgoKVxuXG4gICAgY29uc3QgcnRuID0gdGhpcy5fZHJhdyhjdHgpXG4gICAgaWYgKHJ0biB8fCB0eXBlb2YgcnRuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodGhpcy5pc0ZpbGxWaXNpYmxlKCkgJiYgKGRvRmlsbCA9PT0gbnVsbCB8fCBCb29sZWFuKGRvRmlsbCkpKSB7XG4gICAgICAgIHN0eWxlU3RhdGUuc2V0RmlsbFN0eWxlKGN0eCwgdGhpcylcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1N0cm9rZVZpc2libGUoKSAmJiAoZG9TdHJva2UgPT09IG51bGwgfHwgQm9vbGVhbihkb1N0cm9rZSkpKSB7XG4gICAgICAgIHN0eWxlU3RhdGUuc2V0U3Ryb2tlU3R5bGUoY3R4LCB0aGlzKVxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlIGZyb20gb25lIEJhc2ljU3R5bGUgb2JqZWN0IHRvIHRoaXMgc2hhcGVcbiAgICogQHBhcmFtIHtCYXNpY1N0eWxlfSBuZXdTdHlsZSBUaGUgc3R5bGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJuIHtCYXNlU2hhcGV9IHRoaXNcbiAgICovXG4gIHNldFN0eWxlKG5ld1N0eWxlKSB7XG4gICAgQmFzaWNTdHlsZS5jb3B5QmFzaWNTdHlsZShuZXdTdHlsZSwgdGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgc2hhcGVcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjb25zaXN0ZW50LXRoaXNcbiAgICBpZiAodGhpcy5fc3RhdGVTdGFjayAmJiB0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCkge1xuICAgICAgc3RhdGUgPSB0aGlzLl9zdGF0ZVN0YWNrWzBdXG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIC8vIHR5cGU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgIC8vIE5PVEU6IEkgd2FudGVkIHRvIHVzZSB0aGUgYWJvdmUgY2FsbCwgd2hpY2ggd291bGQga2VlcCB0aGUgdHlwZVxuICAgICAgLy8gY29uc2lzdGVudCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBjbGFzcywgYnV0IHRoaXMgaXNuJ3QgYWx3YXlzXG4gICAgICAvLyB0aGUgY2FzZSwgYXMgd2FzIGZvdW5kIG91dCBhIGZldyB0aW1lcyB3aGVuIHRyeWluZyB0byBhZGRcbiAgICAgIC8vIHRoaXMgdG8gaW1tZXJzZVxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgekluZGV4OiBzdGF0ZS56SW5kZXhcbiAgICB9LCBCYXNpY1N0eWxlLnRvSlNPTihzdGF0ZSksIFRyYW5zZm9ybTJkLnRvSlNPTih0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gc2hhcGVzLCB1c3VhbGx5IHVzZWQgdG8gc29ydCB0aGUgc2hhcGVzIGZvciBkcmF3aW5nXG4gICAqIEBwYXJhbSAge0Jhc2VTaGFwZX0gc2hhcGUxXG4gICAqIEBwYXJhbSAge0Jhc2VTaGFwZX0gc2hhcGUyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFJldHVybnMgPCAwIGlmIHNoYXBlMSA8IHNoYXBlMiwgPiAwIGlmIHNoYXBlMSA+IHNoYXBlMiwgMCBpZiBzaGFwZTEgPT09IHNoYXBlMlxuICAgKi9cbiAgc3RhdGljIHNoYXBlQ29tcGFyZShzaGFwZTEsIHNoYXBlMikge1xuICAgIGNvbnN0IHpJbmRleDEgPSBzaGFwZTEuekluZGV4XG4gICAgY29uc3QgekluZGV4MiA9IHNoYXBlMi56SW5kZXhcbiAgICBpZiAoekluZGV4MSA8IHpJbmRleDIpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoekluZGV4MSA+IHpJbmRleDIpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGV0IHJ0biA9IEZpbGxTdHlsZS5jb21wYXJlRmlsbFN0eWxlKHNoYXBlMSwgc2hhcGUyKVxuICAgIGlmICghcnRuKSB7XG4gICAgICBydG4gPSBTdHJva2VTdHlsZS5jb21wYXJlU3Ryb2tlU3R5bGUoc2hhcGUxLCBzaGFwZTIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9iYXNlLXNoYXBlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/*\n **  Aggregation -- Aggregation of Base Class and Mixin Classes\n **  Copyright (c) 2015 Ralf S. Engelschall <rse@engelschall.com>\n **\n **  Permission is hereby granted, free of charge, to any person obtaining\n **  a copy of this software and associated documentation files (the\n **  \"Software\"), to deal in the Software without restriction, including\n **  without limitation the rights to use, copy, modify, merge, publish,\n **  distribute, sublicense, and/or sell copies of the Software, and to\n **  permit persons to whom the Software is furnished to do so, subject to\n **  the following conditions:\n **\n **  The above copyright notice and this permission notice shall be included\n **  in all copies or substantial portions of the Software.\n **\n **  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n **  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n **  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n **  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n **  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n **  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n **  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*  ==== ECMAScript 6 variant ====  */\n\n/**\n * Creates a new class constructor function using an optional base class\n * and an optional list of mixins. If mixins need initializing, then\n * they should contain an 'initializer' member function\n * @param  {function}    base   base class construct function, if null, a bare-bones\n *                              base class is used by default\n * @param  {...[function]} mixins mixin classes\n * @return {function}           new class constructor function\n */\nvar aggregation = function aggregation(base) {\n  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n\n  /*  create aggregation class  */\n  var aggregate = base ? function (_base) {\n    _inherits(__Aggregate, _base);\n\n    function __Aggregate() {\n      var _ref;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _classCallCheck(this, __Aggregate);\n\n      /*  call mixin's initializer  */\n      var _this = _possibleConstructorReturn(this, (_ref = __Aggregate.__proto__ || Object.getPrototypeOf(__Aggregate)).call.apply(_ref, [this].concat(args)));\n      /*  call base class constructor  */\n\n\n      mixins.forEach(function (mixin) {\n        if (typeof mixin.prototype.initializer === \"function\") {\n          var _mixin$prototype$init;\n\n          (_mixin$prototype$init = mixin.prototype.initializer).call.apply(_mixin$prototype$init, [_this].concat(args));\n        }\n      });\n      return _this;\n    }\n\n    return __Aggregate;\n  }(base) : function () {/* do nothing */};\n\n  /*  copy properties  */\n  var copyProps = function copyProps(target, source) {\n    Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source)).forEach(function (prop) {\n      if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)) {\n        return;\n      }\n      if (base && prop.match(/^(?:initializer)$/)) {\n        return;\n      }\n      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n    });\n  };\n\n  /*  copy all properties of all mixins into aggregation class  */\n  mixins.forEach(function (mixin) {\n    copyProps(aggregate.prototype, mixin.prototype);\n    copyProps(aggregate, mixin);\n  });\n\n  return aggregate;\n};\n\nexports.default = aggregation;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2FnZ3JlZ2F0aW9uLmpzP2I4ODAiXSwibmFtZXMiOlsiYWdncmVnYXRpb24iLCJiYXNlIiwibWl4aW5zIiwiYWdncmVnYXRlIiwiYXJncyIsImZvckVhY2giLCJtaXhpbiIsInByb3RvdHlwZSIsImluaXRpYWxpemVyIiwiY2FsbCIsImNvcHlQcm9wcyIsInRhcmdldCIsInNvdXJjZSIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wIiwibWF0Y2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7QUFFQTs7Ozs7Ozs7O0FBU0EsSUFBTUEsY0FBYyxTQUFkQSxXQUFjLENBQUNDLElBQUQsRUFBcUI7QUFBQSxvQ0FBWEMsTUFBVztBQUFYQSxVQUFXO0FBQUE7O0FBRXZDO0FBQ0EsTUFBTUMsWUFBYUY7QUFBQTs7QUFDakIsMkJBQXFCO0FBQUE7O0FBQUEseUNBQU5HLElBQU07QUFBTkEsWUFBTTtBQUFBOztBQUFBOztBQUluQjtBQUptQix1SkFFVkEsSUFGVTtBQUNuQjs7O0FBSUFGLGFBQU9HLE9BQVAsQ0FBZSxVQUFDQyxLQUFELEVBQVc7QUFDeEIsWUFBSSxPQUFPQSxNQUFNQyxTQUFOLENBQWdCQyxXQUF2QixLQUF1QyxVQUEzQyxFQUF1RDtBQUFBOztBQUFFLHlDQUFNRCxTQUFOLENBQWdCQyxXQUFoQixFQUE0QkMsSUFBNUIsNkNBQTBDTCxJQUExQztBQUFpRDtBQUMzRyxPQUZEO0FBTG1CO0FBUXBCOztBQVRnQjtBQUFBLElBQWlDSCxJQUFqQyxJQVVmLFlBQU0sQ0FBRSxnQkFBa0IsQ0FWOUI7O0FBWUE7QUFDQSxNQUFNUyxZQUFZLFNBQVpBLFNBQVksQ0FBQ0MsTUFBRCxFQUFTQyxNQUFULEVBQW9CO0FBQ3BDQyxXQUFPQyxtQkFBUCxDQUEyQkYsTUFBM0IsRUFDR0csTUFESCxDQUNVRixPQUFPRyxxQkFBUCxDQUE2QkosTUFBN0IsQ0FEVixFQUVHUCxPQUZILENBRVcsVUFBQ1ksSUFBRCxFQUFVO0FBQ2pCLFVBQUlBLEtBQUtDLEtBQUwsQ0FBVyxtRkFBWCxDQUFKLEVBQXFHO0FBQUU7QUFBUTtBQUMvRyxVQUFJakIsUUFBUWdCLEtBQUtDLEtBQUwsQ0FBVyxtQkFBWCxDQUFaLEVBQTZDO0FBQUU7QUFBUTtBQUN2REwsYUFBT00sY0FBUCxDQUFzQlIsTUFBdEIsRUFBOEJNLElBQTlCLEVBQW9DSixPQUFPTyx3QkFBUCxDQUFnQ1IsTUFBaEMsRUFBd0NLLElBQXhDLENBQXBDO0FBQ0QsS0FOSDtBQU9ELEdBUkQ7O0FBVUE7QUFDQWYsU0FBT0csT0FBUCxDQUFlLFVBQUNDLEtBQUQsRUFBVztBQUN4QkksY0FBVVAsVUFBVUksU0FBcEIsRUFBK0JELE1BQU1DLFNBQXJDO0FBQ0FHLGNBQVVQLFNBQVYsRUFBcUJHLEtBQXJCO0FBQ0QsR0FIRDs7QUFLQSxTQUFPSCxTQUFQO0FBQ0QsQ0FqQ0Q7O2tCQW1DZUgsVyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqKiAgQWdncmVnYXRpb24gLS0gQWdncmVnYXRpb24gb2YgQmFzZSBDbGFzcyBhbmQgTWl4aW4gQ2xhc3Nlc1xuICoqICBDb3B5cmlnaHQgKGMpIDIwMTUgUmFsZiBTLiBFbmdlbHNjaGFsbCA8cnNlQGVuZ2Vsc2NoYWxsLmNvbT5cbiAqKlxuICoqICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAqKiAgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4gKiogIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICoqICB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gKiogIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xuICoqICBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG9cbiAqKiAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICoqXG4gKiogIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4gKiogIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICoqXG4gKiogIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiogIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICoqICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuXG4gKiogIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiogIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG4gKiogIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFXG4gKiogIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qICA9PT09IEVDTUFTY3JpcHQgNiB2YXJpYW50ID09PT0gICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbiB1c2luZyBhbiBvcHRpb25hbCBiYXNlIGNsYXNzXG4gKiBhbmQgYW4gb3B0aW9uYWwgbGlzdCBvZiBtaXhpbnMuIElmIG1peGlucyBuZWVkIGluaXRpYWxpemluZywgdGhlblxuICogdGhleSBzaG91bGQgY29udGFpbiBhbiAnaW5pdGlhbGl6ZXInIG1lbWJlciBmdW5jdGlvblxuICogQHBhcmFtICB7ZnVuY3Rpb259ICAgIGJhc2UgICBiYXNlIGNsYXNzIGNvbnN0cnVjdCBmdW5jdGlvbiwgaWYgbnVsbCwgYSBiYXJlLWJvbmVzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgY2xhc3MgaXMgdXNlZCBieSBkZWZhdWx0XG4gKiBAcGFyYW0gIHsuLi5bZnVuY3Rpb25dfSBtaXhpbnMgbWl4aW4gY2xhc3Nlc1xuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICBuZXcgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqL1xuY29uc3QgYWdncmVnYXRpb24gPSAoYmFzZSwgLi4ubWl4aW5zKSA9PiB7XG5cbiAgLyogIGNyZWF0ZSBhZ2dyZWdhdGlvbiBjbGFzcyAgKi9cbiAgY29uc3QgYWdncmVnYXRlID0gKGJhc2UgPyBjbGFzcyBfX0FnZ3JlZ2F0ZSBleHRlbmRzIGJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgIC8qICBjYWxsIGJhc2UgY2xhc3MgY29uc3RydWN0b3IgICovXG4gICAgICBzdXBlciguLi5hcmdzKVxuXG4gICAgICAvKiAgY2FsbCBtaXhpbidzIGluaXRpYWxpemVyICAqL1xuICAgICAgbWl4aW5zLmZvckVhY2goKG1peGluKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgbWl4aW4ucHJvdG90eXBlLmluaXRpYWxpemVyID09PSBcImZ1bmN0aW9uXCIpIHsgbWl4aW4ucHJvdG90eXBlLmluaXRpYWxpemVyLmNhbGwodGhpcywgLi4uYXJncykgfVxuICAgICAgfSlcbiAgICB9XG4gIH0gOiAoKSA9PiB7IC8qIGRvIG5vdGhpbmcgKi8gfSlcblxuICAvKiAgY29weSBwcm9wZXJ0aWVzICAqL1xuICBjb25zdCBjb3B5UHJvcHMgPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKSlcbiAgICAgIC5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wLm1hdGNoKC9eKD86Y29uc3RydWN0b3J8cHJvdG90eXBlfGFyZ3VtZW50c3xjYWxsZXJ8bmFtZXxiaW5kfGNhbGx8YXBwbHl8dG9TdHJpbmd8bGVuZ3RoKSQvKSkgeyByZXR1cm4gfVxuICAgICAgICBpZiAoYmFzZSAmJiBwcm9wLm1hdGNoKC9eKD86aW5pdGlhbGl6ZXIpJC8pKSB7IHJldHVybiB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wKSlcbiAgICAgIH0pXG4gIH1cblxuICAvKiAgY29weSBhbGwgcHJvcGVydGllcyBvZiBhbGwgbWl4aW5zIGludG8gYWdncmVnYXRpb24gY2xhc3MgICovXG4gIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xuICAgIGNvcHlQcm9wcyhhZ2dyZWdhdGUucHJvdG90eXBlLCBtaXhpbi5wcm90b3R5cGUpXG4gICAgY29weVByb3BzKGFnZ3JlZ2F0ZSwgbWl4aW4pXG4gIH0pXG5cbiAgcmV0dXJuIGFnZ3JlZ2F0ZVxufVxuXG5leHBvcnQgZGVmYXVsdCBhZ2dyZWdhdGlvblxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdXRpbC9hZ2dyZWdhdGlvbi5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aggregation2 = __webpack_require__(7);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _fillStyle = __webpack_require__(17);\n\nvar _fillStyle2 = _interopRequireDefault(_fillStyle);\n\nvar _strokeStyle = __webpack_require__(18);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @class  Basic shape style for a 2d rendering context\n * @extends {FillStyle}\n * @extends {StrokeStyle}\n */\nvar BasicStyle = function (_aggregation) {\n  _inherits(BasicStyle, _aggregation);\n\n  function BasicStyle() {\n    _classCallCheck(this, BasicStyle);\n\n    return _possibleConstructorReturn(this, (BasicStyle.__proto__ || Object.getPrototypeOf(BasicStyle)).apply(this, arguments));\n  }\n\n  _createClass(BasicStyle, null, [{\n    key: \"copyBasicStyle\",\n\n    /**\n     * Copies the properties from one BasicStyle to another\n     * @param  {BasicStyle} srcBasicStyle The style to copy from\n     * @param  {BasicStyle} dstBasicStyle The style to copy to\n     */\n    value: function copyBasicStyle(srcBasicStyle, dstBasicStyle) {\n      _fillStyle2.default.copyFillStyle(srcBasicStyle, dstBasicStyle);\n      _strokeStyle2.default.copyStrokeStyle(srcBasicStyle, dstBasicStyle);\n    }\n\n    /**\n     * Converts a BasicStyle instance to a JSON object\n     * @param  {BasicStyle} basicStyleObj\n     * @return {{fillColor   : string,\n     *           strokeColor : string,\n     *           strokeWidth : number,\n     *           lineJoin    : string,\n     *           lineCap     : string,\n     *           dashPattern : number[],\n     *           dashOffset  : number\n     *          }}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(basicStyleObj) {\n      return Object.assign(_fillStyle2.default.toJSON(basicStyleObj), _strokeStyle2.default.toJSON(basicStyleObj));\n    }\n  }]);\n\n  return BasicStyle;\n}((0, _aggregation3.default)(function BaseBasicStyle() {\n  _classCallCheck(this, BaseBasicStyle);\n}, _fillStyle2.default, _strokeStyle2.default));\n\nexports.default = BasicStyle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9iYXNpYy1zdHlsZS5qcz9kNTU5Il0sIm5hbWVzIjpbIkJhc2ljU3R5bGUiLCJzcmNCYXNpY1N0eWxlIiwiZHN0QmFzaWNTdHlsZSIsIkZpbGxTdHlsZSIsImNvcHlGaWxsU3R5bGUiLCJTdHJva2VTdHlsZSIsImNvcHlTdHJva2VTdHlsZSIsImJhc2ljU3R5bGVPYmoiLCJPYmplY3QiLCJhc3NpZ24iLCJ0b0pTT04iXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0lBS3FCQSxVOzs7Ozs7Ozs7Ozs7QUFDbkI7Ozs7O21DQUtzQkMsYSxFQUFlQyxhLEVBQWU7QUFDbERDLDBCQUFVQyxhQUFWLENBQXdCSCxhQUF4QixFQUF1Q0MsYUFBdkM7QUFDQUcsNEJBQVlDLGVBQVosQ0FBNEJMLGFBQTVCLEVBQTJDQyxhQUEzQztBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7MkJBWWNLLGEsRUFBZTtBQUMzQixhQUFPQyxPQUFPQyxNQUFQLENBQWNOLG9CQUFVTyxNQUFWLENBQWlCSCxhQUFqQixDQUFkLEVBQStDRixzQkFBWUssTUFBWixDQUFtQkgsYUFBbkIsQ0FBL0MsQ0FBUDtBQUNEOzs7O0VBekJxQztBQUFBO0FBQUEsR0FBcUNKLG1CQUFyQyxFQUFnREUscUJBQWhELEM7O2tCQUFuQkwsVSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCBGaWxsU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2ZpbGwtc3R5bGVcIlxuaW1wb3J0IFN0cm9rZVN0eWxlIGZyb20gXCIuLi9zdHlsZS9zdHJva2Utc3R5bGVcIlxuXG4vKipcbiAqIEBjbGFzcyAgQmFzaWMgc2hhcGUgc3R5bGUgZm9yIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBleHRlbmRzIHtGaWxsU3R5bGV9XG4gKiBAZXh0ZW5kcyB7U3Ryb2tlU3R5bGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljU3R5bGUgZXh0ZW5kcyBhZ2dyZWdhdGlvbihjbGFzcyBCYXNlQmFzaWNTdHlsZSB7fSwgRmlsbFN0eWxlLCBTdHJva2VTdHlsZSkge1xuICAvKipcbiAgICogQ29waWVzIHRoZSBwcm9wZXJ0aWVzIGZyb20gb25lIEJhc2ljU3R5bGUgdG8gYW5vdGhlclxuICAgKiBAcGFyYW0gIHtCYXNpY1N0eWxlfSBzcmNCYXNpY1N0eWxlIFRoZSBzdHlsZSB0byBjb3B5IGZyb21cbiAgICogQHBhcmFtICB7QmFzaWNTdHlsZX0gZHN0QmFzaWNTdHlsZSBUaGUgc3R5bGUgdG8gY29weSB0b1xuICAgKi9cbiAgc3RhdGljIGNvcHlCYXNpY1N0eWxlKHNyY0Jhc2ljU3R5bGUsIGRzdEJhc2ljU3R5bGUpIHtcbiAgICBGaWxsU3R5bGUuY29weUZpbGxTdHlsZShzcmNCYXNpY1N0eWxlLCBkc3RCYXNpY1N0eWxlKVxuICAgIFN0cm9rZVN0eWxlLmNvcHlTdHJva2VTdHlsZShzcmNCYXNpY1N0eWxlLCBkc3RCYXNpY1N0eWxlKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgQmFzaWNTdHlsZSBpbnN0YW5jZSB0byBhIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSAge0Jhc2ljU3R5bGV9IGJhc2ljU3R5bGVPYmpcbiAgICogQHJldHVybiB7e2ZpbGxDb2xvciAgIDogc3RyaW5nLFxuICAgKiAgICAgICAgICAgc3Ryb2tlQ29sb3IgOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBzdHJva2VXaWR0aCA6IG51bWJlcixcbiAgICogICAgICAgICAgIGxpbmVKb2luICAgIDogc3RyaW5nLFxuICAgKiAgICAgICAgICAgbGluZUNhcCAgICAgOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBkYXNoUGF0dGVybiA6IG51bWJlcltdLFxuICAgKiAgICAgICAgICAgZGFzaE9mZnNldCAgOiBudW1iZXJcbiAgICogICAgICAgICAgfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oYmFzaWNTdHlsZU9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKEZpbGxTdHlsZS50b0pTT04oYmFzaWNTdHlsZU9iaiksIFN0cm9rZVN0eWxlLnRvSlNPTihiYXNpY1N0eWxlT2JqKSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvYmFzaWMtc3R5bGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _glMatrix = __webpack_require__(1);\n\n/**\n * Returns the Z coordinate of a 2D crossproduct\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    z coord of the 2D crossproduct\n */\n_glMatrix.vec2.cross2d = function (v1, v2) {\n  return v1[0] * v2[1] - v1[1] * v2[0];\n};\n\n/**\n * Calculates the angle between two vectors when directionality\n * is unnecessary (only returns an angle between 0 and PI, inclusive)\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    The angle between two vectors in radians [0, PI]\n */\n_glMatrix.vec2.angleFast = function (v1, v2) {\n  return Math.acos(_glMatrix.vec2.dot(v1, v2));\n};\n\n/**\n * Returns the true angle between two vectors\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    The angle between two vectors in radians [-PI, PI]\n */\n_glMatrix.vec2.angle = function (v1, v2) {\n  var c = _glMatrix.vec2.dot(v1, v2);\n  var s = _glMatrix.vec2.cross2d(v1, v2);\n  var angle = Math.atan2(s, c);\n  return angle;\n};\n\n/**\n * Returns the angle of a vector from the positive X direction\n * in a cartesian coordinate system\n * @param  {Vec2d} v1\n * @return {Number}    The angle in radians [-PI, PI]\n */\n_glMatrix.vec2.anglePosX = function (v) {\n  var angle = Math.atan2(v[1], v[0]);\n  if (angle < 0) {\n    angle *= -1;\n  }\n  return angle;\n};\n\nexports.default = _glMatrix.vec2;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL3ZlYzJkLmpzPzhkZDMiXSwibmFtZXMiOlsiVmVjMmQiLCJjcm9zczJkIiwidjEiLCJ2MiIsImFuZ2xlRmFzdCIsIk1hdGgiLCJhY29zIiwiZG90IiwiYW5nbGUiLCJjIiwicyIsImF0YW4yIiwiYW5nbGVQb3NYIiwidiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOztBQUVBOzs7Ozs7QUFNQUEsZUFBTUMsT0FBTixHQUFnQixVQUFDQyxFQUFELEVBQUtDLEVBQUw7QUFBQSxTQUFZRCxHQUFHLENBQUgsSUFBUUMsR0FBRyxDQUFILENBQVIsR0FBZ0JELEdBQUcsQ0FBSCxJQUFRQyxHQUFHLENBQUgsQ0FBcEM7QUFBQSxDQUFoQjs7QUFFQTs7Ozs7OztBQU9BSCxlQUFNSSxTQUFOLEdBQWtCLFVBQUNGLEVBQUQsRUFBS0MsRUFBTDtBQUFBLFNBQVlFLEtBQUtDLElBQUwsQ0FBVU4sZUFBTU8sR0FBTixDQUFVTCxFQUFWLEVBQWNDLEVBQWQsQ0FBVixDQUFaO0FBQUEsQ0FBbEI7O0FBRUE7Ozs7OztBQU1BSCxlQUFNUSxLQUFOLEdBQWMsVUFBQ04sRUFBRCxFQUFLQyxFQUFMLEVBQVk7QUFDeEIsTUFBTU0sSUFBSVQsZUFBTU8sR0FBTixDQUFVTCxFQUFWLEVBQWNDLEVBQWQsQ0FBVjtBQUNBLE1BQU1PLElBQUlWLGVBQU1DLE9BQU4sQ0FBY0MsRUFBZCxFQUFrQkMsRUFBbEIsQ0FBVjtBQUNBLE1BQU1LLFFBQVFILEtBQUtNLEtBQUwsQ0FBV0QsQ0FBWCxFQUFjRCxDQUFkLENBQWQ7QUFDQSxTQUFPRCxLQUFQO0FBQ0QsQ0FMRDs7QUFPQTs7Ozs7O0FBTUFSLGVBQU1ZLFNBQU4sR0FBa0IsYUFBSztBQUNyQixNQUFJSixRQUFRSCxLQUFLTSxLQUFMLENBQVdFLEVBQUUsQ0FBRixDQUFYLEVBQWlCQSxFQUFFLENBQUYsQ0FBakIsQ0FBWjtBQUNBLE1BQUlMLFFBQVEsQ0FBWixFQUFlO0FBQ2JBLGFBQVMsQ0FBQyxDQUFWO0FBQ0Q7QUFDRCxTQUFPQSxLQUFQO0FBQ0QsQ0FORDs7a0JBUWVSLGMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCB7dmVjMiBhcyBWZWMyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbi8qKlxuICogUmV0dXJucyB0aGUgWiBjb29yZGluYXRlIG9mIGEgMkQgY3Jvc3Nwcm9kdWN0XG4gKiBAcGFyYW0gIHtWZWMyZH0gdjFcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MlxuICogQHJldHVybiB7TnVtYmVyfSAgICB6IGNvb3JkIG9mIHRoZSAyRCBjcm9zc3Byb2R1Y3RcbiAqL1xuVmVjMmQuY3Jvc3MyZCA9ICh2MSwgdjIpID0+IHYxWzBdICogdjJbMV0gLSB2MVsxXSAqIHYyWzBdXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyB3aGVuIGRpcmVjdGlvbmFsaXR5XG4gKiBpcyB1bm5lY2Vzc2FyeSAob25seSByZXR1cm5zIGFuIGFuZ2xlIGJldHdlZW4gMCBhbmQgUEksIGluY2x1c2l2ZSlcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MVxuICogQHBhcmFtICB7VmVjMmR9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGluIHJhZGlhbnMgWzAsIFBJXVxuICovXG5WZWMyZC5hbmdsZUZhc3QgPSAodjEsIHYyKSA9PiBNYXRoLmFjb3MoVmVjMmQuZG90KHYxLCB2MikpXG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJ1ZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzXG4gKiBAcGFyYW0gIHtWZWMyZH0gdjFcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MlxuICogQHJldHVybiB7TnVtYmVyfSAgICBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9ycyBpbiByYWRpYW5zIFstUEksIFBJXVxuICovXG5WZWMyZC5hbmdsZSA9ICh2MSwgdjIpID0+IHtcbiAgY29uc3QgYyA9IFZlYzJkLmRvdCh2MSwgdjIpXG4gIGNvbnN0IHMgPSBWZWMyZC5jcm9zczJkKHYxLCB2MilcbiAgY29uc3QgYW5nbGUgPSBNYXRoLmF0YW4yKHMsIGMpXG4gIHJldHVybiBhbmdsZVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHBvc2l0aXZlIFggZGlyZWN0aW9uXG4gKiBpbiBhIGNhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICogQHBhcmFtICB7VmVjMmR9IHYxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBpbiByYWRpYW5zIFstUEksIFBJXVxuICovXG5WZWMyZC5hbmdsZVBvc1ggPSB2ID0+IHtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih2WzFdLCB2WzBdKVxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKj0gLTFcbiAgfVxuICByZXR1cm4gYW5nbGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVjMmRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvdmVjMmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _convexHull = __webpack_require__(14);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar identityMatrix = _glMatrix.mat2d.create();\n\n/**\n * Expands an axis-aligned bounding box to encapsulate a 2d vertex\n * defined in an array of vertices, and updates a struct used to\n * store the indices of the vertices that define the final bounds\n * of the vertices\n * @param  {AABox2d} box          Bounds to expand\n * @param  {Point2d} pt           2d vertex to encapsulate\n * @param  {number} ptIdx         Index of the vertex in its list of vertices\n * @param  {number[]} extentIndices Struct to store the indices of the bounding vertices\n * @private\n */\nfunction aaboxEncapsulatePt(box, pt, ptIdx, extentIndices) {\n  if (AABox2d.isEmpty(box)) {\n    box[0] = pt[0];\n    box[2] = pt[0];\n    extentIndices[0] = extentIndices[2] = ptIdx;\n    box[1] = pt[1];\n    box[3] = pt[1];\n    extentIndices[1] = extentIndices[3] = ptIdx;\n  } else {\n    if (pt[0] < box[0]) {\n      box[0] = pt[0];\n      extentIndices[0] = ptIdx;\n    } else if (pt[0] > box[2]) {\n      box[2] = pt[0];\n      extentIndices[2] = ptIdx;\n    }\n\n    if (pt[1] < box[1]) {\n      box[1] = pt[1];\n      extentIndices[1] = ptIdx;\n    } else if (pt[1] > box[3]) {\n      box[3] = pt[1];\n      extentIndices[3] = ptIdx;\n    }\n  }\n}\n\n/**\n * Function called sequentially to calculate the centroid of a polygon\n * @param  {Point2d} centroidPt Current centroid point\n * @param  {Point2d} pt1        Point describing one end of an edge of a polygon\n * @param  {Point2d} pt2        Point describing other end of an edge of a polygon\n * @private\n */\nfunction buildCentroid(centroidPt, pt1, pt2) {\n  var a = pt1[0] * pt2[1] - pt2[0] * pt1[1];\n  centroidPt[0] += (pt1[0] + pt2[0]) * a;\n  centroidPt[1] += (pt1[1] + pt2[1]) * a;\n  return a;\n}\n\n/**\n * Utility function used to check whether an argument is an array\n * of an arraybuffer\n * @param  {}  obj\n * @return {Boolean}     Returns true if object is array-like\n */\nfunction isArray(obj) {\n  return Array.isArray(obj) || ArrayBuffer && ArrayBuffer.isView(obj);\n}\n\n/**\n * @typedef {object} PolyLineOptions\n * @property {number[]|Point2d[]} [verts=[]] Initial vertices of the polyline\n */\n\n/**\n * @class Class defining a poly line\n * @extends {BaseShape}\n */\n\nvar PolyLine = function (_BaseShape) {\n  _inherits(PolyLine, _BaseShape);\n\n  /**\n   * Creates a new poly line shape\n   * @param  {PolyLineOptions} [opts] [description]\n   * @return {PolyLine}\n   */\n  function PolyLine(opts) {\n    _classCallCheck(this, PolyLine);\n\n    var verts = opts.verts || [];\n\n    var _this = _possibleConstructorReturn(this, (PolyLine.__proto__ || Object.getPrototypeOf(PolyLine)).call(this, opts));\n\n    if (!isArray(verts) || verts.length === 0 || isArray(verts[0]) && verts.length < 1 || !isArray(verts[0]) && (verts.length < 2 || verts.length % 2 !== 0)) {\n      throw new Error(\"PolyLine shapes must be initialized with an array of 2d points and contain at least 1 points\");\n    }\n\n    // going to build the aabox and store the indices for each vertex\n    // that defines the bounds\n    _this._extentIndices = [-1, -1, -1, -1];\n    _this._localaabox = AABox2d.create();\n    _this._verts = [];\n    _this._centroid = [0, 0];\n    AABox2d.initEmpty(_this._aabox);\n    var signedArea = 0;\n    var i = 0;\n    if (isArray(verts[0])) {\n      for (i = 0; i < verts.length - 1; i += 1) {\n        _this._verts.push(Point2d.clone(verts[i]));\n        aaboxEncapsulatePt(_this._aabox, verts[i], i, _this._extentIndices);\n        signedArea += buildCentroid(_this._centroid, verts[i], verts[i + 1]);\n      }\n      _this._verts.push(Point2d.clone(verts[i]));\n      aaboxEncapsulatePt(_this._aabox, verts[i], i, _this._extentIndices);\n      signedArea += buildCentroid(_this._centroid, verts[i], verts[0]);\n    } else {\n      _this._verts.push(Point2d.create(verts[0], verts[1]));\n      aaboxEncapsulatePt(_this._aabox, _this._verts[0], 0, _this._extentIndices);\n      var idx = 1;\n      for (i = 2; i < verts.length - 2; i += 2, idx += 1) {\n        _this._verts.push(Point2d.create(verts[i], verts[i + 1]));\n        aaboxEncapsulatePt(_this._aabox, _this._verts[idx], idx, _this._extentIndices);\n        signedArea += buildCentroid(_this._centroid, _this._verts[idx - 1], _this._verts[idx]);\n      }\n      _this._verts.push(Point2d.create(verts[i], verts[i + 1]));\n      aaboxEncapsulatePt(_this._aabox, _this._verts[idx], idx, _this._extentIndices);\n      signedArea += buildCentroid(_this._centroid, _this._verts[idx], _this._verts[0]);\n    }\n    signedArea *= 0.5;\n    _this._centroid[0] /= 6.0 * signedArea;\n    _this._centroid[1] /= 6.0 * signedArea;\n\n    // extract the center of the aabox. We are going to use this as the\n    // shape's pivot, so all rotation/scale transformations will be sourced\n    // at this location\n    var pivot = Point2d.create();\n    AABox2d.getCenter(pivot, _this._aabox);\n    _this.pivot = pivot;\n\n    // now build the convex hull of the vertices.\n    // When rebuilding the axis aligned box (a transform is applied for example),\n    // there's no need to traverse all the points. All we need to do is traverse\n    // the points that define the convex hull to rebuild the bounds\n    if (_this._verts.length < 3) {\n      _this._convexHull = _this._verts.map(function (val, idx) {\n        return idx;\n      });\n    } else {\n      _this._convexHull = (0, _convexHull.simpleHull_2D)(_this._verts);\n    }\n    return _this;\n  }\n\n  /**\n   * Get the untransformed width/height of the polyline. This is essentially\n   * the width/height of the poly's bounds\n   * @return {Vec2d} Width/height of the bounds of the polyline\n   */\n\n\n  _createClass(PolyLine, [{\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return [this.width, this.height];\n    }\n\n    /**\n     * Get the untransformed width of the polyline. This is the width of the\n     * axis-aligned bounds of the poly\n     * @return {number} Width of the poly in world-space units\n     */\n\n  }, {\n    key: \"_collapseVerts\",\n\n\n    /**\n     * Utility function that collapses all the verts, meaning the verts\n     * are flattened to their position with local-space transforms applied\n     * and then the local transforms are cleared. This is done whenever\n     * the vertices of the polygon are modified as it can be a little tricky\n     * to re-adjust the pivot/transforms of the vert when new verts are added,\n     * deleted, etc.\n     * @return {boolean} Returns true if the points were indeed flattened\n     *                   The points wouldn't be flattened if there are no\n     *                   transforms to apply, for example\n     * @private\n     */\n    value: function _collapseVerts() {\n      var _this2 = this;\n\n      Point2d.set(this._pivot, 0, 0);\n\n      // TODO(croot): what if this poly is\n      // parented to another transform?\n\n      var xform = this.localXform;\n      if (_glMatrix.mat2d.equals(xform, identityMatrix)) {\n        // if there are no transforms to apply,\n        // do nothing - fast out\n        return false;\n      }\n\n      AABox2d.initEmpty(this._aabox);\n\n      // flatten all the points to their current world-space position\n      // with transforms applied\n      for (var i = 0; i < this._verts.length; i += 1) {\n        Point2d.transformMat2d(this._verts[i], this._verts[i], xform);\n      }\n\n      // now recalcute the convex hull of all the transformed points\n      if (this._verts.length < 3) {\n        this._convexHull = this._verts.map(function (val, idx) {\n          return idx;\n        });\n      } else {\n        this._convexHull = (0, _convexHull.simpleHull_2D)(this._verts);\n      }\n      // use the convex hull points to rebuild the bounds\n      this._convexHull.forEach(function (idx) {\n        aaboxEncapsulatePt(_this2._aabox, _this2._verts[idx], idx, _this2._extentIndices);\n      });\n\n      // reset the local transforms\n      this.setTransformations(0, 0, 1, 1, 0);\n\n      return true;\n    }\n\n    /**\n     * Translates a specific vertex of the polygon by an offset\n     * @param  {number} vertIndex Index of the vertex to translate\n     * @param  {Vec2d} t         Translation offset, in world-space units\n     * @return {PolyLine}           this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If vertIndex is invalid.\n     */\n\n  }, {\n    key: \"translateVert\",\n    value: function translateVert(vertIndex, t) {\n      if (vertIndex >= this._verts.length) {\n        throw new Error(\"Cannot translate vertex at index \" + vertIndex + \". There are only \" + this._verts.length + \" vertices in the polygon.\");\n      }\n\n      if (t[0] || t[1]) {\n        var prev = Point2d.clone(this._verts[vertIndex]);\n        var newPt = Point2d.clone(this._verts[vertIndex]);\n        Point2d.addVec2(newPt, newPt, t);\n\n        // TODO(croot): this could be made smarter by determining whether\n        // this point affects the convex hull or not by checking it's relationship\n        // with its neighbors\n        this._collapseVerts();\n        this._resetAABox = true;\n        this._geomDirty = true;\n        Point2d.copy(newPt);\n        this.fire(\"changed:geom\", {\n          attr: \"verts[\" + vertIndex + \"]\",\n          prevVal: prev,\n          currVal: newPt\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"setVertPosition\",\n    value: function setVertPosition(vertIndex, pos) {\n      if (vertIndex >= this._verts.length) {\n        throw new Error(\"Cannot translate vertex at index \" + vertIndex + \". There are only \" + this._verts.length + \" vertices in the polygon.\");\n      }\n\n      if (!Point2d.equals(pos, this._verts[vertIndex])) {\n        var prev = Point2d.clone(this._verts[vertIndex]);\n        this._collapseVerts();\n        Point2d.copy(this._verts[vertIndex], pos);\n\n        // TODO(croot): this could be made smarter by determining whether\n        // this point affects the convex hull or not by checking it's relationship\n        // with its neighbors\n        this._resetAABox = true;\n        this._geomDirty = true;\n        this.fire(\"changed:geom\", {\n          attr: \"verts[\" + vertIndex + \"]\",\n          prevVal: prev,\n          currVal: pos\n        });\n      }\n    }\n  }, {\n    key: \"insertVert\",\n    value: function insertVert(vertIndex, pos) {\n      var idx = _math2.default.min(_math2.default.max(vertIndex, 0), this._verts.length);\n      this._collapseVerts();\n      if (vertIndex >= this._verts.length) {\n        this._verts.push(Point2d.clone(pos));\n        idx = this._verts.length - 1;\n      } else {\n        this._verts.splice(vertIndex, 0, Point2d.clone(pos));\n      }\n      this._resetAABox = true;\n      this._geomDirty = true;\n\n      this.fire(\"changed:geom:addvert\", {\n        attr: \"verts[\" + idx + \"]\",\n        currVal: pos\n      });\n\n      return idx;\n    }\n  }, {\n    key: \"appendVert\",\n    value: function appendVert(pos) {\n      return this.insertVert(this._verts.length, pos);\n    }\n  }, {\n    key: \"removeVert\",\n    value: function removeVert(vertIndex) {\n      if (vertIndex >= this._verts.length || vertIndex < 0) {\n        throw new Error(\"Cannot remove vertex \" + vertIndex + \". Invalid index. There are only \" + this._verts.length + \" vertices in the shape.\");\n      }\n\n      var pos = this._verts[vertIndex];\n      this._verts.splice(vertIndex, 1);\n      this._collapseVerts();\n      this._resetAABox = true;\n      this._geomDirty = true;\n\n      this.fire(\"changed:geom:removevert\", {\n        attr: \"verts[\" + vertIndex + \"]\",\n        currVal: pos\n      });\n\n      return vertIndex;\n    }\n  }, {\n    key: \"_rebuildAABox\",\n    value: function _rebuildAABox() {\n      var _this3 = this;\n\n      AABox2d.initEmpty(this._aabox);\n      if (this._verts.length < 3) {\n        this._convexHull = this._verts.map(function (val, idx) {\n          return idx;\n        });\n      } else {\n        this._convexHull = (0, _convexHull.simpleHull_2D)(this._verts);\n      }\n      this._convexHull.forEach(function (idx) {\n        aaboxEncapsulatePt(_this3._aabox, _this3._verts[idx], idx, _this3._extentIndices);\n      });\n\n      var pivot = Point2d.create(0, 0);\n      AABox2d.getCenter(pivot, this._aabox);\n      this.pivot = pivot;\n    }\n  }, {\n    key: \"_updateAABox\",\n    value: function _updateAABox() {\n      var _this4 = this;\n\n      if (this._resetAABox) {\n        this._rebuildAABox();\n        this._resetAABox = false;\n      }\n\n      if (this._boundsOutOfDate || this._geomDirty) {\n        AABox2d.initEmpty(this._aabox);\n        var tmppt = [0, 0];\n        var xform = this.globalXform;\n        this._convexHull.forEach(function (idx) {\n          AABox2d.encapsulatePt(_this4._aabox, _this4._aabox, Point2d.transformMat2d(tmppt, _this4._verts[idx], xform));\n        });\n        this._boundsOutOfDate = false;\n\n        if (this._geomDirty) {\n          var pivot = Point2d.create();\n          pivot[0] = this._verts[this._extentIndices[0]][0] + 0.5 * (this._verts[this._extentIndices[2]][0] - this._verts[this._extentIndices[0]][0]);\n          pivot[1] = this._verts[this._extentIndices[1]][1] + 0.5 * (this._verts[this._extentIndices[3]][1] - this._verts[this._extentIndices[1]][1]);\n          this.pivot = pivot;\n          this._geomDirty = false;\n        }\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      var rtn = false;\n      if (this._verts.length >= 2) {\n        ctx.moveTo(this._verts[0][0], this._verts[0][1]);\n        for (var i = 1; i < this._verts.length; i += 1) {\n          ctx.lineTo(this._verts[i][0], this._verts[i][1]);\n        }\n        rtn = true;\n      }\n      return rtn;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"PolyLine\", // NOTE: this much match the name of the class\n        verts: this.vertsRef.map(function (vert) {\n          return [vert[0], vert[1]];\n        })\n      }, _get(PolyLine.prototype.__proto__ || Object.getPrototypeOf(PolyLine.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      this._updateAABox();\n      if (!this._verts.length || this._extentIndices[0] < 0 || this._extentIndices[2] < 0) {\n        return 0;\n      }\n\n      return this._verts[this._extentIndices[2]][0] - this._verts[this._extentIndices[0]][0];\n    }\n\n    /**\n     * Gets the untransformed height of the polyline. This is the height of the axis-aligned\n     * bounds of the poly\n     * @return {number} Height of the poly in world-space units\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      this._updateAABox();\n      if (!this._verts.length || this._extentIndices[0] < 0 || this._extentIndices[2] < 0) {\n        return 0;\n      }\n\n      return this._verts[this._extentIndices[3]][1] - this._verts[this._extentIndices[1]][1];\n    }\n\n    /**\n     * Gets a reference to the vertex array of the polyline\n     * @return {Point2d[]}\n     * @readOnly\n     */\n\n  }, {\n    key: \"vertsRef\",\n    get: function get() {\n      return this._verts;\n    }\n\n    /**\n     * Gets the number of vertices in the polyline\n     * @return {number}\n     */\n\n  }, {\n    key: \"numVerts\",\n    get: function get() {\n      return this._verts.length;\n    }\n  }]);\n\n  return PolyLine;\n}(_baseShape2.default);\n\nexports.default = PolyLine;\n\n\nPolyLine.aaboxEncapsulatePt = aaboxEncapsulatePt;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9seS1saW5lLmpzPzE4ZDQiXSwibmFtZXMiOlsiQUFCb3gyZCIsIlBvaW50MmQiLCJpZGVudGl0eU1hdHJpeCIsIk1hdDJkIiwiY3JlYXRlIiwiYWFib3hFbmNhcHN1bGF0ZVB0IiwiYm94IiwicHQiLCJwdElkeCIsImV4dGVudEluZGljZXMiLCJpc0VtcHR5IiwiYnVpbGRDZW50cm9pZCIsImNlbnRyb2lkUHQiLCJwdDEiLCJwdDIiLCJhIiwiaXNBcnJheSIsIm9iaiIsIkFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJQb2x5TGluZSIsIm9wdHMiLCJ2ZXJ0cyIsImxlbmd0aCIsIkVycm9yIiwiX2V4dGVudEluZGljZXMiLCJfbG9jYWxhYWJveCIsIl92ZXJ0cyIsIl9jZW50cm9pZCIsImluaXRFbXB0eSIsIl9hYWJveCIsInNpZ25lZEFyZWEiLCJpIiwicHVzaCIsImNsb25lIiwiaWR4IiwicGl2b3QiLCJnZXRDZW50ZXIiLCJfY29udmV4SHVsbCIsIm1hcCIsInZhbCIsIndpZHRoIiwiaGVpZ2h0Iiwic2V0IiwiX3Bpdm90IiwieGZvcm0iLCJsb2NhbFhmb3JtIiwiZXF1YWxzIiwidHJhbnNmb3JtTWF0MmQiLCJmb3JFYWNoIiwic2V0VHJhbnNmb3JtYXRpb25zIiwidmVydEluZGV4IiwidCIsInByZXYiLCJuZXdQdCIsImFkZFZlYzIiLCJfY29sbGFwc2VWZXJ0cyIsIl9yZXNldEFBQm94IiwiX2dlb21EaXJ0eSIsImNvcHkiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwicG9zIiwiTWF0aCIsIm1pbiIsIm1heCIsInNwbGljZSIsImluc2VydFZlcnQiLCJfcmVidWlsZEFBQm94IiwiX2JvdW5kc091dE9mRGF0ZSIsInRtcHB0IiwiZ2xvYmFsWGZvcm0iLCJlbmNhcHN1bGF0ZVB0IiwiY3R4IiwicnRuIiwibW92ZVRvIiwibGluZVRvIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsInZlcnRzUmVmIiwidmVydCIsIl91cGRhdGVBQUJveCIsIkJhc2VTaGFwZSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOztJQUFZQyxPOztBQUNaOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUMsaUJBQWlCQyxnQkFBTUMsTUFBTixFQUF2Qjs7QUFFQTs7Ozs7Ozs7Ozs7QUFXQSxTQUFTQyxrQkFBVCxDQUE0QkMsR0FBNUIsRUFBaUNDLEVBQWpDLEVBQXFDQyxLQUFyQyxFQUE0Q0MsYUFBNUMsRUFBMkQ7QUFDekQsTUFBSVQsUUFBUVUsT0FBUixDQUFnQkosR0FBaEIsQ0FBSixFQUEwQjtBQUN4QkEsUUFBSSxDQUFKLElBQVNDLEdBQUcsQ0FBSCxDQUFUO0FBQ0FELFFBQUksQ0FBSixJQUFTQyxHQUFHLENBQUgsQ0FBVDtBQUNBRSxrQkFBYyxDQUFkLElBQW1CQSxjQUFjLENBQWQsSUFBbUJELEtBQXRDO0FBQ0FGLFFBQUksQ0FBSixJQUFTQyxHQUFHLENBQUgsQ0FBVDtBQUNBRCxRQUFJLENBQUosSUFBU0MsR0FBRyxDQUFILENBQVQ7QUFDQUUsa0JBQWMsQ0FBZCxJQUFtQkEsY0FBYyxDQUFkLElBQW1CRCxLQUF0QztBQUNELEdBUEQsTUFPTztBQUNMLFFBQUlELEdBQUcsQ0FBSCxJQUFRRCxJQUFJLENBQUosQ0FBWixFQUFvQjtBQUNsQkEsVUFBSSxDQUFKLElBQVNDLEdBQUcsQ0FBSCxDQUFUO0FBQ0FFLG9CQUFjLENBQWQsSUFBbUJELEtBQW5CO0FBQ0QsS0FIRCxNQUdPLElBQUlELEdBQUcsQ0FBSCxJQUFRRCxJQUFJLENBQUosQ0FBWixFQUFvQjtBQUN6QkEsVUFBSSxDQUFKLElBQVNDLEdBQUcsQ0FBSCxDQUFUO0FBQ0FFLG9CQUFjLENBQWQsSUFBbUJELEtBQW5CO0FBQ0Q7O0FBRUQsUUFBSUQsR0FBRyxDQUFILElBQVFELElBQUksQ0FBSixDQUFaLEVBQW9CO0FBQ2xCQSxVQUFJLENBQUosSUFBU0MsR0FBRyxDQUFILENBQVQ7QUFDQUUsb0JBQWMsQ0FBZCxJQUFtQkQsS0FBbkI7QUFDRCxLQUhELE1BR08sSUFBSUQsR0FBRyxDQUFILElBQVFELElBQUksQ0FBSixDQUFaLEVBQW9CO0FBQ3pCQSxVQUFJLENBQUosSUFBU0MsR0FBRyxDQUFILENBQVQ7QUFDQUUsb0JBQWMsQ0FBZCxJQUFtQkQsS0FBbkI7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTRyxhQUFULENBQXVCQyxVQUF2QixFQUFtQ0MsR0FBbkMsRUFBd0NDLEdBQXhDLEVBQTZDO0FBQzNDLE1BQU1DLElBQUlGLElBQUksQ0FBSixJQUFTQyxJQUFJLENBQUosQ0FBVCxHQUFrQkEsSUFBSSxDQUFKLElBQVNELElBQUksQ0FBSixDQUFyQztBQUNBRCxhQUFXLENBQVgsS0FBaUIsQ0FBQ0MsSUFBSSxDQUFKLElBQVNDLElBQUksQ0FBSixDQUFWLElBQW9CQyxDQUFyQztBQUNBSCxhQUFXLENBQVgsS0FBaUIsQ0FBQ0MsSUFBSSxDQUFKLElBQVNDLElBQUksQ0FBSixDQUFWLElBQW9CQyxDQUFyQztBQUNBLFNBQU9BLENBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU0MsT0FBVCxDQUFpQkMsR0FBakIsRUFBc0I7QUFDcEIsU0FBT0MsTUFBTUYsT0FBTixDQUFjQyxHQUFkLEtBQXVCRSxlQUFlQSxZQUFZQyxNQUFaLENBQW1CSCxHQUFuQixDQUE3QztBQUNEOztBQUVEOzs7OztBQUtBOzs7OztJQUlxQkksUTs7O0FBRW5COzs7OztBQUtBLG9CQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQ2hCLFFBQU1DLFFBQVFELEtBQUtDLEtBQUwsSUFBYyxFQUE1Qjs7QUFEZ0Isb0hBRVZELElBRlU7O0FBR2hCLFFBQUksQ0FBQ04sUUFBUU8sS0FBUixDQUFELElBQ0ZBLE1BQU1DLE1BQU4sS0FBaUIsQ0FEZixJQUNxQlIsUUFBUU8sTUFBTSxDQUFOLENBQVIsS0FBcUJBLE1BQU1DLE1BQU4sR0FBZSxDQUR6RCxJQUVELENBQUNSLFFBQVFPLE1BQU0sQ0FBTixDQUFSLENBQUQsS0FBdUJBLE1BQU1DLE1BQU4sR0FBZSxDQUFmLElBQW9CRCxNQUFNQyxNQUFOLEdBQWUsQ0FBZixLQUFxQixDQUFoRSxDQUZILEVBRXdFO0FBQ3RFLFlBQU0sSUFBSUMsS0FBSixDQUFVLDhGQUFWLENBQU47QUFDRDs7QUFFRDtBQUNBO0FBQ0EsVUFBS0MsY0FBTCxHQUFzQixDQUFDLENBQUMsQ0FBRixFQUFLLENBQUMsQ0FBTixFQUFTLENBQUMsQ0FBVixFQUFhLENBQUMsQ0FBZCxDQUF0QjtBQUNBLFVBQUtDLFdBQUwsR0FBbUIzQixRQUFRSSxNQUFSLEVBQW5CO0FBQ0EsVUFBS3dCLE1BQUwsR0FBYyxFQUFkO0FBQ0EsVUFBS0MsU0FBTCxHQUFpQixDQUFDLENBQUQsRUFBSSxDQUFKLENBQWpCO0FBQ0E3QixZQUFROEIsU0FBUixDQUFrQixNQUFLQyxNQUF2QjtBQUNBLFFBQUlDLGFBQWEsQ0FBakI7QUFDQSxRQUFJQyxJQUFJLENBQVI7QUFDQSxRQUFJakIsUUFBUU8sTUFBTSxDQUFOLENBQVIsQ0FBSixFQUF1QjtBQUNyQixXQUFLVSxJQUFJLENBQVQsRUFBWUEsSUFBSVYsTUFBTUMsTUFBTixHQUFlLENBQS9CLEVBQWtDUyxLQUFLLENBQXZDLEVBQTBDO0FBQ3hDLGNBQUtMLE1BQUwsQ0FBWU0sSUFBWixDQUFpQmpDLFFBQVFrQyxLQUFSLENBQWNaLE1BQU1VLENBQU4sQ0FBZCxDQUFqQjtBQUNBNUIsMkJBQW1CLE1BQUswQixNQUF4QixFQUFnQ1IsTUFBTVUsQ0FBTixDQUFoQyxFQUEwQ0EsQ0FBMUMsRUFBNkMsTUFBS1AsY0FBbEQ7QUFDQU0sc0JBQWNyQixjQUFjLE1BQUtrQixTQUFuQixFQUE4Qk4sTUFBTVUsQ0FBTixDQUE5QixFQUF3Q1YsTUFBTVUsSUFBSSxDQUFWLENBQXhDLENBQWQ7QUFDRDtBQUNELFlBQUtMLE1BQUwsQ0FBWU0sSUFBWixDQUFpQmpDLFFBQVFrQyxLQUFSLENBQWNaLE1BQU1VLENBQU4sQ0FBZCxDQUFqQjtBQUNBNUIseUJBQW1CLE1BQUswQixNQUF4QixFQUFnQ1IsTUFBTVUsQ0FBTixDQUFoQyxFQUEwQ0EsQ0FBMUMsRUFBNkMsTUFBS1AsY0FBbEQ7QUFDQU0sb0JBQWNyQixjQUFjLE1BQUtrQixTQUFuQixFQUE4Qk4sTUFBTVUsQ0FBTixDQUE5QixFQUF3Q1YsTUFBTSxDQUFOLENBQXhDLENBQWQ7QUFDRCxLQVRELE1BU087QUFDTCxZQUFLSyxNQUFMLENBQVlNLElBQVosQ0FBaUJqQyxRQUFRRyxNQUFSLENBQWVtQixNQUFNLENBQU4sQ0FBZixFQUF5QkEsTUFBTSxDQUFOLENBQXpCLENBQWpCO0FBQ0FsQix5QkFBbUIsTUFBSzBCLE1BQXhCLEVBQWdDLE1BQUtILE1BQUwsQ0FBWSxDQUFaLENBQWhDLEVBQWdELENBQWhELEVBQW1ELE1BQUtGLGNBQXhEO0FBQ0EsVUFBSVUsTUFBTSxDQUFWO0FBQ0EsV0FBS0gsSUFBSSxDQUFULEVBQVlBLElBQUlWLE1BQU1DLE1BQU4sR0FBZSxDQUEvQixFQUFrQ1MsS0FBSyxDQUFMLEVBQVFHLE9BQU8sQ0FBakQsRUFBb0Q7QUFDbEQsY0FBS1IsTUFBTCxDQUFZTSxJQUFaLENBQWlCakMsUUFBUUcsTUFBUixDQUFlbUIsTUFBTVUsQ0FBTixDQUFmLEVBQXlCVixNQUFNVSxJQUFJLENBQVYsQ0FBekIsQ0FBakI7QUFDQTVCLDJCQUFtQixNQUFLMEIsTUFBeEIsRUFBZ0MsTUFBS0gsTUFBTCxDQUFZUSxHQUFaLENBQWhDLEVBQWtEQSxHQUFsRCxFQUF1RCxNQUFLVixjQUE1RDtBQUNBTSxzQkFBY3JCLGNBQWMsTUFBS2tCLFNBQW5CLEVBQThCLE1BQUtELE1BQUwsQ0FBWVEsTUFBTSxDQUFsQixDQUE5QixFQUFvRCxNQUFLUixNQUFMLENBQVlRLEdBQVosQ0FBcEQsQ0FBZDtBQUNEO0FBQ0QsWUFBS1IsTUFBTCxDQUFZTSxJQUFaLENBQWlCakMsUUFBUUcsTUFBUixDQUFlbUIsTUFBTVUsQ0FBTixDQUFmLEVBQXlCVixNQUFNVSxJQUFJLENBQVYsQ0FBekIsQ0FBakI7QUFDQTVCLHlCQUFtQixNQUFLMEIsTUFBeEIsRUFBZ0MsTUFBS0gsTUFBTCxDQUFZUSxHQUFaLENBQWhDLEVBQWtEQSxHQUFsRCxFQUF1RCxNQUFLVixjQUE1RDtBQUNBTSxvQkFBY3JCLGNBQWMsTUFBS2tCLFNBQW5CLEVBQThCLE1BQUtELE1BQUwsQ0FBWVEsR0FBWixDQUE5QixFQUFnRCxNQUFLUixNQUFMLENBQVksQ0FBWixDQUFoRCxDQUFkO0FBQ0Q7QUFDREksa0JBQWMsR0FBZDtBQUNBLFVBQUtILFNBQUwsQ0FBZSxDQUFmLEtBQXFCLE1BQU1HLFVBQTNCO0FBQ0EsVUFBS0gsU0FBTCxDQUFlLENBQWYsS0FBcUIsTUFBTUcsVUFBM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTUssUUFBUXBDLFFBQVFHLE1BQVIsRUFBZDtBQUNBSixZQUFRc0MsU0FBUixDQUFrQkQsS0FBbEIsRUFBeUIsTUFBS04sTUFBOUI7QUFDQSxVQUFLTSxLQUFMLEdBQWFBLEtBQWI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJLE1BQUtULE1BQUwsQ0FBWUosTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUMxQixZQUFLZSxXQUFMLEdBQW1CLE1BQUtYLE1BQUwsQ0FBWVksR0FBWixDQUFnQixVQUFDQyxHQUFELEVBQU1MLEdBQU47QUFBQSxlQUFjQSxHQUFkO0FBQUEsT0FBaEIsQ0FBbkI7QUFDRCxLQUZELE1BRU87QUFDTCxZQUFLRyxXQUFMLEdBQW1CLCtCQUFjLE1BQUtYLE1BQW5CLENBQW5CO0FBQ0Q7QUEzRGU7QUE0RGpCOztBQUVEOzs7Ozs7Ozs7b0NBS2dCO0FBQ2QsYUFBTyxDQUFDLEtBQUtjLEtBQU4sRUFBYSxLQUFLQyxNQUFsQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUE2Q0E7Ozs7Ozs7Ozs7OztxQ0FZaUI7QUFBQTs7QUFDZjFDLGNBQVEyQyxHQUFSLENBQVksS0FBS0MsTUFBakIsRUFBeUIsQ0FBekIsRUFBNEIsQ0FBNUI7O0FBRUE7QUFDQTs7QUFFQSxVQUFNQyxRQUFRLEtBQUtDLFVBQW5CO0FBQ0EsVUFBSTVDLGdCQUFNNkMsTUFBTixDQUFhRixLQUFiLEVBQW9CNUMsY0FBcEIsQ0FBSixFQUF5QztBQUN2QztBQUNBO0FBQ0EsZUFBTyxLQUFQO0FBQ0Q7O0FBRURGLGNBQVE4QixTQUFSLENBQWtCLEtBQUtDLE1BQXZCOztBQUVBO0FBQ0E7QUFDQSxXQUFLLElBQUlFLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLTCxNQUFMLENBQVlKLE1BQWhDLEVBQXdDUyxLQUFLLENBQTdDLEVBQWdEO0FBQzlDaEMsZ0JBQVFnRCxjQUFSLENBQXVCLEtBQUtyQixNQUFMLENBQVlLLENBQVosQ0FBdkIsRUFBdUMsS0FBS0wsTUFBTCxDQUFZSyxDQUFaLENBQXZDLEVBQXVEYSxLQUF2RDtBQUNEOztBQUVEO0FBQ0EsVUFBSSxLQUFLbEIsTUFBTCxDQUFZSixNQUFaLEdBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGFBQUtlLFdBQUwsR0FBbUIsS0FBS1gsTUFBTCxDQUFZWSxHQUFaLENBQWdCLFVBQUNDLEdBQUQsRUFBTUwsR0FBTjtBQUFBLGlCQUFjQSxHQUFkO0FBQUEsU0FBaEIsQ0FBbkI7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLRyxXQUFMLEdBQW1CLCtCQUFjLEtBQUtYLE1BQW5CLENBQW5CO0FBQ0Q7QUFDRDtBQUNBLFdBQUtXLFdBQUwsQ0FBaUJXLE9BQWpCLENBQXlCLGVBQU87QUFDOUI3QywyQkFBbUIsT0FBSzBCLE1BQXhCLEVBQWdDLE9BQUtILE1BQUwsQ0FBWVEsR0FBWixDQUFoQyxFQUFrREEsR0FBbEQsRUFBdUQsT0FBS1YsY0FBNUQ7QUFDRCxPQUZEOztBQUlBO0FBQ0EsV0FBS3lCLGtCQUFMLENBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLENBQTlCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDOztBQUVBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozs7Ozs7OztrQ0FRY0MsUyxFQUFXQyxDLEVBQUc7QUFDMUIsVUFBSUQsYUFBYSxLQUFLeEIsTUFBTCxDQUFZSixNQUE3QixFQUFxQztBQUNuQyxjQUFNLElBQUlDLEtBQUosdUNBQThDMkIsU0FBOUMseUJBQTJFLEtBQUt4QixNQUFMLENBQVlKLE1BQXZGLCtCQUFOO0FBQ0Q7O0FBRUQsVUFBSTZCLEVBQUUsQ0FBRixLQUFRQSxFQUFFLENBQUYsQ0FBWixFQUFrQjtBQUNoQixZQUFNQyxPQUFPckQsUUFBUWtDLEtBQVIsQ0FBYyxLQUFLUCxNQUFMLENBQVl3QixTQUFaLENBQWQsQ0FBYjtBQUNBLFlBQU1HLFFBQVF0RCxRQUFRa0MsS0FBUixDQUFjLEtBQUtQLE1BQUwsQ0FBWXdCLFNBQVosQ0FBZCxDQUFkO0FBQ0FuRCxnQkFBUXVELE9BQVIsQ0FBZ0JELEtBQWhCLEVBQXVCQSxLQUF2QixFQUE4QkYsQ0FBOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBS0ksY0FBTDtBQUNBLGFBQUtDLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxhQUFLQyxVQUFMLEdBQWtCLElBQWxCO0FBQ0ExRCxnQkFBUTJELElBQVIsQ0FBYUwsS0FBYjtBQUNBLGFBQUtNLElBQUwsQ0FBVSxjQUFWLEVBQTBCO0FBQ3hCQywyQkFBZVYsU0FBZixNQUR3QjtBQUV4QlcsbUJBQVNULElBRmU7QUFHeEJVLG1CQUFTVDtBQUhlLFNBQTFCO0FBS0Q7QUFDRCxhQUFPLElBQVA7QUFDRDs7O29DQUVlSCxTLEVBQVdhLEcsRUFBSztBQUM5QixVQUFJYixhQUFhLEtBQUt4QixNQUFMLENBQVlKLE1BQTdCLEVBQXFDO0FBQ25DLGNBQU0sSUFBSUMsS0FBSix1Q0FBOEMyQixTQUE5Qyx5QkFBMkUsS0FBS3hCLE1BQUwsQ0FBWUosTUFBdkYsK0JBQU47QUFDRDs7QUFFRCxVQUFJLENBQUN2QixRQUFRK0MsTUFBUixDQUFlaUIsR0FBZixFQUFvQixLQUFLckMsTUFBTCxDQUFZd0IsU0FBWixDQUFwQixDQUFMLEVBQWtEO0FBQ2hELFlBQU1FLE9BQU9yRCxRQUFRa0MsS0FBUixDQUFjLEtBQUtQLE1BQUwsQ0FBWXdCLFNBQVosQ0FBZCxDQUFiO0FBQ0EsYUFBS0ssY0FBTDtBQUNBeEQsZ0JBQVEyRCxJQUFSLENBQWEsS0FBS2hDLE1BQUwsQ0FBWXdCLFNBQVosQ0FBYixFQUFxQ2EsR0FBckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBS1AsV0FBTCxHQUFtQixJQUFuQjtBQUNBLGFBQUtDLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxhQUFLRSxJQUFMLENBQVUsY0FBVixFQUEwQjtBQUN4QkMsMkJBQWVWLFNBQWYsTUFEd0I7QUFFeEJXLG1CQUFTVCxJQUZlO0FBR3hCVSxtQkFBU0M7QUFIZSxTQUExQjtBQUtEO0FBQ0Y7OzsrQkFFVWIsUyxFQUFXYSxHLEVBQUs7QUFDekIsVUFBSTdCLE1BQU04QixlQUFLQyxHQUFMLENBQVNELGVBQUtFLEdBQUwsQ0FBU2hCLFNBQVQsRUFBb0IsQ0FBcEIsQ0FBVCxFQUFpQyxLQUFLeEIsTUFBTCxDQUFZSixNQUE3QyxDQUFWO0FBQ0EsV0FBS2lDLGNBQUw7QUFDQSxVQUFJTCxhQUFhLEtBQUt4QixNQUFMLENBQVlKLE1BQTdCLEVBQXFDO0FBQ25DLGFBQUtJLE1BQUwsQ0FBWU0sSUFBWixDQUFpQmpDLFFBQVFrQyxLQUFSLENBQWM4QixHQUFkLENBQWpCO0FBQ0E3QixjQUFNLEtBQUtSLE1BQUwsQ0FBWUosTUFBWixHQUFxQixDQUEzQjtBQUNELE9BSEQsTUFHTztBQUNMLGFBQUtJLE1BQUwsQ0FBWXlDLE1BQVosQ0FBbUJqQixTQUFuQixFQUE4QixDQUE5QixFQUFpQ25ELFFBQVFrQyxLQUFSLENBQWM4QixHQUFkLENBQWpDO0FBQ0Q7QUFDRCxXQUFLUCxXQUFMLEdBQW1CLElBQW5CO0FBQ0EsV0FBS0MsVUFBTCxHQUFrQixJQUFsQjs7QUFFQSxXQUFLRSxJQUFMLENBQVUsc0JBQVYsRUFBa0M7QUFDaENDLHlCQUFlMUIsR0FBZixNQURnQztBQUVoQzRCLGlCQUFTQztBQUZ1QixPQUFsQzs7QUFLQSxhQUFPN0IsR0FBUDtBQUNEOzs7K0JBRVU2QixHLEVBQUs7QUFDZCxhQUFPLEtBQUtLLFVBQUwsQ0FBZ0IsS0FBSzFDLE1BQUwsQ0FBWUosTUFBNUIsRUFBb0N5QyxHQUFwQyxDQUFQO0FBQ0Q7OzsrQkFFVWIsUyxFQUFXO0FBQ3BCLFVBQUlBLGFBQWEsS0FBS3hCLE1BQUwsQ0FBWUosTUFBekIsSUFBbUM0QixZQUFZLENBQW5ELEVBQXNEO0FBQ3BELGNBQU0sSUFBSTNCLEtBQUosMkJBQWtDMkIsU0FBbEMsd0NBQThFLEtBQUt4QixNQUFMLENBQVlKLE1BQTFGLDZCQUFOO0FBQ0Q7O0FBRUQsVUFBTXlDLE1BQU0sS0FBS3JDLE1BQUwsQ0FBWXdCLFNBQVosQ0FBWjtBQUNBLFdBQUt4QixNQUFMLENBQVl5QyxNQUFaLENBQW1CakIsU0FBbkIsRUFBOEIsQ0FBOUI7QUFDQSxXQUFLSyxjQUFMO0FBQ0EsV0FBS0MsV0FBTCxHQUFtQixJQUFuQjtBQUNBLFdBQUtDLFVBQUwsR0FBa0IsSUFBbEI7O0FBRUEsV0FBS0UsSUFBTCxDQUFVLHlCQUFWLEVBQXFDO0FBQ25DQyx5QkFBZVYsU0FBZixNQURtQztBQUVuQ1ksaUJBQVNDO0FBRjBCLE9BQXJDOztBQUtBLGFBQU9iLFNBQVA7QUFDRDs7O29DQUVlO0FBQUE7O0FBQ2RwRCxjQUFROEIsU0FBUixDQUFrQixLQUFLQyxNQUF2QjtBQUNBLFVBQUksS0FBS0gsTUFBTCxDQUFZSixNQUFaLEdBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGFBQUtlLFdBQUwsR0FBbUIsS0FBS1gsTUFBTCxDQUFZWSxHQUFaLENBQWdCLFVBQUNDLEdBQUQsRUFBTUwsR0FBTjtBQUFBLGlCQUFjQSxHQUFkO0FBQUEsU0FBaEIsQ0FBbkI7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFLRyxXQUFMLEdBQW1CLCtCQUFjLEtBQUtYLE1BQW5CLENBQW5CO0FBQ0Q7QUFDRCxXQUFLVyxXQUFMLENBQWlCVyxPQUFqQixDQUF5QixlQUFPO0FBQzlCN0MsMkJBQW1CLE9BQUswQixNQUF4QixFQUFnQyxPQUFLSCxNQUFMLENBQVlRLEdBQVosQ0FBaEMsRUFBa0RBLEdBQWxELEVBQXVELE9BQUtWLGNBQTVEO0FBQ0QsT0FGRDs7QUFJQSxVQUFNVyxRQUFRcEMsUUFBUUcsTUFBUixDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZDtBQUNBSixjQUFRc0MsU0FBUixDQUFrQkQsS0FBbEIsRUFBeUIsS0FBS04sTUFBOUI7QUFDQSxXQUFLTSxLQUFMLEdBQWFBLEtBQWI7QUFDRDs7O21DQUVjO0FBQUE7O0FBQ2IsVUFBSSxLQUFLcUIsV0FBVCxFQUFzQjtBQUNwQixhQUFLYSxhQUFMO0FBQ0EsYUFBS2IsV0FBTCxHQUFtQixLQUFuQjtBQUNEOztBQUVELFVBQUksS0FBS2MsZ0JBQUwsSUFBeUIsS0FBS2IsVUFBbEMsRUFBOEM7QUFDNUMzRCxnQkFBUThCLFNBQVIsQ0FBa0IsS0FBS0MsTUFBdkI7QUFDQSxZQUFNMEMsUUFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWQ7QUFDQSxZQUFNM0IsUUFBUSxLQUFLNEIsV0FBbkI7QUFDQSxhQUFLbkMsV0FBTCxDQUFpQlcsT0FBakIsQ0FBeUIsZUFBTztBQUM5QmxELGtCQUFRMkUsYUFBUixDQUFzQixPQUFLNUMsTUFBM0IsRUFBbUMsT0FBS0EsTUFBeEMsRUFBZ0Q5QixRQUFRZ0QsY0FBUixDQUF1QndCLEtBQXZCLEVBQThCLE9BQUs3QyxNQUFMLENBQVlRLEdBQVosQ0FBOUIsRUFBZ0RVLEtBQWhELENBQWhEO0FBQ0QsU0FGRDtBQUdBLGFBQUswQixnQkFBTCxHQUF3QixLQUF4Qjs7QUFFQSxZQUFJLEtBQUtiLFVBQVQsRUFBcUI7QUFDbkIsY0FBTXRCLFFBQVFwQyxRQUFRRyxNQUFSLEVBQWQ7QUFDQWlDLGdCQUFNLENBQU4sSUFBVyxLQUFLVCxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLElBQXlDLE9BQU8sS0FBS0UsTUFBTCxDQUFZLEtBQUtGLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBWixFQUFvQyxDQUFwQyxJQUF5QyxLQUFLRSxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLENBQWhELENBQXBEO0FBQ0FXLGdCQUFNLENBQU4sSUFBVyxLQUFLVCxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLElBQXlDLE9BQU8sS0FBS0UsTUFBTCxDQUFZLEtBQUtGLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBWixFQUFvQyxDQUFwQyxJQUF5QyxLQUFLRSxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLENBQWhELENBQXBEO0FBQ0EsZUFBS1csS0FBTCxHQUFhQSxLQUFiO0FBQ0EsZUFBS3NCLFVBQUwsR0FBa0IsS0FBbEI7QUFDRDtBQUNGO0FBQ0Y7OzswQkFFS2lCLEcsRUFBSztBQUNULFVBQUlDLE1BQU0sS0FBVjtBQUNBLFVBQUksS0FBS2pELE1BQUwsQ0FBWUosTUFBWixJQUFzQixDQUExQixFQUE2QjtBQUMzQm9ELFlBQUlFLE1BQUosQ0FBVyxLQUFLbEQsTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQVgsRUFBOEIsS0FBS0EsTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQTlCO0FBQ0EsYUFBSyxJQUFJSyxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS0wsTUFBTCxDQUFZSixNQUFoQyxFQUF3Q1MsS0FBSyxDQUE3QyxFQUFnRDtBQUM5QzJDLGNBQUlHLE1BQUosQ0FBVyxLQUFLbkQsTUFBTCxDQUFZSyxDQUFaLEVBQWUsQ0FBZixDQUFYLEVBQThCLEtBQUtMLE1BQUwsQ0FBWUssQ0FBWixFQUFlLENBQWYsQ0FBOUI7QUFDRDtBQUNENEMsY0FBTSxJQUFOO0FBQ0Q7QUFDRCxhQUFPQSxHQUFQO0FBQ0Q7Ozs2QkFFUTtBQUNQLGFBQU9HLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxVQURhLEVBQ0Q7QUFDbEIzRCxlQUFPLEtBQUs0RCxRQUFMLENBQWMzQyxHQUFkLENBQWtCO0FBQUEsaUJBQVEsQ0FBQzRDLEtBQUssQ0FBTCxDQUFELEVBQVVBLEtBQUssQ0FBTCxDQUFWLENBQVI7QUFBQSxTQUFsQjtBQUZZLE9BQWQsNkdBQVA7QUFJRDs7O3dCQXhQVztBQUNWLFdBQUtDLFlBQUw7QUFDQSxVQUFJLENBQUMsS0FBS3pELE1BQUwsQ0FBWUosTUFBYixJQUF1QixLQUFLRSxjQUFMLENBQW9CLENBQXBCLElBQXlCLENBQWhELElBQXFELEtBQUtBLGNBQUwsQ0FBb0IsQ0FBcEIsSUFBeUIsQ0FBbEYsRUFBcUY7QUFDbkYsZUFBTyxDQUFQO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLRSxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLElBQXlDLEtBQUtFLE1BQUwsQ0FBWSxLQUFLRixjQUFMLENBQW9CLENBQXBCLENBQVosRUFBb0MsQ0FBcEMsQ0FBaEQ7QUFDRDs7QUFFRDs7Ozs7Ozs7d0JBS2E7QUFDWCxXQUFLMkQsWUFBTDtBQUNBLFVBQUksQ0FBQyxLQUFLekQsTUFBTCxDQUFZSixNQUFiLElBQXVCLEtBQUtFLGNBQUwsQ0FBb0IsQ0FBcEIsSUFBeUIsQ0FBaEQsSUFBcUQsS0FBS0EsY0FBTCxDQUFvQixDQUFwQixJQUF5QixDQUFsRixFQUFxRjtBQUNuRixlQUFPLENBQVA7QUFDRDs7QUFFRCxhQUFPLEtBQUtFLE1BQUwsQ0FBWSxLQUFLRixjQUFMLENBQW9CLENBQXBCLENBQVosRUFBb0MsQ0FBcEMsSUFBeUMsS0FBS0UsTUFBTCxDQUFZLEtBQUtGLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBWixFQUFvQyxDQUFwQyxDQUFoRDtBQUNEOztBQUVEOzs7Ozs7Ozt3QkFLZTtBQUNiLGFBQU8sS0FBS0UsTUFBWjtBQUNEOztBQUVEOzs7Ozs7O3dCQUllO0FBQ2IsYUFBTyxLQUFLQSxNQUFMLENBQVlKLE1BQW5CO0FBQ0Q7Ozs7RUF6SG1DOEQsbUI7O2tCQUFqQmpFLFE7OztBQStVckJBLFNBQVNoQixrQkFBVCxHQUE4QkEsa0JBQTlCIiwiZmlsZSI6IjEwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tbWFnaWMtbnVtYmVycyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gXCIuL2Jhc2Utc2hhcGUuanNcIlxuaW1wb3J0IHttYXQyZCBhcyBNYXQyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcbmltcG9ydCB7c2ltcGxlSHVsbF8yRH0gZnJvbSBcIi4uL21hdGgvY29udmV4LWh1bGxcIlxuXG5jb25zdCBpZGVudGl0eU1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG5cbi8qKlxuICogRXhwYW5kcyBhbiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IHRvIGVuY2Fwc3VsYXRlIGEgMmQgdmVydGV4XG4gKiBkZWZpbmVkIGluIGFuIGFycmF5IG9mIHZlcnRpY2VzLCBhbmQgdXBkYXRlcyBhIHN0cnVjdCB1c2VkIHRvXG4gKiBzdG9yZSB0aGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXMgdGhhdCBkZWZpbmUgdGhlIGZpbmFsIGJvdW5kc1xuICogb2YgdGhlIHZlcnRpY2VzXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggICAgICAgICAgQm91bmRzIHRvIGV4cGFuZFxuICogQHBhcmFtICB7UG9pbnQyZH0gcHQgICAgICAgICAgIDJkIHZlcnRleCB0byBlbmNhcHN1bGF0ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwdElkeCAgICAgICAgIEluZGV4IG9mIHRoZSB2ZXJ0ZXggaW4gaXRzIGxpc3Qgb2YgdmVydGljZXNcbiAqIEBwYXJhbSAge251bWJlcltdfSBleHRlbnRJbmRpY2VzIFN0cnVjdCB0byBzdG9yZSB0aGUgaW5kaWNlcyBvZiB0aGUgYm91bmRpbmcgdmVydGljZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFhYm94RW5jYXBzdWxhdGVQdChib3gsIHB0LCBwdElkeCwgZXh0ZW50SW5kaWNlcykge1xuICBpZiAoQUFCb3gyZC5pc0VtcHR5KGJveCkpIHtcbiAgICBib3hbMF0gPSBwdFswXVxuICAgIGJveFsyXSA9IHB0WzBdXG4gICAgZXh0ZW50SW5kaWNlc1swXSA9IGV4dGVudEluZGljZXNbMl0gPSBwdElkeFxuICAgIGJveFsxXSA9IHB0WzFdXG4gICAgYm94WzNdID0gcHRbMV1cbiAgICBleHRlbnRJbmRpY2VzWzFdID0gZXh0ZW50SW5kaWNlc1szXSA9IHB0SWR4XG4gIH0gZWxzZSB7XG4gICAgaWYgKHB0WzBdIDwgYm94WzBdKSB7XG4gICAgICBib3hbMF0gPSBwdFswXVxuICAgICAgZXh0ZW50SW5kaWNlc1swXSA9IHB0SWR4XG4gICAgfSBlbHNlIGlmIChwdFswXSA+IGJveFsyXSkge1xuICAgICAgYm94WzJdID0gcHRbMF1cbiAgICAgIGV4dGVudEluZGljZXNbMl0gPSBwdElkeFxuICAgIH1cblxuICAgIGlmIChwdFsxXSA8IGJveFsxXSkge1xuICAgICAgYm94WzFdID0gcHRbMV1cbiAgICAgIGV4dGVudEluZGljZXNbMV0gPSBwdElkeFxuICAgIH0gZWxzZSBpZiAocHRbMV0gPiBib3hbM10pIHtcbiAgICAgIGJveFszXSA9IHB0WzFdXG4gICAgICBleHRlbnRJbmRpY2VzWzNdID0gcHRJZHhcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjYWxsZWQgc2VxdWVudGlhbGx5IHRvIGNhbGN1bGF0ZSB0aGUgY2VudHJvaWQgb2YgYSBwb2x5Z29uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBjZW50cm9pZFB0IEN1cnJlbnQgY2VudHJvaWQgcG9pbnRcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0MSAgICAgICAgUG9pbnQgZGVzY3JpYmluZyBvbmUgZW5kIG9mIGFuIGVkZ2Ugb2YgYSBwb2x5Z29uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdDIgICAgICAgIFBvaW50IGRlc2NyaWJpbmcgb3RoZXIgZW5kIG9mIGFuIGVkZ2Ugb2YgYSBwb2x5Z29uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBidWlsZENlbnRyb2lkKGNlbnRyb2lkUHQsIHB0MSwgcHQyKSB7XG4gIGNvbnN0IGEgPSBwdDFbMF0gKiBwdDJbMV0gLSBwdDJbMF0gKiBwdDFbMV1cbiAgY2VudHJvaWRQdFswXSArPSAocHQxWzBdICsgcHQyWzBdKSAqIGFcbiAgY2VudHJvaWRQdFsxXSArPSAocHQxWzFdICsgcHQyWzFdKSAqIGFcbiAgcmV0dXJuIGFcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgdG8gY2hlY2sgd2hldGhlciBhbiBhcmd1bWVudCBpcyBhbiBhcnJheVxuICogb2YgYW4gYXJyYXlidWZmZXJcbiAqIEBwYXJhbSAge30gIG9ialxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYXJyYXktbGlrZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8IChBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSlcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQb2x5TGluZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW118UG9pbnQyZFtdfSBbdmVydHM9W11dIEluaXRpYWwgdmVydGljZXMgb2YgdGhlIHBvbHlsaW5lXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQ2xhc3MgZGVmaW5pbmcgYSBwb2x5IGxpbmVcbiAqIEBleHRlbmRzIHtCYXNlU2hhcGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBvbHlMaW5lIGV4dGVuZHMgQmFzZVNoYXBlIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwb2x5IGxpbmUgc2hhcGVcbiAgICogQHBhcmFtICB7UG9seUxpbmVPcHRpb25zfSBbb3B0c10gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtQb2x5TGluZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBjb25zdCB2ZXJ0cyA9IG9wdHMudmVydHMgfHwgW11cbiAgICBzdXBlcihvcHRzKVxuICAgIGlmICghaXNBcnJheSh2ZXJ0cykgfHxcbiAgICAgIHZlcnRzLmxlbmd0aCA9PT0gMCB8fCAoaXNBcnJheSh2ZXJ0c1swXSkgJiYgdmVydHMubGVuZ3RoIDwgMSkgfHxcbiAgICAgICghaXNBcnJheSh2ZXJ0c1swXSkgJiYgKHZlcnRzLmxlbmd0aCA8IDIgfHwgdmVydHMubGVuZ3RoICUgMiAhPT0gMCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5TGluZSBzaGFwZXMgbXVzdCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGFycmF5IG9mIDJkIHBvaW50cyBhbmQgY29udGFpbiBhdCBsZWFzdCAxIHBvaW50c1wiKVxuICAgIH1cblxuICAgIC8vIGdvaW5nIHRvIGJ1aWxkIHRoZSBhYWJveCBhbmQgc3RvcmUgdGhlIGluZGljZXMgZm9yIGVhY2ggdmVydGV4XG4gICAgLy8gdGhhdCBkZWZpbmVzIHRoZSBib3VuZHNcbiAgICB0aGlzLl9leHRlbnRJbmRpY2VzID0gWy0xLCAtMSwgLTEsIC0xXVxuICAgIHRoaXMuX2xvY2FsYWFib3ggPSBBQUJveDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fdmVydHMgPSBbXVxuICAgIHRoaXMuX2NlbnRyb2lkID0gWzAsIDBdXG4gICAgQUFCb3gyZC5pbml0RW1wdHkodGhpcy5fYWFib3gpXG4gICAgbGV0IHNpZ25lZEFyZWEgPSAwXG4gICAgbGV0IGkgPSAwXG4gICAgaWYgKGlzQXJyYXkodmVydHNbMF0pKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jbG9uZSh2ZXJ0c1tpXSkpXG4gICAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdmVydHNbaV0sIGksIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICAgIHNpZ25lZEFyZWEgKz0gYnVpbGRDZW50cm9pZCh0aGlzLl9jZW50cm9pZCwgdmVydHNbaV0sIHZlcnRzW2kgKyAxXSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jbG9uZSh2ZXJ0c1tpXSkpXG4gICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHZlcnRzW2ldLCBpLCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgICAgc2lnbmVkQXJlYSArPSBidWlsZENlbnRyb2lkKHRoaXMuX2NlbnRyb2lkLCB2ZXJ0c1tpXSwgdmVydHNbMF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jcmVhdGUodmVydHNbMF0sIHZlcnRzWzFdKSlcbiAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdGhpcy5fdmVydHNbMF0sIDAsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICBsZXQgaWR4ID0gMVxuICAgICAgZm9yIChpID0gMjsgaSA8IHZlcnRzLmxlbmd0aCAtIDI7IGkgKz0gMiwgaWR4ICs9IDEpIHtcbiAgICAgICAgdGhpcy5fdmVydHMucHVzaChQb2ludDJkLmNyZWF0ZSh2ZXJ0c1tpXSwgdmVydHNbaSArIDFdKSlcbiAgICAgICAgYWFib3hFbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB0aGlzLl92ZXJ0c1tpZHhdLCBpZHgsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICAgIHNpZ25lZEFyZWEgKz0gYnVpbGRDZW50cm9pZCh0aGlzLl9jZW50cm9pZCwgdGhpcy5fdmVydHNbaWR4IC0gMV0sIHRoaXMuX3ZlcnRzW2lkeF0pXG4gICAgICB9XG4gICAgICB0aGlzLl92ZXJ0cy5wdXNoKFBvaW50MmQuY3JlYXRlKHZlcnRzW2ldLCB2ZXJ0c1tpICsgMV0pKVxuICAgICAgYWFib3hFbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB0aGlzLl92ZXJ0c1tpZHhdLCBpZHgsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgICBzaWduZWRBcmVhICs9IGJ1aWxkQ2VudHJvaWQodGhpcy5fY2VudHJvaWQsIHRoaXMuX3ZlcnRzW2lkeF0sIHRoaXMuX3ZlcnRzWzBdKVxuICAgIH1cbiAgICBzaWduZWRBcmVhICo9IDAuNVxuICAgIHRoaXMuX2NlbnRyb2lkWzBdIC89IDYuMCAqIHNpZ25lZEFyZWFcbiAgICB0aGlzLl9jZW50cm9pZFsxXSAvPSA2LjAgKiBzaWduZWRBcmVhXG5cbiAgICAvLyBleHRyYWN0IHRoZSBjZW50ZXIgb2YgdGhlIGFhYm94LiBXZSBhcmUgZ29pbmcgdG8gdXNlIHRoaXMgYXMgdGhlXG4gICAgLy8gc2hhcGUncyBwaXZvdCwgc28gYWxsIHJvdGF0aW9uL3NjYWxlIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIHNvdXJjZWRcbiAgICAvLyBhdCB0aGlzIGxvY2F0aW9uXG4gICAgY29uc3QgcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgpXG4gICAgQUFCb3gyZC5nZXRDZW50ZXIocGl2b3QsIHRoaXMuX2FhYm94KVxuICAgIHRoaXMucGl2b3QgPSBwaXZvdFxuXG4gICAgLy8gbm93IGJ1aWxkIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgdmVydGljZXMuXG4gICAgLy8gV2hlbiByZWJ1aWxkaW5nIHRoZSBheGlzIGFsaWduZWQgYm94IChhIHRyYW5zZm9ybSBpcyBhcHBsaWVkIGZvciBleGFtcGxlKSxcbiAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gdHJhdmVyc2UgYWxsIHRoZSBwb2ludHMuIEFsbCB3ZSBuZWVkIHRvIGRvIGlzIHRyYXZlcnNlXG4gICAgLy8gdGhlIHBvaW50cyB0aGF0IGRlZmluZSB0aGUgY29udmV4IGh1bGwgdG8gcmVidWlsZCB0aGUgYm91bmRzXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSB0aGlzLl92ZXJ0cy5tYXAoKHZhbCwgaWR4KSA9PiBpZHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSBzaW1wbGVIdWxsXzJEKHRoaXMuX3ZlcnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGgvaGVpZ2h0IG9mIHRoZSBwb2x5bGluZS4gVGhpcyBpcyBlc3NlbnRpYWxseVxuICAgKiB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSBwb2x5J3MgYm91bmRzXG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9oZWlnaHQgb2YgdGhlIGJvdW5kcyBvZiB0aGUgcG9seWxpbmVcbiAgICovXG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLndpZHRoLCB0aGlzLmhlaWdodF1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHBvbHlsaW5lLiBUaGlzIGlzIHRoZSB3aWR0aCBvZiB0aGVcbiAgICogYXhpcy1hbGlnbmVkIGJvdW5kcyBvZiB0aGUgcG9seVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFdpZHRoIG9mIHRoZSBwb2x5IGluIHdvcmxkLXNwYWNlIHVuaXRzXG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgdGhpcy5fdXBkYXRlQUFCb3goKVxuICAgIGlmICghdGhpcy5fdmVydHMubGVuZ3RoIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMF0gPCAwIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMl0gPCAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzJdXVswXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMF1dWzBdXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW50cmFuc2Zvcm1lZCBoZWlnaHQgb2YgdGhlIHBvbHlsaW5lLiBUaGlzIGlzIHRoZSBoZWlnaHQgb2YgdGhlIGF4aXMtYWxpZ25lZFxuICAgKiBib3VuZHMgb2YgdGhlIHBvbHlcbiAgICogQHJldHVybiB7bnVtYmVyfSBIZWlnaHQgb2YgdGhlIHBvbHkgaW4gd29ybGQtc3BhY2UgdW5pdHNcbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgdGhpcy5fdXBkYXRlQUFCb3goKVxuICAgIGlmICghdGhpcy5fdmVydHMubGVuZ3RoIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMF0gPCAwIHx8IHRoaXMuX2V4dGVudEluZGljZXNbMl0gPCAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzNdXVsxXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMV1dWzFdXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgdmVydGV4IGFycmF5IG9mIHRoZSBwb2x5bGluZVxuICAgKiBAcmV0dXJuIHtQb2ludDJkW119XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0IHZlcnRzUmVmKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJ0c1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBpbiB0aGUgcG9seWxpbmVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IG51bVZlcnRzKCkge1xuICAgIHJldHVybiB0aGlzLl92ZXJ0cy5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgY29sbGFwc2VzIGFsbCB0aGUgdmVydHMsIG1lYW5pbmcgdGhlIHZlcnRzXG4gICAqIGFyZSBmbGF0dGVuZWQgdG8gdGhlaXIgcG9zaXRpb24gd2l0aCBsb2NhbC1zcGFjZSB0cmFuc2Zvcm1zIGFwcGxpZWRcbiAgICogYW5kIHRoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybXMgYXJlIGNsZWFyZWQuIFRoaXMgaXMgZG9uZSB3aGVuZXZlclxuICAgKiB0aGUgdmVydGljZXMgb2YgdGhlIHBvbHlnb24gYXJlIG1vZGlmaWVkIGFzIGl0IGNhbiBiZSBhIGxpdHRsZSB0cmlja3lcbiAgICogdG8gcmUtYWRqdXN0IHRoZSBwaXZvdC90cmFuc2Zvcm1zIG9mIHRoZSB2ZXJ0IHdoZW4gbmV3IHZlcnRzIGFyZSBhZGRlZCxcbiAgICogZGVsZXRlZCwgZXRjLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50cyB3ZXJlIGluZGVlZCBmbGF0dGVuZWRcbiAgICogICAgICAgICAgICAgICAgICAgVGhlIHBvaW50cyB3b3VsZG4ndCBiZSBmbGF0dGVuZWQgaWYgdGhlcmUgYXJlIG5vXG4gICAqICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybXMgdG8gYXBwbHksIGZvciBleGFtcGxlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29sbGFwc2VWZXJ0cygpIHtcbiAgICBQb2ludDJkLnNldCh0aGlzLl9waXZvdCwgMCwgMClcblxuICAgIC8vIFRPRE8oY3Jvb3QpOiB3aGF0IGlmIHRoaXMgcG9seSBpc1xuICAgIC8vIHBhcmVudGVkIHRvIGFub3RoZXIgdHJhbnNmb3JtP1xuXG4gICAgY29uc3QgeGZvcm0gPSB0aGlzLmxvY2FsWGZvcm1cbiAgICBpZiAoTWF0MmQuZXF1YWxzKHhmb3JtLCBpZGVudGl0eU1hdHJpeCkpIHtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0cmFuc2Zvcm1zIHRvIGFwcGx5LFxuICAgICAgLy8gZG8gbm90aGluZyAtIGZhc3Qgb3V0XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBBQUJveDJkLmluaXRFbXB0eSh0aGlzLl9hYWJveClcblxuICAgIC8vIGZsYXR0ZW4gYWxsIHRoZSBwb2ludHMgdG8gdGhlaXIgY3VycmVudCB3b3JsZC1zcGFjZSBwb3NpdGlvblxuICAgIC8vIHdpdGggdHJhbnNmb3JtcyBhcHBsaWVkXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl92ZXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl92ZXJ0c1tpXSwgdGhpcy5fdmVydHNbaV0sIHhmb3JtKVxuICAgIH1cblxuICAgIC8vIG5vdyByZWNhbGN1dGUgdGhlIGNvbnZleCBodWxsIG9mIGFsbCB0aGUgdHJhbnNmb3JtZWQgcG9pbnRzXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSB0aGlzLl92ZXJ0cy5tYXAoKHZhbCwgaWR4KSA9PiBpZHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NvbnZleEh1bGwgPSBzaW1wbGVIdWxsXzJEKHRoaXMuX3ZlcnRzKVxuICAgIH1cbiAgICAvLyB1c2UgdGhlIGNvbnZleCBodWxsIHBvaW50cyB0byByZWJ1aWxkIHRoZSBib3VuZHNcbiAgICB0aGlzLl9jb252ZXhIdWxsLmZvckVhY2goaWR4ID0+IHtcbiAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdGhpcy5fdmVydHNbaWR4XSwgaWR4LCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgIH0pXG5cbiAgICAvLyByZXNldCB0aGUgbG9jYWwgdHJhbnNmb3Jtc1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtYXRpb25zKDAsIDAsIDEsIDEsIDApXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgYSBzcGVjaWZpYyB2ZXJ0ZXggb2YgdGhlIHBvbHlnb24gYnkgYW4gb2Zmc2V0XG4gICAqIEBwYXJhbSAge251bWJlcn0gdmVydEluZGV4IEluZGV4IG9mIHRoZSB2ZXJ0ZXggdG8gdHJhbnNsYXRlXG4gICAqIEBwYXJhbSAge1ZlYzJkfSB0ICAgICAgICAgVHJhbnNsYXRpb24gb2Zmc2V0LCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKiBAcmV0dXJuIHtQb2x5TGluZX0gICAgICAgICAgIHRoaXNcbiAgICogQGZpcmVzIHtTaGFwZSNnZW9tQ2hhbmdlZH1cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHZlcnRJbmRleCBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdHJhbnNsYXRlVmVydCh2ZXJ0SW5kZXgsIHQpIHtcbiAgICBpZiAodmVydEluZGV4ID49IHRoaXMuX3ZlcnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgdHJhbnNsYXRlIHZlcnRleCBhdCBpbmRleCAke3ZlcnRJbmRleH0uIFRoZXJlIGFyZSBvbmx5ICR7dGhpcy5fdmVydHMubGVuZ3RofSB2ZXJ0aWNlcyBpbiB0aGUgcG9seWdvbi5gKVxuICAgIH1cblxuICAgIGlmICh0WzBdIHx8IHRbMV0pIHtcbiAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3ZlcnRzW3ZlcnRJbmRleF0pXG4gICAgICBjb25zdCBuZXdQdCA9IFBvaW50MmQuY2xvbmUodGhpcy5fdmVydHNbdmVydEluZGV4XSlcbiAgICAgIFBvaW50MmQuYWRkVmVjMihuZXdQdCwgbmV3UHQsIHQpXG5cbiAgICAgIC8vIFRPRE8oY3Jvb3QpOiB0aGlzIGNvdWxkIGJlIG1hZGUgc21hcnRlciBieSBkZXRlcm1pbmluZyB3aGV0aGVyXG4gICAgICAvLyB0aGlzIHBvaW50IGFmZmVjdHMgdGhlIGNvbnZleCBodWxsIG9yIG5vdCBieSBjaGVja2luZyBpdCdzIHJlbGF0aW9uc2hpcFxuICAgICAgLy8gd2l0aCBpdHMgbmVpZ2hib3JzXG4gICAgICB0aGlzLl9jb2xsYXBzZVZlcnRzKClcbiAgICAgIHRoaXMuX3Jlc2V0QUFCb3ggPSB0cnVlXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlXG4gICAgICBQb2ludDJkLmNvcHkobmV3UHQpXG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOmdlb21cIiwge1xuICAgICAgICBhdHRyOiBgdmVydHNbJHt2ZXJ0SW5kZXh9XWAsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IG5ld1B0XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc2V0VmVydFBvc2l0aW9uKHZlcnRJbmRleCwgcG9zKSB7XG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHRyYW5zbGF0ZSB2ZXJ0ZXggYXQgaW5kZXggJHt2ZXJ0SW5kZXh9LiBUaGVyZSBhcmUgb25seSAke3RoaXMuX3ZlcnRzLmxlbmd0aH0gdmVydGljZXMgaW4gdGhlIHBvbHlnb24uYClcbiAgICB9XG5cbiAgICBpZiAoIVBvaW50MmQuZXF1YWxzKHBvcywgdGhpcy5fdmVydHNbdmVydEluZGV4XSkpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3ZlcnRzW3ZlcnRJbmRleF0pXG4gICAgICB0aGlzLl9jb2xsYXBzZVZlcnRzKClcbiAgICAgIFBvaW50MmQuY29weSh0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXhdLCBwb3MpXG5cbiAgICAgIC8vIFRPRE8oY3Jvb3QpOiB0aGlzIGNvdWxkIGJlIG1hZGUgc21hcnRlciBieSBkZXRlcm1pbmluZyB3aGV0aGVyXG4gICAgICAvLyB0aGlzIHBvaW50IGFmZmVjdHMgdGhlIGNvbnZleCBodWxsIG9yIG5vdCBieSBjaGVja2luZyBpdCdzIHJlbGF0aW9uc2hpcFxuICAgICAgLy8gd2l0aCBpdHMgbmVpZ2hib3JzXG4gICAgICB0aGlzLl9yZXNldEFBQm94ID0gdHJ1ZVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdHJ1ZVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tXCIsIHtcbiAgICAgICAgYXR0cjogYHZlcnRzWyR7dmVydEluZGV4fV1gLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiBwb3NcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgaW5zZXJ0VmVydCh2ZXJ0SW5kZXgsIHBvcykge1xuICAgIGxldCBpZHggPSBNYXRoLm1pbihNYXRoLm1heCh2ZXJ0SW5kZXgsIDApLCB0aGlzLl92ZXJ0cy5sZW5ndGgpXG4gICAgdGhpcy5fY29sbGFwc2VWZXJ0cygpXG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jbG9uZShwb3MpKVxuICAgICAgaWR4ID0gdGhpcy5fdmVydHMubGVuZ3RoIC0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92ZXJ0cy5zcGxpY2UodmVydEluZGV4LCAwLCBQb2ludDJkLmNsb25lKHBvcykpXG4gICAgfVxuICAgIHRoaXMuX3Jlc2V0QUFCb3ggPSB0cnVlXG4gICAgdGhpcy5fZ2VvbURpcnR5ID0gdHJ1ZVxuXG4gICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tOmFkZHZlcnRcIiwge1xuICAgICAgYXR0cjogYHZlcnRzWyR7aWR4fV1gLFxuICAgICAgY3VyclZhbDogcG9zXG4gICAgfSlcblxuICAgIHJldHVybiBpZHhcbiAgfVxuXG4gIGFwcGVuZFZlcnQocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0VmVydCh0aGlzLl92ZXJ0cy5sZW5ndGgsIHBvcylcbiAgfVxuXG4gIHJlbW92ZVZlcnQodmVydEluZGV4KSB7XG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGggfHwgdmVydEluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVtb3ZlIHZlcnRleCAke3ZlcnRJbmRleH0uIEludmFsaWQgaW5kZXguIFRoZXJlIGFyZSBvbmx5ICR7dGhpcy5fdmVydHMubGVuZ3RofSB2ZXJ0aWNlcyBpbiB0aGUgc2hhcGUuYClcbiAgICB9XG5cbiAgICBjb25zdCBwb3MgPSB0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXhdXG4gICAgdGhpcy5fdmVydHMuc3BsaWNlKHZlcnRJbmRleCwgMSlcbiAgICB0aGlzLl9jb2xsYXBzZVZlcnRzKClcbiAgICB0aGlzLl9yZXNldEFBQm94ID0gdHJ1ZVxuICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWVcblxuICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbTpyZW1vdmV2ZXJ0XCIsIHtcbiAgICAgIGF0dHI6IGB2ZXJ0c1ske3ZlcnRJbmRleH1dYCxcbiAgICAgIGN1cnJWYWw6IHBvc1xuICAgIH0pXG5cbiAgICByZXR1cm4gdmVydEluZGV4XG4gIH1cblxuICBfcmVidWlsZEFBQm94KCkge1xuICAgIEFBQm94MmQuaW5pdEVtcHR5KHRoaXMuX2FhYm94KVxuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gdGhpcy5fdmVydHMubWFwKCh2YWwsIGlkeCkgPT4gaWR4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gc2ltcGxlSHVsbF8yRCh0aGlzLl92ZXJ0cylcbiAgICB9XG4gICAgdGhpcy5fY29udmV4SHVsbC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHRoaXMuX3ZlcnRzW2lkeF0sIGlkeCwgdGhpcy5fZXh0ZW50SW5kaWNlcylcbiAgICB9KVxuXG4gICAgY29uc3QgcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuICAgIEFBQm94MmQuZ2V0Q2VudGVyKHBpdm90LCB0aGlzLl9hYWJveClcbiAgICB0aGlzLnBpdm90ID0gcGl2b3RcbiAgfVxuXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fcmVzZXRBQUJveCkge1xuICAgICAgdGhpcy5fcmVidWlsZEFBQm94KClcbiAgICAgIHRoaXMuX3Jlc2V0QUFCb3ggPSBmYWxzZVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ib3VuZHNPdXRPZkRhdGUgfHwgdGhpcy5fZ2VvbURpcnR5KSB7XG4gICAgICBBQUJveDJkLmluaXRFbXB0eSh0aGlzLl9hYWJveClcbiAgICAgIGNvbnN0IHRtcHB0ID0gWzAsIDBdXG4gICAgICBjb25zdCB4Zm9ybSA9IHRoaXMuZ2xvYmFsWGZvcm1cbiAgICAgIHRoaXMuX2NvbnZleEh1bGwuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICBBQUJveDJkLmVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHRoaXMuX2FhYm94LCBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcHB0LCB0aGlzLl92ZXJ0c1tpZHhdLCB4Zm9ybSkpXG4gICAgICB9KVxuICAgICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcblxuICAgICAgaWYgKHRoaXMuX2dlb21EaXJ0eSkge1xuICAgICAgICBjb25zdCBwaXZvdCA9IFBvaW50MmQuY3JlYXRlKClcbiAgICAgICAgcGl2b3RbMF0gPSB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzBdXVswXSArIDAuNSAqICh0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzJdXVswXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMF1dWzBdKVxuICAgICAgICBwaXZvdFsxXSA9IHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMV1dWzFdICsgMC41ICogKHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbM11dWzFdIC0gdGhpcy5fdmVydHNbdGhpcy5fZXh0ZW50SW5kaWNlc1sxXV1bMV0pXG4gICAgICAgIHRoaXMucGl2b3QgPSBwaXZvdFxuICAgICAgICB0aGlzLl9nZW9tRGlydHkgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9kcmF3KGN0eCkge1xuICAgIGxldCBydG4gPSBmYWxzZVxuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPj0gMikge1xuICAgICAgY3R4Lm1vdmVUbyh0aGlzLl92ZXJ0c1swXVswXSwgdGhpcy5fdmVydHNbMF1bMV0pXG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX3ZlcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGN0eC5saW5lVG8odGhpcy5fdmVydHNbaV1bMF0sIHRoaXMuX3ZlcnRzW2ldWzFdKVxuICAgICAgfVxuICAgICAgcnRuID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcnRuXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogXCJQb2x5TGluZVwiLCAvLyBOT1RFOiB0aGlzIG11Y2ggbWF0Y2ggdGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgICB2ZXJ0czogdGhpcy52ZXJ0c1JlZi5tYXAodmVydCA9PiBbdmVydFswXSwgdmVydFsxXV0pXG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cblxufVxuXG5Qb2x5TGluZS5hYWJveEVuY2Fwc3VsYXRlUHQgPSBhYWJveEVuY2Fwc3VsYXRlUHRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9wb2x5LWxpbmUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.buildXformMatrix = buildXformMatrix;\nexports.createEventedTransform2dMixin = createEventedTransform2dMixin;\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _aggregation = __webpack_require__(7);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Builds a 2D transformation matrix (2x3 matrix) from a rotation (in degrees),\n * an x,y scale, a translation, and a pivot (an offset from the origin to\n * apply the transformation around)\n * @param  {Mat2d} mat   Matrix to store the result of the operation\n * @param  {number} rdeg  rotation, in degrees\n * @param  {Vec2d} s     Scale vector, in x & y\n * @param  {Vec2d} t     Translation vector, in x & y\n * @param  {Vec2d} pivot Offset from origin to apply the transformation\n * @return {Mat2d}       Matrix referenced by the mat argument\n */\nfunction buildXformMatrix(mat, rdeg, s, t, pivot) {\n  _glMatrix.mat2d.identity(mat);\n  _glMatrix.mat2d.translate(mat, mat, [t[0] + pivot[0], t[1] + pivot[1]]);\n  _glMatrix.mat2d.rotate(mat, mat, _math2.default.DEG_TO_RAD * rdeg);\n  _glMatrix.mat2d.scale(mat, mat, s);\n  _glMatrix.mat2d.translate(mat, mat, [-pivot[0], -pivot[1]]);\n  return mat;\n}\n\n/**\n * Utility function to dirty all the descendants of a transform node.\n * This is called when a transform node has been modified in some way\n * that it's children need to be notified about.\n * @param  {Transform2d[]} children\n */\nfunction dirtyChildren(children) {\n  children.forEach(function (child) {\n    child._xformDirty = true;\n    dirtyChildren(child._children);\n  });\n}\n\n/**\n * @typedef {object} Transform2dOptions\n * @property {Point2d} [position = [0,0]] Position in world space coords\n * @property {Vec2d} [scale = [1,1]] Scale in world space coords\n * @property {number} [rotation = 0] Rotation in degrees\n * @property {Vec2d} [pivot = [0, 0]] Offset from origin to apply the setTransformations\n */\n\n/**\n * @class Class to manage basic 2d affine transformations\n * @mixin Can also be used as a mixin\n */\n\nvar Transform2d = function () {\n  /**\n   * Creates a new Transform2d\n   * @param  {Transform2dOptions} [opts]\n   * @return {Transform2d}\n   */\n  function Transform2d(opts) {\n    _classCallCheck(this, Transform2d);\n\n    this.initializer(opts);\n  }\n\n  /**\n   * Initializes a transform 2d object from options\n   * @param  {Transform2dOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(Transform2d, [{\n    key: \"_initTransformFromOptions\",\n    value: function _initTransformFromOptions(opts) {\n      if (!opts) {\n        return;\n      }\n\n      if (typeof opts.position !== \"undefined\") {\n        this.setPosition(opts.position);\n      }\n\n      if (typeof opts.scale !== \"undefined\") {\n        this.setScale(opts.scale);\n      }\n\n      if (typeof opts.rotation !== \"undefined\") {\n        this.setRotation(opts.rotation);\n      }\n\n      if (typeof opts.pivot !== \"undefined\") {\n        this.pivot = opts.pivot;\n      }\n    }\n\n    /**\n     * Initializes a transform 2d object from options,\n     * called from either constructor (if used as base class)\n     * or base mixin class (if used as a mixin)\n     * @param  {Transform2dOptions} [opts]\n     * @protected\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._localXform = _glMatrix.mat2d.create();\n      this._lxformDirty = false;\n\n      this._pivot = Point2d.create(0, 0);\n\n      this._pos = Point2d.create(0, 0);\n      this._scale = _glMatrix.vec2.fromValues(1, 1);\n      this._rotDeg = 0;\n\n      this._globalXform = _glMatrix.mat2d.create();\n      this._xformDirty = false;\n      this._parent = null;\n      this._children = new Set();\n\n      this._initTransformFromOptions(opts);\n    }\n\n    /**\n     * Adds a child to this transform node\n     * @param {Transform2d} childXform\n     */\n\n  }, {\n    key: \"addChildXform\",\n    value: function addChildXform(childXform) {\n      if (!this._children.has(childXform)) {\n        this._children.add(childXform);\n        if (childXform._parent) {\n          childXform._parent.removeChild(childXform);\n        }\n        childXform._parent = this;\n        childXform._xformDirty = true;\n        dirtyChildren(childXform._children);\n      }\n    }\n\n    /**\n     * Removes a child from this transform node\n     * @param  {Transform2d} childXform\n     */\n\n  }, {\n    key: \"removeChildXform\",\n    value: function removeChildXform(childXform) {\n      this._children.delete(childXform);\n    }\n\n    /**\n     * Unparents this node from its parent, if it has one\n     */\n\n  }, {\n    key: \"unparentXform\",\n    value: function unparentXform() {\n      if (this._parent) {\n        this._parent.removeChild(this);\n        this._parent = null;\n        _glMatrix.mat2d.copy(this._globalXform, this.localXform);\n      }\n    }\n\n    /**\n     * Sets the pivot of the transform\n     * @param  {Vec2d} pivot Offset vector from the origin to apply the transformations\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"getPosition\",\n\n\n    /**\n     * Gets the current unparented position of the transform\n     * @return {Point2d} This is the position of the node as if it were unparented\n     */\n    value: function getPosition() {\n      return _glMatrix.vec2.clone(this._pos);\n    }\n\n    /**\n     * Gets the reference to the unparented position of the transform, avoiding\n     * a copy\n     * @return {Point2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"getPositionRef\",\n    value: function getPositionRef() {\n      return this._pos;\n    }\n\n    /**\n     * Gets the current world position of the transform, this is its position\n     * after all parent transformations have been applied\n     * @return {Point2d}\n     */\n\n  }, {\n    key: \"getWorldPosition\",\n    value: function getWorldPosition() {\n      var xform = this.globalXform;\n      return Point2d.create(xform[4], xform[5]);\n    }\n\n    /**\n     * Sets the unparented world position of the transform\n     * @param {Point2d} pos\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(pos) {\n      Point2d.copy(this._pos, pos);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n    }\n\n    /**\n     * Translates the unparented world position of the transform by an offset\n     * @param  {Vec2d} translation\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(translation) {\n      if (translation[0] || translation[1]) {\n        Point2d.addVec2(this._pos, this._pos, translation);\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current unparented x,y scale of the transform\n     * @return {Vec2d}\n     */\n\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return _glMatrix.vec2.clone(this._scale);\n    }\n\n    /**\n     * Gets the current unparented x/y scale reference of the transform\n     * avoiding a copy\n     * @return {Vec2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"getScaleRef\",\n    value: function getScaleRef() {\n      return this._scale;\n    }\n\n    /**\n     * Sets the unparented scale of the transform\n     * @param {Vec2d} scale\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      _glMatrix.vec2.copy(this._scale, scale);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Scales the current unparented scale by a 2d multiplier\n     * @param  {Vec2d} scaleMult\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(scaleMult) {\n      if (scaleMult[0] !== 1 || scaleMult[1] !== 1) {\n        _glMatrix.vec2.multiply(this._scale, this._scale, scaleMult);\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current unparented rotation in degrees of the transform\n     * @return {number}\n     */\n\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      return this._rotDeg;\n    }\n\n    /**\n     * Sets the unparented rotation of the transform\n     * @param {number} deg Rotation in degrees\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(deg) {\n      this._rotDeg = deg;\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Adds an additional rotation in degrees to the current rotation\n     * of the transform\n     * @param  {number} deg Rotation offset in degrees\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(deg) {\n      if (deg) {\n        this._rotDeg += deg;\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Utility function to dirty all the descendants of this node\n     * @private\n     */\n\n  }, {\n    key: \"_dirtyChildren\",\n    value: function _dirtyChildren() {\n      dirtyChildren(this._children);\n    }\n\n    /**\n     * Updates the local affine matrix if marked as dirty\n     * If derived/mixin classes have a _localXformUpdates method\n     * defined, that will be called here when the local transform\n     * is updated.\n     * @private\n     */\n\n  }, {\n    key: \"_updatelocalxform\",\n    value: function _updatelocalxform() {\n      if (this._lxformDirty) {\n        buildXformMatrix(this._localXform, this._rotDeg, this._scale, this._pos, this._pivot);\n        if (this._localXformUpdated) {\n          this._localXformUpdated();\n        }\n        this._lxformDirty = false;\n      }\n    }\n\n    /**\n     * Updates the global 2x3 matrix of the transform if marked dirty\n     * If derived/mixin classes have a _globalXformUpdates method\n     * defined, that will be called here when the global transform\n     * is updated.\n     * @private\n     */\n\n  }, {\n    key: \"_updateglobalxform\",\n    value: function _updateglobalxform() {\n      if (this._lxformDirty || this._xformDirty) {\n        this._updatelocalxform();\n        if (this._parent) {\n          _glMatrix.mat2d.multiply(this._globalXform, this._parent.globalXform, this._localXform);\n        } else {\n          _glMatrix.mat2d.copy(this._globalXform, this._localXform);\n        }\n        if (this._globalXformUpdated) {\n          this._globalXformUpdated();\n        }\n        this._xformDirty = false;\n      }\n    }\n\n    /**\n     * Gets the current local transformation matrix of the node.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"transformCtx\",\n\n\n    /**\n     * Sets the transform state of a 2d rendering context\n     * @param  {CanvasRenderingContext2D} ctx\n     * @param  {Mat2d} currMatrix          The current matrix used to store the result of the\n     *                                     model-view-projection-screen matrix multiplication for this node\n     * @param  {Mat2d} worldToScreenMatrix The current world-to-screen tranform\n     */\n    value: function transformCtx(ctx, currMatrix, worldToScreenMatrix) {\n      _glMatrix.mat2d.multiply(currMatrix, worldToScreenMatrix, this.globalXform);\n\n      ctx.setTransform(currMatrix[0], currMatrix[1], currMatrix[2], currMatrix[3], currMatrix[4], currMatrix[5]);\n    }\n\n    /**\n     * Converts a Transform2d instance to a JSON object\n     * @param  {Transform2d} xformObj\n     * @return {{position: Point2d, scale: Vec2d, rotation: number, pivot: Vec2d}}\n     */\n\n  }, {\n    key: \"pivot\",\n    set: function set(pivot) {\n      Point2d.copy(this._pivot, pivot);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Gets the current pivot of the transform\n     * @return {Vec2d}\n     */\n    ,\n    get: function get() {\n      return Point2d.clone(this._pivot);\n    }\n\n    /**\n     * Gets the current pivot reference of the transform.\n     * @return {[type]} [description]\n     * @readOnly\n     */\n\n  }, {\n    key: \"pivotRef\",\n    get: function get() {\n      return this._pivot;\n    }\n\n    /**\n     * Gets the parent transform node, if one is attached\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n  }, {\n    key: \"localXform\",\n    get: function get() {\n      this._updatelocalxform();\n      return this._localXform;\n    }\n\n    /**\n     * Gets the current global transformation matrix of the node. This is essentially\n     * its local transform multiplied against all the local transforms of its parents.\n     * This is ultimately used to convert a point from object space to world space, and\n     * inversely, from world space to object space.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"globalXform\",\n    get: function get() {\n      this._updateglobalxform();\n      return this._globalXform;\n    }\n  }], [{\n    key: \"toJSON\",\n    value: function toJSON(xformObj) {\n      // TODO(croot): How do we deal with parenting here?\n      // To properly deal with this, we may need to supply an\n      // identifier for every created object... This may likely\n      // need to be a name string supplied by the user\n      var pos = xformObj.getPositionRef();\n      var scale = xformObj.getScaleRef();\n      var pivot = xformObj.pivotRef;\n      return {\n        position: [pos[0], pos[1]],\n        scale: [scale[0], scale[1]],\n        rotation: xformObj.getRotation(),\n        pivot: [pivot[0], pivot[1]]\n      };\n    }\n  }]);\n\n  return Transform2d;\n}();\n\n/**\n * Creates a new Transform2d mixin class that is intended to be mixed in with\n * a class that inherits from the EventHandler class\n * @param  {string} eventName Type name of the event fired when the transform is modified\n * @return {function}           Mixin\n */\n\n\nexports.default = Transform2d;\nfunction createEventedTransform2dMixin(eventName) {\n  /**\n   * Transform2d modification event\n   * @event EventedTransform2d#changed\n   * @type {object}\n   * @property {string} attr Name of the attribute modified\n   * @property {} prevVal Previous value of the attribute prior to modification\n   * @property {} currVal Value of the attribute post modification\n   */\n\n  /**\n   * @mixin Transform2d mixin with event firing when modified\n   */\n  return (0, _aggregation2.default)(null, Transform2d, function () {\n    function EventedTransform2d() {\n      _classCallCheck(this, EventedTransform2d);\n    }\n\n    _createClass(EventedTransform2d, [{\n      key: \"setPosition\",\n\n\n      /**\n       * Sets the unparented position of the transform.\n       * @param {Point2d} pos\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n      value: function setPosition(pos) {\n        if (!Point2d.equals(pos, this._pos)) {\n          var prev = [this._pos[0], this._pos[1]];\n          Point2d.copy(this._pos, pos);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"position\",\n            prevVal: prev,\n            currVal: pos\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Translates the unparented position of a transform by an offset.\n       * @param  {Vec2d} translation\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"translate\",\n      value: function translate(translation) {\n        if (translation[0] || translation[1]) {\n          var prev = [this._pos[0], this._pos[1]];\n          Point2d.addVec2(this._pos, this._pos, translation);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"position\",\n            prevVal: prev,\n            currVal: [this._pos[0], this._pos[1]]\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Sets the unparented 2d scale of the transform\n       * @param {Vec2d} scale\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setScale\",\n      value: function setScale(scale) {\n        if (!_glMatrix.vec2.equals(scale, this._scale)) {\n          var prev = [this._scale[0], this._scale[1]];\n          _glMatrix.vec2.copy(this._scale, scale);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"size\",\n            prevVal: prev,\n            currVal: scale\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Multiplies the current unparented scale of the transform by a 2d scalar\n       * @param  {Vec2d} scaleMult\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"scale\",\n      value: function scale(scaleMult) {\n        if (scaleMult[0] !== 1 || scaleMult[1] !== 1) {\n          var prev = [this._scale[0], this._scale[1]];\n          _glMatrix.vec2.multiply(this._scale, this._scale, scaleMult);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"size\",\n            prevVal: prev,\n            currVal: [this._scale[0], this._scale[1]]\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Sets the unparented rotation of the transform in degrees\n       * @param {number} deg Rotation angle in degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setRotation\",\n      value: function setRotation(deg) {\n        var degToUse = deg % 360;\n        if (degToUse !== this._rotDeg) {\n          var prev = this._rotDeg;\n          this._rotDeg = degToUse;\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"orientation\",\n            prevVal: prev,\n            curral: this._rotDeg\n          });\n        }\n      }\n\n      /**\n       * Adds a rotation angle in degrees to the current unparented\n       * rotation of the transform.\n       * @param  {number} deg Additional rotation angle in degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"rotate\",\n      value: function rotate(deg) {\n        if (deg) {\n          var prev = this._rotDeg;\n          this._rotDeg += deg;\n          this._rotDeg %= 360;\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"orientation\",\n            prevVal: prev,\n            curral: this._rotDeg\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Utility function to reset all the unparented transform parameters\n       * @param {number} tx  Translation in x in world units\n       * @param {number} ty  Translation in y in world units\n       * @param {number} sx  Scale in x in world units\n       * @param {number} sy  Scale in y in world units\n       * @param {number} deg Rotation angle degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setTransformations\",\n      value: function setTransformations(tx, ty, sx, sy, deg) {\n        var attrs = [];\n        var prevVals = [];\n        var currVals = [];\n        if (typeof tx !== \"undefined\" && typeof ty !== \"undefined\" && (!_glMatrix.glMatrix.equals(tx, this._pos[0]) || !_glMatrix.glMatrix.equals(ty, this._pos[1]))) {\n          var prev = Point2d.clone(this._pos);\n          this._pos[0] = tx;\n          this._pos[1] = ty;\n          attrs.push(\"position\");\n          prevVals.push(prev);\n          currVals.push(Point2d.clone(this._pos));\n        }\n\n        if (typeof sx !== \"undefined\" && typeof sy !== \"undefined\" && (!_glMatrix.glMatrix.equals(sx, this._scale[0]) || !_glMatrix.glMatrix.equals(sy, this._scale[1]))) {\n          var _prev = _glMatrix.vec2.clone(this._scale);\n          _glMatrix.vec2.set(this._scale, sx, sy);\n          attrs.push(\"size\");\n          prevVals.push(_prev);\n          currVals.push(_glMatrix.vec2.clone(this._scale));\n        }\n\n        if (typeof deg !== \"undefined\") {\n          var degToUse = deg % 360;\n          if (!_glMatrix.glMatrix.equals(degToUse, this._rotDeg)) {\n            var _prev2 = this._rotDeg;\n            this._rotDeg = degToUse;\n            attrs.push(\"orientation\");\n            prevVals.push(_prev2);\n            currVals.push(this._rotDeg);\n          }\n        }\n\n        if (attrs.length) {\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attrs: attrs,\n            prevVals: prevVals,\n            currVals: currVals\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"pivot\",\n\n      /**\n       * Sets the unparented pivot of the transform. The pivot is\n       * the offset from the transform's primary position where the\n       * transformation is applied.\n       * @param {Vec2d} pivot\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n      set: function set(pivot) {\n        if (!Point2d.equals(pivot, this._pivot)) {\n          var prev = [this._pivot[0], this._pivot[1]];\n          Point2d.copy(this._pivot, pivot);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"pivot\",\n            prevVal: prev,\n            currVal: pivot\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets a copy of the unparented pivot of the transform\n       * @return {Vec2d}\n       */\n      ,\n      get: function get() {\n        return Point2d.clone(this._pivot);\n      }\n    }]);\n\n    return EventedTransform2d;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvdHJhbnNmb3JtMmQuanM/ZDAwMiJdLCJuYW1lcyI6WyJidWlsZFhmb3JtTWF0cml4IiwiY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4iLCJQb2ludDJkIiwibWF0IiwicmRlZyIsInMiLCJ0IiwicGl2b3QiLCJNYXQyZCIsImlkZW50aXR5IiwidHJhbnNsYXRlIiwicm90YXRlIiwiTWF0aCIsIkRFR19UT19SQUQiLCJzY2FsZSIsImRpcnR5Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImZvckVhY2giLCJjaGlsZCIsIl94Zm9ybURpcnR5IiwiX2NoaWxkcmVuIiwiVHJhbnNmb3JtMmQiLCJvcHRzIiwiaW5pdGlhbGl6ZXIiLCJwb3NpdGlvbiIsInNldFBvc2l0aW9uIiwic2V0U2NhbGUiLCJyb3RhdGlvbiIsInNldFJvdGF0aW9uIiwiX2xvY2FsWGZvcm0iLCJjcmVhdGUiLCJfbHhmb3JtRGlydHkiLCJfcGl2b3QiLCJfcG9zIiwiX3NjYWxlIiwiVmVjMmQiLCJmcm9tVmFsdWVzIiwiX3JvdERlZyIsIl9nbG9iYWxYZm9ybSIsIl9wYXJlbnQiLCJTZXQiLCJfaW5pdFRyYW5zZm9ybUZyb21PcHRpb25zIiwiY2hpbGRYZm9ybSIsImhhcyIsImFkZCIsInJlbW92ZUNoaWxkIiwiZGVsZXRlIiwiY29weSIsImxvY2FsWGZvcm0iLCJjbG9uZSIsInhmb3JtIiwiZ2xvYmFsWGZvcm0iLCJwb3MiLCJ0cmFuc2xhdGlvbiIsImFkZFZlYzIiLCJzY2FsZU11bHQiLCJtdWx0aXBseSIsImRlZyIsIl9sb2NhbFhmb3JtVXBkYXRlZCIsIl91cGRhdGVsb2NhbHhmb3JtIiwiX2dsb2JhbFhmb3JtVXBkYXRlZCIsImN0eCIsImN1cnJNYXRyaXgiLCJ3b3JsZFRvU2NyZWVuTWF0cml4Iiwic2V0VHJhbnNmb3JtIiwiX3VwZGF0ZWdsb2JhbHhmb3JtIiwieGZvcm1PYmoiLCJnZXRQb3NpdGlvblJlZiIsImdldFNjYWxlUmVmIiwicGl2b3RSZWYiLCJnZXRSb3RhdGlvbiIsImV2ZW50TmFtZSIsImVxdWFscyIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwiZGVnVG9Vc2UiLCJjdXJyYWwiLCJ0eCIsInR5Iiwic3giLCJzeSIsImF0dHJzIiwicHJldlZhbHMiLCJjdXJyVmFscyIsIkdMTWF0cml4IiwicHVzaCIsInNldCIsImxlbmd0aCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O1FBa0JnQkEsZ0IsR0FBQUEsZ0I7UUE2WkFDLDZCLEdBQUFBLDZCOztBQTdhaEI7O0lBQVlDLE87O0FBQ1o7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7OztBQVdPLFNBQVNGLGdCQUFULENBQTBCRyxHQUExQixFQUErQkMsSUFBL0IsRUFBcUNDLENBQXJDLEVBQXdDQyxDQUF4QyxFQUEyQ0MsS0FBM0MsRUFBa0Q7QUFDdkRDLGtCQUFNQyxRQUFOLENBQWVOLEdBQWY7QUFDQUssa0JBQU1FLFNBQU4sQ0FBZ0JQLEdBQWhCLEVBQXFCQSxHQUFyQixFQUEwQixDQUFDRyxFQUFFLENBQUYsSUFBT0MsTUFBTSxDQUFOLENBQVIsRUFBa0JELEVBQUUsQ0FBRixJQUFPQyxNQUFNLENBQU4sQ0FBekIsQ0FBMUI7QUFDQUMsa0JBQU1HLE1BQU4sQ0FBYVIsR0FBYixFQUFrQkEsR0FBbEIsRUFBdUJTLGVBQUtDLFVBQUwsR0FBa0JULElBQXpDO0FBQ0FJLGtCQUFNTSxLQUFOLENBQVlYLEdBQVosRUFBaUJBLEdBQWpCLEVBQXNCRSxDQUF0QjtBQUNBRyxrQkFBTUUsU0FBTixDQUFnQlAsR0FBaEIsRUFBcUJBLEdBQXJCLEVBQTBCLENBQUMsQ0FBQ0ksTUFBTSxDQUFOLENBQUYsRUFBWSxDQUFDQSxNQUFNLENBQU4sQ0FBYixDQUExQjtBQUNBLFNBQU9KLEdBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTUEsU0FBU1ksYUFBVCxDQUF1QkMsUUFBdkIsRUFBaUM7QUFDL0JBLFdBQVNDLE9BQVQsQ0FBaUIsaUJBQVM7QUFDeEJDLFVB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WUFBTCxHQUFvQixJQUFwQjtBQUNBaEIsd0JBQWMsS0FBS0ssU0FBbkI7QUFDQSxlQUFLc0QsSUFBTCxDQUFVSCxTQUFWLEVBQXFCO0FBQ25CYSx3QkFEbUI7QUFFbkJDLDhCQUZtQjtBQUduQkM7QUFIbUIsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBcE5JO0FBQUE7O0FBQ0w7Ozs7Ozs7O0FBREssd0JBU0svRSxLQVRMLEVBU1k7QUFDZixZQUFJLENBQUNMLFFBQVFzRSxNQUFSLENBQWVqRSxLQUFmLEVBQXNCLEtBQUt5QixNQUEzQixDQUFMLEVBQXlDO0FBQ3ZDLGNBQU15QyxPQUFPLENBQUMsS0FBS3pDLE1BQUwsQ0FBWSxDQUFaLENBQUQsRUFBaUIsS0FBS0EsTUFBTCxDQUFZLENBQVosQ0FBakIsQ0FBYjtBQUNBOUIsa0JBQVE2QyxJQUFSLENBQWEsS0FBS2YsTUFBbEIsRUFBMEJ6QixLQUExQjtBQUNBLGVBQUt3QixZQUFMLEdBQW9CLElBQXBCO0FBQ0FoQix3QkFBYyxLQUFLSyxTQUFuQjtBQUNBLGVBQUtzRCxJQUFMLENBQVVILFNBQVYsRUFBcUI7QUFDbkJJLGtCQUFNLE9BRGE7QUFFbkJDLHFCQUFTSCxJQUZVO0FBR25CSSxxQkFBU3RFO0FBSFUsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBeEJLO0FBQUEsMEJBNEJPO0FBQ1YsZUFBT0wsUUFBUStDLEtBQVIsQ0FBYyxLQUFLakIsTUFBbkIsQ0FBUDtBQUNEO0FBOUJJOztBQUFBO0FBQUEsTUFBUDtBQXNORCIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQge2dsTWF0cml4IGFzIEdMTWF0cml4LCBtYXQyZCBhcyBNYXQyZCwgdmVjMiBhcyBWZWMyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5pbXBvcnQgYWdncmVnYXRpb24gZnJvbSBcIi4uL3V0aWwvYWdncmVnYXRpb25cIlxuaW1wb3J0IE1hdGggZnJvbSBcIi4uL21hdGgvbWF0aFwiXG5cbi8qKlxuICogQnVpbGRzIGEgMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4ICgyeDMgbWF0cml4KSBmcm9tIGEgcm90YXRpb24gKGluIGRlZ3JlZXMpLFxuICogYW4geCx5IHNjYWxlLCBhIHRyYW5zbGF0aW9uLCBhbmQgYSBwaXZvdCAoYW4gb2Zmc2V0IGZyb20gdGhlIG9yaWdpbiB0b1xuICogYXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uIGFyb3VuZClcbiAqIEBwYXJhbSAge01hdDJkfSBtYXQgICBNYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJkZWcgIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG4gKiBAcGFyYW0gIHtWZWMyZH0gcyAgICAgU2NhbGUgdmVjdG9yLCBpbiB4ICYgeVxuICogQHBhcmFtICB7VmVjMmR9IHQgICAgIFRyYW5zbGF0aW9uIHZlY3RvciwgaW4geCAmIHlcbiAqIEBwYXJhbSAge1ZlYzJkfSBwaXZvdCBPZmZzZXQgZnJvbSBvcmlnaW4gdG8gYXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcmV0dXJuIHtNYXQyZH0gICAgICAgTWF0cml4IHJlZmVyZW5jZWQgYnkgdGhlIG1hdCBhcmd1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRYZm9ybU1hdHJpeChtYXQsIHJkZWcsIHMsIHQsIHBpdm90KSB7XG4gIE1hdDJkLmlkZW50aXR5KG1hdClcbiAgTWF0MmQudHJhbnNsYXRlKG1hdCwgbWF0LCBbdFswXSArIHBpdm90WzBdLCB0WzFdICsgcGl2b3RbMV1dKVxuICBNYXQyZC5yb3RhdGUobWF0LCBtYXQsIE1hdGguREVHX1RPX1JBRCAqIHJkZWcpXG4gIE1hdDJkLnNjYWxlKG1hdCwgbWF0LCBzKVxuICBNYXQyZC50cmFuc2xhdGUobWF0LCBtYXQsIFstcGl2b3RbMF0sIC1waXZvdFsxXV0pXG4gIHJldHVybiBtYXRcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGRpcnR5IGFsbCB0aGUgZGVzY2VuZGFudHMgb2YgYSB0cmFuc2Zvcm0gbm9kZS5cbiAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB0cmFuc2Zvcm0gbm9kZSBoYXMgYmVlbiBtb2RpZmllZCBpbiBzb21lIHdheVxuICogdGhhdCBpdCdzIGNoaWxkcmVuIG5lZWQgdG8gYmUgbm90aWZpZWQgYWJvdXQuXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm0yZFtdfSBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBkaXJ0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGNoaWxkLl94Zm9ybURpcnR5ID0gdHJ1ZVxuICAgIGRpcnR5Q2hpbGRyZW4oY2hpbGQuX2NoaWxkcmVuKVxuICB9KVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zZm9ybTJkT3B0aW9uc1xuICogQHByb3BlcnR5IHtQb2ludDJkfSBbcG9zaXRpb24gPSBbMCwwXV0gUG9zaXRpb24gaW4gd29ybGQgc3BhY2UgY29vcmRzXG4gKiBAcHJvcGVydHkge1ZlYzJkfSBbc2NhbGUgPSBbMSwxXV0gU2NhbGUgaW4gd29ybGQgc3BhY2UgY29vcmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uID0gMF0gUm90YXRpb24gaW4gZGVncmVlc1xuICogQHByb3BlcnR5IHtWZWMyZH0gW3Bpdm90ID0gWzAsIDBdXSBPZmZzZXQgZnJvbSBvcmlnaW4gdG8gYXBwbHkgdGhlIHNldFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbi8qKlxuICogQGNsYXNzIENsYXNzIHRvIG1hbmFnZSBiYXNpYyAyZCBhZmZpbmUgdHJhbnNmb3JtYXRpb25zXG4gKiBAbWl4aW4gQ2FuIGFsc28gYmUgdXNlZCBhcyBhIG1peGluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybTJkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHJhbnNmb3JtMmRcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmRPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgdHJhbnNmb3JtIDJkIG9iamVjdCBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmRPcHRpb25zfSBbb3B0c11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0VHJhbnNmb3JtRnJvbU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBvc2l0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNjYWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFNjYWxlKG9wdHMuc2NhbGUpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnJvdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKG9wdHMucm90YXRpb24pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBpdm90ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnBpdm90ID0gb3B0cy5waXZvdFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHRyYW5zZm9ybSAyZCBvYmplY3QgZnJvbSBvcHRpb25zLFxuICAgKiBjYWxsZWQgZnJvbSBlaXRoZXIgY29uc3RydWN0b3IgKGlmIHVzZWQgYXMgYmFzZSBjbGFzcylcbiAgICogb3IgYmFzZSBtaXhpbiBjbGFzcyAoaWYgdXNlZCBhcyBhIG1peGluKVxuICAgKiBAcGFyYW0gIHtUcmFuc2Zvcm0yZE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgdGhpcy5fbG9jYWxYZm9ybSA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fbHhmb3JtRGlydHkgPSBmYWxzZVxuXG4gICAgdGhpcy5fcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuXG4gICAgdGhpcy5fcG9zID0gUG9pbnQyZC5jcmVhdGUoMCwgMClcbiAgICB0aGlzLl9zY2FsZSA9IFZlYzJkLmZyb21WYWx1ZXMoMSwgMSlcbiAgICB0aGlzLl9yb3REZWcgPSAwXG5cbiAgICB0aGlzLl9nbG9iYWxYZm9ybSA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5feGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNldCgpXG5cbiAgICB0aGlzLl9pbml0VHJhbnNmb3JtRnJvbU9wdGlvbnMob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhpcyB0cmFuc2Zvcm0gbm9kZVxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybTJkfSBjaGlsZFhmb3JtXG4gICAqL1xuICBhZGRDaGlsZFhmb3JtKGNoaWxkWGZvcm0pIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuLmhhcyhjaGlsZFhmb3JtKSkge1xuICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKGNoaWxkWGZvcm0pXG4gICAgICBpZiAoY2hpbGRYZm9ybS5fcGFyZW50KSB7XG4gICAgICAgIGNoaWxkWGZvcm0uX3BhcmVudC5yZW1vdmVDaGlsZChjaGlsZFhmb3JtKVxuICAgICAgfVxuICAgICAgY2hpbGRYZm9ybS5fcGFyZW50ID0gdGhpc1xuICAgICAgY2hpbGRYZm9ybS5feGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgIGRpcnR5Q2hpbGRyZW4oY2hpbGRYZm9ybS5fY2hpbGRyZW4pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoaXMgdHJhbnNmb3JtIG5vZGVcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmR9IGNoaWxkWGZvcm1cbiAgICovXG4gIHJlbW92ZUNoaWxkWGZvcm0oY2hpbGRYZm9ybSkge1xuICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZShjaGlsZFhmb3JtKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucGFyZW50cyB0aGlzIG5vZGUgZnJvbSBpdHMgcGFyZW50LCBpZiBpdCBoYXMgb25lXG4gICAqL1xuICB1bnBhcmVudFhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKVxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICAgICAgTWF0MmQuY29weSh0aGlzLl9nbG9iYWxYZm9ybSwgdGhpcy5sb2NhbFhmb3JtKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwaXZvdCBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSAge1ZlYzJkfSBwaXZvdCBPZmZzZXQgdmVjdG9yIGZyb20gdGhlIG9yaWdpbiB0byBhcHBseSB0aGUgdHJhbnNmb3JtYXRpb25zXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgc2V0IHBpdm90KHBpdm90KSB7XG4gICAgUG9pbnQyZC5jb3B5KHRoaXMuX3Bpdm90LCBwaXZvdClcbiAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwaXZvdCBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge1ZlYzJkfVxuICAgKi9cbiAgZ2V0IHBpdm90KCkge1xuICAgIHJldHVybiBQb2ludDJkLmNsb25lKHRoaXMuX3Bpdm90KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcGl2b3QgcmVmZXJlbmNlIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCBwaXZvdFJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl2b3RcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJlbnQgdHJhbnNmb3JtIG5vZGUsIGlmIG9uZSBpcyBhdHRhY2hlZFxuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm0yZH1cbiAgICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCBwb3NpdGlvbiBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge1BvaW50MmR9IFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFzIGlmIGl0IHdlcmUgdW5wYXJlbnRlZFxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIFZlYzJkLmNsb25lKHRoaXMuX3BvcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWZlcmVuY2UgdG8gdGhlIHVucGFyZW50ZWQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSwgYXZvaWRpbmdcbiAgICogYSBjb3B5XG4gICAqIEByZXR1cm4ge1BvaW50MmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0UG9zaXRpb25SZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSwgdGhpcyBpcyBpdHMgcG9zaXRpb25cbiAgICogYWZ0ZXIgYWxsIHBhcmVudCB0cmFuc2Zvcm1hdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICogQHJldHVybiB7UG9pbnQyZH1cbiAgICovXG4gIGdldFdvcmxkUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeGZvcm0gPSB0aGlzLmdsb2JhbFhmb3JtXG4gICAgcmV0dXJuIFBvaW50MmQuY3JlYXRlKHhmb3JtWzRdLCB4Zm9ybVs1XSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtQb2ludDJkfSBwb3NcbiAgICovXG4gIHNldFBvc2l0aW9uKHBvcykge1xuICAgIFBvaW50MmQuY29weSh0aGlzLl9wb3MsIHBvcylcbiAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgdGhlIHVucGFyZW50ZWQgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSBieSBhbiBvZmZzZXRcbiAgICogQHBhcmFtICB7VmVjMmR9IHRyYW5zbGF0aW9uXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgdHJhbnNsYXRlKHRyYW5zbGF0aW9uKSB7XG4gICAgaWYgKHRyYW5zbGF0aW9uWzBdIHx8IHRyYW5zbGF0aW9uWzFdKSB7XG4gICAgICBQb2ludDJkLmFkZFZlYzIodGhpcy5fcG9zLCB0aGlzLl9wb3MsIHRyYW5zbGF0aW9uKVxuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCB4LHkgc2NhbGUgb2YgdGhlIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiBWZWMyZC5jbG9uZSh0aGlzLl9zY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVucGFyZW50ZWQgeC95IHNjYWxlIHJlZmVyZW5jZSBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIGF2b2lkaW5nIGEgY29weVxuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBnZXRTY2FsZVJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtWZWMyZH0gc2NhbGVcbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIFZlYzJkLmNvcHkodGhpcy5fc2NhbGUsIHNjYWxlKVxuICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZXMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCBzY2FsZSBieSBhIDJkIG11bHRpcGxpZXJcbiAgICogQHBhcmFtICB7VmVjMmR9IHNjYWxlTXVsdFxuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm0yZH1cbiAgICovXG4gIHNjYWxlKHNjYWxlTXVsdCkge1xuICAgIGlmIChzY2FsZU11bHRbMF0gIT09IDEgfHwgc2NhbGVNdWx0WzFdICE9PSAxKSB7XG4gICAgICBWZWMyZC5tdWx0aXBseSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHNjYWxlTXVsdClcbiAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVucGFyZW50ZWQgcm90YXRpb24gaW4gZGVncmVlcyBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3REZWdcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHJvdGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyBSb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgc2V0Um90YXRpb24oZGVnKSB7XG4gICAgdGhpcy5fcm90RGVnID0gZGVnXG4gICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gYWRkaXRpb25hbCByb3RhdGlvbiBpbiBkZWdyZWVzIHRvIHRoZSBjdXJyZW50IHJvdGF0aW9uXG4gICAqIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtICB7bnVtYmVyfSBkZWcgUm90YXRpb24gb2Zmc2V0IGluIGRlZ3JlZXNcbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICByb3RhdGUoZGVnKSB7XG4gICAgaWYgKGRlZykge1xuICAgICAgdGhpcy5fcm90RGVnICs9IGRlZ1xuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZGlydHkgYWxsIHRoZSBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXJ0eUNoaWxkcmVuKCkge1xuICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgYWZmaW5lIG1hdHJpeCBpZiBtYXJrZWQgYXMgZGlydHlcbiAgICogSWYgZGVyaXZlZC9taXhpbiBjbGFzc2VzIGhhdmUgYSBfbG9jYWxYZm9ybVVwZGF0ZXMgbWV0aG9kXG4gICAqIGRlZmluZWQsIHRoYXQgd2lsbCBiZSBjYWxsZWQgaGVyZSB3aGVuIHRoZSBsb2NhbCB0cmFuc2Zvcm1cbiAgICogaXMgdXBkYXRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVsb2NhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSkge1xuICAgICAgYnVpbGRYZm9ybU1hdHJpeCh0aGlzLl9sb2NhbFhmb3JtLCB0aGlzLl9yb3REZWcsIHRoaXMuX3NjYWxlLCB0aGlzLl9wb3MsIHRoaXMuX3Bpdm90KVxuICAgICAgaWYgKHRoaXMuX2xvY2FsWGZvcm1VcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsWGZvcm1VcGRhdGVkKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZ2xvYmFsIDJ4MyBtYXRyaXggb2YgdGhlIHRyYW5zZm9ybSBpZiBtYXJrZWQgZGlydHlcbiAgICogSWYgZGVyaXZlZC9taXhpbiBjbGFzc2VzIGhhdmUgYSBfZ2xvYmFsWGZvcm1VcGRhdGVzIG1ldGhvZFxuICAgKiBkZWZpbmVkLCB0aGF0IHdpbGwgYmUgY2FsbGVkIGhlcmUgd2hlbiB0aGUgZ2xvYmFsIHRyYW5zZm9ybVxuICAgKiBpcyB1cGRhdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZWdsb2JhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCB0aGlzLl94Zm9ybURpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVsb2NhbHhmb3JtKClcbiAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgTWF0MmQubXVsdGlwbHkodGhpcy5fZ2xvYmFsWGZvcm0sIHRoaXMuX3BhcmVudC5nbG9iYWxYZm9ybSwgdGhpcy5fbG9jYWxYZm9ybSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1hdDJkLmNvcHkodGhpcy5fZ2xvYmFsWGZvcm0sIHRoaXMuX2xvY2FsWGZvcm0pXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZ2xvYmFsWGZvcm1VcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFhmb3JtVXBkYXRlZCgpXG4gICAgICB9XG4gICAgICB0aGlzLl94Zm9ybURpcnR5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IGxvY2FsWGZvcm0oKSB7XG4gICAgdGhpcy5fdXBkYXRlbG9jYWx4Zm9ybSgpXG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsWGZvcm1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIG5vZGUuIFRoaXMgaXMgZXNzZW50aWFsbHlcbiAgICogaXRzIGxvY2FsIHRyYW5zZm9ybSBtdWx0aXBsaWVkIGFnYWluc3QgYWxsIHRoZSBsb2NhbCB0cmFuc2Zvcm1zIG9mIGl0cyBwYXJlbnRzLlxuICAgKiBUaGlzIGlzIHVsdGltYXRlbHkgdXNlZCB0byBjb252ZXJ0IGEgcG9pbnQgZnJvbSBvYmplY3Qgc3BhY2UgdG8gd29ybGQgc3BhY2UsIGFuZFxuICAgKiBpbnZlcnNlbHksIGZyb20gd29ybGQgc3BhY2UgdG8gb2JqZWN0IHNwYWNlLlxuICAgKiBAcmV0dXJuIHtNYXQyZH1cbiAgICovXG4gIGdldCBnbG9iYWxYZm9ybSgpIHtcbiAgICB0aGlzLl91cGRhdGVnbG9iYWx4Zm9ybSgpXG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFhmb3JtXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIHN0YXRlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtICB7TWF0MmR9IGN1cnJNYXRyaXggICAgICAgICAgVGhlIGN1cnJlbnQgbWF0cml4IHVzZWQgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwtdmlldy1wcm9qZWN0aW9uLXNjcmVlbiBtYXRyaXggbXVsdGlwbGljYXRpb24gZm9yIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0gIHtNYXQyZH0gd29ybGRUb1NjcmVlbk1hdHJpeCBUaGUgY3VycmVudCB3b3JsZC10by1zY3JlZW4gdHJhbmZvcm1cbiAgICovXG4gIHRyYW5zZm9ybUN0eChjdHgsIGN1cnJNYXRyaXgsIHdvcmxkVG9TY3JlZW5NYXRyaXgpIHtcbiAgICBNYXQyZC5tdWx0aXBseShjdXJyTWF0cml4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLmdsb2JhbFhmb3JtKVxuXG4gICAgY3R4LnNldFRyYW5zZm9ybShjdXJyTWF0cml4WzBdLFxuICAgICAgY3Vyck1hdHJpeFsxXSxcbiAgICAgIGN1cnJNYXRyaXhbMl0sXG4gICAgICBjdXJyTWF0cml4WzNdLFxuICAgICAgY3Vyck1hdHJpeFs0XSxcbiAgICAgIGN1cnJNYXRyaXhbNV0pXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBUcmFuc2Zvcm0yZCBpbnN0YW5jZSB0byBhIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSAge1RyYW5zZm9ybTJkfSB4Zm9ybU9ialxuICAgKiBAcmV0dXJuIHt7cG9zaXRpb246IFBvaW50MmQsIHNjYWxlOiBWZWMyZCwgcm90YXRpb246IG51bWJlciwgcGl2b3Q6IFZlYzJkfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oeGZvcm1PYmopIHtcbiAgICAvLyBUT0RPKGNyb290KTogSG93IGRvIHdlIGRlYWwgd2l0aCBwYXJlbnRpbmcgaGVyZT9cbiAgICAvLyBUbyBwcm9wZXJseSBkZWFsIHdpdGggdGhpcywgd2UgbWF5IG5lZWQgdG8gc3VwcGx5IGFuXG4gICAgLy8gaWRlbnRpZmllciBmb3IgZXZlcnkgY3JlYXRlZCBvYmplY3QuLi4gVGhpcyBtYXkgbGlrZWx5XG4gICAgLy8gbmVlZCB0byBiZSBhIG5hbWUgc3RyaW5nIHN1cHBsaWVkIGJ5IHRoZSB1c2VyXG4gICAgY29uc3QgcG9zID0geGZvcm1PYmouZ2V0UG9zaXRpb25SZWYoKVxuICAgIGNvbnN0IHNjYWxlID0geGZvcm1PYmouZ2V0U2NhbGVSZWYoKVxuICAgIGNvbnN0IHBpdm90ID0geGZvcm1PYmoucGl2b3RSZWZcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IFtwb3NbMF0sIHBvc1sxXV0sXG4gICAgICBzY2FsZTogW3NjYWxlWzBdLCBzY2FsZVsxXV0sXG4gICAgICByb3RhdGlvbjogeGZvcm1PYmouZ2V0Um90YXRpb24oKSxcbiAgICAgIHBpdm90OiBbcGl2b3RbMF0sIHBpdm90WzFdXVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVHJhbnNmb3JtMmQgbWl4aW4gY2xhc3MgdGhhdCBpcyBpbnRlbmRlZCB0byBiZSBtaXhlZCBpbiB3aXRoXG4gKiBhIGNsYXNzIHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgRXZlbnRIYW5kbGVyIGNsYXNzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZSBUeXBlIG5hbWUgb2YgdGhlIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRyYW5zZm9ybSBpcyBtb2RpZmllZFxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICBNaXhpblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4oZXZlbnROYW1lKSB7XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0yZCBtb2RpZmljYXRpb24gZXZlbnRcbiAgICogQGV2ZW50IEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBtb2RpZmllZFxuICAgKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICAgKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWl4aW4gVHJhbnNmb3JtMmQgbWl4aW4gd2l0aCBldmVudCBmaXJpbmcgd2hlbiBtb2RpZmllZFxuICAgKi9cbiAgcmV0dXJuIGFnZ3JlZ2F0aW9uKG51bGwsIFRyYW5zZm9ybTJkLCBjbGFzcyBFdmVudGVkVHJhbnNmb3JtMmQge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVucGFyZW50ZWQgcGl2b3Qgb2YgdGhlIHRyYW5zZm9ybS4gVGhlIHBpdm90IGlzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSB0cmFuc2Zvcm0ncyBwcmltYXJ5IHBvc2l0aW9uIHdoZXJlIHRoZVxuICAgICAqIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtWZWMyZH0gcGl2b3RcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHNldCBwaXZvdChwaXZvdCkge1xuICAgICAgaWYgKCFQb2ludDJkLmVxdWFscyhwaXZvdCwgdGhpcy5fcGl2b3QpKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fcGl2b3RbMF0sIHRoaXMuX3Bpdm90WzFdXVxuICAgICAgICBQb2ludDJkLmNvcHkodGhpcy5fcGl2b3QsIHBpdm90KVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwicGl2b3RcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IHBpdm90XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb3B5IG9mIHRoZSB1bnBhcmVudGVkIHBpdm90IG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICAgKi9cbiAgICBnZXQgcGl2b3QoKSB7XG4gICAgICByZXR1cm4gUG9pbnQyZC5jbG9uZSh0aGlzLl9waXZvdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtQb2ludDJkfSBwb3NcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uKHBvcykge1xuICAgICAgaWYgKCFQb2ludDJkLmVxdWFscyhwb3MsIHRoaXMuX3BvcykpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IFt0aGlzLl9wb3NbMF0sIHRoaXMuX3Bvc1sxXV1cbiAgICAgICAgUG9pbnQyZC5jb3B5KHRoaXMuX3BvcywgcG9zKVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwicG9zaXRpb25cIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IHBvc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSB1bnBhcmVudGVkIHBvc2l0aW9uIG9mIGEgdHJhbnNmb3JtIGJ5IGFuIG9mZnNldC5cbiAgICAgKiBAcGFyYW0gIHtWZWMyZH0gdHJhbnNsYXRpb25cbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh0cmFuc2xhdGlvbikge1xuICAgICAgaWYgKHRyYW5zbGF0aW9uWzBdIHx8IHRyYW5zbGF0aW9uWzFdKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fcG9zWzBdLCB0aGlzLl9wb3NbMV1dXG4gICAgICAgIFBvaW50MmQuYWRkVmVjMih0aGlzLl9wb3MsIHRoaXMuX3BvcywgdHJhbnNsYXRpb24pXG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJwb3NpdGlvblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VyclZhbDogW3RoaXMuX3Bvc1swXSwgdGhpcy5fcG9zWzFdXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIDJkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge1ZlYzJkfSBzY2FsZVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZFRyYW5zZm9ybTJkI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gICAgICovXG4gICAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICAgIGlmICghVmVjMmQuZXF1YWxzKHNjYWxlLCB0aGlzLl9zY2FsZSkpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IFt0aGlzLl9zY2FsZVswXSwgdGhpcy5fc2NhbGVbMV1dXG4gICAgICAgIFZlYzJkLmNvcHkodGhpcy5fc2NhbGUsIHNjYWxlKVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwic2l6ZVwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VyclZhbDogc2NhbGVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCB1bnBhcmVudGVkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm0gYnkgYSAyZCBzY2FsYXJcbiAgICAgKiBAcGFyYW0gIHtWZWMyZH0gc2NhbGVNdWx0XG4gICAgICogQGZpcmVzICBFdmVudGVkVHJhbnNmb3JtMmQjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAgICAgKi9cbiAgICBzY2FsZShzY2FsZU11bHQpIHtcbiAgICAgIGlmIChzY2FsZU11bHRbMF0gIT09IDEgfHwgc2NhbGVNdWx0WzFdICE9PSAxKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fc2NhbGVbMF0sIHRoaXMuX3NjYWxlWzFdXVxuICAgICAgICBWZWMyZC5tdWx0aXBseSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHNjYWxlTXVsdClcbiAgICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICBhdHRyOiBcInNpemVcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IFt0aGlzLl9zY2FsZVswXSwgdGhpcy5fc2NhbGVbMV1dXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVucGFyZW50ZWQgcm90YXRpb24gb2YgdGhlIHRyYW5zZm9ybSBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyBSb3RhdGlvbiBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQGZpcmVzICBFdmVudGVkVHJhbnNmb3JtMmQjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbihkZWcpIHtcbiAgICAgIGNvbnN0IGRlZ1RvVXNlID0gZGVnICUgMzYwXG4gICAgICBpZiAoZGVnVG9Vc2UgIT09IHRoaXMuX3JvdERlZykge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcm90RGVnXG4gICAgICAgIHRoaXMuX3JvdERlZyA9IGRlZ1RvVXNlXG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9yb3REZWdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYW5nbGUgaW4gZGVncmVlcyB0byB0aGUgY3VycmVudCB1bnBhcmVudGVkXG4gICAgICogcm90YXRpb24gb2YgdGhlIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGRlZyBBZGRpdGlvbmFsIHJvdGF0aW9uIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHJvdGF0ZShkZWcpIHtcbiAgICAgIGlmIChkZWcpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3JvdERlZ1xuICAgICAgICB0aGlzLl9yb3REZWcgKz0gZGVnXG4gICAgICAgIHRoaXMuX3JvdERlZyAlPSAzNjBcbiAgICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICBhdHRyOiBcIm9yaWVudGF0aW9uXCIsXG4gICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICBjdXJyYWw6IHRoaXMuX3JvdERlZ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHJlc2V0IGFsbCB0aGUgdW5wYXJlbnRlZCB0cmFuc2Zvcm0gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAgVHJhbnNsYXRpb24gaW4geCBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAgVHJhbnNsYXRpb24gaW4geSBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCAgU2NhbGUgaW4geCBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSAgU2NhbGUgaW4geSBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgUm90YXRpb24gYW5nbGUgZGVncmVlc1xuICAgICAqIEBmaXJlcyAgRXZlbnRlZFRyYW5zZm9ybTJkI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtYXRpb25zKHR4LCB0eSwgc3gsIHN5LCBkZWcpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gW11cbiAgICAgIGNvbnN0IHByZXZWYWxzID0gW11cbiAgICAgIGNvbnN0IGN1cnJWYWxzID0gW11cbiAgICAgIGlmICh0eXBlb2YgdHggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHR5ICE9PSBcInVuZGVmaW5lZFwiICYmICghR0xNYXRyaXguZXF1YWxzKHR4LCB0aGlzLl9wb3NbMF0pIHx8ICFHTE1hdHJpeC5lcXVhbHModHksIHRoaXMuX3Bvc1sxXSkpKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3BvcylcbiAgICAgICAgdGhpcy5fcG9zWzBdID0gdHhcbiAgICAgICAgdGhpcy5fcG9zWzFdID0gdHlcbiAgICAgICAgYXR0cnMucHVzaChcInBvc2l0aW9uXCIpXG4gICAgICAgIHByZXZWYWxzLnB1c2gocHJldilcbiAgICAgICAgY3VyclZhbHMucHVzaChQb2ludDJkLmNsb25lKHRoaXMuX3BvcykpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHN5ICE9PSBcInVuZGVmaW5lZFwiICYmICghR0xNYXRyaXguZXF1YWxzKHN4LCB0aGlzLl9zY2FsZVswXSkgfHwgIUdMTWF0cml4LmVxdWFscyhzeSwgdGhpcy5fc2NhbGVbMV0pKSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gVmVjMmQuY2xvbmUodGhpcy5fc2NhbGUpXG4gICAgICAgIFZlYzJkLnNldCh0aGlzLl9zY2FsZSwgc3gsIHN5KVxuICAgICAgICBhdHRycy5wdXNoKFwic2l6ZVwiKVxuICAgICAgICBwcmV2VmFscy5wdXNoKHByZXYpXG4gICAgICAgIGN1cnJWYWxzLnB1c2goVmVjMmQuY2xvbmUodGhpcy5fc2NhbGUpKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBkZWdUb1VzZSA9IGRlZyAlIDM2MFxuICAgICAgICBpZiAoIUdMTWF0cml4LmVxdWFscyhkZWdUb1VzZSwgdGhpcy5fcm90RGVnKSkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9yb3REZWdcbiAgICAgICAgICB0aGlzLl9yb3REZWcgPSBkZWdUb1VzZVxuICAgICAgICAgIGF0dHJzLnB1c2goXCJvcmllbnRhdGlvblwiKVxuICAgICAgICAgIHByZXZWYWxzLnB1c2gocHJldilcbiAgICAgICAgICBjdXJyVmFscy5wdXNoKHRoaXMuX3JvdERlZylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgcHJldlZhbHMsXG4gICAgICAgICAgY3VyclZhbHNcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3RyYW5zZm9ybTJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 12 */
/***/ (function(module, exports) {

	eval("\"use strict\";\n\n/**\n  @typedef EventObject\n  @type {object}\n  @property {string} type - the type of the event\n  @property {string} target - the target object that fired the event\n /\n\n/**\n * This callback is displayed as a global member.\n * @callback EventCallback\n * @param {EventObject} Event object describing the event being fired\n */\n\n/**\n * Recursively fires hierarchical events from an handler's registered\n * event types. For example, if an event is registered as \"changed:color\",\n * both a \"changed:color\" and \"changed\" event is fired, so listeners who\n * only generically care if something changed on an object can be notified.\n * @param  {Map} currMap  map datastructure holding all hierarchical events and callbacks\n * @param  {string[]} subtypes the \":\" separated list of the event\n * @param  {number} currIdx  the current index of subtypes being processed\n * @param  {Object} fireData the event object to fire\n * @return {number}          total number of listeners called\n * @private\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction recursiveFire(currMap, subtypes, currIdx, fireData) {\n  var _this = this;\n\n  if (currIdx >= subtypes.length) {\n    return 0;\n  }\n\n  var cnt = 0;\n  var data = null;\n  data = currMap.get(subtypes[currIdx]);\n  if (data) {\n    cnt = recursiveFire(data[0], subtypes, currIdx + 1, fireData);\n    data[1].forEach(function (listener) {\n      return listener.call(_this, fireData);\n    });\n    cnt += data[1].length;\n  }\n  return cnt;\n}\n\n/**\n * Recursively deletes specific listeners from a handlers event\n * data structure. For instance, if the same callback is used for both\n * a \"changed\" and a \"changed:color\" event, and that callback is deleted\n * from the \"changed\" event, it is also deleted from the \"changed:color\" event\n * @param  {Object} currNode  Current node of the map data structure being processed\n * @param  {function[]} listeners Array of listeners to delete\n * @private\n */\nfunction recursiveDelete(currNode, listeners) {\n  var index = -1;\n  var subnodes = currNode[0];\n  var nodelisteners = currNode[1];\n  if (nodelisteners.length) {\n    listeners.forEach(function (listener) {\n      if ((index = nodelisteners.indexOf(listener)) >= 0) {\n        nodelisteners.splice(index, 1);\n      }\n    });\n  }\n  subnodes.forEach(function (node) {\n    recursiveDelete(node, listeners);\n  });\n}\n\n/**\n * Validates that an input is a string or an array of strings, and if the former\n * returns a 1-element string array\n * @param  {string|string[]} intype\n * @return {string[]}\n * @private\n */\nfunction arrayify(intype) {\n  var arrayToUse = intype;\n  if (typeof intype === \"string\") {\n    arrayToUse = [intype];\n  } else if (!Array.isArray(intype)) {\n    throw new Error(\"Input must be an array of strings\");\n  }\n  return arrayToUse;\n}\n\n/** Class for managing events and listeners. Can be used as a base class or a mixin (using @see {@link aggregation}) */\n\nvar EventHandler = function () {\n\n  /**\n   * Create a new event handler\n   * @param  {string|string[]} eventsToRegister initial events to register\n   */\n  function EventHandler(eventsToRegister) {\n    _classCallCheck(this, EventHandler);\n\n    this.initializer(eventsToRegister);\n  }\n\n  /**\n   * Initializes an event handler object\n   * @param  {string|string[]} eventsToRegister events to initialize event handler with\n   * @see  {@link aggregation}\n   */\n\n\n  _createClass(EventHandler, [{\n    key: \"initializer\",\n    value: function initializer(eventsToRegister) {\n      this._listeners = new Map();\n      this.registerEvents(eventsToRegister);\n    }\n\n    /**\n     * Registers new events for the event handler\n     * @param  {string|string[]} events new event(s) to register\n     */\n\n  }, {\n    key: \"registerEvents\",\n    value: function registerEvents(events) {\n      var _this2 = this;\n\n      if (!events) {\n        return;\n      }\n\n      var eventsToUse = arrayify(events);\n      if (typeof events === \"string\") {\n        eventsToUse = [events];\n      } else if (!Array.isArray(events)) {\n        throw new Error(\"Events must be an array of strings\");\n      }\n\n      eventsToUse.forEach(function (event) {\n        var subevents = event.split(\":\");\n        var currMap = _this2._listeners;\n        for (var i = 0; i < subevents.length; i += 1) {\n          var data = currMap.get(subevents[i]);\n          if (!data) {\n            data = [new Map(), []];\n            currMap.set(subevents[i], data);\n          }\n          currMap = data[0];\n        }\n      });\n    }\n\n    /**\n     * Adds a new listener to a specific event or list of different events\n     * @param  {string|string[]} types    event(s) this listener is listening to\n     * @param  {EventCallback} listener function to be called when events destribed by types is fired\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(types, listener) {\n      var _this3 = this;\n\n      var typesToUse = arrayify(types);\n      typesToUse.forEach(function (type) {\n        var subtypes = type.split(\":\");\n        var currMap = _this3._listeners;\n        var data = null;\n        subtypes.forEach(function (subtype) {\n          data = currMap.get(subtype);\n          if (!data) {\n            var keys = [];\n            currMap.forEach(function (val, key) {\n              return keys.push(key);\n            });\n            throw new Error(type + \" is not a valid event type. The registered event types at this level are [\" + keys + \"]\");\n          }\n          currMap = data[0];\n        });\n        if (data[1].indexOf(listener) < 0) {\n          data[1].push(listener);\n        }\n      });\n\n      return this;\n    }\n\n    /**\n     * Removes a listener from specific events\n     * @param  {string|string[]} types    event(s) the listener is being removed from\n     * @param  {EventCallback} listener callback function to be cleared from the specified event types\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(types, listener) {\n      var _this4 = this;\n\n      var typesToUse = arrayify(types);\n      var listeners = listener;\n      if (!Array.isArray(listeners)) {\n        listeners = [listener];\n      }\n      typesToUse.forEach(function (type) {\n        var subtypes = type.split(\":\");\n        var currMap = _this4._listeners;\n        var data = null;\n        var i = 0;\n        for (i = 0; i < subtypes.length; i += 1) {\n          data = currMap.get(subtypes[i]);\n          if (!data) {\n            break;\n          }\n          currMap = data[0];\n        }\n        if (data) {\n          recursiveDelete(data, listeners);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Sets up a lister callback to only be called once\n     * @param  {string|string[]} types    event(s) the listener is listening to\n     * @param  {EventCallback} listener callback function to be called with event(s) are fired\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(types, listener) {\n      var _this5 = this;\n\n      var wrapper = function wrapper(data) {\n        _this5.off(types, wrapper);\n        listener.call(_this5, data);\n      };\n      this.on(types, wrapper);\n      return this;\n    }\n\n    /**\n     * Fires a specific event and calls any listeners of that event type.\n     * @param  {string} type Event type to fire\n     * @param  {Object} data Additional data to fire with the event\n     * @return {EventHandler}      this\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(type, data) {\n      var subtypes = type.split(\":\");\n\n      var fireData = {\n        type: type,\n        target: this\n      };\n\n      Object.assign(fireData, data);\n\n      recursiveFire(this._listeners, subtypes, 0, fireData);\n\n      // To ensure that no error events are dropped, print them to the\n      // console if they have no listeners.\n      // if (!numFires && endsWith(type, \"error\")) {\n      //   console.error((data && data.error) || data || \"Empty error event\")\n      // }\n\n      if (this._eventParent) {\n        fireData = {};\n        Object.getOwnPropertyNames(data).forEach(function (key) {\n          fireData[key] = data[key];\n        });\n        this._eventParent.fire(type, fireData);\n      }\n\n      return this;\n    }\n\n    /**\n     * Returns whether or not this event hander fires a specific event type\n     * @param  {string} type Event type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"listens\",\n    value: function listens(type) {\n      var subtypes = type.split(\":\");\n      var currMap = this._listeners;\n      var data = null;\n      for (var i = 0; i < subtypes.length; i += 1) {\n        data = currMap.get(subtypes[i]);\n        if (!data) {\n          break;\n        }\n        currMap = data[0];\n      }\n      return data || this._eventParent && this._eventParent.listens(type);\n    }\n\n    /**\n     * Sets a parent event handler\n     * @param {EventHandler} parent\n     * @param {object} data\n     */\n\n  }, {\n    key: \"setEventedParent\",\n    value: function setEventedParent(parent, data) {\n      this._eventParent = parent;\n      this._eventParentData = data;\n\n      return this;\n    }\n  }]);\n\n  return EventHandler;\n}();\n\nexports.default = EventHandler;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2V2ZW50LWhhbmRsZXIuanM/MWM0OSJdLCJuYW1lcyI6WyJyZWN1cnNpdmVGaXJlIiwiY3Vyck1hcCIsInN1YnR5cGVzIiwiY3VycklkeCIsImZpcmVEYXRhIiwibGVuZ3RoIiwiY250IiwiZGF0YSIsImdldCIsImZvckVhY2giLCJsaXN0ZW5lciIsImNhbGwiLCJyZWN1cnNpdmVEZWxldGUiLCJjdXJyTm9kZSIsImxpc3RlbmVycyIsImluZGV4Iiwic3Vibm9kZXMiLCJub2RlbGlzdGVuZXJzIiwiaW5kZXhPZiIsInNwbGljZSIsIm5vZGUiLCJhcnJheWlmeSIsImludHlwZSIsImFycmF5VG9Vc2UiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsIkV2ZW50SGFuZGxlciIsImV2ZW50c1RvUmVnaXN0ZXIiLCJpbml0aWFsaXplciIsIl9saXN0ZW5lcnMiLCJNYXAiLCJyZWdpc3RlckV2ZW50cyIsImV2ZW50cyIsImV2ZW50c1RvVXNlIiwic3ViZXZlbnRzIiwiZXZlbnQiLCJzcGxpdCIsImkiLCJzZXQiLCJ0eXBlcyIsInR5cGVzVG9Vc2UiLCJ0eXBlIiwic3VidHlwZSIsImtleXMiLCJ2YWwiLCJrZXkiLCJwdXNoIiwid3JhcHBlciIsIm9mZiIsIm9uIiwidGFyZ2V0IiwiT2JqZWN0IiwiYXNzaWduIiwiX2V2ZW50UGFyZW50IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZpcmUiLCJsaXN0ZW5zIiwicGFyZW50IiwiX2V2ZW50UGFyZW50RGF0YSJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBWUEsU0FBU0EsYUFBVCxDQUF1QkMsT0FBdkIsRUFBZ0NDLFFBQWhDLEVBQTBDQyxPQUExQyxFQUFtREMsUUFBbkQsRUFBNkQ7QUFBQTs7QUFDM0QsTUFBSUQsV0FBV0QsU0FBU0csTUFBeEIsRUFBZ0M7QUFDOUIsV0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBSUMs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RUEsYUFBTyxJQUFQO0FBQ0Q7Ozs7OztrQkE3TGtCb0IsWSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbi8qKlxuICBAdHlwZWRlZiBFdmVudE9iamVjdFxuICBAdHlwZSB7b2JqZWN0fVxuICBAcHJvcGVydHkge3N0cmluZ30gdHlwZSAtIHRoZSB0eXBlIG9mIHRoZSBldmVudFxuICBAcHJvcGVydHkge3N0cmluZ30gdGFyZ2V0IC0gdGhlIHRhcmdldCBvYmplY3QgdGhhdCBmaXJlZCB0aGUgZXZlbnRcbiAvXG5cbi8qKlxuICogVGhpcyBjYWxsYmFjayBpcyBkaXNwbGF5ZWQgYXMgYSBnbG9iYWwgbWVtYmVyLlxuICogQGNhbGxiYWNrIEV2ZW50Q2FsbGJhY2tcbiAqIEBwYXJhbSB7RXZlbnRPYmplY3R9IEV2ZW50IG9iamVjdCBkZXNjcmliaW5nIHRoZSBldmVudCBiZWluZyBmaXJlZFxuICovXG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZmlyZXMgaGllcmFyY2hpY2FsIGV2ZW50cyBmcm9tIGFuIGhhbmRsZXIncyByZWdpc3RlcmVkXG4gKiBldmVudCB0eXBlcy4gRm9yIGV4YW1wbGUsIGlmIGFuIGV2ZW50IGlzIHJlZ2lzdGVyZWQgYXMgXCJjaGFuZ2VkOmNvbG9yXCIsXG4gKiBib3RoIGEgXCJjaGFuZ2VkOmNvbG9yXCIgYW5kIFwiY2hhbmdlZFwiIGV2ZW50IGlzIGZpcmVkLCBzbyBsaXN0ZW5lcnMgd2hvXG4gKiBvbmx5IGdlbmVyaWNhbGx5IGNhcmUgaWYgc29tZXRoaW5nIGNoYW5nZWQgb24gYW4gb2JqZWN0IGNhbiBiZSBub3RpZmllZC5cbiAqIEBwYXJhbSAge01hcH0gY3Vyck1hcCAgbWFwIGRhdGFzdHJ1Y3R1cmUgaG9sZGluZyBhbGwgaGllcmFyY2hpY2FsIGV2ZW50cyBhbmQgY2FsbGJhY2tzXG4gKiBAcGFyYW0gIHtzdHJpbmdbXX0gc3VidHlwZXMgdGhlIFwiOlwiIHNlcGFyYXRlZCBsaXN0IG9mIHRoZSBldmVudFxuICogQHBhcmFtICB7bnVtYmVyfSBjdXJySWR4ICB0aGUgY3VycmVudCBpbmRleCBvZiBzdWJ0eXBlcyBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSAge09iamVjdH0gZmlyZURhdGEgdGhlIGV2ZW50IG9iamVjdCB0byBmaXJlXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgIHRvdGFsIG51bWJlciBvZiBsaXN0ZW5lcnMgY2FsbGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVGaXJlKGN1cnJNYXAsIHN1YnR5cGVzLCBjdXJySWR4LCBmaXJlRGF0YSkge1xuICBpZiAoY3VycklkeCA+PSBzdWJ0eXBlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgbGV0IGNudCA9IDBcbiAgbGV0IGRhdGEgPSBudWxsXG4gIGRhdGEgPSBjdXJyTWFwLmdldChzdWJ0eXBlc1tjdXJySWR4XSlcbiAgaWYgKGRhdGEpIHtcbiAgICBjbnQgPSByZWN1cnNpdmVGaXJlKGRhdGFbMF0sIHN1YnR5cGVzLCBjdXJySWR4ICsgMSwgZmlyZURhdGEpXG4gICAgZGF0YVsxXS5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyLmNhbGwodGhpcywgZmlyZURhdGEpKVxuICAgIGNudCArPSBkYXRhWzFdLmxlbmd0aFxuICB9XG4gIHJldHVybiBjbnRcbn1cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBkZWxldGVzIHNwZWNpZmljIGxpc3RlbmVycyBmcm9tIGEgaGFuZGxlcnMgZXZlbnRcbiAqIGRhdGEgc3RydWN0dXJlLiBGb3IgaW5zdGFuY2UsIGlmIHRoZSBzYW1lIGNhbGxiYWNrIGlzIHVzZWQgZm9yIGJvdGhcbiAqIGEgXCJjaGFuZ2VkXCIgYW5kIGEgXCJjaGFuZ2VkOmNvbG9yXCIgZXZlbnQsIGFuZCB0aGF0IGNhbGxiYWNrIGlzIGRlbGV0ZWRcbiAqIGZyb20gdGhlIFwiY2hhbmdlZFwiIGV2ZW50LCBpdCBpcyBhbHNvIGRlbGV0ZWQgZnJvbSB0aGUgXCJjaGFuZ2VkOmNvbG9yXCIgZXZlbnRcbiAqIEBwYXJhbSAge09iamVjdH0gY3Vyck5vZGUgIEN1cnJlbnQgbm9kZSBvZiB0aGUgbWFwIGRhdGEgc3RydWN0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtICB7ZnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBkZWxldGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZURlbGV0ZShjdXJyTm9kZSwgbGlzdGVuZXJzKSB7XG4gIGxldCBpbmRleCA9IC0xXG4gIGNvbnN0IHN1Ym5vZGVzID0gY3Vyck5vZGVbMF1cbiAgY29uc3Qgbm9kZWxpc3RlbmVycyA9IGN1cnJOb2RlWzFdXG4gIGlmIChub2RlbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgIGxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IHtcbiAgICAgIGlmICgoaW5kZXggPSBub2RlbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpKSA+PSAwKSB7XG4gICAgICAgIG5vZGVsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgc3Vibm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIHJlY3Vyc2l2ZURlbGV0ZShub2RlLCBsaXN0ZW5lcnMpXG4gIH0pXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgYW4gaW5wdXQgaXMgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncywgYW5kIGlmIHRoZSBmb3JtZXJcbiAqIHJldHVybnMgYSAxLWVsZW1lbnQgc3RyaW5nIGFycmF5XG4gKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IGludHlwZVxuICogQHJldHVybiB7c3RyaW5nW119XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcnJheWlmeShpbnR5cGUpIHtcbiAgbGV0IGFycmF5VG9Vc2UgPSBpbnR5cGVcbiAgaWYgKHR5cGVvZiBpbnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBhcnJheVRvVXNlID0gW2ludHlwZV1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpbnR5cGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpXG4gIH1cbiAgcmV0dXJuIGFycmF5VG9Vc2Vcbn1cblxuLyoqIENsYXNzIGZvciBtYW5hZ2luZyBldmVudHMgYW5kIGxpc3RlbmVycy4gQ2FuIGJlIHVzZWQgYXMgYSBiYXNlIGNsYXNzIG9yIGEgbWl4aW4gKHVzaW5nIEBzZWUge0BsaW5rIGFnZ3JlZ2F0aW9ufSkgKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50SGFuZGxlciB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gZXZlbnRzVG9SZWdpc3RlciBpbml0aWFsIGV2ZW50cyB0byByZWdpc3RlclxuICAgKi9cbiAgY29uc3RydWN0b3IoZXZlbnRzVG9SZWdpc3Rlcikge1xuICAgIHRoaXMuaW5pdGlhbGl6ZXIoZXZlbnRzVG9SZWdpc3RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhbiBldmVudCBoYW5kbGVyIG9iamVjdFxuICAgKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IGV2ZW50c1RvUmVnaXN0ZXIgZXZlbnRzIHRvIGluaXRpYWxpemUgZXZlbnQgaGFuZGxlciB3aXRoXG4gICAqIEBzZWUgIHtAbGluayBhZ2dyZWdhdGlvbn1cbiAgICovXG4gIGluaXRpYWxpemVyKGV2ZW50c1RvUmVnaXN0ZXIpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgTWFwKClcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKGV2ZW50c1RvUmVnaXN0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIG5ldyBldmVudHMgZm9yIHRoZSBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gZXZlbnRzIG5ldyBldmVudChzKSB0byByZWdpc3RlclxuICAgKi9cbiAgcmVnaXN0ZXJFdmVudHMoZXZlbnRzKSB7XG4gICAgaWYgKCFldmVudHMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBldmVudHNUb1VzZSA9IGFycmF5aWZ5KGV2ZW50cylcbiAgICBpZiAodHlwZW9mIGV2ZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgZXZlbnRzVG9Vc2UgPSBbZXZlbnRzXVxuICAgIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnRzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXZlbnRzIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiKVxuICAgIH1cblxuICAgIGV2ZW50c1RvVXNlLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc3ViZXZlbnRzID0gZXZlbnQuc3BsaXQoXCI6XCIpXG4gICAgICBsZXQgY3Vyck1hcCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBjdXJyTWFwLmdldChzdWJldmVudHNbaV0pXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBbbmV3IE1hcCgpLCBbXV1cbiAgICAgICAgICBjdXJyTWFwLnNldChzdWJldmVudHNbaV0sIGRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgY3Vyck1hcCA9IGRhdGFbMF1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgbGlzdGVuZXIgdG8gYSBzcGVjaWZpYyBldmVudCBvciBsaXN0IG9mIGRpZmZlcmVudCBldmVudHNcbiAgICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlcyAgICBldmVudChzKSB0aGlzIGxpc3RlbmVyIGlzIGxpc3RlbmluZyB0b1xuICAgKiBAcGFyYW0gIHtFdmVudENhbGxiYWNrfSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiBldmVudHMgZGVzdHJpYmVkIGJ5IHR5cGVzIGlzIGZpcmVkXG4gICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlcn0gICAgICAgICAgdGhpc1xuICAgKi9cbiAgb24odHlwZXMsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgdHlwZXNUb1VzZSA9IGFycmF5aWZ5KHR5cGVzKVxuICAgIHR5cGVzVG9Vc2UuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgIGNvbnN0IHN1YnR5cGVzID0gdHlwZS5zcGxpdChcIjpcIilcbiAgICAgIGxldCBjdXJyTWFwID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgICBsZXQgZGF0YSA9IG51bGxcbiAgICAgIHN1YnR5cGVzLmZvckVhY2goc3VidHlwZSA9PiB7XG4gICAgICAgIGRhdGEgPSBjdXJyTWFwLmdldChzdWJ0eXBlKVxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBjb25zdCBrZXlzID0gW11cbiAgICAgICAgICBjdXJyTWFwLmZvckVhY2goKHZhbCwga2V5KSA9PiBrZXlzLnB1c2goa2V5KSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZX0gaXMgbm90IGEgdmFsaWQgZXZlbnQgdHlwZS4gVGhlIHJlZ2lzdGVyZWQgZXZlbnQgdHlwZXMgYXQgdGhpcyBsZXZlbCBhcmUgWyR7a2V5c31dYClcbiAgICAgICAgfVxuICAgICAgICBjdXJyTWFwID0gZGF0YVswXVxuICAgICAgfSlcbiAgICAgIGlmIChkYXRhWzFdLmluZGV4T2YobGlzdGVuZXIpIDwgMCkge1xuICAgICAgICBkYXRhWzFdLnB1c2gobGlzdGVuZXIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGxpc3RlbmVyIGZyb20gc3BlY2lmaWMgZXZlbnRzXG4gICAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gdHlwZXMgICAgZXZlbnQocykgdGhlIGxpc3RlbmVyIGlzIGJlaW5nIHJlbW92ZWQgZnJvbVxuICAgKiBAcGFyYW0gIHtFdmVudENhbGxiYWNrfSBsaXN0ZW5lciBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjbGVhcmVkIGZyb20gdGhlIHNwZWNpZmllZCBldmVudCB0eXBlc1xuICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZXJ9ICAgICAgICAgIHRoaXNcbiAgICovXG4gIG9mZih0eXBlcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCB0eXBlc1RvVXNlID0gYXJyYXlpZnkodHlwZXMpXG4gICAgbGV0IGxpc3RlbmVycyA9IGxpc3RlbmVyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3RlbmVycykpIHtcbiAgICAgIGxpc3RlbmVycyA9IFtsaXN0ZW5lcl1cbiAgICB9XG4gICAgdHlwZXNUb1VzZS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3Qgc3VidHlwZXMgPSB0eXBlLnNwbGl0KFwiOlwiKVxuICAgICAgbGV0IGN1cnJNYXAgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAgIGxldCBkYXRhID0gbnVsbFxuICAgICAgbGV0IGkgPSAwXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgc3VidHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZGF0YSA9IGN1cnJNYXAuZ2V0KHN1YnR5cGVzW2ldKVxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGN1cnJNYXAgPSBkYXRhWzBdXG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICByZWN1cnNpdmVEZWxldGUoZGF0YSwgbGlzdGVuZXJzKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIGEgbGlzdGVyIGNhbGxiYWNrIHRvIG9ubHkgYmUgY2FsbGVkIG9uY2VcbiAgICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlcyAgICBldmVudChzKSB0aGUgbGlzdGVuZXIgaXMgbGlzdGVuaW5nIHRvXG4gICAqIEBwYXJhbSAge0V2ZW50Q2FsbGJhY2t9IGxpc3RlbmVyIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aXRoIGV2ZW50KHMpIGFyZSBmaXJlZFxuICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZXJ9ICAgICAgICAgIHRoaXNcbiAgICovXG4gIG9uY2UodHlwZXMsIGxpc3RlbmVyKSB7XG4gICAgY29uc3Qgd3JhcHBlciA9IChkYXRhKSA9PiB7XG4gICAgICB0aGlzLm9mZih0eXBlcywgd3JhcHBlcilcbiAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZGF0YSlcbiAgICB9XG4gICAgdGhpcy5vbih0eXBlcywgd3JhcHBlcilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgc3BlY2lmaWMgZXZlbnQgYW5kIGNhbGxzIGFueSBsaXN0ZW5lcnMgb2YgdGhhdCBldmVudCB0eXBlLlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZSB0byBmaXJlXG4gICAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBBZGRpdGlvbmFsIGRhdGEgdG8gZmlyZSB3aXRoIHRoZSBldmVudFxuICAgKiBAcmV0dXJuIHtFdmVudEhhbmRsZXJ9ICAgICAgdGhpc1xuICAgKi9cbiAgZmlyZSh0eXBlLCBkYXRhKSB7XG4gICAgY29uc3Qgc3VidHlwZXMgPSB0eXBlLnNwbGl0KFwiOlwiKVxuXG4gICAgbGV0IGZpcmVEYXRhID0ge1xuICAgICAgdHlwZSxcbiAgICAgIHRhcmdldDogdGhpc1xuICAgIH1cblxuICAgIE9iamVjdC5hc3NpZ24oZmlyZURhdGEsIGRhdGEpXG5cbiAgICByZWN1cnNpdmVGaXJlKHRoaXMuX2xpc3RlbmVycywgc3VidHlwZXMsIDAsIGZpcmVEYXRhKVxuXG4gICAgLy8gVG8gZW5zdXJlIHRoYXQgbm8gZXJyb3IgZXZlbnRzIGFyZSBkcm9wcGVkLCBwcmludCB0aGVtIHRvIHRoZVxuICAgIC8vIGNvbnNvbGUgaWYgdGhleSBoYXZlIG5vIGxpc3RlbmVycy5cbiAgICAvLyBpZiAoIW51bUZpcmVzICYmIGVuZHNXaXRoKHR5cGUsIFwiZXJyb3JcIikpIHtcbiAgICAvLyAgIGNvbnNvbGUuZXJyb3IoKGRhdGEgJiYgZGF0YS5lcnJvcikgfHwgZGF0YSB8fCBcIkVtcHR5IGVycm9yIGV2ZW50XCIpXG4gICAgLy8gfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50UGFyZW50KSB7XG4gICAgICBmaXJlRGF0YSA9IHt9XG4gICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhkYXRhKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGZpcmVEYXRhW2tleV0gPSBkYXRhW2tleV1cbiAgICAgIH0pXG4gICAgICB0aGlzLl9ldmVudFBhcmVudC5maXJlKHR5cGUsIGZpcmVEYXRhKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIGV2ZW50IGhhbmRlciBmaXJlcyBhIHNwZWNpZmljIGV2ZW50IHR5cGVcbiAgICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIEV2ZW50IHR5cGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGxpc3RlbnModHlwZSkge1xuICAgIGNvbnN0IHN1YnR5cGVzID0gdHlwZS5zcGxpdChcIjpcIilcbiAgICBsZXQgY3Vyck1hcCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgIGxldCBkYXRhID0gbnVsbFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VidHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRhdGEgPSBjdXJyTWFwLmdldChzdWJ0eXBlc1tpXSlcbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgY3Vyck1hcCA9IGRhdGFbMF1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGEgfHwgKHRoaXMuX2V2ZW50UGFyZW50ICYmIHRoaXMuX2V2ZW50UGFyZW50Lmxpc3RlbnModHlwZSkpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIHBhcmVudCBldmVudCBoYW5kbGVyXG4gICAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyfSBwYXJlbnRcbiAgICogQHBhcmFtIHtvYmplY3R9IGRhdGFcbiAgICovXG4gIHNldEV2ZW50ZWRQYXJlbnQocGFyZW50LCBkYXRhKSB7XG4gICAgdGhpcy5fZXZlbnRQYXJlbnQgPSBwYXJlbnRcbiAgICB0aGlzLl9ldmVudFBhcmVudERhdGEgPSBkYXRhXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlsL2V2ZW50LWhhbmRsZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventConstants = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _canvasUtils = __webpack_require__(26);\n\nvar CanvasUtils = _interopRequireWildcard(_canvasUtils);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _basicStyle = __webpack_require__(8);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _utils = __webpack_require__(27);\n\nvar _camera2d = __webpack_require__(28);\n\nvar _camera2d2 = _interopRequireDefault(_camera2d);\n\nvar _eventHandler = __webpack_require__(12);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _ResizeSensor = __webpack_require__(29);\n\nvar _ResizeSensor2 = _interopRequireDefault(_ResizeSensor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar mouseevents = [\"mousedown\", \"mouseup\", \"mousemove\", \"click\", \"dblclick\", \"mouseover\", \"mouseout\", \"touchstart\", \"touchend\", \"touchmove\"];\nvar marginProps = [\"top\", \"bottom\", \"left\", \"right\"];\n\nvar EventConstants = exports.EventConstants = {\n  MOUSEDOWN: \"mousedown\",\n  MOUSEUP: \"mouseup\",\n  MOUSEMOVE: \"mousemove\",\n  CLICK: \"click\",\n  DBLCLICK: \"dblclick\",\n  MOUSEOVER: \"mouseover\",\n  MOUSEOUT: \"mouseout\",\n  SHAPE_ADD: \"shape:add\",\n  SHAPE_DELETE: \"shape:delete\",\n  TOUCHSTART: \"touchstart\",\n  TOUCHEND: \"touchend\",\n  TOUCHMOVE: \"touchmove\"\n};\n\nvar DrawStyleState = function (_BasicStyle) {\n  _inherits(DrawStyleState, _BasicStyle);\n\n  function DrawStyleState() {\n    var _ref;\n\n    _classCallCheck(this, DrawStyleState);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = _possibleConstructorReturn(this, (_ref = DrawStyleState.__proto__ || Object.getPrototypeOf(DrawStyleState)).call.apply(_ref, [this].concat(args)));\n\n    _this._defaults = {\n      packedFillColor: _this.packedFillColor,\n      packedStrokeColor: _this.packedStrokeColor,\n      strokeWidth: _this.strokeWidth,\n      lineJoin: _this.lineJoin,\n      lineCap: _this.lineCap,\n      dashPattern: _this.dashPattern,\n      dashOffset: _this.dashOffset\n    };\n    return _this;\n  }\n\n  _createClass(DrawStyleState, [{\n    key: \"setFillStyle\",\n    value: function setFillStyle(ctx, fillStyle) {\n      if (fillStyle.packedFillColor !== this.packedFillColor) {\n        this.packedFillColor = fillStyle.packedFillColor;\n        ctx.fillStyle = this.fillColor;\n      }\n    }\n  }, {\n    key: \"setStrokeStyle\",\n    value: function setStrokeStyle(ctx, strokeStyle) {\n      if (strokeStyle.packedStrokeColor !== this.packedStrokeColor) {\n        this.packedStrokeColor = strokeStyle.packedStrokeColor;\n        ctx.strokeStyle = this.strokeColor;\n      }\n      if (strokeStyle.strokeWidth !== this._strokeWidth) {\n        this.strokeWidth = strokeStyle.strokeWidth;\n        ctx.lineWidth = this._strokeWidth;\n      }\n      if (strokeStyle.lineJoin !== this._lineJoin) {\n        this.lineJoin = strokeStyle.lineJoin;\n        ctx.lineJoin = this._lineJoin;\n      }\n      if (strokeStyle.lineCap !== this._lineCap) {\n        this.lineCap = strokeStyle.lineCap;\n        ctx.lineCap = this._lineCap;\n      }\n\n      var dashPattern = strokeStyle._dashPattern;\n      var diff = false;\n      if (dashPattern.length === this._dashPattern.length) {\n        for (var i = 0; i < dashPattern.length; i += 1) {\n          if (dashPattern[i] !== this._dashPattern[i]) {\n            diff = true;\n            break;\n          }\n        }\n      } else {\n        diff = true;\n      }\n\n      if (diff) {\n        this.dashPattern = dashPattern;\n        ctx.setLineDash(this._dashPattern);\n      }\n\n      if (strokeStyle.dashOffset !== this._dashOffset) {\n        this.dashOffset = strokeStyle.dashOffset;\n        ctx.lineDashOffset = this._dashOffset;\n      }\n    }\n  }, {\n    key: \"applyDefaults\",\n    value: function applyDefaults(ctx) {\n      var _this2 = this;\n\n      Object.getOwnPropertyNames(this._defaults).forEach(function (prop) {\n        _this2[prop] = _this2._defaults[prop];\n      });\n      this.setFillCtx(ctx);\n      this.setStrokeCtx(ctx);\n    }\n  }]);\n\n  return DrawStyleState;\n}(_basicStyle2.default);\n\nfunction addClass(element, className) {\n  if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") < 0) {\n    element.className += (element.className ? \" \" : \"\") + className;\n  }\n}\n\nfunction createCanvas(parent) {\n  var canvasContainer = document.createElement(\"div\");\n  addClass(canvasContainer, \"mapd-draw-canvas-container\");\n\n  var canvas = document.createElement(\"canvas\");\n  var canvasContext = canvas.getContext(\"2d\");\n  var ratio = CanvasUtils.makeCanvasAutoHighDPI(canvasContext);\n  // const ratio = 1\n\n  // add class?\n  addClass(canvas, \"mapd-draw-canvas\");\n  canvas.style.position = \"absolute\";\n  canvas.style.pointerEvents = \"none\";\n\n  canvasContainer.appendChild(canvas);\n\n  // canvas.setAttribute(\"width\", ratio * parent.offsetX)\n  // canvas.setAttribute(\"height\", ratio * parent.offsetY)\n  // parent.insertBefore(canvas, parent.firstChild)\n  parent.appendChild(canvasContainer);\n\n  return {\n    canvasContainer: canvasContainer,\n    canvas: canvas,\n    canvasContext: canvasContext,\n    ratio: ratio\n  };\n}\n\nfunction addShapesToMap(newShapes, existingObjectsMap, currIds, reorderCb, redrawCb) {\n  newShapes.forEach(function (shape) {\n    existingObjectsMap.set(shape, {\n      shapeObj: shape,\n      shapeId: currIds.shapeId,\n      shapeIdx: -1\n    });\n    shape.on([\"changed:order\", \"changed:visibility\", \"changed:style\"], reorderCb);\n    shape.on([\"changed:geom\", \"changed:visibility\", \"changed:xform\"], redrawCb);\n    currIds.shapeId += 1;\n  });\n}\n\nfunction deleteShapesFromMap(shapes, existingObjectsMap, reorderCb, redrawCb) {\n  var idxs = [];\n  shapes.forEach(function (shape) {\n    var shapeInfo = existingObjectsMap.get(shape);\n    if (shapeInfo) {\n      idxs.push(shapeInfo.shapeIdx);\n    }\n    existingObjectsMap.delete(shape);\n    shape.off([\"changed\"], [reorderCb, redrawCb]);\n  });\n  return idxs;\n}\n\nvar DrawEngine = function (_EventHander) {\n  _inherits(DrawEngine, _EventHander);\n\n  function DrawEngine(parent, opts) {\n    _classCallCheck(this, DrawEngine);\n\n    var _this3 = _possibleConstructorReturn(this, (DrawEngine.__proto__ || Object.getPrototypeOf(DrawEngine)).call(this));\n\n    _this3._init(parent, opts);\n    return _this3;\n  }\n\n  _createClass(DrawEngine, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this4 = this;\n\n      this._destroyCanvas();\n\n      if (this._objects) {\n        this._objects.forEach(function (shapeInfo, shape) {\n          shape.off(\"changed\", [_this4._reorderCb, _this4._redrawCb]);\n        });\n        this._objects.clear();\n        this._sortedObjs = [];\n        this._reorderedObjIdxs.clear();\n      }\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(opts) {\n      var width = 0;\n      if (this._parent.offsetWidth) {\n        width = Math.max(width, this._parent.offsetWidth - this._margins.left - this._margins.right);\n      }\n\n      var height = 0;\n      if (this._parent.offsetHeight) {\n        height = Math.max(height, this._parent.offsetHeight - this._margins.top - this._margins.bottom);\n      }\n\n      this._drawCanvas.width = width * this._pixelRatio;\n      this._drawCanvas.height = height * this._pixelRatio;\n\n      this._drawCanvas.style.left = this._margins.left + \"px\";\n      this._drawCanvas.style.top = this._margins.top + \"px\";\n      this._drawCanvas.style.width = width + \"px\";\n      this._drawCanvas.style.height = height + \"px\";\n\n      if (this._camera) {\n        // const currViewport = this._camera.viewport\n        // const currSpace = this._camera.projectionBounds\n        // const viewportExtents = [0, 0]\n        // AABox2d.getExtents(viewportExtents, currViewport)\n        // const spaceCenter = [0, 0]\n        // const spaceExtents = [0, 0]\n        // AABox2d.getCenter(spaceCenter, currSpace)\n        // AABox2d.getExtents(spaceExtents, currSpace)\n        // const ratio = spaceExtents\n        // Vec2d.div(ratio, spaceExtents, viewportExtents)\n        // AABox2d.set(currViewport, 0, 0, width, height)\n        // AABox2d.getExtents(viewportExtents, currViewport)\n        // Vec2d.multiply(spaceExtents, ratio, viewportExtents)\n        // AABox2d.initCenterExtents(currSpace, spaceCenter, spaceExtents)\n        // this._camera.viewport = currViewport\n        // this._camera.projectionBounds = currSpace\n        //   // this._camera.viewport = [0, 0, width, height]\n        //   // this._camera.projectionBounds = [0, 0, width, height]\n      } else {\n        var projDims = opts && opts.projectionDimensions ? opts.projectionDimensions : [width, height];\n        this._camera = new _camera2d2.default([0, 0, width, height], projDims, opts.flipY ? Boolean(opts.flipY) : false);\n        this._camera.setPosition(opts && opts.cameraPosition ? opts.cameraPosition : [width / 2.0, height / 2.0]);\n        this._camera.on(\"changed\", this._rerenderCb);\n      }\n      // this._camera = new Camera2d([0, 0, this.width, this.height], [0, 0, this.width, this.height])\n      // this._camera.on(\"changed\", this._rerenderCb)\n\n      this._rerenderCb();\n    }\n  }, {\n    key: \"_mousedownCB\",\n    value: function _mousedownCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mousedown\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_touchstartCB\",\n    value: function _touchstartCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n      this.fire(\"touchstart\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseupCB\",\n    value: function _mouseupCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseup\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_touchendCB\",\n    value: function _touchendCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"touchend\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mousemoveCB\",\n    value: function _mousemoveCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mousemove\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_touchmoveCB\",\n    value: function _touchmoveCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"touchmove\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_clickCB\",\n    value: function _clickCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"click\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_dblclickCB\",\n    value: function _dblclickCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"dblclick\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseoverCB\",\n    value: function _mouseoverCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseover\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseoutCB\",\n    value: function _mouseoutCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseout\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_enableEvents\",\n    value: function _enableEvents() {\n      this.registerEvents(mouseevents);\n      var callbacks = mouseevents.map(function (event) {\n        return \"_\" + event + \"CB\";\n      });\n      // bindAll(callbacks, this)\n      for (var i = 0; i < mouseevents.length; i += 1) {\n        document.addEventListener(mouseevents[i], this[callbacks[i]], true);\n      }\n    }\n  }, {\n    key: \"_disableEvents\",\n    value: function _disableEvents() {\n      var callbacks = mouseevents.map(function (event) {\n        return \"_\" + event + \"CB\";\n      });\n      for (var i = 0; i < mouseevents.length; i += 1) {\n        document.removeEventListener(mouseevents[i], this[callbacks[i]], true);\n      }\n    }\n  }, {\n    key: \"_initCanvas\",\n    value: function _initCanvas(parent, opts) {\n      var _this5 = this;\n\n      var forceEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this._margins = opts && opts.margins ? Object.assign({}, opts.margins) : {};\n      marginProps.forEach(function (prop) {\n        if (typeof _this5._margins[prop] !== \"number\") {\n          _this5._margins[prop] = 0;\n        }\n      });\n\n      var _createCanvas = createCanvas(parent),\n          canvasContainer = _createCanvas.canvasContainer,\n          canvas = _createCanvas.canvas,\n          canvasContext = _createCanvas.canvasContext,\n          ratio = _createCanvas.ratio;\n\n      this._container = canvasContainer;\n      this._drawCanvas = canvas;\n      this._drawCtx = canvasContext;\n      this._pixelRatio = ratio;\n      this._parent = parent;\n\n      (0, _utils.bindAll)([\"_resize\"], this);\n      this._resize(opts);\n      this._resizeSensor = new _ResizeSensor2.default(parent, this._resize);\n\n      if (forceEvents || forceEvents === null && opts && opts.enableEvents) {\n        this._enableEvents();\n      }\n    }\n  }, {\n    key: \"_destroyCanvas\",\n    value: function _destroyCanvas() {\n      if (this._drawCanvas) {\n        this._disableEvents();\n      }\n\n      if (this._parent) {\n        this._parent.removeChild(this._drawCanvas);\n\n        if (this._resizeSensor) {\n          this._resizeSensor.detach(this._parent, this._resize);\n        }\n      }\n\n      this._drawCanvas = null;\n      this._drawCtx = null;\n      this._parent = null;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(parent, opts) {\n      var forceEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this.registerEvents([EventConstants.SHAPE_ADD, EventConstants.SHAPE_DELETE]);\n\n      (0, _utils.bindAll)([\"_reorderCb\", \"_rerenderCb\"], this);\n      (0, _utils.bindAll)([\"_mousedownCB\", \"_mouseupCB\", \"_mousemoveCB\", \"_clickCB\", \"_dblclickCB\", \"_mouseoverCB\", \"_mouseoutCB\", \"_touchstartCB\", \"_touchendCB\", \"_touchmoveCB\"], this);\n\n      this._renderFrameCb = this.renderAll.bind(this);\n      this._renderRequestId = 0;\n      this._ids = {\n        shapeId: 1\n      };\n\n      this._objects = new Map();\n      this._sortedObjs = [];\n      this._reorderedObjIdxs = new Set();\n\n      this._initCanvas(parent, opts, forceEvents);\n\n      this._styleState = new DrawStyleState({\n        fillColor: \"red\"\n      });\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this._parent;\n    }\n  }, {\n    key: \"getCanvasContainer\",\n    value: function getCanvasContainer() {\n      return this._container;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this._drawCanvas;\n    }\n  }, {\n    key: \"project\",\n    value: function project(out, screenPt) {\n      var screenToWorldMatrix = this._camera.screenToWorldMatrix;\n      return Point2d.transformMat2d(out, screenPt, screenToWorldMatrix);\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(out, worldPt) {\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      return Point2d.transformMat2d(out, worldPt, worldToScreenMatrix);\n    }\n  }, {\n    key: \"hasShape\",\n    value: function hasShape(shape) {\n      return this._objects.has(shape);\n    }\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      addShapesToMap(shapes, this._objects, this._ids, this._reorderCb, this._rerenderCb);\n\n      // fire add event\n      this.fire(\"shape:add\", {\n        shape: shapes\n      });\n\n      var proxyEvent = {\n        target: shapes\n      };\n      this._reorderCb(proxyEvent);\n\n      return this;\n    }\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      var idxs = deleteShapesFromMap(shapes, this._objects, this._reorderCb, this._rerenderCb);\n      var index = -1;\n      for (var i = 0; i < shapes.length; i += 1) {\n        if ((index = this._sortedObjs.indexOf(shapes[i])) >= 0) {\n          this._sortedObjs.splice(index, 1);\n        }\n        this._reorderedObjIdxs.add(idxs[i]);\n      }\n      this._rerenderCb();\n\n      this.fire(\"shape:delete\", {\n        shape: shapes\n      });\n\n      return this;\n    }\n  }, {\n    key: \"deleteAllShapes\",\n    value: function deleteAllShapes() {\n      this.deleteShape(this.sortedShapes.slice());\n      return this;\n    }\n  }, {\n    key: \"moveShapeToTop\",\n    value: function moveShapeToTop(shape) {\n      if (this._objects.has(shape)) {\n        var shapes = this.sortedShapes;\n        var zindex = shapes[shapes.length - 1].zIndex;\n        shape.zIndex = zindex + 1;\n      }\n    }\n  }, {\n    key: \"moveShapeToBack\",\n    value: function moveShapeToBack(shape) {\n      if (this._objects.has(shape)) {\n        var shapes = this.sortedShapes;\n        var zindex = shapes[0].zIndex;\n        shape.zIndex = zindex;\n      }\n    }\n  }, {\n    key: \"getShapesAsJSON\",\n    value: function getShapesAsJSON() {\n      var shapes = this.sortedShapes;\n      return shapes.map(function (shape) {\n        return shape.toJSON();\n      });\n    }\n  }, {\n    key: \"_rerenderCb\",\n    value: function _rerenderCb() {\n      if (this._renderRequestId) {\n        window.cancelAnimationFrame(this._renderRequestId);\n      }\n      this._renderRequestId = window.requestAnimationFrame(this._renderFrameCb);\n    }\n  }, {\n    key: \"_reorderCb\",\n    value: function _reorderCb(event) {\n      var _this6 = this;\n\n      var changedShapes = event.target;\n      if (!Array.isArray(changedShapes)) {\n        changedShapes = [event.target];\n      }\n      changedShapes.forEach(function (changedShape) {\n        console.assert(changedShape, \"A changed event doesn't have an object\");\n        var shapeInfo = _this6._objects.get(changedShape);\n        console.assert(shapeInfo, \"A changed event target isn't in the list of shapes \" + changedShape);\n        if (shapeInfo.shapeIdx < 0) {\n          shapeInfo.shapeIdx = _this6._sortedObjs.push(changedShape) - 1;\n        }\n        _this6._reorderedObjIdxs.add(shapeInfo.shapeIdx);\n      });\n      this._rerenderCb();\n    }\n  }, {\n    key: \"_renderShapes\",\n    value: function _renderShapes(ctx, drawShapes, camera) {\n      var _this7 = this;\n\n      var worldToScreenMat = camera.worldToScreenMatrix;\n      drawShapes.forEach(function (shape) {\n        if (shape.visible) {\n          shape.render(ctx, worldToScreenMat, _this7._styleState);\n        }\n      });\n    }\n  }, {\n    key: \"renderAll\",\n    value: function renderAll() {\n      var ctx = this._drawCtx;\n      // ctx.clearRect(0, 0, this.width, this.height)\n      ctx.clearRect(0, 0, this._drawCanvas.offsetWidth, this._drawCanvas.offsetHeight);\n\n      if (!this._objects.size) {\n        return;\n      }\n\n      ctx.save();\n      var drawShapes = this.sortedShapes;\n      this._styleState.applyDefaults(ctx);\n      this._renderShapes(ctx, drawShapes, this._camera);\n      ctx.restore();\n    }\n  }, {\n    key: \"sortedShapes\",\n    get: function get() {\n      if (this._reorderedObjIdxs.size) {\n        console.assert(this._sortedObjs.length === this._objects.size, \"Size mismatch when rendering objets. Something got out of sync - sorted objs length: \" + this._sortedObjs.length + \", objects length: \" + this._objects.size);\n\n        // if (this._reorderedObjIdxs.length / this._sortedObjs.length > 0.7) {\n        //   // might as well just resort the whole thing over\n        //   this._sortedObjs.sort(shapeInfoCompare)\n        // } else {\n        // }\n\n        this._sortedObjs.sort(_baseShape2.default.shapeCompare);\n        this._reorderedObjIdxs.clear();\n      }\n      return this._sortedObjs;\n    }\n  }, {\n    key: \"margins\",\n    get: function get() {\n      var _this8 = this;\n\n      var rtn = {};\n      marginProps.forEach(function (prop) {\n        rtn[prop] = _this8._margins[prop];\n      });\n      return rtn;\n    },\n    set: function set(margins) {\n      var _this9 = this;\n\n      marginProps.forEach(function (prop) {\n        if (typeof margins[prop] === \"number\" && margins[prop] !== _this9._margins[prop]) {\n          _this9._margins[prop] = margins.prop;\n        }\n      });\n\n      this._resize();\n    }\n  }, {\n    key: \"viewport\",\n    get: function get() {\n      return this._camera.viewport;\n    },\n    set: function set(viewport) {\n      this._camera.viewport = viewport;\n    }\n  }, {\n    key: \"projectionDimensions\",\n    get: function get() {\n      return this._camera.projectionDimensions;\n    },\n    set: function set(projectionDimensions) {\n      this._camera.projectionDimensions = projectionDimensions;\n      return this;\n    }\n  }, {\n    key: \"cameraPosition\",\n    get: function get() {\n      return this._camera.getPosition();\n    },\n    set: function set(pos) {\n      this._camera.setPosition(pos);\n      return this;\n    }\n  }]);\n\n  return DrawEngine;\n}(_eventHandler2.default);\n\nexports.default = DrawEngine;\n\n\nDrawEngine.EventConstants = EventConstants;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvZHJhdy1lbmdpbmUuanM/ZmYwMiJdLCJuYW1lcyI6WyJDYW52YXNVdGlscyIsIlBvaW50MmQiLCJtb3VzZWV2ZW50cyIsIm1hcmdpblByb3BzIiwiRXZlbnRDb25zdGFudHMiLCJNT1VTRURPV04iLCJNT1VTRVVQIiwiTU9VU0VNT1ZFIiwiQ0xJQ0siLCJEQkxDTElDSyIsIk1PVVNFT1ZFUiIsIk1PVVNFT1VUIiwiU0hBUEVfQUREIiwiU0hBUEVfREVMRVRFIiwiVE9VQ0hTVEFSVCIsIlRPVUNIRU5EIiwiVE9VQ0hNT1ZFIiwiRHJhd1N0eWxlU3RhdGUiLCJhcmdzIiwiX2RlZmF1bHRzIiwicGFja2VkRmlsbENvbG9yIiwicGFja2VkU3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImxpbmVKb2luIiwibGluZUNhcCIsImRhc2hQYXR0ZXJuIiwiZGFzaE9mZnNldCIsImN0eCIsImZpbGxTdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZVN0eWxlIiwic3Ryb2tlQ29sb3IiLCJfc3Ryb2tlV2lkdGgiLCJsaW5lV2lkdGgiLCJfbGluZUpvaW4iLCJfbGluZUNhcCIsIl9kYXNoUGF0dGVybiIsImRpZmYiLCJsZW5ndGgiLCJpIiwic2V0TGluZURhc2giLCJfZGFzaE9mZnNldCIsImxpbmVEYXNoT2Zmc2V0IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZvckVhY2giLCJwcm9wIiwic2V0RmlsbEN0eCIsInNldFN0cm9rZUN0eCIsIkJhc2ljU3R5bGUiLCJhZGRDbGFzcyIsImVsZW1lbnQiLCJjbGFzc05hbWUiLCJpbmRleE9mIiwiY3JlYXRlQ2FudmFzIiwicGFyZW50IiwiY2FudmFzQ29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2FudmFzIiwiY2FudmFzQ29udGV4dCIsImdldENvbnRleHQiLCJyYXRpbyIsIm1ha2VDYW52YXNBdXRvSGlnaERQSSIsInN0eWxlIiwicG9zaXRpb24iLCJwb2ludGVyRXZlbnRzIiwiYXBwZW5kQ2hpbGQiLCJhZGRTaGFwZXNUb01hcCIsIm5ld1NoYXBlcyIsImV4aXN0aW5nT2JqZWN0c01hcCIsImN1cnJJZHMiLCJyZW9yZGVyQ2IiLCJyZWRyYXdDYiIsInNldCIsInNoYXBlIiwic2hhcGVPYmoiLCJzaGFwZUlkIiwic2hhcGVJZHgiLCJvbiIsImRlbGV0ZVNoYXBlc0Zyb21NYXAiLCJzaGFwZXMiLCJpZHhzIiwic2hhcGVJbmZvIiwiZ2V0IiwicHVzaCIsImRlbGV0ZSIsIm9mZiIsIkRyYXdFbmdpbmUiLCJvcHRzIiwiX2luaXQiLCJfZGVzdHJveUNhbnZhcyIsIl9vYmplY3RzIiwiX3Jlb3JkZXJDYiIsIl9yZWRyYXdDYiIsImNsZWFyIiwiX3NvcnRlZE9ianMiLCJfcmVvcmRlcmVkT2JqSWR4cyIsIndpZHRoIiwiX3BhcmVudCIsIm9mZnNldFdpZHRoIiwiTWF0aCIsIm1heCIsIl9tYXJnaW5zIiwibGVmdCIsInJpZ2h0IiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwidG9wIiwiYm90dG9tIiwiX2RyYXdDYW52YXMiLCJfcGl4ZWxSYXRpbyIsIl9jYW1lcmEiLCJwcm9qRGltcyIsInByb2plY3Rpb25EaW1lbnNpb25zIiwiQ2FtZXJhMmQiLCJmbGlwWSIsIkJvb2xlYW4iLCJzZXRQb3NpdGlvbiIsImNhbWVyYVBvc2l0aW9uIiwiX3JlcmVuZGVyQ2IiLCJldmVudCIsInRhcmdldCIsImZpcmUiLCJvcmlnaW5hbEV2ZW50IiwicmVnaXN0ZXJFdmVudHMiLCJjYWxsYmFja3MiLCJtYXAiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZvcmNlRXZlbnRzIiwibWFyZ2lucyIsImFzc2lnbiIsIl9jb250YWluZXIiLCJfZHJhd0N0eCIsIl9yZXNpemUiLCJfcmVzaXplU2Vuc29yIiwiUmVzaXplU2Vuc29yIiwiZW5hYmxlRXZlbnRzIiwiX2VuYWJsZUV2ZW50cyIsIl9kaXNhYmxlRXZlbnRzIiwicmVtb3ZlQ2hpbGQiLCJkZXRhY2giLCJfcmVuZGVyRnJhbWVDYiIsInJlbmRlckFsbCIsImJpbmQiLCJfcmVuZGVyUmVxdWVzdElkIiwiX2lkcyIsIk1hcCIsIlNldCIsIl9pbml0Q2FudmFzIiwiX3N0eWxlU3RhdGUiLCJvdXQiLCJzY3JlZW5QdCIsInNjcmVlblRvV29ybGRNYXRyaXgiLCJ0cmFuc2Zvcm1NYXQyZCIsIndvcmxkUHQiLCJ3b3JsZFRvU2NyZWVuTWF0cml4IiwiaGFzIiwiQXJyYXkiLCJpc0FycmF5IiwicHJveHlFdmVudCIsImluZGV4Iiwic3BsaWNlIiwiYWRkIiwiZGVsZXRlU2hhcGUiLCJzb3J0ZWRTaGFwZXMiLCJzbGljZSIsInppbmRleCIsInpJbmRleCIsInRvSlNPTiIsIndpbmRvdyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiY2hhbmdlZFNoYXBlcyIsImNvbnNvbGUiLCJhc3NlcnQiLCJjaGFuZ2VkU2hhcGUiLCJkcmF3U2hhcGVzIiwiY2FtZXJhIiwid29ybGRUb1NjcmVlbk1hdCIsInZpc2libGUiLCJyZW5kZXIiLCJjbGVhclJlY3QiLCJzaXplIiwic2F2ZSIsImFwcGx5RGVmYXVsdHMiLCJfcmVuZGVyU2hhcGVzIiwicmVzdG9yZSIsInNvcnQiLCJCYXNlU2hhcGUiLCJzaGFwZUNvbXBhcmUiLCJydG4iLCJ2aWV3cG9ydCIsImdldFBvc2l0aW9uIiwicG9zIiwiRXZlbnRIYW5kZXIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFFQTs7SUFBWUEsVzs7QUFDWjs7SUFBWUMsTzs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1DLGNBQWMsQ0FBQyxXQUFELEVBQWMsU0FBZCxFQUF5QixXQUF6QixFQUFzQyxPQUF0QyxFQUErQyxVQUEvQyxFQUEyRCxXQUEzRCxFQUF3RSxVQUF4RSxFQUFvRixZQUFwRixFQUFrRyxVQUFsRyxFQUE4RyxXQUE5RyxDQUFwQjtBQUNBLElBQU1DLGNB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QUFDekIsYUFBTyxLQUFLakYsT0FBTCxDQUFhRSxvQkFBcEI7QUFDRCxLO3NCQUV3QkEsb0IsRUFBc0I7QUFDN0MsV0FBS0YsT0FBTCxDQUFhRSxvQkFBYixHQUFvQ0Esb0JBQXBDO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozt3QkFFb0I7QUFDbkIsYUFBTyxLQUFLRixPQUFMLENBQWFrRixXQUFiLEVBQVA7QUFDRCxLO3NCQUVrQkMsRyxFQUFLO0FBQ3RCLFdBQUtuRixPQUFMLENBQWFNLFdBQWIsQ0FBeUI2RSxHQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7O0VBdFVxQ0Msc0I7O2tCQUFuQjVHLFU7OztBQThjckJBLFdBQVdwRixjQUFYLEdBQTRCQSxjQUE1QiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIENhbnZhc1V0aWxzIGZyb20gXCIuLi91dGlsL2NhbnZhcy11dGlsc1wiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi4vc2hhcGVzL2Jhc2Utc2hhcGVcIlxuaW1wb3J0IEJhc2ljU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2Jhc2ljLXN0eWxlXCJcbmltcG9ydCB7XG4gIGJpbmRBbGxcbn0gZnJvbSBcIi4uL3V0aWwvdXRpbHNcIlxuaW1wb3J0IENhbWVyYTJkIGZyb20gXCIuLi92aWV3L2NhbWVyYTJkXCJcbmltcG9ydCBFdmVudEhhbmRlciBmcm9tIFwiLi4vdXRpbC9ldmVudC1oYW5kbGVyXCJcbmltcG9ydCBSZXNpemVTZW5zb3IgZnJvbSBcImNzcy1lbGVtZW50LXF1ZXJpZXMvc3JjL1Jlc2l6ZVNlbnNvclwiXG5cbmNvbnN0IG1vdXNlZXZlbnRzID0gW1wibW91c2Vkb3duXCIsIFwibW91c2V1cFwiLCBcIm1vdXNlbW92ZVwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiLCBcInRvdWNoc3RhcnRcIiwgXCJ0b3VjaGVuZFwiLCBcInRvdWNobW92ZVwiXVxuY29uc3QgbWFyZ2luUHJvcHMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl1cblxuZXhwb3J0IGNvbnN0IEV2ZW50Q29uc3RhbnRzID0ge1xuICBNT1VTRURPV046IFwibW91c2Vkb3duXCIsXG4gIE1PVVNFVVA6IFwibW91c2V1cFwiLFxuICBNT1VTRU1PVkU6IFwibW91c2Vtb3ZlXCIsXG4gIENMSUNLOiBcImNsaWNrXCIsXG4gIERCTENMSUNLOiBcImRibGNsaWNrXCIsXG4gIE1PVVNFT1ZFUjogXCJtb3VzZW92ZXJcIixcbiAgTU9VU0VPVVQ6IFwibW91c2VvdXRcIixcbiAgU0hBUEVfQUREOiBcInNoYXBlOmFkZFwiLFxuICBTSEFQRV9ERUxFVEU6IFwic2hhcGU6ZGVsZXRlXCIsXG4gIFRPVUNIU1RBUlQ6IFwidG91Y2hzdGFydFwiLFxuICBUT1VDSEVORDogXCJ0b3VjaGVuZFwiLFxuICBUT1VDSE1PVkU6IFwidG91Y2htb3ZlXCJcbn1cblxuY2xhc3MgRHJhd1N0eWxlU3RhdGUgZXh0ZW5kcyBCYXNpY1N0eWxlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fZGVmYXVsdHMgPSB7XG4gICAgICBwYWNrZWRGaWxsQ29sb3I6IHRoaXMucGFja2VkRmlsbENvbG9yLFxuICAgICAgcGFja2VkU3Ryb2tlQ29sb3I6IHRoaXMucGFja2VkU3Ryb2tlQ29sb3IsXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgIGxpbmVKb2luOiB0aGlzLmxpbmVKb2luLFxuICAgICAgbGluZUNhcDogdGhpcy5saW5lQ2FwLFxuICAgICAgZGFzaFBhdHRlcm46IHRoaXMuZGFzaFBhdHRlcm4sXG4gICAgICBkYXNoT2Zmc2V0OiB0aGlzLmRhc2hPZmZzZXRcbiAgICB9XG4gIH1cblxuICBzZXRGaWxsU3R5bGUoY3R4LCBmaWxsU3R5bGUpIHtcbiAgICBpZiAoZmlsbFN0eWxlLnBhY2tlZEZpbGxDb2xvciAhPT0gdGhpcy5wYWNrZWRGaWxsQ29sb3IpIHtcbiAgICAgIHRoaXMucGFja2VkRmlsbENvbG9yID0gZmlsbFN0eWxlLnBhY2tlZEZpbGxDb2xvclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbENvbG9yXG4gICAgfVxuICB9XG5cbiAgc2V0U3Ryb2tlU3R5bGUoY3R4LCBzdHJva2VTdHlsZSkge1xuICAgIGlmIChzdHJva2VTdHlsZS5wYWNrZWRTdHJva2VDb2xvciAhPT0gdGhpcy5wYWNrZWRTdHJva2VDb2xvcikge1xuICAgICAgdGhpcy5wYWNrZWRTdHJva2VDb2xvciA9IHN0cm9rZVN0eWxlLnBhY2tlZFN0cm9rZUNvbG9yXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZUNvbG9yXG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZS5zdHJva2VXaWR0aCAhPT0gdGhpcy5fc3Ryb2tlV2lkdGgpIHtcbiAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBzdHJva2VTdHlsZS5zdHJva2VXaWR0aFxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX3N0cm9rZVdpZHRoXG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZS5saW5lSm9pbiAhPT0gdGhpcy5fbGluZUpvaW4pIHtcbiAgICAgIHRoaXMubGluZUpvaW4gPSBzdHJva2VTdHlsZS5saW5lSm9pblxuICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5fbGluZUpvaW5cbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlLmxpbmVDYXAgIT09IHRoaXMuX2xpbmVDYXApIHtcbiAgICAgIHRoaXMubGluZUNhcCA9IHN0cm9rZVN0eWxlLmxpbmVDYXBcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5fbGluZUNhcFxuICAgIH1cblxuICAgIGNvbnN0IGRhc2hQYXR0ZXJuID0gc3Ryb2tlU3R5bGUuX2Rhc2hQYXR0ZXJuXG4gICAgbGV0IGRpZmYgPSBmYWxzZVxuICAgIGlmIChkYXNoUGF0dGVybi5sZW5ndGggPT09IHRoaXMuX2Rhc2hQYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXNoUGF0dGVybi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZGFzaFBhdHRlcm5baV0gIT09IHRoaXMuX2Rhc2hQYXR0ZXJuW2ldKSB7XG4gICAgICAgICAgZGlmZiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZmYgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIHRoaXMuZGFzaFBhdHRlcm4gPSBkYXNoUGF0dGVyblxuICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMuX2Rhc2hQYXR0ZXJuKVxuICAgIH1cblxuICAgIGlmIChzdHJva2VTdHlsZS5kYXNoT2Zmc2V0ICE9PSB0aGlzLl9kYXNoT2Zmc2V0KSB7XG4gICAgICB0aGlzLmRhc2hPZmZzZXQgPSBzdHJva2VTdHlsZS5kYXNoT2Zmc2V0XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0XG4gICAgfVxuICB9XG5cbiAgYXBwbHlEZWZhdWx0cyhjdHgpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9kZWZhdWx0cykuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHRoaXNbcHJvcF0gPSB0aGlzLl9kZWZhdWx0c1twcm9wXVxuICAgIH0pXG4gICAgdGhpcy5zZXRGaWxsQ3R4KGN0eClcbiAgICB0aGlzLnNldFN0cm9rZUN0eChjdHgpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50ICYmIChgICR7ZWxlbWVudC5jbGFzc05hbWV9IGApLmluZGV4T2YoYCAke2NsYXNzTmFtZX0gYCkgPCAwKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgKz0gKGVsZW1lbnQuY2xhc3NOYW1lID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTmFtZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhwYXJlbnQpIHtcbiAgY29uc3QgY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBhZGRDbGFzcyhjYW52YXNDb250YWluZXIsIFwibWFwZC1kcmF3LWNhbnZhcy1jb250YWluZXJcIilcblxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpXG4gIGNvbnN0IGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gIGNvbnN0IHJhdGlvID0gQ2FudmFzVXRpbHMubWFrZUNhbnZhc0F1dG9IaWdoRFBJKGNhbnZhc0NvbnRleHQpXG4gIC8vIGNvbnN0IHJhdGlvID0gMVxuXG4gIC8vIGFkZCBjbGFzcz9cbiAgYWRkQ2xhc3MoY2FudmFzLCBcIm1hcGQtZHJhdy1jYW52YXNcIilcbiAgY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiXG4gIGNhbnZhcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCJcblxuICBjYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKVxuXG4gIC8vIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByYXRpbyAqIHBhcmVudC5vZmZzZXRYKVxuICAvLyBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHJhdGlvICogcGFyZW50Lm9mZnNldFkpXG4gIC8vIHBhcmVudC5pbnNlcnRCZWZvcmUoY2FudmFzLCBwYXJlbnQuZmlyc3RDaGlsZClcbiAgcGFyZW50LmFwcGVuZENoaWxkKGNhbnZhc0NvbnRhaW5lcilcblxuICByZXR1cm4ge1xuICAgIGNhbnZhc0NvbnRhaW5lcixcbiAgICBjYW52YXMsXG4gICAgY2FudmFzQ29udGV4dCxcbiAgICByYXRpb1xuICB9XG59XG5cblxuZnVuY3Rpb24gYWRkU2hhcGVzVG9NYXAobmV3U2hhcGVzLCBleGlzdGluZ09iamVjdHNNYXAsIGN1cnJJZHMsIHJlb3JkZXJDYiwgcmVkcmF3Q2IpIHtcbiAgbmV3U2hhcGVzLmZvckVhY2goc2hhcGUgPT4ge1xuICAgIGV4aXN0aW5nT2JqZWN0c01hcC5zZXQoc2hhcGUsIHtcbiAgICAgIHNoYXBlT2JqOiBzaGFwZSxcbiAgICAgIHNoYXBlSWQ6IGN1cnJJZHMuc2hhcGVJZCxcbiAgICAgIHNoYXBlSWR4OiAtMVxuICAgIH0pXG4gICAgc2hhcGUub24oW1wiY2hhbmdlZDpvcmRlclwiLCBcImNoYW5nZWQ6dmlzaWJpbGl0eVwiLCBcImNoYW5nZWQ6c3R5bGVcIl0sIHJlb3JkZXJDYilcbiAgICBzaGFwZS5vbihbXCJjaGFuZ2VkOmdlb21cIiwgXCJjaGFuZ2VkOnZpc2liaWxpdHlcIiwgXCJjaGFuZ2VkOnhmb3JtXCJdLCByZWRyYXdDYilcbiAgICBjdXJySWRzLnNoYXBlSWQgKz0gMVxuICB9KVxufVxuXG5mdW5jdGlvbiBkZWxldGVTaGFwZXNGcm9tTWFwKHNoYXBlcywgZXhpc3RpbmdPYmplY3RzTWFwLCByZW9yZGVyQ2IsIHJlZHJhd0NiKSB7XG4gIGNvbnN0IGlkeHMgPSBbXVxuICBzaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgY29uc3Qgc2hhcGVJbmZvID0gZXhpc3RpbmdPYmplY3RzTWFwLmdldChzaGFwZSlcbiAgICBpZiAoc2hhcGVJbmZvKSB7XG4gICAgICBpZHhzLnB1c2goc2hhcGVJbmZvLnNoYXBlSWR4KVxuICAgIH1cbiAgICBleGlzdGluZ09iamVjdHNNYXAuZGVsZXRlKHNoYXBlKVxuICAgIHNoYXBlLm9mZihbXCJjaGFuZ2VkXCJdLCBbcmVvcmRlckNiLCByZWRyYXdDYl0pXG4gIH0pXG4gIHJldHVybiBpZHhzXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERyYXdFbmdpbmUgZXh0ZW5kcyBFdmVudEhhbmRlciB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCwgb3B0cykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pbml0KHBhcmVudCwgb3B0cylcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fZGVzdHJveUNhbnZhcygpXG5cbiAgICBpZiAodGhpcy5fb2JqZWN0cykge1xuICAgICAgdGhpcy5fb2JqZWN0cy5mb3JFYWNoKChzaGFwZUluZm8sIHNoYXBlKSA9PiB7XG4gICAgICAgIHNoYXBlLm9mZihcImNoYW5nZWRcIiwgW3RoaXMuX3Jlb3JkZXJDYiwgdGhpcy5fcmVkcmF3Q2JdKVxuICAgICAgfSlcbiAgICAgIHRoaXMuX29iamVjdHMuY2xlYXIoKVxuICAgICAgdGhpcy5fc29ydGVkT2JqcyA9IFtdXG4gICAgICB0aGlzLl9yZW9yZGVyZWRPYmpJZHhzLmNsZWFyKClcbiAgICB9XG4gIH1cblxuICBfcmVzaXplKG9wdHMpIHtcbiAgICBsZXQgd2lkdGggPSAwXG4gICAgaWYgKHRoaXMuX3BhcmVudC5vZmZzZXRXaWR0aCkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heCh3aWR0aCwgdGhpcy5fcGFyZW50Lm9mZnNldFdpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodClcbiAgICB9XG5cbiAgICBsZXQgaGVpZ2h0ID0gMFxuICAgIGlmICh0aGlzLl9wYXJlbnQub2Zmc2V0SGVpZ2h0KSB7XG4gICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHRoaXMuX3BhcmVudC5vZmZzZXRIZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tKVxuICAgIH1cblxuICAgIHRoaXMuX2RyYXdDYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMuX3BpeGVsUmF0aW9cbiAgICB0aGlzLl9kcmF3Q2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMuX3BpeGVsUmF0aW9cblxuICAgIHRoaXMuX2RyYXdDYW52YXMuc3R5bGUubGVmdCA9IGAke3RoaXMuX21hcmdpbnMubGVmdH1weGBcbiAgICB0aGlzLl9kcmF3Q2FudmFzLnN0eWxlLnRvcCA9IGAke3RoaXMuX21hcmdpbnMudG9wfXB4YFxuICAgIHRoaXMuX2RyYXdDYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGBcbiAgICB0aGlzLl9kcmF3Q2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGBcblxuICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcbiAgICAgIC8vIGNvbnN0IGN1cnJWaWV3cG9ydCA9IHRoaXMuX2NhbWVyYS52aWV3cG9ydFxuICAgICAgLy8gY29uc3QgY3VyclNwYWNlID0gdGhpcy5fY2FtZXJhLnByb2plY3Rpb25Cb3VuZHNcbiAgICAgIC8vIGNvbnN0IHZpZXdwb3J0RXh0ZW50cyA9IFswLCAwXVxuICAgICAgLy8gQUFCb3gyZC5nZXRFeHRlbnRzKHZpZXdwb3J0RXh0ZW50cywgY3VyclZpZXdwb3J0KVxuICAgICAgLy8gY29uc3Qgc3BhY2VDZW50ZXIgPSBbMCwgMF1cbiAgICAgIC8vIGNvbnN0IHNwYWNlRXh0ZW50cyA9IFswLCAwXVxuICAgICAgLy8gQUFCb3gyZC5nZXRDZW50ZXIoc3BhY2VDZW50ZXIsIGN1cnJTcGFjZSlcbiAgICAgIC8vIEFBQm94MmQuZ2V0RXh0ZW50cyhzcGFjZUV4dGVudHMsIGN1cnJTcGFjZSlcbiAgICAgIC8vIGNvbnN0IHJhdGlvID0gc3BhY2VFeHRlbnRzXG4gICAgICAvLyBWZWMyZC5kaXYocmF0aW8sIHNwYWNlRXh0ZW50cywgdmlld3BvcnRFeHRlbnRzKVxuICAgICAgLy8gQUFCb3gyZC5zZXQoY3VyclZpZXdwb3J0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KVxuICAgICAgLy8gQUFCb3gyZC5nZXRFeHRlbnRzKHZpZXdwb3J0RXh0ZW50cywgY3VyclZpZXdwb3J0KVxuICAgICAgLy8gVmVjMmQubXVsdGlwbHkoc3BhY2VFeHRlbnRzLCByYXRpbywgdmlld3BvcnRFeHRlbnRzKVxuICAgICAgLy8gQUFCb3gyZC5pbml0Q2VudGVyRXh0ZW50cyhjdXJyU3BhY2UsIHNwYWNlQ2VudGVyLCBzcGFjZUV4dGVudHMpXG4gICAgICAvLyB0aGlzLl9jYW1lcmEudmlld3BvcnQgPSBjdXJyVmlld3BvcnRcbiAgICAgIC8vIHRoaXMuX2NhbWVyYS5wcm9qZWN0aW9uQm91bmRzID0gY3VyclNwYWNlXG4gICAgICAvLyAgIC8vIHRoaXMuX2NhbWVyYS52aWV3cG9ydCA9IFswLCAwLCB3aWR0aCwgaGVpZ2h0XVxuICAgICAgLy8gICAvLyB0aGlzLl9jYW1lcmEucHJvamVjdGlvbkJvdW5kcyA9IFswLCAwLCB3aWR0aCwgaGVpZ2h0XVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm9qRGltcyA9IChvcHRzICYmIG9wdHMucHJvamVjdGlvbkRpbWVuc2lvbnMgPyBvcHRzLnByb2plY3Rpb25EaW1lbnNpb25zIDogW3dpZHRoLCBoZWlnaHRdKVxuICAgICAgdGhpcy5fY2FtZXJhID0gbmV3IENhbWVyYTJkKFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgcHJvakRpbXMsIChvcHRzLmZsaXBZID8gQm9vbGVhbihvcHRzLmZsaXBZKSA6IGZhbHNlKSlcbiAgICAgIHRoaXMuX2NhbWVyYS5zZXRQb3NpdGlvbigob3B0cyAmJiBvcHRzLmNhbWVyYVBvc2l0aW9uID8gb3B0cy5jYW1lcmFQb3NpdGlvbiA6IFt3aWR0aCAvIDIuMCwgaGVpZ2h0IC8gMi4wXSkpXG4gICAgICB0aGlzLl9jYW1lcmEub24oXCJjaGFuZ2VkXCIsIHRoaXMuX3JlcmVuZGVyQ2IpXG4gICAgfVxuICAgIC8vIHRoaXMuX2NhbWVyYSA9IG5ldyBDYW1lcmEyZChbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdLCBbMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdKVxuICAgIC8vIHRoaXMuX2NhbWVyYS5vbihcImNoYW5nZWRcIiwgdGhpcy5fcmVyZW5kZXJDYilcblxuICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuICB9XG5cbiAgX21vdXNlZG93bkNCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJtb3VzZWRvd25cIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX3RvdWNoc3RhcnRDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuZmlyZShcInRvdWNoc3RhcnRcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX21vdXNldXBDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwibW91c2V1cFwiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfdG91Y2hlbmRDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwidG91Y2hlbmRcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX21vdXNlbW92ZUNCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJtb3VzZW1vdmVcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX3RvdWNobW92ZUNCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJ0b3VjaG1vdmVcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX2NsaWNrQ0IoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmlyZShcImNsaWNrXCIsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIF9kYmxjbGlja0NCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJkYmxjbGlja1wiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfbW91c2VvdmVyQ0IoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmlyZShcIm1vdXNlb3ZlclwiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfbW91c2VvdXRDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwibW91c2VvdXRcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX2VuYWJsZUV2ZW50cygpIHtcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKG1vdXNlZXZlbnRzKVxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IG1vdXNlZXZlbnRzLm1hcChldmVudCA9PiBgXyR7ZXZlbnR9Q0JgKVxuICAgIC8vIGJpbmRBbGwoY2FsbGJhY2tzLCB0aGlzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW91c2VldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobW91c2VldmVudHNbaV0sIHRoaXNbY2FsbGJhY2tzW2ldXSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBfZGlzYWJsZUV2ZW50cygpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBtb3VzZWV2ZW50cy5tYXAoZXZlbnQgPT4gYF8ke2V2ZW50fUNCYClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vdXNlZXZlbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKG1vdXNlZXZlbnRzW2ldLCB0aGlzW2NhbGxiYWNrc1tpXV0sIHRydWUpXG4gICAgfVxuICB9XG5cbiAgX2luaXRDYW52YXMocGFyZW50LCBvcHRzLCBmb3JjZUV2ZW50cyA9IG51bGwpIHtcbiAgICB0aGlzLl9tYXJnaW5zID0gKG9wdHMgJiYgb3B0cy5tYXJnaW5zID8gT2JqZWN0LmFzc2lnbih7fSwgb3B0cy5tYXJnaW5zKSA6IHt9KVxuICAgIG1hcmdpblByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX21hcmdpbnNbcHJvcF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5fbWFyZ2luc1twcm9wXSA9IDBcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzQ29udGFpbmVyLFxuICAgICAgY2FudmFzLFxuICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgIHJhdGlvXG4gICAgfSA9IGNyZWF0ZUNhbnZhcyhwYXJlbnQpXG5cbiAgICB0aGlzLl9jb250YWluZXIgPSBjYW52YXNDb250YWluZXJcbiAgICB0aGlzLl9kcmF3Q2FudmFzID0gY2FudmFzXG4gICAgdGhpcy5fZHJhd0N0eCA9IGNhbnZhc0NvbnRleHRcbiAgICB0aGlzLl9waXhlbFJhdGlvID0gcmF0aW9cbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcblxuICAgIGJpbmRBbGwoW1wiX3Jlc2l6ZVwiXSwgdGhpcylcbiAgICB0aGlzLl9yZXNpemUob3B0cylcbiAgICB0aGlzLl9yZXNpemVTZW5zb3IgPSBuZXcgUmVzaXplU2Vuc29yKHBhcmVudCwgdGhpcy5fcmVzaXplKVxuXG4gICAgaWYgKGZvcmNlRXZlbnRzIHx8IChmb3JjZUV2ZW50cyA9PT0gbnVsbCAmJiBvcHRzICYmIG9wdHMuZW5hYmxlRXZlbnRzKSkge1xuICAgICAgdGhpcy5fZW5hYmxlRXZlbnRzKClcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveUNhbnZhcygpIHtcbiAgICBpZiAodGhpcy5fZHJhd0NhbnZhcykge1xuICAgICAgdGhpcy5fZGlzYWJsZUV2ZW50cygpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5fcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuX2RyYXdDYW52YXMpXG5cbiAgICAgIGlmICh0aGlzLl9yZXNpemVTZW5zb3IpIHtcbiAgICAgICAgdGhpcy5fcmVzaXplU2Vuc29yLmRldGFjaCh0aGlzLl9wYXJlbnQsIHRoaXMuX3Jlc2l6ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kcmF3Q2FudmFzID0gbnVsbFxuICAgIHRoaXMuX2RyYXdDdHggPSBudWxsXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICB9XG5cbiAgX2luaXQocGFyZW50LCBvcHRzLCBmb3JjZUV2ZW50cyA9IG51bGwpIHtcbiAgICB0aGlzLnJlZ2lzdGVyRXZlbnRzKFtFdmVudENvbnN0YW50cy5TSEFQRV9BREQsIEV2ZW50Q29uc3RhbnRzLlNIQVBFX0RFTEVURV0pXG5cbiAgICBiaW5kQWxsKFtcIl9yZW9yZGVyQ2JcIiwgXCJfcmVyZW5kZXJDYlwiXSwgdGhpcylcbiAgICBiaW5kQWxsKFtcIl9tb3VzZWRvd25DQlwiLCBcIl9tb3VzZXVwQ0JcIiwgXCJfbW91c2Vtb3ZlQ0JcIiwgXCJfY2xpY2tDQlwiLCBcIl9kYmxjbGlja0NCXCIsIFwiX21vdXNlb3ZlckNCXCIsIFwiX21vdXNlb3V0Q0JcIiwgXCJfdG91Y2hzdGFydENCXCIsIFwiX3RvdWNoZW5kQ0JcIiwgXCJfdG91Y2htb3ZlQ0JcIl0sIHRoaXMpXG5cbiAgICB0aGlzLl9yZW5kZXJGcmFtZUNiID0gdGhpcy5yZW5kZXJBbGwuYmluZCh0aGlzKVxuICAgIHRoaXMuX3JlbmRlclJlcXVlc3RJZCA9IDBcbiAgICB0aGlzLl9pZHMgPSB7XG4gICAgICBzaGFwZUlkOiAxXG4gICAgfVxuXG4gICAgdGhpcy5fb2JqZWN0cyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX3NvcnRlZE9ianMgPSBbXVxuICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMgPSBuZXcgU2V0KClcblxuICAgIHRoaXMuX2luaXRDYW52YXMocGFyZW50LCBvcHRzLCBmb3JjZUV2ZW50cylcblxuICAgIHRoaXMuX3N0eWxlU3RhdGUgPSBuZXcgRHJhd1N0eWxlU3RhdGUoe1xuICAgICAgZmlsbENvbG9yOiBcInJlZFwiXG4gICAgfSlcbiAgfVxuXG4gIGdldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50XG4gIH1cblxuICBnZXRDYW52YXNDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lclxuICB9XG5cbiAgZ2V0Q2FudmFzKCkge1xuICAgIHJldHVybiB0aGlzLl9kcmF3Q2FudmFzXG4gIH1cblxuICBnZXQgc29ydGVkU2hhcGVzKCkge1xuICAgIGlmICh0aGlzLl9yZW9yZGVyZWRPYmpJZHhzLnNpemUpIHtcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KHRoaXMuX3NvcnRlZE9ianMubGVuZ3RoID09PSB0aGlzLl9vYmplY3RzLnNpemUsXG4gICAgICAgICAgYFNpemUgbWlzbWF0Y2ggd2hlbiByZW5kZXJpbmcgb2JqZXRzLiBTb21ldGhpbmcgZ290IG91dCBvZiBzeW5jIC0gc29ydGVkIG9ianMgbGVuZ3RoOiAke3RoaXMuX3NvcnRlZE9ianMubGVuZ3RofSwgb2JqZWN0cyBsZW5ndGg6ICR7dGhpcy5fb2JqZWN0cy5zaXplfWApXG5cbiAgICAgIC8vIGlmICh0aGlzLl9yZW9yZGVyZWRPYmpJZHhzLmxlbmd0aCAvIHRoaXMuX3NvcnRlZE9ianMubGVuZ3RoID4gMC43KSB7XG4gICAgICAvLyAgIC8vIG1pZ2h0IGFzIHdlbGwganVzdCByZXNvcnQgdGhlIHdob2xlIHRoaW5nIG92ZXJcbiAgICAgIC8vICAgdGhpcy5fc29ydGVkT2Jqcy5zb3J0KHNoYXBlSW5mb0NvbXBhcmUpXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gfVxuXG4gICAgICB0aGlzLl9zb3J0ZWRPYmpzLnNvcnQoQmFzZVNoYXBlLnNoYXBlQ29tcGFyZSlcbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuY2xlYXIoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc29ydGVkT2Jqc1xuICB9XG5cbiAgZ2V0IG1hcmdpbnMoKSB7XG4gICAgY29uc3QgcnRuID0ge31cbiAgICBtYXJnaW5Qcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcnRuW3Byb3BdID0gdGhpcy5fbWFyZ2luc1twcm9wXVxuICAgIH0pXG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbiAgc2V0IG1hcmdpbnMobWFyZ2lucykge1xuICAgIG1hcmdpblByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1hcmdpbnNbcHJvcF0gPT09IFwibnVtYmVyXCIgJiYgbWFyZ2luc1twcm9wXSAhPT0gdGhpcy5fbWFyZ2luc1twcm9wXSkge1xuICAgICAgICB0aGlzLl9tYXJnaW5zW3Byb3BdID0gbWFyZ2lucy5wcm9wXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuX3Jlc2l6ZSgpXG4gIH1cblxuICBnZXQgdmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYS52aWV3cG9ydFxuICB9XG5cbiAgc2V0IHZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgdGhpcy5fY2FtZXJhLnZpZXdwb3J0ID0gdmlld3BvcnRcbiAgfVxuXG4gIGdldCBwcm9qZWN0aW9uRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FtZXJhLnByb2plY3Rpb25EaW1lbnNpb25zXG4gIH1cblxuICBzZXQgcHJvamVjdGlvbkRpbWVuc2lvbnMocHJvamVjdGlvbkRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLl9jYW1lcmEucHJvamVjdGlvbkRpbWVuc2lvbnMgPSBwcm9qZWN0aW9uRGltZW5zaW9uc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgY2FtZXJhUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbWVyYS5nZXRQb3NpdGlvbigpXG4gIH1cblxuICBzZXQgY2FtZXJhUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy5fY2FtZXJhLnNldFBvc2l0aW9uKHBvcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJvamVjdChvdXQsIHNjcmVlblB0KSB7XG4gICAgY29uc3Qgc2NyZWVuVG9Xb3JsZE1hdHJpeCA9IHRoaXMuX2NhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4XG4gICAgcmV0dXJuIFBvaW50MmQudHJhbnNmb3JtTWF0MmQob3V0LCBzY3JlZW5QdCwgc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgfVxuXG4gIHVucHJvamVjdChvdXQsIHdvcmxkUHQpIHtcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICByZXR1cm4gUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChvdXQsIHdvcmxkUHQsIHdvcmxkVG9TY3JlZW5NYXRyaXgpXG4gIH1cblxuICBoYXNTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiB0aGlzLl9vYmplY3RzLmhhcyhzaGFwZSlcbiAgfVxuXG4gIGFkZFNoYXBlKHNoYXBlKSB7XG4gICAgbGV0IHNoYXBlcyA9IHNoYXBlXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNoYXBlcykpIHtcbiAgICAgIHNoYXBlcyA9IFtzaGFwZV1cbiAgICB9XG5cbiAgICBhZGRTaGFwZXNUb01hcChzaGFwZXMsIHRoaXMuX29iamVjdHMsIHRoaXMuX2lkcywgdGhpcy5fcmVvcmRlckNiLCB0aGlzLl9yZXJlbmRlckNiKVxuXG4gICAgLy8gZmlyZSBhZGQgZXZlbnRcbiAgICB0aGlzLmZpcmUoXCJzaGFwZTphZGRcIiwge1xuICAgICAgc2hhcGU6IHNoYXBlc1xuICAgIH0pXG5cbiAgICBjb25zdCBwcm94eUV2ZW50ID0ge1xuICAgICAgdGFyZ2V0OiBzaGFwZXNcbiAgICB9XG4gICAgdGhpcy5fcmVvcmRlckNiKHByb3h5RXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZGVsZXRlU2hhcGUoc2hhcGUpIHtcbiAgICBsZXQgc2hhcGVzID0gc2hhcGVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuICAgICAgc2hhcGVzID0gW3NoYXBlXVxuICAgIH1cblxuICAgIGNvbnN0IGlkeHMgPSBkZWxldGVTaGFwZXNGcm9tTWFwKHNoYXBlcywgdGhpcy5fb2JqZWN0cywgdGhpcy5fcmVvcmRlckNiLCB0aGlzLl9yZXJlbmRlckNiKVxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmICgoaW5kZXggPSB0aGlzLl9zb3J0ZWRPYmpzLmluZGV4T2Yoc2hhcGVzW2ldKSkgPj0gMCkge1xuICAgICAgICB0aGlzLl9zb3J0ZWRPYmpzLnNwbGljZShpbmRleCwgMSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuYWRkKGlkeHNbaV0pXG4gICAgfVxuICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuXG4gICAgdGhpcy5maXJlKFwic2hhcGU6ZGVsZXRlXCIsIHtcbiAgICAgIHNoYXBlOiBzaGFwZXNcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRlbGV0ZUFsbFNoYXBlcygpIHtcbiAgICB0aGlzLmRlbGV0ZVNoYXBlKHRoaXMuc29ydGVkU2hhcGVzLnNsaWNlKCkpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG1vdmVTaGFwZVRvVG9wKHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX29iamVjdHMuaGFzKHNoYXBlKSkge1xuICAgICAgY29uc3Qgc2hhcGVzID0gdGhpcy5zb3J0ZWRTaGFwZXNcbiAgICAgIGNvbnN0IHppbmRleCA9IHNoYXBlc1tzaGFwZXMubGVuZ3RoIC0gMV0uekluZGV4XG4gICAgICBzaGFwZS56SW5kZXggPSB6aW5kZXggKyAxXG4gICAgfVxuICB9XG5cbiAgbW92ZVNoYXBlVG9CYWNrKHNoYXBlKSB7XG4gICAgaWYgKHRoaXMuX29iamVjdHMuaGFzKHNoYXBlKSkge1xuICAgICAgY29uc3Qgc2hhcGVzID0gdGhpcy5zb3J0ZWRTaGFwZXNcbiAgICAgIGNvbnN0IHppbmRleCA9IHNoYXBlc1swXS56SW5kZXhcbiAgICAgIHNoYXBlLnpJbmRleCA9IHppbmRleFxuICAgIH1cbiAgfVxuXG4gIGdldFNoYXBlc0FzSlNPTigpIHtcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIHJldHVybiBzaGFwZXMubWFwKHNoYXBlID0+IHNoYXBlLnRvSlNPTigpKVxuICB9XG5cbiAgX3JlcmVuZGVyQ2IoKSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclJlcXVlc3RJZCkge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlclJlcXVlc3RJZClcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyUmVxdWVzdElkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNiKVxuICB9XG5cbiAgX3Jlb3JkZXJDYihldmVudCkge1xuICAgIGxldCBjaGFuZ2VkU2hhcGVzID0gZXZlbnQudGFyZ2V0XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5nZWRTaGFwZXMpKSB7XG4gICAgICBjaGFuZ2VkU2hhcGVzID0gW2V2ZW50LnRhcmdldF1cbiAgICB9XG4gICAgY2hhbmdlZFNoYXBlcy5mb3JFYWNoKGNoYW5nZWRTaGFwZSA9PiB7XG4gICAgICBjb25zb2xlLmFzc2VydChjaGFuZ2VkU2hhcGUsIFwiQSBjaGFuZ2VkIGV2ZW50IGRvZXNuJ3QgaGF2ZSBhbiBvYmplY3RcIilcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KGNoYW5nZWRTaGFwZSlcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KHNoYXBlSW5mbywgYEEgY2hhbmdlZCBldmVudCB0YXJnZXQgaXNuJ3QgaW4gdGhlIGxpc3Qgb2Ygc2hhcGVzICR7Y2hhbmdlZFNoYXBlfWApXG4gICAgICBpZiAoc2hhcGVJbmZvLnNoYXBlSWR4IDwgMCkge1xuICAgICAgICBzaGFwZUluZm8uc2hhcGVJZHggPSB0aGlzLl9zb3J0ZWRPYmpzLnB1c2goY2hhbmdlZFNoYXBlKSAtIDFcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuYWRkKHNoYXBlSW5mby5zaGFwZUlkeClcbiAgICB9KVxuICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuICB9XG5cbiAgX3JlbmRlclNoYXBlcyhjdHgsIGRyYXdTaGFwZXMsIGNhbWVyYSkge1xuICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXQgPSBjYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgIGRyYXdTaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICBpZiAoc2hhcGUudmlzaWJsZSkge1xuICAgICAgICBzaGFwZS5yZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCB0aGlzLl9zdHlsZVN0YXRlKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICByZW5kZXJBbGwoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZHJhd0N0eFxuICAgIC8vIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9kcmF3Q2FudmFzLm9mZnNldFdpZHRoLCB0aGlzLl9kcmF3Q2FudmFzLm9mZnNldEhlaWdodClcblxuICAgIGlmICghdGhpcy5fb2JqZWN0cy5zaXplKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpXG4gICAgY29uc3QgZHJhd1NoYXBlcyA9IHRoaXMuc29ydGVkU2hhcGVzXG4gICAgdGhpcy5fc3R5bGVTdGF0ZS5hcHBseURlZmF1bHRzKGN0eClcbiAgICB0aGlzLl9yZW5kZXJTaGFwZXMoY3R4LCBkcmF3U2hhcGVzLCB0aGlzLl9jYW1lcmEpXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG59XG5cbkRyYXdFbmdpbmUuRXZlbnRDb25zdGFudHMgPSBFdmVudENvbnN0YW50c1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZW5naW5lL2RyYXctZW5naW5lLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

	eval("/* eslint-disable */\n// Copyright 2001 softSurfer, 2012 Dan Sunday\n// This code may be freely used and modified for any purpose\n// providing that this copyright notice is included with it.\n// SoftSurfer makes no warranty for this code, and cannot be held\n// liable for any real or imagined damage resulting from its use.\n// Users of this code must verify correctness for their application.\n\n// from http://geomalgorithms.com/a12-_hull-3.html\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleHull_2D = simpleHull_2D;\nvar X = 0;\nvar Y = 1;\n\n/**\n * Test if a point is Left|On|Right of an infinite line.\n * @param  {Point2d}  P0 [description]\n * @param  {Point2d}  P1 [description]\n * @param  {Point2d}  P2 [description]\n * @return {Boolean}  Returns > 0 if P2 is left of the line thru P0 & P1,\n *                    Returns < 0 if P2 is to the right\n *                    Returns 0 if P2 is on the line\n */\nfunction isLeft(P0, P1, P2) {\n  return (P1[X] - P0[X]) * (P2[Y] - P0[Y]) - (P2[X] - P0[X]) * (P1[Y] - P0[Y]);\n}\n\n/**\n * Melkman's 2D simple polyline O(n) convex hull algorithm\n * @param  {Point2d[]} verts [description]\n * @return {number[]}       [description]\n */\nfunction simpleHull_2D(verts) {\n  // initialize a deque D[] from bottom to top so that the\n  // 1st three vertices of P[] are a ccw triangle\n  var H = [];\n  var n = verts.length;\n\n  if (n < 3) {\n    for (var i = 0; i < n; i += 1) {\n      H[i] = i;\n    }\n    return H;\n  }\n\n  var D = new Array(2 * n + 1);\n  D.fill(-1);\n  var bot = n - 2;\n  var top = bot + 3; // initial bottom and top deque indices\n\n  D[bot] = D[top] = 2; // 3rd vertex is at both bot and top\n  if (isLeft(verts[0], verts[1], verts[2]) > 0) {\n    D[bot + 1] = 0;\n    D[bot + 2] = 1; // ccw vertices are: 2,0,1,2\n  } else {\n    D[bot + 1] = 1;\n    D[bot + 2] = 0; // ccw vertices are: 2,1,0,2\n  }\n\n  // compute the hull on the deque D[]\n  for (var _i = 3; _i < n; _i += 1) {\n    // process the rest of vertices\n    // test if next vertex is outside the deque hull\n    if (isLeft(verts[D[bot]], verts[D[bot + 1]], verts[_i]) <= 0 || isLeft(verts[D[top - 1]], verts[D[top]], verts[_i]) <= 0) {\n\n      // incrementally add an exterior vertex to the deque hull\n      // get the rightmost tangent at the deque bot\n      while (D[bot] >= 0 && D[bot + 1] >= 0 && isLeft(verts[D[bot]], verts[D[bot + 1]], verts[_i]) <= 0) {\n        bot += 1; // remove bot of deque\n      }\n      bot -= 1;\n      D[bot] = _i; // insert verts[i] at bot of deque\n\n      // get the leftmost tangent at the deque top\n      while (D[top] >= 0 && D[top + 1] >= 0 && isLeft(verts[D[top - 1]], verts[D[top]], verts[_i]) <= 0) {\n        top -= 1; // pop top of deque\n      }\n      top += 1;\n      D[top] = _i; // push verts[i] onto top of deque\n    }\n  }\n\n  // transcribe deque D[] to the output hull array H[]\n  var h = 0;\n  for (h = 0; h <= top - bot - 1; h += 1) {\n    H[h] = D[bot + h];\n  }\n\n  if (D[bot + h] !== H[0]) {\n    H[h] = D[bot + h];\n  }\n\n  return H;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRoL2NvbnZleC1odWxsLmpzPzBkYTkiXSwibmFtZXMiOlsic2ltcGxlSHVsbF8yRCIsIlgiLCJZIiwiaXNMZWZ0IiwiUDAiLCJQMSIsIlAyIiwidmVydHMiLCJIIiwibiIsImxlbmd0aCIsImkiLCJEIiwiQXJyYXkiLCJmaWxsIiwiYm90IiwidG9wIiwiaCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7O1FBd0JnQkEsYSxHQUFBQSxhO0FBdEJoQixJQUFNQyxJQUFJLENBQVY7QUFDQSxJQUFNQyxJQUFJLENBQVY7O0FBR0E7Ozs7Ozs7OztBQVNBLFNBQVNDLE1BQVQsQ0FBZ0JDLEVBQWhCLEVBQW9CQyxFQUFwQixFQUF3QkMsRUFBeEIsRUFBNEI7QUFDMUIsU0FBTyxDQUFDRCxHQUFHSixDQUFILElBQVFHLEdBQUdILENBQUgsQ0FBVCxLQUFtQkssR0FBR0osQ0FBSCxJQUFRRSxHQUFHRixDQUFILENBQTNCLElBQW9DLENBQUNJLEdBQUdMLENBQUgsSUFBUUcsR0FBR0gsQ0FBSCxDQUFULEtBQW1CSSxHQUFHSCxDQUFILElBQVFFLEdBQUdGLENBQUgsQ0FBM0IsQ0FBM0M7QUFDRDs7QUFFRDs7Ozs7QUFLTyxTQUFTRixhQUFULENBQXVCTyxLQUF2QixFQUE4QjtBQUNuQztBQUNBO0FBQ0EsTUFBTUMsSUFBSSxFQUFWO0FBQ0EsTUFBTUMsSUFBSUYsTUFBTUcsTUFBaEI7O0FBRUEsTUFBSUQsSUFBSSxDQUFSLEVBQVc7QUFDVCxTQUFLLElBQUlFLElBQUksQ0FBYixFQUFnQkEsSUFBSUYsQ0FBcEIsRUFBdUJFLEtBQUssQ0FBNUIsRUFBK0I7QUFDN0JILFFBQUVHLENBQUYsSUFBT0EsQ0FBUDtBQUNEO0FBQ0QsV0FBT0gsQ0FBUDtBQUNEOztBQUVELE1BQU1JLElBQUksSUFBSUMsS0FBSixDQUFVLElBQUlKLENBQUosR0FBUSxDQUFsQixDQUFWO0FBQ0FHLElBQUVFLElBQUYsQ0FBTyxDQUFDLENBQVI7QUFDQSxNQUFJQyxNQUFNTixJQUFJLENBQWQ7QUFDQSxNQUFJTyxNQUFNRCxNQUFNLENBQWhCLENBaEJtQyxDQWdCakI7O0FBRWxCSCxJQUFFRyxHQUFGLElBQVNILEVBQUVJLEdBQUYsSUFBUyxDQUFsQixDQWxCbUMsQ0FrQmY7QUFDcEIsTUFBSWIsT0FBT0ksTUFBTSxDQUFOLENBQVAsRUFBaUJBLE1BQU0sQ0FBTixDQUFqQixFQUEyQkEsTUFBTSxDQUFOLENBQTNCLElBQXVDLENBQTNDLEVBQThDO0FBQzVDSyxNQUFFRyxNQUFNLENBQVIsSUFBYSxDQUFiO0FBQ0FILE1BQUVHLE1BQU0sQ0FBUixJQUFhLENBQWIsQ0FGNEMsQ0FFN0I7QUFDaEIsR0FIRCxNQUdPO0FBQ0xILE1BQUVHLE1BQU0sQ0FBUixJQUFhLENBQWI7QUFDQUgsTUFBRUcsTUFBTSxDQUFSLElBQWEsQ0FBYixDQUZLLENBRVU7QUFDaEI7O0FBRUQ7QUFDQSxPQUFLLElBQUlKLEtBQUksQ0FBYixFQUFnQkEsS0FBSUYsQ0FBcEIsRUFBdUJFLE1BQUssQ0FBNUIsRUFBK0I7QUFBRTtBQUMvQjtBQUNBLFFBQUtSLE9BQU9JLE1BQU1LLEVBQUVHLEdBQUYsQ0FBTixDQUFQLEVBQXNCUixNQUFNSyxFQUFFRyxNQUFNLENBQVIsQ0FBTixDQUF0QixFQUF5Q1IsTUFBTUksRUFBTixDQUF6QyxLQUFzRCxDQUF2RCxJQUNEUixPQUFPSSxNQUFNSyxFQUFFSSxNQUFNLENBQVIsQ0FBTixDQUFQLEVBQTBCVCxNQUFNSyxFQUFFSSxHQUFGLENBQU4sQ0FBMUIsRUFBeUNULE1BQU1JLEVBQU4sQ0FBekMsS0FBc0QsQ0FEekQsRUFDNkQ7O0FBRTNEO0FBQ0E7QUFDQSxhQUFPQyxFQUFFRyxHQUFGLEtBQVUsQ0FBVixJQUFlSCxFQUFFRyxNQUFNLENBQVIsS0FBYyxDQUE3QixJQUFrQ1osT0FBT0ksTUFBTUssRUFBRUcsR0FBRixDQUFOLENBQVAsRUFBc0JSLE1BQU1LLEVBQUVHLE1BQU0sQ0FBUixDQUFOLENBQXRCLEVBQXlDUixNQUFNSSxFQUFOLENBQXpDLEtBQXNELENBQS9GLEVBQWtHO0FBQ2hHSSxlQUFPLENBQVAsQ0FEZ0csQ0FDdkY7QUFDVjtBQUNEQSxhQUFPLENBQVA7QUFDQUgsUUFBRUcsR0FBRixJQUFTSixFQUFULENBUjJELENBUWhEOztBQUVYO0FBQ0EsYUFBT0MsRUFBRUksR0FBRixLQUFVLENBQVYsSUFBZUosRUFBRUksTUFBTSxDQUFSLEtBQWMsQ0FBN0IsSUFBa0NiLE9BQU9JLE1BQU1LLEVBQUVJLE1BQU0sQ0FBUixDQUFOLENBQVAsRUFBMEJULE1BQU1LLEVBQUVJLEdBQUYsQ0FBTixDQUExQixFQUF5Q1QsTUFBTUksRUFBTixDQUF6QyxLQUFzRCxDQUEvRixFQUFrRztBQUNoR0ssZUFBTyxDQUFQLENBRGdHLENBQ3ZGO0FBQ1Y7QUFDREEsYUFBTyxDQUFQO0FBQ0FKLFFBQUVJLEdBQUYsSUFBU0wsRUFBVCxDQWYyRCxDQWVoRDtBQUNaO0FBQ0Y7O0FBRUQ7QUFDQSxNQUFJTSxJQUFJLENBQVI7QUFDQSxPQUFLQSxJQUFJLENBQVQsRUFBWUEsS0FBTUQsTUFBTUQsR0FBTixHQUFZLENBQTlCLEVBQWtDRSxLQUFLLENBQXZDLEVBQTBDO0FBQ3hDVCxNQUFFUyxDQUFGLElBQU9MLEVBQUVHLE1BQU1FLENBQVIsQ0FBUDtBQUNEOztBQUVELE1BQUlMLEVBQUVHLE1BQU1FLENBQVIsTUFBZVQsRUFBRSxDQUFGLENBQW5CLEVBQXlCO0FBQ3ZCQSxNQUFFUyxDQUFGLElBQU9MLEVBQUVHLE1BQU1FLENBQVIsQ0FBUDtBQUNEOztBQUVELFNBQU9ULENBQVA7QUFDRCIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBDb3B5cmlnaHQgMjAwMSBzb2Z0U3VyZmVyLCAyMDEyIERhbiBTdW5kYXlcbi8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuLy8gcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4vLyBTb2Z0U3VyZmVyIG1ha2VzIG5vIHdhcnJhbnR5IGZvciB0aGlzIGNvZGUsIGFuZCBjYW5ub3QgYmUgaGVsZFxuLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbi8vIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG5cbi8vIGZyb20gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMTItX2h1bGwtMy5odG1sXG5cblwidXNlIHN0cmljdFwiXG5cbmNvbnN0IFggPSAwXG5jb25zdCBZID0gMVxuXG5cbi8qKlxuICogVGVzdCBpZiBhIHBvaW50IGlzIExlZnR8T258UmlnaHQgb2YgYW4gaW5maW5pdGUgbGluZS5cbiAqIEBwYXJhbSAge1BvaW50MmR9ICBQMCBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtQb2ludDJkfSAgUDEgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7UG9pbnQyZH0gIFAyIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICBSZXR1cm5zID4gMCBpZiBQMiBpcyBsZWZ0IG9mIHRoZSBsaW5lIHRocnUgUDAgJiBQMSxcbiAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIDwgMCBpZiBQMiBpcyB0byB0aGUgcmlnaHRcbiAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIDAgaWYgUDIgaXMgb24gdGhlIGxpbmVcbiAqL1xuZnVuY3Rpb24gaXNMZWZ0KFAwLCBQMSwgUDIpIHtcbiAgcmV0dXJuIChQMVtYXSAtIFAwW1hdKSAqIChQMltZXSAtIFAwW1ldKSAtIChQMltYXSAtIFAwW1hdKSAqIChQMVtZXSAtIFAwW1ldKVxufVxuXG4vKipcbiAqIE1lbGttYW4ncyAyRCBzaW1wbGUgcG9seWxpbmUgTyhuKSBjb252ZXggaHVsbCBhbGdvcml0aG1cbiAqIEBwYXJhbSAge1BvaW50MmRbXX0gdmVydHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7bnVtYmVyW119ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUh1bGxfMkQodmVydHMpIHtcbiAgLy8gaW5pdGlhbGl6ZSBhIGRlcXVlIERbXSBmcm9tIGJvdHRvbSB0byB0b3Agc28gdGhhdCB0aGVcbiAgLy8gMXN0IHRocmVlIHZlcnRpY2VzIG9mIFBbXSBhcmUgYSBjY3cgdHJpYW5nbGVcbiAgY29uc3QgSCA9IFtdXG4gIGNvbnN0IG4gPSB2ZXJ0cy5sZW5ndGhcblxuICBpZiAobiA8IDMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuICAgICAgSFtpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIGNvbnN0IEQgPSBuZXcgQXJyYXkoMiAqIG4gKyAxKVxuICBELmZpbGwoLTEpXG4gIGxldCBib3QgPSBuIC0gMlxuICBsZXQgdG9wID0gYm90ICsgMyAvLyBpbml0aWFsIGJvdHRvbSBhbmQgdG9wIGRlcXVlIGluZGljZXNcblxuICBEW2JvdF0gPSBEW3RvcF0gPSAyIC8vIDNyZCB2ZXJ0ZXggaXMgYXQgYm90aCBib3QgYW5kIHRvcFxuICBpZiAoaXNMZWZ0KHZlcnRzWzBdLCB2ZXJ0c1sxXSwgdmVydHNbMl0pID4gMCkge1xuICAgIERbYm90ICsgMV0gPSAwXG4gICAgRFtib3QgKyAyXSA9IDEgLy8gY2N3IHZlcnRpY2VzIGFyZTogMiwwLDEsMlxuICB9IGVsc2Uge1xuICAgIERbYm90ICsgMV0gPSAxXG4gICAgRFtib3QgKyAyXSA9IDAgLy8gY2N3IHZlcnRpY2VzIGFyZTogMiwxLDAsMlxuICB9XG5cbiAgLy8gY29tcHV0ZSB0aGUgaHVsbCBvbiB0aGUgZGVxdWUgRFtdXG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbjsgaSArPSAxKSB7IC8vIHByb2Nlc3MgdGhlIHJlc3Qgb2YgdmVydGljZXNcbiAgICAvLyB0ZXN0IGlmIG5leHQgdmVydGV4IGlzIG91dHNpZGUgdGhlIGRlcXVlIGh1bGxcbiAgICBpZiAoKGlzTGVmdCh2ZXJ0c1tEW2JvdF1dLCB2ZXJ0c1tEW2JvdCArIDFdXSwgdmVydHNbaV0pIDw9IDApIHx8XG4gICAgICAoaXNMZWZ0KHZlcnRzW0RbdG9wIC0gMV1dLCB2ZXJ0c1tEW3RvcF1dLCB2ZXJ0c1tpXSkgPD0gMCkpIHtcblxuICAgICAgLy8gaW5jcmVtZW50YWxseSBhZGQgYW4gZXh0ZXJpb3IgdmVydGV4IHRvIHRoZSBkZXF1ZSBodWxsXG4gICAgICAvLyBnZXQgdGhlIHJpZ2h0bW9zdCB0YW5nZW50IGF0IHRoZSBkZXF1ZSBib3RcbiAgICAgIHdoaWxlIChEW2JvdF0gPj0gMCAmJiBEW2JvdCArIDFdID49IDAgJiYgaXNMZWZ0KHZlcnRzW0RbYm90XV0sIHZlcnRzW0RbYm90ICsgMV1dLCB2ZXJ0c1tpXSkgPD0gMCkge1xuICAgICAgICBib3QgKz0gMSAvLyByZW1vdmUgYm90IG9mIGRlcXVlXG4gICAgICB9XG4gICAgICBib3QgLT0gMVxuICAgICAgRFtib3RdID0gaSAvLyBpbnNlcnQgdmVydHNbaV0gYXQgYm90IG9mIGRlcXVlXG5cbiAgICAgIC8vIGdldCB0aGUgbGVmdG1vc3QgdGFuZ2VudCBhdCB0aGUgZGVxdWUgdG9wXG4gICAgICB3aGlsZSAoRFt0b3BdID49IDAgJiYgRFt0b3AgKyAxXSA+PSAwICYmIGlzTGVmdCh2ZXJ0c1tEW3RvcCAtIDFdXSwgdmVydHNbRFt0b3BdXSwgdmVydHNbaV0pIDw9IDApIHtcbiAgICAgICAgdG9wIC09IDEgLy8gcG9wIHRvcCBvZiBkZXF1ZVxuICAgICAgfVxuICAgICAgdG9wICs9IDFcbiAgICAgIERbdG9wXSA9IGkgLy8gcHVzaCB2ZXJ0c1tpXSBvbnRvIHRvcCBvZiBkZXF1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIHRyYW5zY3JpYmUgZGVxdWUgRFtdIHRvIHRoZSBvdXRwdXQgaHVsbCBhcnJheSBIW11cbiAgbGV0IGggPSAwXG4gIGZvciAoaCA9IDA7IGggPD0gKHRvcCAtIGJvdCAtIDEpOyBoICs9IDEpIHtcbiAgICBIW2hdID0gRFtib3QgKyBoXVxuICB9XG5cbiAgaWYgKERbYm90ICsgaF0gIT09IEhbMF0pIHtcbiAgICBIW2hdID0gRFtib3QgKyBoXVxuICB9XG5cbiAgcmV0dXJuIEhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21hdGgvY29udmV4LWh1bGwuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} RectOptions\n * @property {number} [width=0] Width of the rect in world space coords\n * @property {number} [height=0] Height of the rect in world space coords\n */\n\n/**\n * @class Class for defining a rectangle shape\n * @extends {BaseShape}\n */\nvar Rect = function (_BaseShape) {\n  _inherits(Rect, _BaseShape);\n\n  /**\n   * Creates a new rectangle shape\n   * @param  {RectOptions} [opts]\n   * @return {Rect}\n   */\n  function Rect(opts) {\n    _classCallCheck(this, Rect);\n\n    var _this = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, opts));\n\n    _this._width = 0;\n    _this._height = 0;\n    if (typeof opts.width !== \"undefined\") {\n      _this.width = opts.width;\n    }\n    if (typeof opts.height !== \"undefined\") {\n      _this.height = opts.height;\n    }\n    return _this;\n  }\n\n  /**\n   * Gets the untransformed width/height of the rect\n   * @return {Vec2d} Width/height of the rect\n   */\n\n\n  _createClass(Rect, [{\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return [this._width, this._height];\n    }\n\n    /**\n     * Sets the width of the rectangle\n     * @param  {number} width Width of the rect in world-space coordinates\n     * @return {Rect}       this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If width is not a valid number\n     */\n\n  }, {\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        AABox2d.initCenterExtents(this._aabox, [0, 0], [this._width / 2, this._height / 2]);\n        AABox2d.transformMat2d(this._aabox, this._aabox, this.globalXform);\n        this._geomDirty = this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the rect using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.rect(0 - this.width / 2, 0 - this.height / 2, this.width, this.height);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Rect\",\n        width: this.width,\n        height: this.height\n      }, _get(Rect.prototype.__proto__ || Object.getPrototypeOf(Rect.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"width\",\n    set: function set(width) {\n      if (typeof width !== \"number\") {\n        throw new Error(\"Width must be a number\");\n      }\n\n      if (width !== this._width) {\n        var prev = this._width;\n        this._width = width;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"width\",\n          prevVal: prev,\n          currVal: this._width\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current untransformed width of the rect\n     * @return {number} Width in world-space units\n     */\n    ,\n    get: function get() {\n      return this._width;\n    }\n\n    /**\n     * Sets the height of the rectangle\n     * @param  {number} height Height of the rect in world-space units\n     * @return {Rect}       this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If height is not a valid number\n     */\n\n  }, {\n    key: \"height\",\n    set: function set(height) {\n      if (typeof height !== \"number\") {\n        throw new Error(\"Height must be a number\");\n      }\n\n      if (height !== this._height) {\n        var prev = this._height;\n        this._height = height;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"height\",\n          prevVal: prev,\n          currVal: this._height\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current untransformed height of the rect\n     * @return {number} Height in world-space units\n     */\n    ,\n    get: function get() {\n      return this._height;\n    }\n  }]);\n\n  return Rect;\n}(_baseShape2.default);\n\nexports.default = Rect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcmVjdC5qcz80ZDJiIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJSZWN0Iiwib3B0cyIsIl93aWR0aCIsIl9oZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJ0cmFuc2Zvcm1NYXQyZCIsImdsb2JhbFhmb3JtIiwiY3R4IiwicmVjdCIsIk9iamVjdCIsImFzc2lnbiIsInR5cGUiLCJFcnJvciIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwiQmFzZVNoYXBlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFNQTs7OztJQUlxQkMsSTs7O0FBQ25COzs7OztBQUtBLGdCQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsNEdBQ1ZBLElBRFU7O0FBRWhCLFVBQUtDLE1BQUwsR0FBYyxDQUFkO0FBQ0EsVUFBS0MsT0FBTCxHQUFlLENBQWY7QUFDQSxRQUFJLE9BQU9GLEtBQUtHLEtBQVosS0FBc0IsV0FBMUIsRUFBdUM7QUFDckMsWUFBS0EsS0FBTCxHQUFhSCxLQUFLRyxLQUFsQjtBQUNEO0FBQ0QsUUFBSSxPQUFPSCxLQUFLSSxNQUFaLEtBQXVCLFdBQTNCLEVBQXdDO0FBQ3RDLFlBQUtBLE1BQUwsR0FBY0osS0FBS0ksTUFBbkI7QUFDRDtBQVRlO0FBVWpCOztBQUVEOzs7Ozs7OztvQ0FJZ0I7QUFDZCxhQUFPLENBQUMsS0FBS0gsTUFBTixFQUFjLEtBQUtDLE9BQW5CLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBb0VBOzs7OzttQ0FLZTtBQUNiLFVBQUksS0FBS0csVUFBTCxJQUFtQixLQUFLQyxnQkFBNUIsRUFBOEM7QUFDNUNSLGdCQUFRUyxpQkFBUixDQUEwQixLQUFLQyxNQUEvQixFQUF1QyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQXZDLEVBQStDLENBQUMsS0FBS1AsTUFBTCxHQUFjLENBQWYsRUFBa0IsS0FBS0MsT0FBTCxHQUFlLENBQWpDLENBQS9DO0FBQ0FKLGdCQUFRVyxjQUFSLENBQXVCLEtBQUtELE1BQTVCLEVBQW9DLEtBQUtBLE1BQXpDLEVBQWlELEtBQUtFLFdBQXREO0FBQ0EsYUFBS0wsVUFBTCxHQUFrQixLQUFLQyxnQkFBTCxHQUF3QixLQUExQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzswQkFNTUssRyxFQUFLO0FBQ1RBLFVBQUlDLElBQUosQ0FBUyxJQUFJLEtBQUtULEtBQUwsR0FBYSxDQUExQixFQUE2QixJQUFJLEtBQUtDLE1BQUwsR0FBYyxDQUEvQyxFQUFrRCxLQUFLRCxLQUF2RCxFQUE4RCxLQUFLQyxNQUFuRTtBQUNEOztBQUVEOzs7Ozs7Ozs2QkFLUztBQUNQLGFBQU9TLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxNQURhO0FBRW5CWixlQUFPLEtBQUtBLEtBRk87QUFHbkJDLGdCQUFRLEtBQUtBO0FBSE0sT0FBZCxxR0FBUDtBQUtEOzs7c0JBL0ZTRCxLLEVBQU87QUFDZixVQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsY0FBTSxJQUFJYSxLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUliLFVBQVUsS0FBS0YsTUFBbkIsRUFBMkI7QUFDekIsWUFBTWdCLE9BQU8sS0FBS2hCLE1BQWxCO0FBQ0EsYUFBS0EsTUFBTCxHQUFjRSxLQUFkO0FBQ0EsYUFBS0UsVUFBTCxHQUFrQixJQUFsQixDQUh5QixDQUdGOztBQUV2QixhQUFLYSxJQUFMLENBQVUsY0FBVixFQUEwQjtBQUN4QkMsZ0JBQU0sT0FEa0I7QUFFeEJDLG1CQUFTSCxJQUZlO0FBR3hCSSxtQkFBUyxLQUFLcEI7QUFIVSxTQUExQjtBQUtEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlZO0FBQ1YsYUFBTyxLQUFLQSxNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7c0JBT1dHLE0sRUFBUTtBQUNqQixVQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsY0FBTSxJQUFJWSxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUlaLFdBQVcsS0FBS0YsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTWUsT0FBTyxLQUFLZixPQUFsQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUUsTUFBZjtBQUNBLGFBQUtDLFVBQUwsR0FBa0IsSUFBbEIsQ0FIMkIsQ0FHSjs7QUFFdkIsYUFBS2EsSUFBTCxDQUFVLGNBQVYsRUFBMEI7QUFDeEJDLGdCQUFNLFFBRGtCO0FBRXhCQyxtQkFBU0gsSUFGZTtBQUd4QkksbUJBQVMsS0FBS25CO0FBSFUsU0FBMUI7QUFLRDtBQUNELGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJYTtBQUNYLGFBQU8sS0FBS0EsT0FBWjtBQUNEOzs7O0VBNUYrQm9CLG1COztrQkFBYnZCLEkiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBSZWN0T3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt3aWR0aD0wXSBXaWR0aCBvZiB0aGUgcmVjdCBpbiB3b3JsZCBzcGFjZSBjb29yZHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbaGVpZ2h0PTBdIEhlaWdodCBvZiB0aGUgcmVjdCBpbiB3b3JsZCBzcGFjZSBjb29yZHNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDbGFzcyBmb3IgZGVmaW5pbmcgYSByZWN0YW5nbGUgc2hhcGVcbiAqIEBleHRlbmRzIHtCYXNlU2hhcGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlY3QgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyByZWN0YW5nbGUgc2hhcGVcbiAgICogQHBhcmFtICB7UmVjdE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJuIHtSZWN0fVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5fd2lkdGggPSAwXG4gICAgdGhpcy5faGVpZ2h0ID0gMFxuICAgIGlmICh0eXBlb2Ygb3B0cy53aWR0aCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy53aWR0aCA9IG9wdHMud2lkdGhcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmhlaWdodCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bnRyYW5zZm9ybWVkIHdpZHRoL2hlaWdodCBvZiB0aGUgcmVjdFxuICAgKiBAcmV0dXJuIHtWZWMyZH0gV2lkdGgvaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAqL1xuICBnZXREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiBbdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGggV2lkdGggb2YgdGhlIHJlY3QgaW4gd29ybGQtc3BhY2UgY29vcmRpbmF0ZXNcbiAgICogQHJldHVybiB7UmVjdH0gICAgICAgdGhpc1xuICAgKiBAZmlyZXMge1NoYXBlI2dlb21DaGFuZ2VkfVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgd2lkdGggaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAqL1xuICBzZXQgd2lkdGgod2lkdGgpIHtcbiAgICBpZiAodHlwZW9mIHdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aCBtdXN0IGJlIGEgbnVtYmVyXCIpXG4gICAgfVxuXG4gICAgaWYgKHdpZHRoICE9PSB0aGlzLl93aWR0aCkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3dpZHRoXG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwid2lkdGhcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogdGhpcy5fd2lkdGhcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSByZWN0XG4gICAqIEByZXR1cm4ge251bWJlcn0gV2lkdGggaW4gd29ybGQtc3BhY2UgdW5pdHNcbiAgICovXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgdGhlIHJlY3QgaW4gd29ybGQtc3BhY2UgdW5pdHNcbiAgICogQHJldHVybiB7UmVjdH0gICAgICAgdGhpc1xuICAgKiBAZmlyZXMge1NoYXBlI2dlb21DaGFuZ2VkfVxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgaGVpZ2h0IGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgKi9cbiAgc2V0IGhlaWdodChoZWlnaHQpIHtcbiAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVpZ2h0IG11c3QgYmUgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBpZiAoaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9oZWlnaHRcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodFxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdHJ1ZSAvLyBkaXJ0eSBuZWVkcyB0byBiZSBzZXQgYmVmb3JlIGZpcmluZyBldmVudFxuXG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOmdlb21cIiwge1xuICAgICAgICBhdHRyOiBcImhlaWdodFwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl9oZWlnaHRcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB1bnRyYW5zZm9ybWVkIGhlaWdodCBvZiB0aGUgcmVjdFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhlaWdodCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCByZXF1aXJlcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fZ2VvbURpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSkge1xuICAgICAgQUFCb3gyZC5pbml0Q2VudGVyRXh0ZW50cyh0aGlzLl9hYWJveCwgWzAsIDBdLCBbdGhpcy5fd2lkdGggLyAyLCB0aGlzLl9oZWlnaHQgLyAyXSlcbiAgICAgIEFBQm94MmQudHJhbnNmb3JtTWF0MmQodGhpcy5fYWFib3gsIHRoaXMuX2FhYm94LCB0aGlzLmdsb2JhbFhmb3JtKVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgdGhlIHJlY3QgdXNpbmcgYSAyZCByZW5kZXJpbmcgY29udGV4dC4gQ2FsbGVkIGJ5IHRoZSBCYXNlU2hhcGVcbiAgICogY2xhc3NcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJkfSBjdHggMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfZHJhdyhjdHgpIHtcbiAgICBjdHgucmVjdCgwIC0gdGhpcy53aWR0aCAvIDIsIDAgLSB0aGlzLmhlaWdodCAvIDIsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBjb252ZXJ0IHRoZSBzaGFwZSB0byBhIHNlcmlhbGl6YWJsZSBKU09OIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IFwiUmVjdFwiLFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9yZWN0LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedColorRGBAClass = createEventedColorRGBAClass;\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Color keywords as defined by the CSS color modules\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}\n * @type {Map}\n */\nvar colorKeywords = new Map([[\"aliceblue\", \"#F0F8FF\"], [\"antiquewhite\", \"#FAEBD7\"], [\"aqua\", \"#00FFFF\"], [\"aquamarine\", \"#7FFFD4\"], [\"azure\", \"#F0FFFF\"], [\"beige\", \"#F5F5DC\"], [\"bisque\", \"#FFE4C4\"], [\"black\", \"#000000\"], [\"blanchedalmond\", \"#FFEBCD\"], [\"blue\", \"#0000FF\"], [\"blueviolet\", \"#8A2BE2\"], [\"brown\", \"#A52A2A\"], [\"burlywood\", \"#DEB887\"], [\"cadetblue\", \"#5F9EA0\"], [\"chartreuse\", \"#7FFF00\"], [\"chocolate\", \"#D2691E\"], [\"coral\", \"#FF7F50\"], [\"cornflowerblue\", \"#6495ED\"], [\"cornsilk\", \"#FFF8DC\"], [\"crimson\", \"#DC143C\"], [\"cyan\", \"#00FFFF\"], [\"darkblue\", \"#00008B\"], [\"darkcyan\", \"#008B8B\"], [\"darkgoldenrod\", \"#B8860B\"], [\"darkgray\", \"#A9A9A9\"], [\"darkgreen\", \"#006400\"], [\"darkkhaki\", \"#BDB76B\"], [\"darkmagenta\", \"#8B008B\"], [\"darkolivegreen\", \"#556B2F\"], [\"darkorange\", \"#FF8C00\"], [\"darkorchid\", \"#9932CC\"], [\"darkred\", \"#8B0000\"], [\"darksalmon\", \"#E9967A\"], [\"darkseagreen\", \"#8FBC8F\"], [\"darkslateblue\", \"#483D8B\"], [\"darkslategray\", \"#2F4F4F\"], [\"darkturquoise\", \"#00CED1\"], [\"darkviolet\", \"#9400D3\"], [\"deeppink\", \"#FF1493\"], [\"deepskyblue\", \"#00BFFF\"], [\"dimgray\", \"#696969\"], [\"dodgerblue\", \"#1E90FF\"], [\"firebrick\", \"#B22222\"], [\"floralwhite\", \"#FFFAF0\"], [\"forestgreen\", \"#228B22\"], [\"fuchsia\", \"#FF00FF\"], [\"gainsboro\", \"#DCDCDC\"], [\"ghostwhite\", \"#F8F8FF\"], [\"gold\", \"#FFD700\"], [\"goldenrod\", \"#DAA520\"], [\"gray\", \"#808080\"], [\"green\", \"#008000\"], [\"greenyellow\", \"#ADFF2F\"], [\"honeydew\", \"#F0FFF0\"], [\"hotpink\", \"#FF69B4\"], [\"indianred\", \"#CD5C5C\"], [\"indigo\", \"#4B0082\"], [\"ivory\", \"#FFFFF0\"], [\"khaki\", \"#F0E68C\"], [\"lavender\", \"#E6E6FA\"], [\"lavenderblush\", \"#FFF0F5\"], [\"lawngreen\", \"#7CFC00\"], [\"lemonchiffon\", \"#FFFACD\"], [\"lightblue\", \"#ADD8E6\"], [\"lightcoral\", \"#F08080\"], [\"lightcyan\", \"#E0FFFF\"], [\"lightgoldenrodyellow\", \"#FAFAD2\"], [\"lightgray\", \"#D3D3D3\"], [\"lightgreen\", \"#90EE90\"], [\"lightpink\", \"#FFB6C1\"], [\"lightsalmon\", \"#FFA07A\"], [\"lightseagreen\", \"#20B2AA\"], [\"lightskyblue\", \"#87CEFA\"], [\"lightslategray\", \"#778899\"], [\"lightsteelblue\", \"#B0C4DE\"], [\"lightyellow\", \"#FFFFE0\"], [\"lime\", \"#00FF00\"], [\"limegreen\", \"#32CD32\"], [\"linen\", \"#FAF0E6\"], [\"magenta\", \"#FF00FF\"], [\"maroon\", \"#800000\"], [\"mediumaquamarine\", \"#66CDAA\"], [\"mediumblue\", \"#0000CD\"], [\"mediumorchid\", \"#BA55D3\"], [\"mediumpurple\", \"#9370DB\"], [\"mediumseagreen\", \"#3CB371\"], [\"mediumslateblue\", \"#7B68EE\"], [\"mediumspringgreen\", \"#00FA9A\"], [\"mediumturquoise\", \"#48D1CC\"], [\"mediumvioletred\", \"#C71585\"], [\"midnightblue\", \"#191970\"], [\"mintcream\", \"#F5FFFA\"], [\"mistyrose\", \"#FFE4E1\"], [\"moccasin\", \"#FFE4B5\"], [\"navajowhite\", \"#FFDEAD\"], [\"navy\", \"#000080\"], [\"oldlace\", \"#FDF5E6\"], [\"olive\", \"#808000\"], [\"olivedrab\", \"#6B8E23\"], [\"orange\", \"#FFA500\"], [\"orangered\", \"#FF4500\"], [\"orchid\", \"#DA70D6\"], [\"palegoldenrod\", \"#EEE8AA\"], [\"palegreen\", \"#98FB98\"], [\"paleturquoise\", \"#AFEEEE\"], [\"palevioletred\", \"#DB7093\"], [\"papayawhip\", \"#FFEFD5\"], [\"peachpuff\", \"#FFDAB9\"], [\"peru\", \"#CD853F\"], [\"pink\", \"#FFC0CB\"], [\"plum\", \"#DDA0DD\"], [\"powderblue\", \"#B0E0E6\"], [\"purple\", \"#800080\"], [\"rebeccapurple\", \"#663399\"], [\"red\", \"#FF0000\"], [\"rosybrown\", \"#BC8F8F\"], [\"royalblue\", \"#4169E1\"], [\"saddlebrown\", \"#8B4513\"], [\"salmon\", \"#FA8072\"], [\"sandybrown\", \"#F4A460\"], [\"seagreen\", \"#2E8B57\"], [\"seashell\", \"#FFF5EE\"], [\"sienna\", \"#A0522D\"], [\"silver\", \"#C0C0C0\"], [\"skyblue\", \"#87CEEB\"], [\"slateblue\", \"#6A5ACD\"], [\"slategray\", \"#708090\"], [\"snow\", \"#FFFAFA\"], [\"springgreen\", \"#00FF7F\"], [\"steelblue\", \"#4682B4\"], [\"tan\", \"#D2B48C\"], [\"teal\", \"#008080\"], [\"thistle\", \"#D8BFD8\"], [\"tomato\", \"#FF6347\"], [\"turquoise\", \"#40E0D0\"], [\"violet\", \"#EE82EE\"], [\"wheat\", \"#F5DEB3\"], [\"white\", \"#FFFFFF\"], [\"whitesmoke\", \"#F5F5F5\"], [\"yellow\", \"#FFFF00\"], [\"yellowgreen\", \"#9ACD32\"]]);\n\n/**\n * rgb regex to handle \"rgb([0-255],[0-255],[0-255])\" color strings\n * @type {RegExp}\n */\nvar rgbRegex = /^rgb\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)\\s*$/i;\n\n/**\n * rgba regex to handle \"rgba([0-255],[0-255],[0-255],[0.0-1.0])\" color strings\n * @type {RegExp}\n */\nvar rgbaRegex = /^rgba\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([0,1](?:\\.\\d*)?)\\s*\\)\\s*$/i;\n\n/**\n * hex regex to handle \"#[00-FF][00-FF][00-FF]\" color strings.\n * @type {RegExp}\n */\nvar hexRegex = /^#([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})\\s*$/i;\n\n/**\n * Extracts an opacity from an rgba color packed into a 32-bit integer\n * @param  {number} packedRgbaColor\n * @return {number}                 opacity extracted in range of [0,1]\n */\nfunction getOpacity(packedRgbaColor) {\n  return (packedRgbaColor & 0xFF) / 255.0;\n}\n\n/**\n * packs an opacity value [0,1] into an 8-bit integer to be packed\n * into a 32-bit int\n * @param  {number} opacity [0,1]\n * @return {number}         [0,255]\n */\nfunction packOpacity(opacity) {\n  return _math2.default.floor(_math2.default.clamp01(opacity) * 255);\n}\n\n/**\n * Given a color packed into a 32-bit integer, returns a css-style \"rgba()\" string\n * @param  {number} packedRgbaColor\n * @return {string}                 int the form \"rgba([0,255],[0,255],[0,255],[0,1])\"\n */\nfunction getRGBAString(packedRgbaColor) {\n  return \"rgba(\" + (packedRgbaColor >>> 24) + \", \" + ((packedRgbaColor & 0xFF0000) >> 16) + \", \" + ((packedRgbaColor & 0xFF00) >> 8) + \", \" + getOpacity(packedRgbaColor) + \")\";\n}\n\n/**\n * Given an rgba() color string, extracts a numeric color packed into a 32-bit int\n * @param  {string} color\n * @return {number}\n */\nfunction getPackedColorRGBAFromString(color) {\n  if (typeof color !== \"string\") {\n    throw new Error(color + \" is not a valid color string\");\n  }\n\n  var packedColor = 0;\n\n  var match = null;\n  if (match = color.match(rgbRegex)) {\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 10), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 10), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 10), 0, 255) << 24;\n  } else if (match = color.match(rgbaRegex)) {\n    packedColor = packOpacity(Number.parseFloat(match[4], 10));\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 10), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 10), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 10), 0, 255) << 24;\n  } else if (match = color.match(hexRegex)) {\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 16), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 16), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 16), 0, 255) << 24;\n  } else if (colorKeywords.has(color)) {\n    match = colorKeywords.get(color).match(hexRegex);\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 16), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 16), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 16), 0, 255) << 24;\n  } else {\n    throw new Error(color + \" is not a valid color string\");\n  }\n\n  return packedColor;\n}\n\n/** @class manages colors in the RGBA color space. Can also be used as a mixin */\n\nvar ColorRGBA = function () {\n  /**\n   * Creates a new color in the RGBA color space\n   * @param  {string}    initColorStr color string in the form \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"red\")\n   * @param  {...object} args         Additional arguments that may be passed to other initializers/constructors\n   *                                  if this class is used as a base class or mixin\n   * @return {ColorRGBA}\n   */\n  function ColorRGBA(initColorStr) {\n    _classCallCheck(this, ColorRGBA);\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this.initializer.apply(this, [initColorStr].concat(args));\n  }\n\n  /**\n   * initializes a color in the RGBA color space using a color string\n   * @param  {string} initColorStr initializer string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n   */\n\n\n  _createClass(ColorRGBA, [{\n    key: \"initializer\",\n    value: function initializer(initColorStr) {\n      this._color = 0;\n      if (initColorStr) {\n        this.value = initColorStr;\n      }\n    }\n\n    /**\n     * sets all the channels of the RGBA color given a color string\n     * @param  {string} color color string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"isTransparent\",\n\n\n    /**\n     * Returns true if the current opacity of the rgba color < 1\n     * @return {Boolean}\n     */\n    value: function isTransparent() {\n      return getOpacity(this._color) < 1.0;\n    }\n  }, {\n    key: \"value\",\n    set: function set(color) {\n      this._color = getPackedColorRGBAFromString(color);\n      return this;\n    }\n\n    /**\n     * Gets the rgba color as a color string \"rgba()\"\n     * @return {string} rgba color as a string\n     */\n    ,\n    get: function get() {\n      return getRGBAString(this._color);\n    }\n\n    /**\n     * Sets the value of the RGBA color packed as a 32-bit int\n     * @param  {number} packedColor\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"packedValue\",\n    set: function set(packedColor) {\n      this._color = 0;\n      this._color |= packedColor;\n      return this;\n    }\n\n    /**\n     * Gets the current value of the RGBA color as a packed 32-bit int\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._color;\n    }\n\n    /**\n     * sets the opacity of the RGBA color (modifies alpha channel only)\n     * @param  {number} opacity [0,1]\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"opacity\",\n    set: function set(opacity) {\n      if (typeof opacity !== \"number\") {\n        throw new Error(\"Opacity must be a number between 0-1\");\n      }\n\n      var currOpacity = this._color & 0xFF;\n      var newOpacity = packOpacity(opacity);\n      if (newOpacity !== currOpacity) {\n        this._color &= 0xFFFFFF00;\n        this._color |= newOpacity;\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current opacity (alpha channel) of the RGBA color\n     * @return {number} [0,1]\n     */\n    ,\n    get: function get() {\n      return getOpacity(this._color);\n    }\n  }]);\n\n  return ColorRGBA;\n}();\n\n/**\n * Creates a new color RGBA class that fires events whenever the color\n * is changed externally\n * @param  {string} eventName Event type to fire when color is modified\n * @param  {string} colorName Name of the color attribute. This string is used in the event object fired\n * @return {function}         New class constructor function\n */\n\n\nexports.default = ColorRGBA;\nfunction createEventedColorRGBAClass(eventName, colorName) {\n\n  /**\n   * @class New rgba color class that fires events when modified\n   * @extends {ColorRGBA}\n   */\n  return function (_ColorRGBA) {\n    _inherits(EventedColorRGBA, _ColorRGBA);\n\n    function EventedColorRGBA() {\n      _classCallCheck(this, EventedColorRGBA);\n\n      return _possibleConstructorReturn(this, (EventedColorRGBA.__proto__ || Object.getPrototypeOf(EventedColorRGBA)).apply(this, arguments));\n    }\n\n    _createClass(EventedColorRGBA, [{\n      key: \"initializer\",\n\n      /**\n       * Color modification event\n       * @event EventedColor#changed\n       * @type {object}\n       * @property {string} attr Name of the attribute modified\n       * @property {} prevVal Previous value of the attribute prior to modification\n       * @property {} currVal Value of the attribute post modification\n       */\n\n      /**\n       * Initializes the evented color\n       * @param  {string} initColorStr initial color as string\n       * @param  {EventHandler} eventHandler Event handler instance used to manage the color\n       *                                     modification events\n       * @protected\n       */\n      value: function initializer(initColorStr, eventHandler) {\n        this._eventHandler = eventHandler;\n        _get(EventedColorRGBA.prototype.__proto__ || Object.getPrototypeOf(EventedColorRGBA.prototype), \"initializer\", this).call(this, initColorStr);\n      }\n\n      /**\n       * Validates modification of the rgba color, and if modified, fires\n       * modification events\n       * @param  {number} newPackedColor Color defined by a 32-bit int\n       * @private\n       */\n\n    }, {\n      key: \"_checkPackedColorChanged\",\n      value: function _checkPackedColorChanged(newPackedColor) {\n        if (newPackedColor !== this._color) {\n          var prev = this._color;\n          var prevOpacity = getOpacity(prev);\n          var opacity = getOpacity(newPackedColor);\n          this._color = newPackedColor;\n\n          this._eventHandler.fire(eventName, {\n            attr: colorName,\n            prevVal: getRGBAString(prev),\n            currVal: getRGBAString(this._color)\n          });\n\n          if (opacity !== prevOpacity) {\n            this._eventHandler.fire(eventName, {\n              attr: \"opacity\",\n              prevVal: prevOpacity,\n              currVal: opacity\n            });\n          }\n        }\n      }\n\n      /**\n       * sets all the channels of the RGBA color from a color string\n       * @param  {string} color color string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"value\",\n      set: function set(color) {\n        var tmpcolor = getPackedColorRGBAFromString(color);\n        this._checkPackedColorChanged(tmpcolor);\n        return this;\n      }\n\n      /**\n       * Gets the rgba color as a color string \"rgba()\"\n       * @return {string} rgba color as a string\n       */\n      ,\n      get: function get() {\n        return getRGBAString(this._color);\n      }\n\n      /**\n       * Sets the value of the RGBA color packed as a 32-bit int\n       * @param  {number} packedColor\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"packedValue\",\n      set: function set(packedColor) {\n        var tmpcolor = 0;\n        tmpcolor |= packedColor;\n        this._checkPackedColorChanged(tmpcolor);\n        return this;\n      }\n\n      /**\n       * Gets the current value of the RGBA color as a packed 32-bit int\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._color;\n      }\n\n      /**\n       * sets the opacity of the RGBA color (modifies alpha channel only)\n       * @param  {number} opacity [0,1]\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"opacity\",\n      set: function set(opacity) {\n        if (typeof opacity !== \"number\") {\n          throw new Error(\"Opacity must be a number between 0-1\");\n        }\n\n        var currOpacity = this._color & 0xFF;\n        var newOpacity = packOpacity(opacity);\n        if (newOpacity !== currOpacity) {\n          this._color &= 0xFFFFFF00;\n          this._color |= newOpacity;\n\n          this._eventHandler.fire(eventName, {\n            attr: \"opacity\",\n            prevVal: currOpacity / 255.0,\n            currVal: newOpacity / 255.0\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current opacity (alpha channel) of the RGBA color\n       * @return {number} [0,1]\n       */\n      ,\n      get: function get() {\n        return getOpacity(this._color);\n      }\n    }]);\n\n    return EventedColorRGBA;\n  }(ColorRGBA);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9jb2xvci1yZ2JhLmpzPzdlYmEiXSwibmFtZXMiOlsiY3JlYXRlRXZlbnRlZENvbG9yUkdCQUNsYXNzIiwiY29sb3JLZXl3b3JkcyIsIk1hcCIsInJnYlJlZ2V4IiwicmdiYVJlZ2V4IiwiaGV4UmVnZXgiLCJnZXRPcGFjaXR5IiwicGFja2VkUmdiYUNvbG9yIiwicGFja09wYWNpdHkiLCJvcGFjaXR5IiwiTWF0aCIsImZsb29yIiwiY2xhbXAwMSIsImdldFJHQkFTdHJpbmciLCJnZXRQYWNrZWRDb2xvclJHQkFGcm9tU3RyaW5nIiwiY29sb3IiLCJFcnJvciIsInBhY2tlZENvbG9yIiwibWF0Y2giLCJjbGFtcCIsIk51bWJlciIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsImhhcyIsImdldCIsIkNvbG9yUkdCQSIsImluaXRDb2xvclN0ciIsImFyZ3MiLCJpbml0aWFsaXplciIsIl9jb2xvciIsInZhbHVlIiwiY3Vyck9wYWNpdHkiLCJuZXdPcGFjaXR5IiwiZXZlbnROYW1lIiwiY29sb3JOYW1lIiwiZXZlbnRIYW5kbGVyIiwiX2V2ZW50SGFuZGxlciIsIm5ld1BhY2tlZENvbG9yIiwicHJldiIsInByZXZPcGFjaXR5IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsInRtcGNvbG9yIiwiX2NoZWNrUGFja2VkQ29sb3JDaGFuZ2VkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7O1FBc1ZnQkEsMkIsR0FBQUEsMkI7O0FBcFZoQjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0EsSUFBTUMsZ0JBQWdCLElBQUlDLEdBQUosQ0FBUSxDQUFDLENBQUMsV0FBRCxFQUFjLFNBQWQsQ0FBRCxFQUNDLENBQUMsY0FBRCxFQUFpQixTQUFqQixDQURELEVBRUMsQ0FBQyxNQUFELEVBQVMsU0FBVCxDQUZELEVBR0MsQ0FBQyxZQUFELEVBQWUsU0FBZixDQUhELEVBSUMsQ0FBQyxPQUFELEVBQVUsU0FBVixDQUpE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OztBQXZFRjtBQUFBO0FBQUEsd0JBNkVrQlosV0E3RWxCLEVBNkUrQjtBQUMzQixZQUFJMkIsV0FBVyxDQUFmO0FBQ0FBLG9CQUFZM0IsV0FBWjtBQUNBLGFBQUs0Qix3QkFBTCxDQUE4QkQsUUFBOUI7QUFDQSxlQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXBGRjtBQUFBLDBCQXdGb0I7QUFDaEIsZUFBTyxLQUFLZixNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUE1RkY7QUFBQTtBQUFBLHdCQWtHY3BCLE9BbEdkLEVBa0d1QjtBQUNuQixZQUFJLE9BQU9BLE9BQVAsS0FBbUIsUUFBdkIsRUFBaUM7QUFDL0IsZ0JBQU0sSUFBSU8sS0FBSixDQUFVLHNDQUFWLENBQU47QUFDRDs7QUFFRCxZQUFNZSxjQUFjLEtBQUtGLE1BQUwsR0FBYyxJQUFsQztBQUNBLFlBQU1HLGFBQWF4QixZQUFZQyxPQUFaLENBQW5CO0FBQ0EsWUFBSXVCLGVBQWVELFdBQW5CLEVBQWdDO0FBQzlCLGVBQUtGLE1BQUwsSUFBZSxVQUFmO0FBQ0EsZUFBS0EsTUFBTCxJQUFlRyxVQUFmOztBQUVBLGVBQUtJLGFBQUwsQ0FBbUJJLElBQW5CLENBQXdCUCxTQUF4QixFQUFtQztBQUNqQ1Esa0JBQU0sU0FEMkI7QUFFakNDLHFCQUFTWCxjQUFjLEtBRlU7QUFHakNZLHFCQUFTWCxhQUFhO0FBSFcsV0FBbkM7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBdEhGO0FBQUEsMEJBMEhnQjtBQUNaLGVBQU8xQixXQUFXLEtBQUt1QixNQUFoQixDQUFQO0FBQ0Q7QUE1SEg7O0FBQUE7QUFBQSxJQUFzQ0osU0FBdEM7QUE4SEQiLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1tYWdpYy1udW1iZXJzICovXG5cInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBDb2xvciBrZXl3b3JkcyBhcyBkZWZpbmVkIGJ5IHRoZSBDU1MgY29sb3IgbW9kdWxlc1xuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfVxuICogQHR5cGUge01hcH1cbiAqL1xuY29uc3QgY29sb3JLZXl3b3JkcyA9IG5ldyBNYXAoW1tcImFsaWNlYmx1ZVwiLCBcIiNGMEY4RkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYW50aXF1ZXdoaXRlXCIsIFwiI0ZBRUJEN1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhcXVhXCIsIFwiIzAwRkZGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhcXVhbWFyaW5lXCIsIFwiIzdGRkZENFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJhenVyZVwiLCBcIiNGMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmVpZ2VcIiwgXCIjRjVGNURDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJpc3F1ZVwiLCBcIiNGRkU0QzRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmxhY2tcIiwgXCIjMDAwMDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJsYW5jaGVkYWxtb25kXCIsIFwiI0ZGRUJDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJibHVlXCIsIFwiIzAwMDBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJibHVldmlvbGV0XCIsIFwiIzhBMkJFMlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJicm93blwiLCBcIiNBNTJBMkFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYnVybHl3b29kXCIsIFwiI0RFQjg4N1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjYWRldGJsdWVcIiwgXCIjNUY5RUEwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNoYXJ0cmV1c2VcIiwgXCIjN0ZGRjAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNob2NvbGF0ZVwiLCBcIiNEMjY5MUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY29yYWxcIiwgXCIjRkY3RjUwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNvcm5mbG93ZXJibHVlXCIsIFwiIzY0OTVFRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjb3Juc2lsa1wiLCBcIiNGRkY4RENcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY3JpbXNvblwiLCBcIiNEQzE0M0NcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY3lhblwiLCBcIiMwMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2JsdWVcIiwgXCIjMDAwMDhCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtjeWFuXCIsIFwiIzAwOEI4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrZ29sZGVucm9kXCIsIFwiI0I4ODYwQlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrZ3JheVwiLCBcIiNBOUE5QTlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2dyZWVuXCIsIFwiIzAwNjQwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJra2hha2lcIiwgXCIjQkRCNzZCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmttYWdlbnRhXCIsIFwiIzhCMDA4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrb2xpdmVncmVlblwiLCBcIiM1NTZCMkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya29yYW5nZVwiLCBcIiNGRjhDMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya29yY2hpZFwiLCBcIiM5OTMyQ0NcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3JlZFwiLCBcIiM4QjAwMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3NhbG1vblwiLCBcIiNFOTk2N0FcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3NlYWdyZWVuXCIsIFwiIzhGQkM4RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrc2xhdGVibHVlXCIsIFwiIzQ4M0Q4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrc2xhdGVncmF5XCIsIFwiIzJGNEY0RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrdHVycXVvaXNlXCIsIFwiIzAwQ0VEMVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrdmlvbGV0XCIsIFwiIzk0MDBEM1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkZWVwcGlua1wiLCBcIiNGRjE0OTNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGVlcHNreWJsdWVcIiwgXCIjMDBCRkZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRpbWdyYXlcIiwgXCIjNjk2OTY5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRvZGdlcmJsdWVcIiwgXCIjMUU5MEZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImZpcmVicmlja1wiLCBcIiNCMjIyMjJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZmxvcmFsd2hpdGVcIiwgXCIjRkZGQUYwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImZvcmVzdGdyZWVuXCIsIFwiIzIyOEIyMlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJmdWNoc2lhXCIsIFwiI0ZGMDBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJnYWluc2Jvcm9cIiwgXCIjRENEQ0RDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdob3N0d2hpdGVcIiwgXCIjRjhGOEZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdvbGRcIiwgXCIjRkZENzAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdvbGRlbnJvZFwiLCBcIiNEQUE1MjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ3JheVwiLCBcIiM4MDgwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ3JlZW5cIiwgXCIjMDA4MDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdyZWVueWVsbG93XCIsIFwiI0FERkYyRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJob25leWRld1wiLCBcIiNGMEZGRjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaG90cGlua1wiLCBcIiNGRjY5QjRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaW5kaWFucmVkXCIsIFwiI0NENUM1Q1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJpbmRpZ29cIiwgXCIjNEIwMDgyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIml2b3J5XCIsIFwiI0ZGRkZGMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJraGFraVwiLCBcIiNGMEU2OENcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGF2ZW5kZXJcIiwgXCIjRTZFNkZBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxhdmVuZGVyYmx1c2hcIiwgXCIjRkZGMEY1XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxhd25ncmVlblwiLCBcIiM3Q0ZDMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGVtb25jaGlmZm9uXCIsIFwiI0ZGRkFDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodGJsdWVcIiwgXCIjQUREOEU2XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Y29yYWxcIiwgXCIjRjA4MDgwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Y3lhblwiLCBcIiNFMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIiwgXCIjRkFGQUQyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Z3JheVwiLCBcIiNEM0QzRDNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRncmVlblwiLCBcIiM5MEVFOTBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRwaW5rXCIsIFwiI0ZGQjZDMVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodHNhbG1vblwiLCBcIiNGRkEwN0FcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRzZWFncmVlblwiLCBcIiMyMEIyQUFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRza3libHVlXCIsIFwiIzg3Q0VGQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodHNsYXRlZ3JheVwiLCBcIiM3Nzg4OTlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRzdGVlbGJsdWVcIiwgXCIjQjBDNERFXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0eWVsbG93XCIsIFwiI0ZGRkZFMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaW1lXCIsIFwiIzAwRkYwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaW1lZ3JlZW5cIiwgXCIjMzJDRDMyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpbmVuXCIsIFwiI0ZBRjBFNlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtYWdlbnRhXCIsIFwiI0ZGMDBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtYXJvb25cIiwgXCIjODAwMDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bWFxdWFtYXJpbmVcIiwgXCIjNjZDREFBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bWJsdWVcIiwgXCIjMDAwMENEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bW9yY2hpZFwiLCBcIiNCQTU1RDNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtcHVycGxlXCIsIFwiIzkzNzBEQlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1zZWFncmVlblwiLCBcIiMzQ0IzNzFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtc2xhdGVibHVlXCIsIFwiIzdCNjhFRVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1zcHJpbmdncmVlblwiLCBcIiMwMEZBOUFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtdHVycXVvaXNlXCIsIFwiIzQ4RDFDQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW12aW9sZXRyZWRcIiwgXCIjQzcxNTg1XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1pZG5pZ2h0Ymx1ZVwiLCBcIiMxOTE5NzBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWludGNyZWFtXCIsIFwiI0Y1RkZGQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtaXN0eXJvc2VcIiwgXCIjRkZFNEUxXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1vY2Nhc2luXCIsIFwiI0ZGRTRCNVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJuYXZham93aGl0ZVwiLCBcIiNGRkRFQURcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibmF2eVwiLCBcIiMwMDAwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib2xkbGFjZVwiLCBcIiNGREY1RTZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib2xpdmVcIiwgXCIjODA4MDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9saXZlZHJhYlwiLCBcIiM2QjhFMjNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib3JhbmdlXCIsIFwiI0ZGQTUwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJvcmFuZ2VyZWRcIiwgXCIjRkY0NTAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9yY2hpZFwiLCBcIiNEQTcwRDZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFsZWdvbGRlbnJvZFwiLCBcIiNFRUU4QUFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFsZWdyZWVuXCIsIFwiIzk4RkI5OFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwYWxldHVycXVvaXNlXCIsIFwiI0FGRUVFRVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwYWxldmlvbGV0cmVkXCIsIFwiI0RCNzA5M1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwYXBheWF3aGlwXCIsIFwiI0ZGRUZENVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwZWFjaHB1ZmZcIiwgXCIjRkZEQUI5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBlcnVcIiwgXCIjQ0Q4NTNGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBpbmtcIiwgXCIjRkZDMENCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBsdW1cIiwgXCIjRERBMEREXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBvd2RlcmJsdWVcIiwgXCIjQjBFMEU2XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInB1cnBsZVwiLCBcIiM4MDAwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicmViZWNjYXB1cnBsZVwiLCBcIiM2NjMzOTlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicmVkXCIsIFwiI0ZGMDAwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJyb3N5YnJvd25cIiwgXCIjQkM4RjhGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInJveWFsYmx1ZVwiLCBcIiM0MTY5RTFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2FkZGxlYnJvd25cIiwgXCIjOEI0NTEzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNhbG1vblwiLCBcIiNGQTgwNzJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2FuZHlicm93blwiLCBcIiNGNEE0NjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2VhZ3JlZW5cIiwgXCIjMkU4QjU3XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNlYXNoZWxsXCIsIFwiI0ZGRjVFRVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzaWVubmFcIiwgXCIjQTA1MjJEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNpbHZlclwiLCBcIiNDMEMwQzBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2t5Ymx1ZVwiLCBcIiM4N0NFRUJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2xhdGVibHVlXCIsIFwiIzZBNUFDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzbGF0ZWdyYXlcIiwgXCIjNzA4MDkwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNub3dcIiwgXCIjRkZGQUZBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNwcmluZ2dyZWVuXCIsIFwiIzAwRkY3RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzdGVlbGJsdWVcIiwgXCIjNDY4MkI0XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInRhblwiLCBcIiNEMkI0OENcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widGVhbFwiLCBcIiMwMDgwODBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widGhpc3RsZVwiLCBcIiNEOEJGRDhcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widG9tYXRvXCIsIFwiI0ZGNjM0N1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ0dXJxdW9pc2VcIiwgXCIjNDBFMEQwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInZpb2xldFwiLCBcIiNFRTgyRUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wid2hlYXRcIiwgXCIjRjVERUIzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIndoaXRlXCIsIFwiI0ZGRkZGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ3aGl0ZXNtb2tlXCIsIFwiI0Y1RjVGNVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ5ZWxsb3dcIiwgXCIjRkZGRjAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInllbGxvd2dyZWVuXCIsIFwiIzlBQ0QzMlwiXV0pXG5cbi8qKlxuICogcmdiIHJlZ2V4IHRvIGhhbmRsZSBcInJnYihbMC0yNTVdLFswLTI1NV0sWzAtMjU1XSlcIiBjb2xvciBzdHJpbmdzXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCByZ2JSZWdleCA9IC9ecmdiXFxzKlxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqXFwpXFxzKiQvaVxuXG4vKipcbiAqIHJnYmEgcmVnZXggdG8gaGFuZGxlIFwicmdiYShbMC0yNTVdLFswLTI1NV0sWzAtMjU1XSxbMC4wLTEuMF0pXCIgY29sb3Igc3RyaW5nc1xuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgcmdiYVJlZ2V4ID0gL15yZ2JhXFxzKlxcKFxccyooXFxkezEsM30pXFxzKixcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooWzAsMV0oPzpcXC5cXGQqKT8pXFxzKlxcKVxccyokL2lcblxuLyoqXG4gKiBoZXggcmVnZXggdG8gaGFuZGxlIFwiI1swMC1GRl1bMDAtRkZdWzAwLUZGXVwiIGNvbG9yIHN0cmluZ3MuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5jb25zdCBoZXhSZWdleCA9IC9eIyhbMC05LGEtZixBLUZdezJ9KShbMC05LGEtZixBLUZdezJ9KShbMC05LGEtZixBLUZdezJ9KVxccyokL2lcblxuLyoqXG4gKiBFeHRyYWN0cyBhbiBvcGFjaXR5IGZyb20gYW4gcmdiYSBjb2xvciBwYWNrZWQgaW50byBhIDMyLWJpdCBpbnRlZ2VyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZFJnYmFDb2xvclxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICAgb3BhY2l0eSBleHRyYWN0ZWQgaW4gcmFuZ2Ugb2YgWzAsMV1cbiAqL1xuZnVuY3Rpb24gZ2V0T3BhY2l0eShwYWNrZWRSZ2JhQ29sb3IpIHtcbiAgcmV0dXJuIChwYWNrZWRSZ2JhQ29sb3IgJiAweEZGKSAvIDI1NS4wXG59XG5cbi8qKlxuICogcGFja3MgYW4gb3BhY2l0eSB2YWx1ZSBbMCwxXSBpbnRvIGFuIDgtYml0IGludGVnZXIgdG8gYmUgcGFja2VkXG4gKiBpbnRvIGEgMzItYml0IGludFxuICogQHBhcmFtICB7bnVtYmVyfSBvcGFjaXR5IFswLDFdXG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgWzAsMjU1XVxuICovXG5mdW5jdGlvbiBwYWNrT3BhY2l0eShvcGFjaXR5KSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGguY2xhbXAwMShvcGFjaXR5KSAqIDI1NSlcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGNvbG9yIHBhY2tlZCBpbnRvIGEgMzItYml0IGludGVnZXIsIHJldHVybnMgYSBjc3Mtc3R5bGUgXCJyZ2JhKClcIiBzdHJpbmdcbiAqIEBwYXJhbSAge251bWJlcn0gcGFja2VkUmdiYUNvbG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBpbnQgdGhlIGZvcm0gXCJyZ2JhKFswLDI1NV0sWzAsMjU1XSxbMCwyNTVdLFswLDFdKVwiXG4gKi9cbmZ1bmN0aW9uIGdldFJHQkFTdHJpbmcocGFja2VkUmdiYUNvbG9yKSB7XG4gIHJldHVybiBgcmdiYSgkeyhwYWNrZWRSZ2JhQ29sb3IpID4+PiAyNH0sICR7KHBhY2tlZFJnYmFDb2xvciAmIDB4RkYwMDAwKSA+PiAxNn0sICR7KHBhY2tlZFJnYmFDb2xvciAmIDB4RkYwMCkgPj4gOH0sICR7Z2V0T3BhY2l0eShwYWNrZWRSZ2JhQ29sb3IpfSlgXG59XG5cbi8qKlxuICogR2l2ZW4gYW4gcmdiYSgpIGNvbG9yIHN0cmluZywgZXh0cmFjdHMgYSBudW1lcmljIGNvbG9yIHBhY2tlZCBpbnRvIGEgMzItYml0IGludFxuICogQHBhcmFtICB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRQYWNrZWRDb2xvclJHQkFGcm9tU3RyaW5nKGNvbG9yKSB7XG4gIGlmICh0eXBlb2YgY29sb3IgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29sb3J9IGlzIG5vdCBhIHZhbGlkIGNvbG9yIHN0cmluZ2ApXG4gIH1cblxuICBsZXQgcGFja2VkQ29sb3IgPSAwXG5cbiAgbGV0IG1hdGNoID0gbnVsbFxuICBpZiAoKG1hdGNoID0gY29sb3IubWF0Y2gocmdiUmVnZXgpKSkge1xuICAgIHBhY2tlZENvbG9yID0gMjU1IC8vIChmdWxseSBvcGFxdWUpXG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbM10sIDEwKSwgMCwgMjU1KSA8PCA4XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMl0sIDEwKSwgMCwgMjU1KSA8PCAxNlxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxMCksIDAsIDI1NSkgPDwgMjRcbiAgfSBlbHNlIGlmICgobWF0Y2ggPSBjb2xvci5tYXRjaChyZ2JhUmVnZXgpKSkge1xuICAgIHBhY2tlZENvbG9yID0gcGFja09wYWNpdHkoTnVtYmVyLnBhcnNlRmxvYXQobWF0Y2hbNF0sIDEwKSlcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFszXSwgMTApLCAwLCAyNTUpIDw8IDhcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsyXSwgMTApLCAwLCAyNTUpIDw8IDE2XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDEwKSwgMCwgMjU1KSA8PCAyNFxuICB9IGVsc2UgaWYgKChtYXRjaCA9IGNvbG9yLm1hdGNoKGhleFJlZ2V4KSkpIHtcbiAgICBwYWNrZWRDb2xvciA9IDI1NSAvLyAoZnVsbHkgb3BhcXVlKVxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzNdLCAxNiksIDAsIDI1NSkgPDwgOFxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzJdLCAxNiksIDAsIDI1NSkgPDwgMTZcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpLCAwLCAyNTUpIDw8IDI0XG4gIH0gZWxzZSBpZiAoY29sb3JLZXl3b3Jkcy5oYXMoY29sb3IpKSB7XG4gICAgbWF0Y2ggPSBjb2xvcktleXdvcmRzLmdldChjb2xvcikubWF0Y2goaGV4UmVnZXgpXG4gICAgcGFja2VkQ29sb3IgPSAyNTUgLy8gKGZ1bGx5IG9wYXF1ZSlcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFszXSwgMTYpLCAwLCAyNTUpIDw8IDhcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsyXSwgMTYpLCAwLCAyNTUpIDw8IDE2XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSwgMCwgMjU1KSA8PCAyNFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtjb2xvcn0gaXMgbm90IGEgdmFsaWQgY29sb3Igc3RyaW5nYClcbiAgfVxuXG4gIHJldHVybiBwYWNrZWRDb2xvclxufVxuXG4vKiogQGNsYXNzIG1hbmFnZXMgY29sb3JzIGluIHRoZSBSR0JBIGNvbG9yIHNwYWNlLiBDYW4gYWxzbyBiZSB1c2VkIGFzIGEgbWl4aW4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbG9yUkdCQSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbG9yIGluIHRoZSBSR0JBIGNvbG9yIHNwYWNlXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgaW5pdENvbG9yU3RyIGNvbG9yIHN0cmluZyBpbiB0aGUgZm9ybSBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBhIGNvbG9yIGtleXdvcmQgKGkuZS4gXCJyZWRcIilcbiAgICogQHBhcmFtICB7Li4ub2JqZWN0fSBhcmdzICAgICAgICAgQWRkaXRpb25hbCBhcmd1bWVudHMgdGhhdCBtYXkgYmUgcGFzc2VkIHRvIG90aGVyIGluaXRpYWxpemVycy9jb25zdHJ1Y3RvcnNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgdGhpcyBjbGFzcyBpcyB1c2VkIGFzIGEgYmFzZSBjbGFzcyBvciBtaXhpblxuICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0Q29sb3JTdHIsIC4uLmFyZ3MpIHtcbiAgICB0aGlzLmluaXRpYWxpemVyKGluaXRDb2xvclN0ciwgLi4uYXJncylcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplcyBhIGNvbG9yIGluIHRoZSBSR0JBIGNvbG9yIHNwYWNlIHVzaW5nIGEgY29sb3Igc3RyaW5nXG4gICAqIEBwYXJhbSAge3N0cmluZ30gaW5pdENvbG9yU3RyIGluaXRpYWxpemVyIHN0cmluZyBpbiB0aGUgZm9ybSBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBjb2xvciBrZXl3b3JkXG4gICAqL1xuICBpbml0aWFsaXplcihpbml0Q29sb3JTdHIpIHtcbiAgICB0aGlzLl9jb2xvciA9IDBcbiAgICBpZiAoaW5pdENvbG9yU3RyKSB7XG4gICAgICB0aGlzLnZhbHVlID0gaW5pdENvbG9yU3RyXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIHNldHMgYWxsIHRoZSBjaGFubmVscyBvZiB0aGUgUkdCQSBjb2xvciBnaXZlbiBhIGNvbG9yIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbG9yIGNvbG9yIHN0cmluZyBpbiB0aGUgZm9ybSBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBjb2xvciBrZXl3b3JkXG4gICAqIEByZXR1cm4ge0NvbG9yUkdCQX1cbiAgICovXG4gIHNldCB2YWx1ZShjb2xvcikge1xuICAgIHRoaXMuX2NvbG9yID0gZ2V0UGFja2VkQ29sb3JSR0JBRnJvbVN0cmluZyhjb2xvcilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJnYmEgY29sb3IgYXMgYSBjb2xvciBzdHJpbmcgXCJyZ2JhKClcIlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IHJnYmEgY29sb3IgYXMgYSBzdHJpbmdcbiAgICovXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gZ2V0UkdCQVN0cmluZyh0aGlzLl9jb2xvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgUkdCQSBjb2xvciBwYWNrZWQgYXMgYSAzMi1iaXQgaW50XG4gICAqIEBwYXJhbSAge251bWJlcn0gcGFja2VkQ29sb3JcbiAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgKi9cbiAgc2V0IHBhY2tlZFZhbHVlKHBhY2tlZENvbG9yKSB7XG4gICAgdGhpcy5fY29sb3IgPSAwXG4gICAgdGhpcy5fY29sb3IgfD0gcGFja2VkQ29sb3JcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIFJHQkEgY29sb3IgYXMgYSBwYWNrZWQgMzItYml0IGludFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcGFja2VkVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbG9yXG4gIH1cblxuICAvKipcbiAgICogc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgUkdCQSBjb2xvciAobW9kaWZpZXMgYWxwaGEgY2hhbm5lbCBvbmx5KVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9wYWNpdHkgWzAsMV1cbiAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgKi9cbiAgc2V0IG9wYWNpdHkob3BhY2l0eSkge1xuICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3BhY2l0eSBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMC0xXCIpXG4gICAgfVxuXG4gICAgY29uc3QgY3Vyck9wYWNpdHkgPSB0aGlzLl9jb2xvciAmIDB4RkZcbiAgICBjb25zdCBuZXdPcGFjaXR5ID0gcGFja09wYWNpdHkob3BhY2l0eSlcbiAgICBpZiAobmV3T3BhY2l0eSAhPT0gY3Vyck9wYWNpdHkpIHtcbiAgICAgIHRoaXMuX2NvbG9yICY9IDB4RkZGRkZGMDBcbiAgICAgIHRoaXMuX2NvbG9yIHw9IG5ld09wYWNpdHlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9wYWNpdHkgKGFscGhhIGNoYW5uZWwpIG9mIHRoZSBSR0JBIGNvbG9yXG4gICAqIEByZXR1cm4ge251bWJlcn0gWzAsMV1cbiAgICovXG4gIGdldCBvcGFjaXR5KCkge1xuICAgIHJldHVybiBnZXRPcGFjaXR5KHRoaXMuX2NvbG9yKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY3VycmVudCBvcGFjaXR5IG9mIHRoZSByZ2JhIGNvbG9yIDwgMVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNUcmFuc3BhcmVudCgpIHtcbiAgICByZXR1cm4gZ2V0T3BhY2l0eSh0aGlzLl9jb2xvcikgPCAxLjBcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29sb3IgUkdCQSBjbGFzcyB0aGF0IGZpcmVzIGV2ZW50cyB3aGVuZXZlciB0aGUgY29sb3JcbiAqIGlzIGNoYW5nZWQgZXh0ZXJuYWxseVxuICogQHBhcmFtICB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgdHlwZSB0byBmaXJlIHdoZW4gY29sb3IgaXMgbW9kaWZpZWRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29sb3JOYW1lIE5hbWUgb2YgdGhlIGNvbG9yIGF0dHJpYnV0ZS4gVGhpcyBzdHJpbmcgaXMgdXNlZCBpbiB0aGUgZXZlbnQgb2JqZWN0IGZpcmVkXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICBOZXcgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50ZWRDb2xvclJHQkFDbGFzcyhldmVudE5hbWUsIGNvbG9yTmFtZSkge1xuXG4gIC8qKlxuICAgKiBAY2xhc3MgTmV3IHJnYmEgY29sb3IgY2xhc3MgdGhhdCBmaXJlcyBldmVudHMgd2hlbiBtb2RpZmllZFxuICAgKiBAZXh0ZW5kcyB7Q29sb3JSR0JBfVxuICAgKi9cbiAgcmV0dXJuIGNsYXNzIEV2ZW50ZWRDb2xvclJHQkEgZXh0ZW5kcyBDb2xvclJHQkEge1xuICAgIC8qKlxuICAgICAqIENvbG9yIG1vZGlmaWNhdGlvbiBldmVudFxuICAgICAqIEBldmVudCBFdmVudGVkQ29sb3IjY2hhbmdlZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gICAgICogQHByb3BlcnR5IHt9IHByZXZWYWwgUHJldmlvdXMgdmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwcmlvciB0byBtb2RpZmljYXRpb25cbiAgICAgKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgZXZlbnRlZCBjb2xvclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaW5pdENvbG9yU3RyIGluaXRpYWwgY29sb3IgYXMgc3RyaW5nXG4gICAgICogQHBhcmFtICB7RXZlbnRIYW5kbGVyfSBldmVudEhhbmRsZXIgRXZlbnQgaGFuZGxlciBpbnN0YW5jZSB1c2VkIHRvIG1hbmFnZSB0aGUgY29sb3JcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmljYXRpb24gZXZlbnRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVyKGluaXRDb2xvclN0ciwgZXZlbnRIYW5kbGVyKSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIgPSBldmVudEhhbmRsZXJcbiAgICAgIHN1cGVyLmluaXRpYWxpemVyKGluaXRDb2xvclN0cilcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgbW9kaWZpY2F0aW9uIG9mIHRoZSByZ2JhIGNvbG9yLCBhbmQgaWYgbW9kaWZpZWQsIGZpcmVzXG4gICAgICogbW9kaWZpY2F0aW9uIGV2ZW50c1xuICAgICAqIEBwYXJhbSAge251bWJlcn0gbmV3UGFja2VkQ29sb3IgQ29sb3IgZGVmaW5lZCBieSBhIDMyLWJpdCBpbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jaGVja1BhY2tlZENvbG9yQ2hhbmdlZChuZXdQYWNrZWRDb2xvcikge1xuICAgICAgaWYgKG5ld1BhY2tlZENvbG9yICE9PSB0aGlzLl9jb2xvcikge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fY29sb3JcbiAgICAgICAgY29uc3QgcHJldk9wYWNpdHkgPSBnZXRPcGFjaXR5KHByZXYpXG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBnZXRPcGFjaXR5KG5ld1BhY2tlZENvbG9yKVxuICAgICAgICB0aGlzLl9jb2xvciA9IG5ld1BhY2tlZENvbG9yXG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogY29sb3JOYW1lLFxuICAgICAgICAgIHByZXZWYWw6IGdldFJHQkFTdHJpbmcocHJldiksXG4gICAgICAgICAgY3VyclZhbDogZ2V0UkdCQVN0cmluZyh0aGlzLl9jb2xvcilcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAob3BhY2l0eSAhPT0gcHJldk9wYWNpdHkpIHtcbiAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICAgIGF0dHI6IFwib3BhY2l0eVwiLFxuICAgICAgICAgICAgcHJldlZhbDogcHJldk9wYWNpdHksXG4gICAgICAgICAgICBjdXJyVmFsOiBvcGFjaXR5XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHMgYWxsIHRoZSBjaGFubmVscyBvZiB0aGUgUkdCQSBjb2xvciBmcm9tIGEgY29sb3Igc3RyaW5nXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb2xvciBjb2xvciBzdHJpbmcgaW4gdGhlIGZvcm0gXCJyZ2IoKVwiLCBcInJnYmEoKVwiLCBcIiMuLi4uLi5cIiwgb3IgY29sb3Iga2V5d29yZFxuICAgICAqIEBmaXJlcyAgRXZlbnRlZENvbG9yI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAgICovXG4gICAgc2V0IHZhbHVlKGNvbG9yKSB7XG4gICAgICBjb25zdCB0bXBjb2xvciA9IGdldFBhY2tlZENvbG9yUkdCQUZyb21TdHJpbmcoY29sb3IpXG4gICAgICB0aGlzLl9jaGVja1BhY2tlZENvbG9yQ2hhbmdlZCh0bXBjb2xvcilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmdiYSBjb2xvciBhcyBhIGNvbG9yIHN0cmluZyBcInJnYmEoKVwiXG4gICAgICogQHJldHVybiB7c3RyaW5nfSByZ2JhIGNvbG9yIGFzIGEgc3RyaW5nXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgcmV0dXJuIGdldFJHQkFTdHJpbmcodGhpcy5fY29sb3IpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFJHQkEgY29sb3IgcGFja2VkIGFzIGEgMzItYml0IGludFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gcGFja2VkQ29sb3JcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRDb2xvciNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgICAqL1xuICAgIHNldCBwYWNrZWRWYWx1ZShwYWNrZWRDb2xvcikge1xuICAgICAgbGV0IHRtcGNvbG9yID0gMFxuICAgICAgdG1wY29sb3IgfD0gcGFja2VkQ29sb3JcbiAgICAgIHRoaXMuX2NoZWNrUGFja2VkQ29sb3JDaGFuZ2VkKHRtcGNvbG9yKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBSR0JBIGNvbG9yIGFzIGEgcGFja2VkIDMyLWJpdCBpbnRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHBhY2tlZFZhbHVlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgUkdCQSBjb2xvciAobW9kaWZpZXMgYWxwaGEgY2hhbm5lbCBvbmx5KVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gb3BhY2l0eSBbMCwxXVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZENvbG9yI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAgICovXG4gICAgc2V0IG9wYWNpdHkob3BhY2l0eSkge1xuICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wYWNpdHkgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAtMVwiKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjdXJyT3BhY2l0eSA9IHRoaXMuX2NvbG9yICYgMHhGRlxuICAgICAgY29uc3QgbmV3T3BhY2l0eSA9IHBhY2tPcGFjaXR5KG9wYWNpdHkpXG4gICAgICBpZiAobmV3T3BhY2l0eSAhPT0gY3Vyck9wYWNpdHkpIHtcbiAgICAgICAgdGhpcy5fY29sb3IgJj0gMHhGRkZGRkYwMFxuICAgICAgICB0aGlzLl9jb2xvciB8PSBuZXdPcGFjaXR5XG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJvcGFjaXR5XCIsXG4gICAgICAgICAgcHJldlZhbDogY3Vyck9wYWNpdHkgLyAyNTUuMCxcbiAgICAgICAgICBjdXJyVmFsOiBuZXdPcGFjaXR5IC8gMjU1LjBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBvcGFjaXR5IChhbHBoYSBjaGFubmVsKSBvZiB0aGUgUkdCQSBjb2xvclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gWzAsMV1cbiAgICAgKi9cbiAgICBnZXQgb3BhY2l0eSgpIHtcbiAgICAgIHJldHVybiBnZXRPcGFjaXR5KHRoaXMuX2NvbG9yKVxuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvY29sb3ItcmdiYS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedFillStyleMixin = createEventedFillStyleMixin;\n\nvar _colorRgba = __webpack_require__(16);\n\nvar _colorRgba2 = _interopRequireDefault(_colorRgba);\n\nvar _aggregation = __webpack_require__(7);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {object} FillStyleOptions\n * @property {string} [fillColor=\"black\"] Fill color defined as a string\n * @property {number} [fillOpacity=1] Opacity of the fill color. This supersedes any opacity inherent in fillColor\n */\n\n/**\n * Manages the fill style of a 2d rendering context. Can be used as a mixin or base class\n * @class\n * @mixin\n */\nvar FillStyle = function () {\n  /**\n   * Creates a new fill style object\n   * @param {FillStyleOptions} [opts]\n   * @return {FillStyle}\n   */\n  function FillStyle(opts) {\n    _classCallCheck(this, FillStyle);\n\n    // TODO(croot): support gradients and patterns\n    this.initializer(opts);\n  }\n\n  /**\n   * initializes the fill style object from an options object\n   * @param  {FillStyleOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(FillStyle, [{\n    key: \"_initFillStyleFromOptions\",\n    value: function _initFillStyleFromOptions(opts) {\n      if (opts) {\n        if (typeof opts.fillColor !== \"undefined\") {\n          this.fillColor = opts.fillColor;\n        }\n        if (typeof opts.fillOpacity !== \"undefined\") {\n          this.fillOpacity = opts.fillOpacity;\n        }\n      }\n    }\n\n    /**\n     * Initializer method to initialize a fill style. Used for both initializing\n     * via base-class and mixin hierarchy.\n     * @param  {FillStyleOptions} [opts]\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._fillColor = new _colorRgba2.default(\"black\");\n      this._initFillStyleFromOptions(opts);\n    }\n\n    /**\n     * Sets the fill color\n     * @param  {string} fillColor Color as a string, \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"black\")\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"isFillVisible\",\n\n\n    /**\n     * Returns true if the fill style is visible, i.e. it has an opacity > 0\n     * @return {Boolean}\n     */\n    value: function isFillVisible() {\n      return this._fillColor.opacity > 0;\n    }\n\n    /**\n     * Returns true if the fill style is transparent in any way, i.e. opacity < 1\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isTransparent\",\n    value: function isTransparent() {\n      return this._fillColor.isTransparent();\n    }\n\n    /**\n     * Sets the fill style state of a 2d rendering context\n     * @param {CanvasRenderingContext2D} ctx\n     */\n\n  }, {\n    key: \"setFillCtx\",\n    value: function setFillCtx(ctx) {\n      ctx.fillStyle = this.fillColor;\n    }\n\n    /**\n     * Copies the properties of one fill style to another\n     * @param  {FillStyle} srcStyle FillStyle object to copy from\n     * @param  {FillStyle} dstStyle FillStyle object to copy to\n     */\n\n  }, {\n    key: \"fillColor\",\n    set: function set(fillColor) {\n      this._fillColor.value = fillColor;\n      return this;\n    }\n\n    /**\n     * Gets the fill color of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return this._fillColor.value;\n    }\n\n    /**\n     * Sets the opacity of the fill style\n     * @param  {number} opacity [0,1]\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"fillOpacity\",\n    set: function set(opacity) {\n      this._fillColor.opacity = opacity;\n      return this;\n    }\n\n    /**\n     * Gets the current opacity of the fill style [0,1]\n     * @return {number} Opacity in the range [0,1]\n     */\n    ,\n    get: function get() {\n      return this._fillColor.opacity;\n    }\n\n    /**\n     * Sets the fill color of the style defined as a 32-bit int\n     * @param  {number} packedFillColor Color value as a 32-bit int (i.e. 0xFFFFFFFF)\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"packedFillColor\",\n    set: function set(packedFillColor) {\n      this._fillColor.packedValue = packedFillColor;\n      return this;\n    }\n\n    /**\n     * Gets the current value of the color of the fill style as a 32-bit int\n     * @return {number} i.e. 0xFFFFFFFF\n     */\n    ,\n    get: function get() {\n      return this._fillColor.packedValue;\n    }\n  }], [{\n    key: \"copyFillStyle\",\n    value: function copyFillStyle(srcStyle, dstStyle) {\n      if (typeof srcStyle.packedFillColor === \"undefined\") {\n        if (typeof srcStyle.fillColor !== \"undefined\") {\n          dstStyle.fillColor = srcStyle.fillColor;\n        }\n        if (typeof srcStyle.fillOpacity !== \"undefined\") {\n          dstStyle.fillOpacity = srcStyle.fillOpacity;\n        }\n      } else {\n        dstStyle.packedFillColor = srcStyle.packedFillColor;\n      }\n    }\n\n    /**\n     * Comparison operator between two FillStyle objects. This is primarily\n     * used for sorting to minimize context switching of a 2d renderer\n     * @param  {FillStyle} fillStyleA\n     * @param  {FillStyle} fillStyleB\n     * @return {number}            Returns < 0 if fillStyleA < fillStyleB, > 0 if fillStyleA > fillStyleB, or 0 if they are equal.\n     */\n\n  }, {\n    key: \"compareFillStyle\",\n    value: function compareFillStyle(fillStyleA, fillStyleB) {\n      var valA = fillStyleA.isFillVisible();\n      var valB = fillStyleB.isFillVisible();\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      return fillStyleA.packedFillColor - fillStyleB.packedFillColor;\n    }\n\n    /**\n     * Returns a json object of a FillStyle object\n     * @param  {FillStyle} fillStyleObj\n     * @return {{fillColor: string}}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(fillStyleObj) {\n      return {\n        fillColor: fillStyleObj.fillColor\n      };\n    }\n  }]);\n\n  return FillStyle;\n}();\n\n/**\n * Creates a new fill style class that fires events whenever the style\n * is modified.\n * @param  {string} eventName Event type to fire when fill style is modified\n * @return {function}         New class constructor function\n */\n\n\nexports.default = FillStyle;\nfunction createEventedFillStyleMixin(eventName) {\n  /**\n   * Evented fill color class to handle fill color modifications\n   * @type {ColorRGBA}\n   */\n  var FillColorClass = (0, _colorRgba.createEventedColorRGBAClass)(eventName, \"fillColor\");\n\n  /**\n   * @mixin New evented fill style mixin. Will fire events whenever\n   *        the fill color is modified\n   */\n  return (0, _aggregation2.default)(null, FillStyle, function () {\n    function EventedFillStyle() {\n      _classCallCheck(this, EventedFillStyle);\n    }\n\n    _createClass(EventedFillStyle, [{\n      key: \"initializer\",\n      value: function initializer(opts) {\n        this._fillColor = new FillColorClass(\"red\", this);\n        this._initFillStyleFromOptions(opts);\n      }\n    }]);\n\n    return EventedFillStyle;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9maWxsLXN0eWxlLmpzP2I3MGIiXSwibmFtZXMiOlsiY3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGluIiwiRmlsbFN0eWxlIiwib3B0cyIsImluaXRpYWxpemVyIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJfZmlsbENvbG9yIiwiQ29sb3JSR0JBIiwiX2luaXRGaWxsU3R5bGVGcm9tT3B0aW9ucyIsIm9wYWNpdHkiLCJpc1RyYW5zcGFyZW50IiwiY3R4IiwiZmlsbFN0eWxlIiwidmFsdWUiLCJwYWNrZWRGaWxsQ29sb3IiLCJwYWNrZWRWYWx1ZSIsInNyY1N0eWxlIiwiZHN0U3R5bGUiLCJmaWxsU3R5bGVBIiwiZmlsbFN0eWxlQiIsInZhbEEiLCJpc0ZpbGxWaXNpYmxlIiwidmFsQiIsImZpbGxTdHlsZU9iaiIsImV2ZW50TmFtZSIsIkZpbGxDb2xvckNsYXNzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7UUF1TGdCQSwyQixHQUFBQSwyQjs7QUFyTGhCOzs7O0FBQ0E7Ozs7Ozs7O0FBRUE7Ozs7OztBQU1BOzs7OztJQUtxQkMsUztBQUNuQjs7Ozs7QUFLQSxxQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUNoQjtBQUNBLFNBQUtDLFdBQUwsQ0FBaUJELElBQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs4Q0FLMEJBLEksRUFBTTtBQUM5QixVQUFJQSxJQUFKLEVBQVU7QUFDUixZQUFJLE9BQU9BLEtBQUtFLFNBQVosS0FBMEIsV0FBOUIsRUFBMkM7QUFDekMsZUFBS0EsU0FBTCxHQUFpQkYsS0FBS0UsU0FBdEI7QUFDRDtBQUNELFlBQUksT0FBT0YsS0FBS0csV0FBWixLQUE0QixXQUFoQyxFQUE2QztBQUMzQyxlQUFLQSxXQUFMLEdBQW1CSCxLQUFLRyxXQUF4QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Z0NBS1lILEksRUFBTTtBQUNoQixXQUFLSSxVQUFMLEdBQWtCLElBQUlDLG1CQUFKLENBQWMsT0FBZCxDQUFsQjtBQUNBLFdBQUtDLHlCQUFMLENBQStCTixJQUEvQjtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBc0RBOzs7O29DQUlnQjtBQUNkLGFBQU8sS0FBS0ksVUFBTCxDQUFnQkcsT0FBaEIsR0FBMEIsQ0FBakM7QUFDRDs7QUFFRDs7Ozs7OztvQ0FJZ0I7QUFDZCxhQUFPLEtBQUtILFVBQUwsQ0FBZ0JJLGFBQWhCLEVBQVA7QUFDRDs7QUFFRDs7Ozs7OzsrQkFJV0MsRyxFQUFLO0FBQ2RBLFVBQUlDLFNBQUosR0FBZ0IsS0FBS1IsU0FBckI7QUFDRDs7QUFFRDs7Ozs7Ozs7c0JBekVjQSxTLEVBQVc7QUFDdkIsV0FBS0UsVUFBTCxDQUFnQk8sS0FBaEIsR0FBd0JULFNBQXhCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlnQjtBQUNkLGFBQU8sS0FBS0UsVUFBTCxDQUFnQk8sS0FBdkI7QUFDRDs7QUFFRDs7Ozs7Ozs7c0JBS2dCSixPLEVBQVM7QUFDdkIsV0FBS0gsVUFBTCxDQUFnQkcsT0FBaEIsR0FBMEJBLE9BQTFCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlrQjtBQUNoQixhQUFPLEtBQUtILFVBQUwsQ0FBZ0JHLE9BQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3NCQUtvQkssZSxFQUFpQjtBQUNuQyxXQUFLUixVQUFMLENBQWdCUyxXQUFoQixHQUE4QkQsZUFBOUI7QUFDQSxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7d0JBSXNCO0FBQ3BCLGFBQU8sS0FBS1IsVUFBTCxDQUFnQlMsV0FBdkI7QUFDRDs7O2tDQStCb0JDLFEsRUFBVUMsUSxFQUFVO0FBQ3ZDLFVBQUksT0FBT0QsU0FBU0YsZUFBaEIsS0FBb0MsV0FBeEMsRUFBcUQ7QUFDbkQsWUFBSSxPQUFPRSxTQUFTWixTQUFoQixLQUE4QixXQUFsQyxFQUErQztBQUM3Q2EsbUJBQVNiLFNBQVQsR0FBcUJZLFNBQVNaLFNBQTlCO0FBQ0Q7QUFDRCxZQUFJLE9BQU9ZLFNBQVNYLFdBQWhCLEtBQWdDLFdBQXBDLEVBQWlEO0FBQy9DWSxtQkFBU1osV0FBVCxHQUF1QlcsU0FBU1gsV0FBaEM7QUFDRDtBQUNGLE9BUEQsTUFPTztBQUNMWSxpQkFBU0gsZUFBVCxHQUEyQkUsU0FBU0YsZUFBcEM7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7O3FDQU93QkksVSxFQUFZQyxVLEVBQVk7QUFDOUMsVUFBTUMsT0FBT0YsV0FBV0csYUFBWCxFQUFiO0FBQ0EsVUFBTUMsT0FBT0gsV0FBV0UsYUFBWCxFQUFiO0FBQ0EsVUFBSUQsU0FBU0UsSUFBYixFQUFtQjtBQUNqQixlQUFPRixPQUFPRSxJQUFkO0FBQ0Q7QUFDRCxhQUFPSixXQUFXSixlQUFYLEdBQTZCSyxXQUFXTCxlQUEvQztBQUNEOztBQUVEOzs7Ozs7OzsyQkFLY1MsWSxFQUFjO0FBQzFCLGFBQU87QUFDTG5CLG1CQUFXbUIsYUFBYW5CO0FBRG5CLE9BQVA7QUFHRDs7Ozs7O0FBR0g7Ozs7Ozs7O2tCQWpLcUJILFM7QUF1S2QsU0FBU0QsMkJBQVQsQ0FBcUN3QixTQUFyQyxFQUFnRDtBQUNyRDs7OztBQUlBLE1BQU1DLGlCQUFpQiw0Q0FBNEJELFNBQTVCLEVBQXVDLFdBQXZDLENBQXZCOztBQUVBOzs7O0FBSUEsU0FBTywyQkFBWSxJQUFaLEVBQWtCdkIsU0FBbEI7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBLGtDQUNPQyxJQURQLEVBQ2E7QUFDaEIsYUFBS0ksVUFBTCxHQUFrQixJQUFJbUIsY0FBSixDQUFtQixLQUFuQixFQUEwQixJQUExQixDQUFsQjtBQUNBLGFBQUtqQix5QkFBTCxDQUErQk4sSUFBL0I7QUFDRDtBQUpJOztBQUFBO0FBQUEsTUFBUDtBQU1EIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IENvbG9yUkdCQSwge2NyZWF0ZUV2ZW50ZWRDb2xvclJHQkFDbGFzc30gZnJvbSBcIi4vY29sb3ItcmdiYVwiXG5pbXBvcnQgYWdncmVnYXRpb24gZnJvbSBcIi4uL3V0aWwvYWdncmVnYXRpb25cIlxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZpbGxTdHlsZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZmlsbENvbG9yPVwiYmxhY2tcIl0gRmlsbCBjb2xvciBkZWZpbmVkIGFzIGEgc3RyaW5nXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZpbGxPcGFjaXR5PTFdIE9wYWNpdHkgb2YgdGhlIGZpbGwgY29sb3IuIFRoaXMgc3VwZXJzZWRlcyBhbnkgb3BhY2l0eSBpbmhlcmVudCBpbiBmaWxsQ29sb3JcbiAqL1xuXG4vKipcbiAqIE1hbmFnZXMgdGhlIGZpbGwgc3R5bGUgb2YgYSAyZCByZW5kZXJpbmcgY29udGV4dC4gQ2FuIGJlIHVzZWQgYXMgYSBtaXhpbiBvciBiYXNlIGNsYXNzXG4gKiBAY2xhc3NcbiAqIEBtaXhpblxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWxsU3R5bGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBmaWxsIHN0eWxlIG9iamVjdFxuICAgKiBAcGFyYW0ge0ZpbGxTdHlsZU9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJuIHtGaWxsU3R5bGV9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLy8gVE9ETyhjcm9vdCk6IHN1cHBvcnQgZ3JhZGllbnRzIGFuZCBwYXR0ZXJuc1xuICAgIHRoaXMuaW5pdGlhbGl6ZXIob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplcyB0aGUgZmlsbCBzdHlsZSBvYmplY3QgZnJvbSBhbiBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0RmlsbFN0eWxlRnJvbU9wdGlvbnMob3B0cykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMuZmlsbENvbG9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gb3B0cy5maWxsQ29sb3JcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5maWxsT3BhY2l0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmZpbGxPcGFjaXR5ID0gb3B0cy5maWxsT3BhY2l0eVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBtZXRob2QgdG8gaW5pdGlhbGl6ZSBhIGZpbGwgc3R5bGUuIFVzZWQgZm9yIGJvdGggaW5pdGlhbGl6aW5nXG4gICAqIHZpYSBiYXNlLWNsYXNzIGFuZCBtaXhpbiBoaWVyYXJjaHkuXG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZU9wdGlvbnN9IFtvcHRzXVxuICAgKi9cbiAgaW5pdGlhbGl6ZXIob3B0cykge1xuICAgIHRoaXMuX2ZpbGxDb2xvciA9IG5ldyBDb2xvclJHQkEoXCJibGFja1wiKVxuICAgIHRoaXMuX2luaXRGaWxsU3R5bGVGcm9tT3B0aW9ucyhvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbGwgY29sb3JcbiAgICogQHBhcmFtICB7c3RyaW5nfSBmaWxsQ29sb3IgQ29sb3IgYXMgYSBzdHJpbmcsIFwicmdiKClcIiwgXCJyZ2JhKClcIiwgXCIjLi4uLi4uXCIsIG9yIGEgY29sb3Iga2V5d29yZCAoaS5lLiBcImJsYWNrXCIpXG4gICAqIEByZXR1cm4ge0ZpbGxTdHlsZX1cbiAgICovXG4gIHNldCBmaWxsQ29sb3IoZmlsbENvbG9yKSB7XG4gICAgdGhpcy5fZmlsbENvbG9yLnZhbHVlID0gZmlsbENvbG9yXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBmaWxsIGNvbG9yIG9mIHRoZSBzdHlsZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgZmlsbENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsQ29sb3IudmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBmaWxsIHN0eWxlXG4gICAqIEBwYXJhbSAge251bWJlcn0gb3BhY2l0eSBbMCwxXVxuICAgKiBAcmV0dXJuIHtGaWxsU3R5bGV9XG4gICAqL1xuICBzZXQgZmlsbE9wYWNpdHkob3BhY2l0eSkge1xuICAgIHRoaXMuX2ZpbGxDb2xvci5vcGFjaXR5ID0gb3BhY2l0eVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBvcGFjaXR5IG9mIHRoZSBmaWxsIHN0eWxlIFswLDFdXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3BhY2l0eSBpbiB0aGUgcmFuZ2UgWzAsMV1cbiAgICovXG4gIGdldCBmaWxsT3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLm9wYWNpdHlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxsIGNvbG9yIG9mIHRoZSBzdHlsZSBkZWZpbmVkIGFzIGEgMzItYml0IGludFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZEZpbGxDb2xvciBDb2xvciB2YWx1ZSBhcyBhIDMyLWJpdCBpbnQgKGkuZS4gMHhGRkZGRkZGRilcbiAgICogQHJldHVybiB7RmlsbFN0eWxlfVxuICAgKi9cbiAgc2V0IHBhY2tlZEZpbGxDb2xvcihwYWNrZWRGaWxsQ29sb3IpIHtcbiAgICB0aGlzLl9maWxsQ29sb3IucGFja2VkVmFsdWUgPSBwYWNrZWRGaWxsQ29sb3JcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGNvbG9yIG9mIHRoZSBmaWxsIHN0eWxlIGFzIGEgMzItYml0IGludFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGkuZS4gMHhGRkZGRkZGRlxuICAgKi9cbiAgZ2V0IHBhY2tlZEZpbGxDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLnBhY2tlZFZhbHVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxsIHN0eWxlIGlzIHZpc2libGUsIGkuZS4gaXQgaGFzIGFuIG9wYWNpdHkgPiAwXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc0ZpbGxWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxsQ29sb3Iub3BhY2l0eSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGwgc3R5bGUgaXMgdHJhbnNwYXJlbnQgaW4gYW55IHdheSwgaS5lLiBvcGFjaXR5IDwgMVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNUcmFuc3BhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLmlzVHJhbnNwYXJlbnQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpbGwgc3R5bGUgc3RhdGUgb2YgYSAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBzZXRGaWxsQ3R4KGN0eCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxDb2xvclxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgcHJvcGVydGllcyBvZiBvbmUgZmlsbCBzdHlsZSB0byBhbm90aGVyXG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZX0gc3JjU3R5bGUgRmlsbFN0eWxlIG9iamVjdCB0byBjb3B5IGZyb21cbiAgICogQHBhcmFtICB7RmlsbFN0eWxlfSBkc3RTdHlsZSBGaWxsU3R5bGUgb2JqZWN0IHRvIGNvcHkgdG9cbiAgICovXG4gIHN0YXRpYyBjb3B5RmlsbFN0eWxlKHNyY1N0eWxlLCBkc3RTdHlsZSkge1xuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUucGFja2VkRmlsbENvbG9yID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodHlwZW9mIHNyY1N0eWxlLmZpbGxDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkc3RTdHlsZS5maWxsQ29sb3IgPSBzcmNTdHlsZS5maWxsQ29sb3JcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuZmlsbE9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZHN0U3R5bGUuZmlsbE9wYWNpdHkgPSBzcmNTdHlsZS5maWxsT3BhY2l0eVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkc3RTdHlsZS5wYWNrZWRGaWxsQ29sb3IgPSBzcmNTdHlsZS5wYWNrZWRGaWxsQ29sb3JcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyaXNvbiBvcGVyYXRvciBiZXR3ZWVuIHR3byBGaWxsU3R5bGUgb2JqZWN0cy4gVGhpcyBpcyBwcmltYXJpbHlcbiAgICogdXNlZCBmb3Igc29ydGluZyB0byBtaW5pbWl6ZSBjb250ZXh0IHN3aXRjaGluZyBvZiBhIDJkIHJlbmRlcmVyXG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZX0gZmlsbFN0eWxlQVxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGV9IGZpbGxTdHlsZUJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgIFJldHVybnMgPCAwIGlmIGZpbGxTdHlsZUEgPCBmaWxsU3R5bGVCLCA+IDAgaWYgZmlsbFN0eWxlQSA+IGZpbGxTdHlsZUIsIG9yIDAgaWYgdGhleSBhcmUgZXF1YWwuXG4gICAqL1xuICBzdGF0aWMgY29tcGFyZUZpbGxTdHlsZShmaWxsU3R5bGVBLCBmaWxsU3R5bGVCKSB7XG4gICAgY29uc3QgdmFsQSA9IGZpbGxTdHlsZUEuaXNGaWxsVmlzaWJsZSgpXG4gICAgY29uc3QgdmFsQiA9IGZpbGxTdHlsZUIuaXNGaWxsVmlzaWJsZSgpXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICByZXR1cm4gZmlsbFN0eWxlQS5wYWNrZWRGaWxsQ29sb3IgLSBmaWxsU3R5bGVCLnBhY2tlZEZpbGxDb2xvclxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBqc29uIG9iamVjdCBvZiBhIEZpbGxTdHlsZSBvYmplY3RcbiAgICogQHBhcmFtICB7RmlsbFN0eWxlfSBmaWxsU3R5bGVPYmpcbiAgICogQHJldHVybiB7e2ZpbGxDb2xvcjogc3RyaW5nfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oZmlsbFN0eWxlT2JqKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxDb2xvcjogZmlsbFN0eWxlT2JqLmZpbGxDb2xvclxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbCBzdHlsZSBjbGFzcyB0aGF0IGZpcmVzIGV2ZW50cyB3aGVuZXZlciB0aGUgc3R5bGVcbiAqIGlzIG1vZGlmaWVkLlxuICogQHBhcmFtICB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgdHlwZSB0byBmaXJlIHdoZW4gZmlsbCBzdHlsZSBpcyBtb2RpZmllZFxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgTmV3IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudGVkRmlsbFN0eWxlTWl4aW4oZXZlbnROYW1lKSB7XG4gIC8qKlxuICAgKiBFdmVudGVkIGZpbGwgY29sb3IgY2xhc3MgdG8gaGFuZGxlIGZpbGwgY29sb3IgbW9kaWZpY2F0aW9uc1xuICAgKiBAdHlwZSB7Q29sb3JSR0JBfVxuICAgKi9cbiAgY29uc3QgRmlsbENvbG9yQ2xhc3MgPSBjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3MoZXZlbnROYW1lLCBcImZpbGxDb2xvclwiKVxuXG4gIC8qKlxuICAgKiBAbWl4aW4gTmV3IGV2ZW50ZWQgZmlsbCBzdHlsZSBtaXhpbi4gV2lsbCBmaXJlIGV2ZW50cyB3aGVuZXZlclxuICAgKiAgICAgICAgdGhlIGZpbGwgY29sb3IgaXMgbW9kaWZpZWRcbiAgICovXG4gIHJldHVybiBhZ2dyZWdhdGlvbihudWxsLCBGaWxsU3R5bGUsIGNsYXNzIEV2ZW50ZWRGaWxsU3R5bGUge1xuICAgIGluaXRpYWxpemVyKG9wdHMpIHtcbiAgICAgIHRoaXMuX2ZpbGxDb2xvciA9IG5ldyBGaWxsQ29sb3JDbGFzcyhcInJlZFwiLCB0aGlzKVxuICAgICAgdGhpcy5faW5pdEZpbGxTdHlsZUZyb21PcHRpb25zKG9wdHMpXG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvZmlsbC1zdHlsZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedStrokeStyleMixin = createEventedStrokeStyleMixin;\n\nvar _colorRgba = __webpack_require__(16);\n\nvar _colorRgba2 = _interopRequireDefault(_colorRgba);\n\nvar _aggregation = __webpack_require__(7);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {object} StrokeStyleOptions\n * @property {string} [strokeColor = \"black\"]\n * @property {number} [strokeWidth = 0]\n * @property {string} [lineJoin = \"miter\"]\n * @property {string} [lineCap = \"butt\"]\n * @property {number[]} [dashPattern = []]\n * @property {number} [dashOffset = 0]\n */\n\n/**\n * validates a possible stroke width value\n * @param  {number} strokeWidth\n * @throws If validation fails\n * @private\n */\nfunction validateStrokeWidth(strokeWidth) {\n  if (typeof strokeWidth !== \"number\") {\n    throw new Error(\"Stroke width must be a number\");\n  }\n}\n\n/**\n * Enum for line join values\n * @enum {number}\n */\nvar JoinEnum = {\n  MITER: 0,\n  BEVEL: 1,\n  ROUND: 2\n\n  /**\n   * line join values as strings, the enum values match the index in this string\n   * @type {string[]}\n   */\n};var lineJoinOpts = [\"miter\", \"bevel\", \"round\"];\n\n/**\n * validates a line join value\n * @param  {string} lineJoin Should be one of [\"miter\", \"bevel\", \"round\"]\n * @throws If validation fails\n * @return {JoinEnum}\n * @private\n */\nfunction validateLineJoin(lineJoin) {\n  var idx = -1;\n  if (typeof lineJoin !== \"string\" || (idx = lineJoinOpts.indexOf(lineJoin.toLowerCase())) < 0) {\n    throw new Error(\"Line join must be a string and must be one of [\" + lineJoinOpts.join(\", \") + \"]\");\n  }\n  return idx;\n}\n\n/**\n * Enum for line cap values\n * @enum {number}\n */\nvar CapEnum = {\n  BUTT: 0,\n  SQUARE: 1,\n  ROUND: 2\n\n  /**\n   * line cap values as strings, the CapEnum values match the index in this string\n   * @type {string[]}\n   */\n};var lineCapOpts = [\"butt\", \"square\", \"round\"];\n\n/**\n * validates a line cap value\n * @param  {string} lineCap Should be one of \"butt\", \"square\", \"round\"\n * @throws If validation fails\n * @return {CapEnum}\n * @private\n */\nfunction validateLineCap(lineCap) {\n  var idx = -1;\n  if (typeof lineCap !== \"string\" || (idx = lineCapOpts.indexOf(lineCap.toLowerCase())) < 0) {\n    throw new Error(\"Line cap must be a string and must be one of [\" + lineCapOpts.join(\", \") + \"]\");\n  }\n  return idx;\n}\n\n/**\n * validates a dash pattern value\n * @param  {number[]} dashPattern\n * @throws If validation fails\n * @private\n */\nfunction validateDashPattern(dashPattern) {\n  if (!dashPattern || !Array.isArray(dashPattern) || dashPattern.length % 2 !== 0) {\n    throw new Error(\"The dash pattern must be an array with an even number of numbers (or an empty array)\");\n  }\n}\n\n/**\n * validates a dash offset value\n * @param  {number} dashOffset\n * @throws If validation fails\n * @private\n */\nfunction validateDashOffset(dashOffset) {\n  if (typeof dashOffset !== \"number\") {\n    throw new Error(\"The dash offset must be a number\");\n  }\n}\n\n/**\n * Manages the stroke style of a 2d rendering context. Can be used as a mixin or base class\n * @class\n * @mixin\n */\n\nvar StrokeStyle = function () {\n  function StrokeStyle(opts) {\n    _classCallCheck(this, StrokeStyle);\n\n    this.initializer(opts);\n  }\n\n  /**\n   * initializes the stroke style object from an options object\n   * @param  {StrokeStyleOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(StrokeStyle, [{\n    key: \"_initStrokeStyleFromOptions\",\n    value: function _initStrokeStyleFromOptions(opts) {\n      if (opts) {\n        if (typeof opts.strokeColor !== \"undefined\") {\n          this.strokeColor = opts.strokeColor;\n        }\n        if (typeof opts.strokeOpacity !== \"undefined\") {\n          this.strokeOpacity = opts.strokeOpacity;\n        }\n        if (typeof opts.strokeWidth !== \"undefined\") {\n          this.strokeWidth = opts.strokeWidth;\n        }\n        if (typeof opts.lineMiter !== \"undefined\") {\n          this.lineJoin = opts.lineMiter;\n        }\n        if (typeof opts.lineCap !== \"undefined\") {\n          this.lineCap = opts.lineCap;\n        }\n        if (typeof opts.dashPattern !== \"undefined\") {\n          this.dashPattern = opts.dashPattern;\n        }\n        if (typeof opts.dashOffset !== \"undefined\") {\n          this.dashOffset = opts.dashOffset;\n        }\n      }\n    }\n\n    /**\n     * Initializer method to initialize a stroke style. Used for both initializing\n     * via base-class and mixin hierarchy.\n     * @param  {StrokeStyleOptions} [opts]\n     * @protected\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._strokeColor = new _colorRgba2.default(\"black\");\n      this._strokeWidth = 0;\n      this._lineJoin = JoinEnum.MITER;\n      this._lineCap = CapEnum.BUTT;\n      this._dashPattern = [];\n      this._dashOffset = 0;\n      this._initStrokeStyleFromOptions(opts);\n    }\n\n    /**\n     * Sets the stroke color\n     * @param  {string} strokeColor Color as a string, \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"black\")\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"isStrokeVisible\",\n\n\n    /**\n     * Returns true if the stroke style is visible, i.e. it is not fully transparent\n     * and has a width > 0\n     * @return {Boolean}\n     */\n    value: function isStrokeVisible() {\n      return this._strokeColor.opacity > 0 && this._strokeWidth > 0;\n    }\n\n    /**\n     * Returns true if stroke is partially transparent, i.e. opacity < 1\n     * @return {Boolean} [description]\n     */\n\n  }, {\n    key: \"isTransparent\",\n    value: function isTransparent() {\n      return this._strokeColor.isTransparent();\n    }\n\n    /**\n     * Sets the stroke style state of a 2d rendering context\n     * @param {CanvasRenderingContext2D} ctx\n     */\n\n  }, {\n    key: \"setStrokeCtx\",\n    value: function setStrokeCtx(ctx) {\n      ctx.strokeStyle = this.strokeColor;\n      ctx.lineWidth = this._strokeWidth;\n      ctx.lineJoin = this._lineJoin;\n      ctx.lineCap = this._lineCap;\n      ctx.setLineDash(this._dashPattern);\n      ctx.lineDashOffset = this._dashOffset;\n    }\n\n    /**\n     * Copies the properties of one stroke style to another\n     * @param  {StrokeStyle} srcStyle StrokeStyle object to copy from\n     * @param  {StrokeStyle} dstStyle StrokeStyle object to copy to\n     */\n\n  }, {\n    key: \"strokeColor\",\n    set: function set(strokeColor) {\n      this._strokeColor.value = strokeColor;\n      return this;\n    }\n\n    /**\n     * Gets the stroke color of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.value;\n    }\n\n    /**\n     * Sets the opacity of the stroke style\n     * @param  {number} opacity [0,1]\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"strokeOpacity\",\n    set: function set(opacity) {\n      this._strokeColor.opacity = opacity;\n    }\n\n    /**\n     * Gets the current opacity of the stroke style [0,1]\n     * @return {number} Opacity in the range [0,1]\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.opacity;\n    }\n\n    /**\n     * Sets the stroke color of the style defined as a 32-bit int\n     * @param  {number} packedStrokeColor Color value as a 32-bit int (i.e. 0xFFFFFFFF)\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"packedStrokeColor\",\n    set: function set(packedStrokeColor) {\n      this._strokeColor.packedValue = packedStrokeColor;\n    }\n\n    /**\n     * Gets the current value of the color of the stroke style as a 32-bit int\n     * @return {number} i.e. 0xFFFFFFFF\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.packedValue;\n    }\n\n    /**\n     * Sets the stroke width\n     * @param  {number} strokeWidth\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"strokeWidth\",\n    set: function set(strokeWidth) {\n      validateStrokeWidth(strokeWidth);\n      this._strokeWidth = strokeWidth;\n      return this;\n    }\n\n    /**\n     * Gets the current stroke width\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._strokeWidth;\n    }\n\n    /**\n     * Sets how lines should be joined\n     * @param  {string} lineJoin One of \"miter\", \"round\", or \"bevel\"\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"lineJoin\",\n    set: function set(lineJoin) {\n      var enumVal = validateLineJoin(lineJoin);\n      this._lineJoin = enumVal;\n      return this;\n    }\n\n    /**\n     * Gets the current line join\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return lineJoinOpts[this._lineJoin];\n    }\n\n    /**\n     * Sets how lines should be capped\n     * @param  {string} lineCap One of \"butt\", \"square\", or \"round\"\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"lineCap\",\n    set: function set(lineCap) {\n      var enumVal = validateLineCap(lineCap);\n      this._lineCap = enumVal;\n      return this;\n    }\n\n    /**\n     * Gets the current line cap of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return lineCapOpts[this._lineJoin];\n    }\n\n    /**\n     * Sets the dash pattern of the style\n     * @param  {number[]} dashPattern A list of numbers that specifies distances to alternately\n     *                                draw a line and a gap (in screen units)\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"dashPattern\",\n    set: function set(dashPattern) {\n      validateDashPattern(dashPattern);\n      this._dashPattern = dashPattern.slice();\n      return this;\n    }\n\n    /**\n     * Gets the current dash pattern of the style\n     * @return {number[]}\n     */\n    ,\n    get: function get() {\n      return this._dashPattern.slice();\n    }\n\n    /**\n     * Sets the dash offset of the style\n     * @param  {number} dashOffset\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"dashOffset\",\n    set: function set(dashOffset) {\n      validateDashOffset(dashOffset);\n      this._dashOffset = dashOffset;\n      return this;\n    }\n\n    /**\n     * Gets the current dash offset\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._dashOffset;\n    }\n  }], [{\n    key: \"copyStrokeStyle\",\n    value: function copyStrokeStyle(srcStyle, dstStyle) {\n      if (typeof srcStyle.packedStrokeColor === \"undefined\") {\n        if (typeof srcStyle.strokeColor !== \"undefined\") {\n          dstStyle.strokeColor = srcStyle.strokeColor;\n        }\n        if (typeof srcStyle.strokeOpacity !== \"undefined\") {\n          dstStyle.strokeOpacity = srcStyle.strokeOpacity;\n        }\n      } else {\n        dstStyle.packedStrokeColor = srcStyle.packedStrokeColor;\n      }\n      if (typeof srcStyle.strokeWidth !== \"undefined\") {\n        dstStyle.strokeWidth = srcStyle.strokeWidth;\n      }\n      if (typeof srcStyle.lineJoin !== \"undefined\") {\n        dstStyle.lineJoin = srcStyle.lineJoin;\n      }\n      if (typeof srcStyle.lineCap !== \"undefined\") {\n        dstStyle.lineCap = srcStyle.lineCap;\n      }\n      if (typeof srcStyle.dashPattern !== \"undefined\") {\n        dstStyle.dashPattern = srcStyle.dashPattern;\n      }\n      if (typeof srcStyle.dashOffset !== \"undefined\") {\n        dstStyle.dashOffset = srcStyle.dashOffset;\n      }\n    }\n\n    /**\n     * Comparison operator between two StrokeStyle objects. This is primarily\n     * used for sorting to minimize context switching of a 2d renderer\n     * @param  {StrokeStyle} strokeStyleA\n     * @param  {StrokeStyle} strokeStyleB\n     * @return {number}            Returns < 0 if strokeStyleA < strokeStyleB, > 0 if strokeStyleA > strokeStyleB, or 0 if they are equal.\n     */\n\n  }, {\n    key: \"compareStrokeStyle\",\n    value: function compareStrokeStyle(strokeStyleA, strokeStyleB) {\n      var valA = strokeStyleA.isStrokeVisible();\n      var valB = strokeStyleB.isStrokeVisible();\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA.packedStrokeColor;\n      valB = strokeStyleB.packedStrokeColor;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA.strokeWidth;\n      valB = strokeStyleB.strokeWidth;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._lineJoin;\n      valB = strokeStyleB._lineJoin;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._lineCap;\n      valB = strokeStyleB._lineCap;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._dashPattern;\n      valB = strokeStyleB._dashPattern;\n      if (valA.length === valB.length && valA.length > 0) {\n        for (var i = 0; i < valA.length; i += 1) {\n          if (valA[i] !== valB[i]) {\n            return valA[i] - valB[i];\n          }\n        }\n        return strokeStyleA.dashOffset - strokeStyleB.dashOffset;\n      }\n      return valA.length - valB.length;\n    }\n\n    /**\n     * Returns a json object of a StrokeStyle object\n     * @param  {StrokeStyle} strokeStyleObj\n     * @return {{strokeColor: string,\n     *           strokeWidth: number,\n     *           lineJoin: string,\n     *           lineCap: string,\n     *           dashPattern: number[],\n     *           dashOffset: number\n     *          }}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(strokeStyleObj) {\n      return {\n        strokeColor: strokeStyleObj.strokeColor,\n        strokeWidth: strokeStyleObj.strokeWidth,\n        lineJoin: strokeStyleObj.lineJoin,\n        lineCap: strokeStyleObj.lineCap,\n        dashPattern: strokeStyleObj.dashPattern,\n        dashOffset: strokeStyleObj.dashOffset\n      };\n    }\n  }]);\n\n  return StrokeStyle;\n}();\n\n/**\n * Creates a new stroke style class that fires events whenever the style\n * is modified.\n * @param  {string} eventName Event type to fire when stroke style is modified\n * @return {function}         New class constructor function\n */\n\n\nexports.default = StrokeStyle;\nfunction createEventedStrokeStyleMixin(eventName) {\n  /**\n   * Evented stroke color class to handle color modification events\n   * @type {ColorRGBA}\n   */\n  var StrokeColorClass = (0, _colorRgba.createEventedColorRGBAClass)(eventName, \"strokeColor\");\n\n  /**\n   * Stroke style modification event\n   * @event EventedStrokeStyle#changed\n   * @type {object}\n   * @property {string} attr Name of the attribute modified\n   * @property {} prevVal Previous value of the attribute prior to modification\n   * @property {} currVal Value of the attribute post modification\n   */\n\n  /**\n   * @mixin New evented stroke style mixin. Will fire events whenever\n   *        the stroke is modified\n   */\n  return (0, _aggregation2.default)(null, StrokeStyle, function () {\n    function EventedStrokeStyle() {\n      _classCallCheck(this, EventedStrokeStyle);\n    }\n\n    _createClass(EventedStrokeStyle, [{\n      key: \"initializer\",\n\n      /**\n       * Initializer method to initialize an evented stroke style.\n       * @param  {StrokeStyleOptions} [opts]\n       * @protected\n       */\n      value: function initializer(opts) {\n        this._strokeColor = new StrokeColorClass(\"black\", this);\n        this._strokeWidth = 0;\n        this._lineJoin = JoinEnum.MITER;\n        this._lineCap = CapEnum.BUTT;\n        this._dashPattern = [];\n        this._dashOffset = 0;\n        this._initStrokeStyleFromOptions(opts);\n      }\n\n      /**\n       * Sets the stroke width\n       * @param  {number}\n       * @fires  EventedStrokeStyle#changed\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"strokeWidth\",\n      set: function set(strokeWidth) {\n        validateStrokeWidth(strokeWidth);\n        if (strokeWidth !== this._strokeWidth) {\n          var prev = this._strokeWidth;\n          this._strokeWidth = strokeWidth;\n          this.fire(eventName, {\n            attr: \"strokeWidth\",\n            prevVal: prev,\n            curral: this._strokeWidth\n          });\n        }\n\n        return this;\n      }\n\n      /**\n       * Gets the current stroke width\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._strokeWidth;\n      }\n\n      /**\n       * Sets the line join\n       * @param  {string} lineJoin\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"lineJoin\",\n      set: function set(lineJoin) {\n        var enumVal = validateLineJoin(lineJoin);\n\n        if (enumVal !== this._lineJoin) {\n          var prev = this._lineJoin;\n          this._lineJoin = enumVal;\n          this.fire(eventName, {\n            attr: \"lineJoin\",\n            prevVal: prev,\n            curral: this._lineJoin\n          });\n        }\n\n        return this;\n      }\n\n      /**\n       * Gets the current line join\n       * @return {string}\n       */\n      ,\n      get: function get() {\n        return lineJoinOpts[this._lineJoin];\n      }\n\n      /**\n       * Sets the line cap\n       * @param  {string} lineCap\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"lineCap\",\n      set: function set(lineCap) {\n        var enumVal = validateLineCap(lineCap);\n        if (enumVal !== this._lineCap) {\n          var prev = this._lineCap;\n          this._lineCap = enumVal;\n          this.fire(eventName, {\n            attr: \"lineCap\",\n            prevVal: prev,\n            curral: this._lineCap\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the line cap\n       * @return {string}\n       */\n      ,\n      get: function get() {\n        return lineCapOpts[this._lineCap];\n      }\n\n      /**\n       * Sets the dash pattern\n       * @param  {number[]} dashPattern\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"dashPattern\",\n      set: function set(dashPattern) {\n        validateDashPattern(dashPattern);\n        var diff = false;\n        if (dashPattern.length === this._dashPattern.length) {\n          for (var i = 0; i < dashPattern.length; i += 1) {\n            if (dashPattern[i] !== this._dashPattern[i]) {\n              diff = true;\n              break;\n            }\n          }\n        } else {\n          diff = true;\n        }\n\n        if (diff) {\n          var prev = this._dashPattern;\n          this._dashPattern = dashPattern.slice();\n          this.fire(eventName, {\n            attr: \"dashPattern\",\n            prevVal: prev,\n            curral: this._dashPattern.slice()\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current dash pattern\n       * @return {number[]}\n       */\n      ,\n      get: function get() {\n        return this._dashPattern.slice();\n      }\n\n      /**\n       * Sets the current dash offset\n       * @param  {number} dashOffset\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"dashOffset\",\n      set: function set(dashOffset) {\n        validateDashOffset(dashOffset);\n\n        if (dashOffset !== this._dashOffset) {\n          var prev = this._dashOffset;\n          this._dashOffset = dashOffset;\n\n          if (this._dashPattern.length) {\n            // only fire if dashing is activated\n            this.fire(eventName, {\n              attr: \"dashOffset\",\n              prevVal: prev,\n              curral: this._dashOffset\n            });\n          }\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current dash offset\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._dashOffset;\n      }\n    }]);\n\n    return EventedStrokeStyle;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9zdHJva2Utc3R5bGUuanM/MzNkZiJdLCJuYW1lcyI6WyJjcmVhdGVFdmVudGVkU3Ryb2tlU3R5bGVNaXhpbiIsInZhbGlkYXRlU3Ryb2tlV2lkdGgiLCJzdHJva2VXaWR0aCIsIkVycm9yIiwiSm9pbkVudW0iLCJNSVRFUiIsIkJFVkVMIiwiUk9VTkQiLCJsaW5lSm9pbk9wdHMiLCJ2YWxpZGF0ZUxpbmVKb2luIiwibGluZUpvaW4iLCJpZHgiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJqb2luIiwiQ2FwRW51bSIsIkJVVFQiLCJTUVVBUkUiLCJsaW5lQ2FwT3B0cyIsInZhbGlkYXRlTGluZUNhcCIsImxpbmVDYXAiLCJ2YWxpZGF0ZURhc2hQYXR0ZXJuIiwiZGFzaFBhdHRlcm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ2YWxpZGF0ZURhc2hPZmZzZXQiLCJkYXNoT2Zmc2V0IiwiU3Ryb2tlU3R5bGUiLCJvcHRzIiwiaW5pdGlhbGl6ZXIiLCJzdHJva2VDb2xvciIsInN0cm9rZU9wYWNpdHkiLCJsaW5lTWl0ZXIiLCJfc3Ryb2tlQ29sb3IiLCJDb2xvclJHQkEiLCJfc3Ryb2tlV2lkdGgiLCJfbGluZUpvaW4iLCJfbGluZUNhcCIsIl9kYXNoUGF0dGVybiIsIl9kYXNoT2Zmc2V0IiwiX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zIiwib3BhY2l0eSIsImlzVHJhbnNwYXJlbnQiLCJjdHgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJ2YWx1ZSIsInBhY2tlZFN0cm9rZUNvbG9yIiwicGFja2VkVmFsdWUiLCJlbnVtVmFsIiwic2xpY2UiLCJzcmNTdHlsZSIsImRzdFN0eWxlIiwic3Ryb2tlU3R5bGVBIiwic3Ryb2tlU3R5bGVCIiwidmFsQSIsImlzU3Ryb2tlVmlzaWJsZSIsInZhbEIiLCJpIiwic3Ryb2tlU3R5bGVPYmoiLCJldmVudE5hbWUiLCJTdHJva2VDb2xvckNsYXNzIiwicHJldiIsImZpcmUiLCJhdHRyIiwicHJldlZhbCIsImN1cnJhbCIsImRpZmYiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztRQXdjZ0JBLDZCLEdBQUFBLDZCOztBQXRjaEI7Ozs7QUFDQTs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7OztBQVVBOzs7Ozs7QUFNQSxTQUFTQyxtQkFBVCxDQUE2QkMsV0FBN0IsRUFBMEM7QUFDeEMsTUFBSSxPQUFPQSxXQUFQLEtBQXVCLFFBQTNCLEVBQXFDO0FBQ25DLFVBQU0sSUFBSUMsS0FBSixDQUFVLCtCQUFWLENBQU47QUFDRDtBQUNGOztBQUVEOzs7O0FBSUEsSUFBTUMsV0FBVztBQUNmQyxTQUFPLENBRFE7QUFFZkMsU0FBTyxDQUZRO0FBR2ZDLFNBQU87O0FBR1Q7Ozs7QUFOaUIsQ0FBakIsQ0FVQSxJQUFNQyxlQUFlLENBQUMsT0FBRCxFQUFVLE9BQVYsRUFBbUIsT0FBbkIsQ0FBckI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxnQkFBVCxDQUEwQkMsUUFBMUIsRUFBb0M7QUFDbEMsTUFBSUMsTUFBTSxDQUFDLENBQVg7QUFDQSxNQUFJLE9BQU9ELFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsQ0FBQ0MsTUFBTUgsYUFBYUksT0FBYixDQUFxQkYsU0FBU0csV0FBVCxFQUFyQixDQUFQLElBQXVELENBQTNGLEVBQThGO0FBQzVGLFVBQU0sSUFBSVYsS0FBSixxREFBNERLLGFBQWFNLElBQWIsQ0FBa0IsSUFBbEIsQ0FBNUQsT0FBTjtBQUNEO0FBQ0QsU0FBT0gsR0FBUDtBQUNEOztBQUVEOzs7O0FBSUEsSUFBTUksVUFBVTtBQUNkQyxRQUFNLENBRFE7QUFFZEMsVUFBUSxDQUZNO0FBR2RWLFNBQU87O0FBR1Q7Ozs7QUFOZ0IsQ0FBaEIsQ0FVQSxJQUFNVyxjQUFjLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUIsT0FBbkIsQ0FBcEI7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTQyxlQUFULENBQXlCQyxPQUF6QixFQUFrQztBQUNoQyxNQUFJ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O0FBQ0E7QUFDRDtBQUNGO0FBQ0YsU0FQRCxNQU9PO0FBQ0xBLGlCQUFPLElBQVA7QUFDRDs7QUFFRCxZQUFJQSxJQUFKLEVBQVU7QUFDUixjQUFNTCxPQUFPLEtBQUsxQixZQUFsQjtBQUNBLGVBQUtBLFlBQUwsR0FBb0JqQixZQUFZK0IsS0FBWixFQUFwQjtBQUNBLGVBQUthLElBQUwsQ0FBVUgsU0FBVixFQUFxQjtBQUNuQkksa0JBQU0sYUFEYTtBQUVuQkMscUJBQVNILElBRlU7QUFHbkJJLG9CQUFRLEtBQUs5QixZQUFMLENBQWtCYyxLQUFsQjtBQUhXLFdBQXJCO0FBS0Q7QUFDRCxlQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXZJSztBQUFBLDBCQTJJYTtBQUNoQixlQUFPLEtBQUtkLFlBQUwsQ0FBa0JjLEtBQWxCLEVBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQS9JSztBQUFBO0FBQUEsd0JBcUpVMUIsVUFySlYsRUFxSnNCO0FBQ3pCRCwyQkFBbUJDLFVBQW5COztBQUVBLFlBQUlBLGVBQWUsS0FBS2EsV0FBeEIsRUFBcUM7QUFDbkMsY0FBTXlCLE9BQU8sS0FBS3pCLFdBQWxCO0FBQ0EsZUFBS0EsV0FBTCxHQUFtQmIsVUFBbkI7O0FBRUEsY0FBSSxLQUFLWSxZQUFMLENBQWtCZCxNQUF0QixFQUE4QjtBQUM1QjtBQUNBLGlCQUFLeUMsSUFBTCxDQUFVSCxTQUFWLEVBQXFCO0FBQ25CSSxvQkFBTSxZQURhO0FBRW5CQyx1QkFBU0gsSUFGVTtBQUduQkksc0JBQVEsS0FBSzdCO0FBSE0sYUFBckI7QUFLRDtBQUNGO0FBQ0QsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUF4S0s7QUFBQSwwQkE0S1k7QUFDZixlQUFPLEtBQUtBLFdBQVo7QUFDRDtBQTlLSTs7QUFBQTtBQUFBLE1BQVA7QUFnTEQiLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgQ29sb3JSR0JBLCB7Y3JlYXRlRXZlbnRlZENvbG9yUkdCQUNsYXNzfSBmcm9tIFwiLi9jb2xvci1yZ2JhXCJcbmltcG9ydCBhZ2dyZWdhdGlvbiBmcm9tIFwiLi4vdXRpbC9hZ2dyZWdhdGlvblwiXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU3Ryb2tlU3R5bGVPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N0cm9rZUNvbG9yID0gXCJibGFja1wiXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdHJva2VXaWR0aCA9IDBdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVKb2luID0gXCJtaXRlclwiXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsaW5lQ2FwID0gXCJidXR0XCJdXG4gKiBAcHJvcGVydHkge251bWJlcltdfSBbZGFzaFBhdHRlcm4gPSBbXV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGFzaE9mZnNldCA9IDBdXG4gKi9cblxuLyoqXG4gKiB2YWxpZGF0ZXMgYSBwb3NzaWJsZSBzdHJva2Ugd2lkdGggdmFsdWVcbiAqIEBwYXJhbSAge251bWJlcn0gc3Ryb2tlV2lkdGhcbiAqIEB0aHJvd3MgSWYgdmFsaWRhdGlvbiBmYWlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTdHJva2VXaWR0aChzdHJva2VXaWR0aCkge1xuICBpZiAodHlwZW9mIHN0cm9rZVdpZHRoICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3Ryb2tlIHdpZHRoIG11c3QgYmUgYSBudW1iZXJcIilcbiAgfVxufVxuXG4vKipcbiAqIEVudW0gZm9yIGxpbmUgam9pbiB2YWx1ZXNcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IEpvaW5FbnVtID0ge1xuICBNSVRFUjogMCxcbiAgQkVWRUw6IDEsXG4gIFJPVU5EOiAyXG59XG5cbi8qKlxuICogbGluZSBqb2luIHZhbHVlcyBhcyBzdHJpbmdzLCB0aGUgZW51bSB2YWx1ZXMgbWF0Y2ggdGhlIGluZGV4IGluIHRoaXMgc3RyaW5nXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IGxpbmVKb2luT3B0cyA9IFtcIm1pdGVyXCIsIFwiYmV2ZWxcIiwgXCJyb3VuZFwiXVxuXG4vKipcbiAqIHZhbGlkYXRlcyBhIGxpbmUgam9pbiB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSBsaW5lSm9pbiBTaG91bGQgYmUgb25lIG9mIFtcIm1pdGVyXCIsIFwiYmV2ZWxcIiwgXCJyb3VuZFwiXVxuICogQHRocm93cyBJZiB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcmV0dXJuIHtKb2luRW51bX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGluZUpvaW4obGluZUpvaW4pIHtcbiAgbGV0IGlkeCA9IC0xXG4gIGlmICh0eXBlb2YgbGluZUpvaW4gIT09IFwic3RyaW5nXCIgfHwgKGlkeCA9IGxpbmVKb2luT3B0cy5pbmRleE9mKGxpbmVKb2luLnRvTG93ZXJDYXNlKCkpKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmUgam9pbiBtdXN0IGJlIGEgc3RyaW5nIGFuZCBtdXN0IGJlIG9uZSBvZiBbJHtsaW5lSm9pbk9wdHMuam9pbihcIiwgXCIpfV1gKVxuICB9XG4gIHJldHVybiBpZHhcbn1cblxuLyoqXG4gKiBFbnVtIGZvciBsaW5lIGNhcCB2YWx1ZXNcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENhcEVudW0gPSB7XG4gIEJVVFQ6IDAsXG4gIFNRVUFSRTogMSxcbiAgUk9VTkQ6IDJcbn1cblxuLyoqXG4gKiBsaW5lIGNhcCB2YWx1ZXMgYXMgc3RyaW5ncywgdGhlIENhcEVudW0gdmFsdWVzIG1hdGNoIHRoZSBpbmRleCBpbiB0aGlzIHN0cmluZ1xuICogQHR5cGUge3N0cmluZ1tdfVxuICovXG5jb25zdCBsaW5lQ2FwT3B0cyA9IFtcImJ1dHRcIiwgXCJzcXVhcmVcIiwgXCJyb3VuZFwiXVxuXG4vKipcbiAqIHZhbGlkYXRlcyBhIGxpbmUgY2FwIHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVDYXAgU2hvdWxkIGJlIG9uZSBvZiBcImJ1dHRcIiwgXCJzcXVhcmVcIiwgXCJyb3VuZFwiXG4gKiBAdGhyb3dzIElmIHZhbGlkYXRpb24gZmFpbHNcbiAqIEByZXR1cm4ge0NhcEVudW19XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUxpbmVDYXAobGluZUNhcCkge1xuICBsZXQgaWR4ID0gLTFcbiAgaWYgKHR5cGVvZiBsaW5lQ2FwICE9PSBcInN0cmluZ1wiIHx8IChpZHggPSBsaW5lQ2FwT3B0cy5pbmRleE9mKGxpbmVDYXAudG9Mb3dlckNhc2UoKSkpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGluZSBjYXAgbXVzdCBiZSBhIHN0cmluZyBhbmQgbXVzdCBiZSBvbmUgb2YgWyR7bGluZUNhcE9wdHMuam9pbihcIiwgXCIpfV1gKVxuICB9XG4gIHJldHVybiBpZHhcbn1cblxuLyoqXG4gKiB2YWxpZGF0ZXMgYSBkYXNoIHBhdHRlcm4gdmFsdWVcbiAqIEBwYXJhbSAge251bWJlcltdfSBkYXNoUGF0dGVyblxuICogQHRocm93cyBJZiB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURhc2hQYXR0ZXJuKGRhc2hQYXR0ZXJuKSB7XG4gIGlmICghZGFzaFBhdHRlcm4gfHwgIUFycmF5LmlzQXJyYXkoZGFzaFBhdHRlcm4pIHx8IGRhc2hQYXR0ZXJuLmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGFzaCBwYXR0ZXJuIG11c3QgYmUgYW4gYXJyYXkgd2l0aCBhbiBldmVuIG51bWJlciBvZiBudW1iZXJzIChvciBhbiBlbXB0eSBhcnJheSlcIilcbiAgfVxufVxuXG4vKipcbiAqIHZhbGlkYXRlcyBhIGRhc2ggb2Zmc2V0IHZhbHVlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGRhc2hPZmZzZXRcbiAqIEB0aHJvd3MgSWYgdmFsaWRhdGlvbiBmYWlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVEYXNoT2Zmc2V0KGRhc2hPZmZzZXQpIHtcbiAgaWYgKHR5cGVvZiBkYXNoT2Zmc2V0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhc2ggb2Zmc2V0IG11c3QgYmUgYSBudW1iZXJcIilcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0cm9rZSBzdHlsZSBvZiBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYW4gYmUgdXNlZCBhcyBhIG1peGluIG9yIGJhc2UgY2xhc3NcbiAqIEBjbGFzc1xuICogQG1peGluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cm9rZVN0eWxlIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMuaW5pdGlhbGl6ZXIob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBpbml0aWFsaXplcyB0aGUgc3Ryb2tlIHN0eWxlIG9iamVjdCBmcm9tIGFuIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlT3B0aW9uc30gW29wdHNdXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdFN0cm9rZVN0eWxlRnJvbU9wdGlvbnMob3B0cykge1xuICAgIGlmIChvcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdHMuc3Ryb2tlQ29sb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IG9wdHMuc3Ryb2tlQ29sb3JcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5zdHJva2VPcGFjaXR5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IG9wdHMuc3Ryb2tlT3BhY2l0eVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzLnN0cm9rZVdpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBvcHRzLnN0cm9rZVdpZHRoXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMubGluZU1pdGVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMubGluZUpvaW4gPSBvcHRzLmxpbmVNaXRlclxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzLmxpbmVDYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5saW5lQ2FwID0gb3B0cy5saW5lQ2FwXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMuZGFzaFBhdHRlcm4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5kYXNoUGF0dGVybiA9IG9wdHMuZGFzaFBhdHRlcm5cbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5kYXNoT2Zmc2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRoaXMuZGFzaE9mZnNldCA9IG9wdHMuZGFzaE9mZnNldFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBtZXRob2QgdG8gaW5pdGlhbGl6ZSBhIHN0cm9rZSBzdHlsZS4gVXNlZCBmb3IgYm90aCBpbml0aWFsaXppbmdcbiAgICogdmlhIGJhc2UtY2xhc3MgYW5kIG1peGluIGhpZXJhcmNoeS5cbiAgICogQHBhcmFtICB7U3Ryb2tlU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgaW5pdGlhbGl6ZXIob3B0cykge1xuICAgIHRoaXMuX3N0cm9rZUNvbG9yID0gbmV3IENvbG9yUkdCQShcImJsYWNrXCIpXG4gICAgdGhpcy5fc3Ryb2tlV2lkdGggPSAwXG4gICAgdGhpcy5fbGluZUpvaW4gPSBKb2luRW51bS5NSVRFUlxuICAgIHRoaXMuX2xpbmVDYXAgPSBDYXBFbnVtLkJVVFRcbiAgICB0aGlzLl9kYXNoUGF0dGVybiA9IFtdXG4gICAgdGhpcy5fZGFzaE9mZnNldCA9IDBcbiAgICB0aGlzLl9pbml0U3Ryb2tlU3R5bGVGcm9tT3B0aW9ucyhvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cm9rZSBjb2xvclxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0cm9rZUNvbG9yIENvbG9yIGFzIGEgc3RyaW5nLCBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBhIGNvbG9yIGtleXdvcmQgKGkuZS4gXCJibGFja1wiKVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBzdHJva2VDb2xvcihzdHJva2VDb2xvcikge1xuICAgIHRoaXMuX3N0cm9rZUNvbG9yLnZhbHVlID0gc3Ryb2tlQ29sb3JcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgc3R5bGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHN0cm9rZUNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci52YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIHN0cm9rZSBzdHlsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9wYWNpdHkgWzAsMV1cbiAgICogQHJldHVybiB7U3Ryb2tlU3R5bGV9XG4gICAqL1xuICBzZXQgc3Ryb2tlT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdGhpcy5fc3Ryb2tlQ29sb3Iub3BhY2l0eSA9IG9wYWNpdHlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IG9wYWNpdHkgb2YgdGhlIHN0cm9rZSBzdHlsZSBbMCwxXVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkgaW4gdGhlIHJhbmdlIFswLDFdXG4gICAqL1xuICBnZXQgc3Ryb2tlT3BhY2l0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlQ29sb3Iub3BhY2l0eVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cm9rZSBjb2xvciBvZiB0aGUgc3R5bGUgZGVmaW5lZCBhcyBhIDMyLWJpdCBpbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwYWNrZWRTdHJva2VDb2xvciBDb2xvciB2YWx1ZSBhcyBhIDMyLWJpdCBpbnQgKGkuZS4gMHhGRkZGRkZGRilcbiAgICogQHJldHVybiB7U3Ryb2tlU3R5bGV9XG4gICAqL1xuICBzZXQgcGFja2VkU3Ryb2tlQ29sb3IocGFja2VkU3Ryb2tlQ29sb3IpIHtcbiAgICB0aGlzLl9zdHJva2VDb2xvci5wYWNrZWRWYWx1ZSA9IHBhY2tlZFN0cm9rZUNvbG9yXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgY29sb3Igb2YgdGhlIHN0cm9rZSBzdHlsZSBhcyBhIDMyLWJpdCBpbnRcbiAgICogQHJldHVybiB7bnVtYmVyfSBpLmUuIDB4RkZGRkZGRkZcbiAgICovXG4gIGdldCBwYWNrZWRTdHJva2VDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlQ29sb3IucGFja2VkVmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJva2Ugd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBzdHJva2VXaWR0aFxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBzdHJva2VXaWR0aChzdHJva2VXaWR0aCkge1xuICAgIHZhbGlkYXRlU3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpXG4gICAgdGhpcy5fc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdHJva2Ugd2lkdGhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHN0cm9rZVdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VXaWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgaG93IGxpbmVzIHNob3VsZCBiZSBqb2luZWRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBsaW5lSm9pbiBPbmUgb2YgXCJtaXRlclwiLCBcInJvdW5kXCIsIG9yIFwiYmV2ZWxcIlxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBsaW5lSm9pbihsaW5lSm9pbikge1xuICAgIGNvbnN0IGVudW1WYWwgPSB2YWxpZGF0ZUxpbmVKb2luKGxpbmVKb2luKVxuICAgIHRoaXMuX2xpbmVKb2luID0gZW51bVZhbFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBsaW5lIGpvaW5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGxpbmVKb2luKCkge1xuICAgIHJldHVybiBsaW5lSm9pbk9wdHNbdGhpcy5fbGluZUpvaW5dXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBob3cgbGluZXMgc2hvdWxkIGJlIGNhcHBlZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVDYXAgT25lIG9mIFwiYnV0dFwiLCBcInNxdWFyZVwiLCBvciBcInJvdW5kXCJcbiAgICogQHJldHVybiB7U3Ryb2tlU3R5bGV9XG4gICAqL1xuICBzZXQgbGluZUNhcChsaW5lQ2FwKSB7XG4gICAgY29uc3QgZW51bVZhbCA9IHZhbGlkYXRlTGluZUNhcChsaW5lQ2FwKVxuICAgIHRoaXMuX2xpbmVDYXAgPSBlbnVtVmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpbmUgY2FwIG9mIHRoZSBzdHlsZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbGluZUNhcCgpIHtcbiAgICByZXR1cm4gbGluZUNhcE9wdHNbdGhpcy5fbGluZUpvaW5dXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGFzaCBwYXR0ZXJuIG9mIHRoZSBzdHlsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJbXX0gZGFzaFBhdHRlcm4gQSBsaXN0IG9mIG51bWJlcnMgdGhhdCBzcGVjaWZpZXMgZGlzdGFuY2VzIHRvIGFsdGVybmF0ZWx5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3IGEgbGluZSBhbmQgYSBnYXAgKGluIHNjcmVlbiB1bml0cylcbiAgICogQHJldHVybiB7U3Ryb2tlU3R5bGV9XG4gICAqL1xuICBzZXQgZGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pIHtcbiAgICB2YWxpZGF0ZURhc2hQYXR0ZXJuKGRhc2hQYXR0ZXJuKVxuICAgIHRoaXMuX2Rhc2hQYXR0ZXJuID0gZGFzaFBhdHRlcm4uc2xpY2UoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBkYXNoIHBhdHRlcm4gb2YgdGhlIHN0eWxlXG4gICAqIEByZXR1cm4ge251bWJlcltdfVxuICAgKi9cbiAgZ2V0IGRhc2hQYXR0ZXJuKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXNoUGF0dGVybi5zbGljZSgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZGFzaCBvZmZzZXQgb2YgdGhlIHN0eWxlXG4gICAqIEBwYXJhbSAge251bWJlcn0gZGFzaE9mZnNldFxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBkYXNoT2Zmc2V0KGRhc2hPZmZzZXQpIHtcbiAgICB2YWxpZGF0ZURhc2hPZmZzZXQoZGFzaE9mZnNldClcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gZGFzaE9mZnNldFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBkYXNoIG9mZnNldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgZGFzaE9mZnNldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGFzaE9mZnNldFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3Ryb2tlIHN0eWxlIGlzIHZpc2libGUsIGkuZS4gaXQgaXMgbm90IGZ1bGx5IHRyYW5zcGFyZW50XG4gICAqIGFuZCBoYXMgYSB3aWR0aCA+IDBcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzU3Ryb2tlVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlQ29sb3Iub3BhY2l0eSA+IDAgJiYgdGhpcy5fc3Ryb2tlV2lkdGggPiAwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHN0cm9rZSBpcyBwYXJ0aWFsbHkgdHJhbnNwYXJlbnQsIGkuZS4gb3BhY2l0eSA8IDFcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgaXNUcmFuc3BhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3Ryb2tlQ29sb3IuaXNUcmFuc3BhcmVudCgpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3Ryb2tlIHN0eWxlIHN0YXRlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgc2V0U3Ryb2tlQ3R4KGN0eCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlQ29sb3JcbiAgICBjdHgubGluZVdpZHRoID0gdGhpcy5fc3Ryb2tlV2lkdGhcbiAgICBjdHgubGluZUpvaW4gPSB0aGlzLl9saW5lSm9pblxuICAgIGN0eC5saW5lQ2FwID0gdGhpcy5fbGluZUNhcFxuICAgIGN0eC5zZXRMaW5lRGFzaCh0aGlzLl9kYXNoUGF0dGVybilcbiAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHRoZSBwcm9wZXJ0aWVzIG9mIG9uZSBzdHJva2Ugc3R5bGUgdG8gYW5vdGhlclxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gc3JjU3R5bGUgU3Ryb2tlU3R5bGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gZHN0U3R5bGUgU3Ryb2tlU3R5bGUgb2JqZWN0IHRvIGNvcHkgdG9cbiAgICovXG4gIHN0YXRpYyBjb3B5U3Ryb2tlU3R5bGUoc3JjU3R5bGUsIGRzdFN0eWxlKSB7XG4gICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5wYWNrZWRTdHJva2VDb2xvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5zdHJva2VDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkc3RTdHlsZS5zdHJva2VDb2xvciA9IHNyY1N0eWxlLnN0cm9rZUNvbG9yXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnN0cm9rZU9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZHN0U3R5bGUuc3Ryb2tlT3BhY2l0eSA9IHNyY1N0eWxlLnN0cm9rZU9wYWNpdHlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZHN0U3R5bGUucGFja2VkU3Ryb2tlQ29sb3IgPSBzcmNTdHlsZS5wYWNrZWRTdHJva2VDb2xvclxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnN0cm9rZVdpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkc3RTdHlsZS5zdHJva2VXaWR0aCA9IHNyY1N0eWxlLnN0cm9rZVdpZHRoXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUubGluZUpvaW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLmxpbmVKb2luID0gc3JjU3R5bGUubGluZUpvaW5cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5saW5lQ2FwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkc3RTdHlsZS5saW5lQ2FwID0gc3JjU3R5bGUubGluZUNhcFxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLmRhc2hQYXR0ZXJuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkc3RTdHlsZS5kYXNoUGF0dGVybiA9IHNyY1N0eWxlLmRhc2hQYXR0ZXJuXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuZGFzaE9mZnNldCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZHN0U3R5bGUuZGFzaE9mZnNldCA9IHNyY1N0eWxlLmRhc2hPZmZzZXRcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFyaXNvbiBvcGVyYXRvciBiZXR3ZWVuIHR3byBTdHJva2VTdHlsZSBvYmplY3RzLiBUaGlzIGlzIHByaW1hcmlseVxuICAgKiB1c2VkIGZvciBzb3J0aW5nIHRvIG1pbmltaXplIGNvbnRleHQgc3dpdGNoaW5nIG9mIGEgMmQgcmVuZGVyZXJcbiAgICogQHBhcmFtICB7U3Ryb2tlU3R5bGV9IHN0cm9rZVN0eWxlQVxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gc3Ryb2tlU3R5bGVCXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICBSZXR1cm5zIDwgMCBpZiBzdHJva2VTdHlsZUEgPCBzdHJva2VTdHlsZUIsID4gMCBpZiBzdHJva2VTdHlsZUEgPiBzdHJva2VTdHlsZUIsIG9yIDAgaWYgdGhleSBhcmUgZXF1YWwuXG4gICAqL1xuICBzdGF0aWMgY29tcGFyZVN0cm9rZVN0eWxlKHN0cm9rZVN0eWxlQSwgc3Ryb2tlU3R5bGVCKSB7XG4gICAgbGV0IHZhbEEgPSBzdHJva2VTdHlsZUEuaXNTdHJva2VWaXNpYmxlKClcbiAgICBsZXQgdmFsQiA9IHN0cm9rZVN0eWxlQi5pc1N0cm9rZVZpc2libGUoKVxuICAgIGlmICh2YWxBICE9PSB2YWxCKSB7XG4gICAgICByZXR1cm4gdmFsQSAtIHZhbEJcbiAgICB9XG4gICAgdmFsQSA9IHN0cm9rZVN0eWxlQS5wYWNrZWRTdHJva2VDb2xvclxuICAgIHZhbEIgPSBzdHJva2VTdHlsZUIucGFja2VkU3Ryb2tlQ29sb3JcbiAgICBpZiAodmFsQSAhPT0gdmFsQikge1xuICAgICAgcmV0dXJuIHZhbEEgLSB2YWxCXG4gICAgfVxuICAgIHZhbEEgPSBzdHJva2VTdHlsZUEuc3Ryb2tlV2lkdGhcbiAgICB2YWxCID0gc3Ryb2tlU3R5bGVCLnN0cm9rZVdpZHRoXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICB2YWxBID0gc3Ryb2tlU3R5bGVBLl9saW5lSm9pblxuICAgIHZhbEIgPSBzdHJva2VTdHlsZUIuX2xpbmVKb2luXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICB2YWxBID0gc3Ryb2tlU3R5bGVBLl9saW5lQ2FwXG4gICAgdmFsQiA9IHN0cm9rZVN0eWxlQi5fbGluZUNhcFxuICAgIGlmICh2YWxBICE9PSB2YWxCKSB7XG4gICAgICByZXR1cm4gdmFsQSAtIHZhbEJcbiAgICB9XG4gICAgdmFsQSA9IHN0cm9rZVN0eWxlQS5fZGFzaFBhdHRlcm5cbiAgICB2YWxCID0gc3Ryb2tlU3R5bGVCLl9kYXNoUGF0dGVyblxuICAgIGlmICh2YWxBLmxlbmd0aCA9PT0gdmFsQi5sZW5ndGggJiYgdmFsQS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbEEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHZhbEFbaV0gIT09IHZhbEJbaV0pIHtcbiAgICAgICAgICByZXR1cm4gdmFsQVtpXSAtIHZhbEJbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cm9rZVN0eWxlQS5kYXNoT2Zmc2V0IC0gc3Ryb2tlU3R5bGVCLmRhc2hPZmZzZXRcbiAgICB9XG4gICAgcmV0dXJuIHZhbEEubGVuZ3RoIC0gdmFsQi5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEganNvbiBvYmplY3Qgb2YgYSBTdHJva2VTdHlsZSBvYmplY3RcbiAgICogQHBhcmFtICB7U3Ryb2tlU3R5bGV9IHN0cm9rZVN0eWxlT2JqXG4gICAqIEByZXR1cm4ge3tzdHJva2VDb2xvcjogc3RyaW5nLFxuICAgKiAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG51bWJlcixcbiAgICogICAgICAgICAgIGxpbmVKb2luOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBsaW5lQ2FwOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBkYXNoUGF0dGVybjogbnVtYmVyW10sXG4gICAqICAgICAgICAgICBkYXNoT2Zmc2V0OiBudW1iZXJcbiAgICogICAgICAgICAgfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oc3Ryb2tlU3R5bGVPYmopIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3Ryb2tlQ29sb3I6IHN0cm9rZVN0eWxlT2JqLnN0cm9rZUNvbG9yLFxuICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVN0eWxlT2JqLnN0cm9rZVdpZHRoLFxuICAgICAgbGluZUpvaW46IHN0cm9rZVN0eWxlT2JqLmxpbmVKb2luLFxuICAgICAgbGluZUNhcDogc3Ryb2tlU3R5bGVPYmoubGluZUNhcCxcbiAgICAgIGRhc2hQYXR0ZXJuOiBzdHJva2VTdHlsZU9iai5kYXNoUGF0dGVybixcbiAgICAgIGRhc2hPZmZzZXQ6IHN0cm9rZVN0eWxlT2JqLmRhc2hPZmZzZXRcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHN0cm9rZSBzdHlsZSBjbGFzcyB0aGF0IGZpcmVzIGV2ZW50cyB3aGVuZXZlciB0aGUgc3R5bGVcbiAqIGlzIG1vZGlmaWVkLlxuICogQHBhcmFtICB7c3RyaW5nfSBldmVudE5hbWUgRXZlbnQgdHlwZSB0byBmaXJlIHdoZW4gc3Ryb2tlIHN0eWxlIGlzIG1vZGlmaWVkXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICBOZXcgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50ZWRTdHJva2VTdHlsZU1peGluKGV2ZW50TmFtZSkge1xuICAvKipcbiAgICogRXZlbnRlZCBzdHJva2UgY29sb3IgY2xhc3MgdG8gaGFuZGxlIGNvbG9yIG1vZGlmaWNhdGlvbiBldmVudHNcbiAgICogQHR5cGUge0NvbG9yUkdCQX1cbiAgICovXG4gIGNvbnN0IFN0cm9rZUNvbG9yQ2xhc3MgPSBjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3MoZXZlbnROYW1lLCBcInN0cm9rZUNvbG9yXCIpXG5cbiAgLyoqXG4gICAqIFN0cm9rZSBzdHlsZSBtb2RpZmljYXRpb24gZXZlbnRcbiAgICogQGV2ZW50IEV2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBtb2RpZmllZFxuICAgKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICAgKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWl4aW4gTmV3IGV2ZW50ZWQgc3Ryb2tlIHN0eWxlIG1peGluLiBXaWxsIGZpcmUgZXZlbnRzIHdoZW5ldmVyXG4gICAqICAgICAgICB0aGUgc3Ryb2tlIGlzIG1vZGlmaWVkXG4gICAqL1xuICByZXR1cm4gYWdncmVnYXRpb24obnVsbCwgU3Ryb2tlU3R5bGUsIGNsYXNzIEV2ZW50ZWRTdHJva2VTdHlsZSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXIgbWV0aG9kIHRvIGluaXRpYWxpemUgYW4gZXZlbnRlZCBzdHJva2Ugc3R5bGUuXG4gICAgICogQHBhcmFtICB7U3Ryb2tlU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZXIob3B0cykge1xuICAgICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSBuZXcgU3Ryb2tlQ29sb3JDbGFzcyhcImJsYWNrXCIsIHRoaXMpXG4gICAgICB0aGlzLl9zdHJva2VXaWR0aCA9IDBcbiAgICAgIHRoaXMuX2xpbmVKb2luID0gSm9pbkVudW0uTUlURVJcbiAgICAgIHRoaXMuX2xpbmVDYXAgPSBDYXBFbnVtLkJVVFRcbiAgICAgIHRoaXMuX2Rhc2hQYXR0ZXJuID0gW11cbiAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAwXG4gICAgICB0aGlzLl9pbml0U3Ryb2tlU3R5bGVGcm9tT3B0aW9ucyhvcHRzKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSAge251bWJlcn1cbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFN0cm9rZVN0eWxlfVxuICAgICAqL1xuICAgIHNldCBzdHJva2VXaWR0aChzdHJva2VXaWR0aCkge1xuICAgICAgdmFsaWRhdGVTdHJva2VXaWR0aChzdHJva2VXaWR0aClcbiAgICAgIGlmIChzdHJva2VXaWR0aCAhPT0gdGhpcy5fc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3N0cm9rZVdpZHRoXG4gICAgICAgIHRoaXMuX3N0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGhcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwic3Ryb2tlV2lkdGhcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJhbDogdGhpcy5fc3Ryb2tlV2lkdGhcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0cm9rZSB3aWR0aFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3Ryb2tlV2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlV2lkdGhcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaW5lIGpvaW5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVKb2luXG4gICAgICogQGZpcmVzIHtFdmVudGVkU3Ryb2tlU3R5bGUjY2hhbmdlZH1cbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgICBjb25zdCBlbnVtVmFsID0gdmFsaWRhdGVMaW5lSm9pbihsaW5lSm9pbilcblxuICAgICAgaWYgKGVudW1WYWwgIT09IHRoaXMuX2xpbmVKb2luKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9saW5lSm9pblxuICAgICAgICB0aGlzLl9saW5lSm9pbiA9IGVudW1WYWxcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwibGluZUpvaW5cIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJhbDogdGhpcy5fbGluZUpvaW5cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpbmUgam9pblxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbGluZUpvaW4oKSB7XG4gICAgICByZXR1cm4gbGluZUpvaW5PcHRzW3RoaXMuX2xpbmVKb2luXVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpbmUgY2FwXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBsaW5lQ2FwXG4gICAgICogQGZpcmVzIHtFdmVudGVkU3Ryb2tlU3R5bGUjY2hhbmdlZH1cbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IGxpbmVDYXAobGluZUNhcCkge1xuICAgICAgY29uc3QgZW51bVZhbCA9IHZhbGlkYXRlTGluZUNhcChsaW5lQ2FwKVxuICAgICAgaWYgKGVudW1WYWwgIT09IHRoaXMuX2xpbmVDYXApIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2xpbmVDYXBcbiAgICAgICAgdGhpcy5fbGluZUNhcCA9IGVudW1WYWxcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwibGluZUNhcFwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9saW5lQ2FwXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpbmUgY2FwXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsaW5lQ2FwKCkge1xuICAgICAgcmV0dXJuIGxpbmVDYXBPcHRzW3RoaXMuX2xpbmVDYXBdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGFzaCBwYXR0ZXJuXG4gICAgICogQHBhcmFtICB7bnVtYmVyW119IGRhc2hQYXR0ZXJuXG4gICAgICogQGZpcmVzIHtFdmVudGVkU3Ryb2tlU3R5bGUjY2hhbmdlZH1cbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IGRhc2hQYXR0ZXJuKGRhc2hQYXR0ZXJuKSB7XG4gICAgICB2YWxpZGF0ZURhc2hQYXR0ZXJuKGRhc2hQYXR0ZXJuKVxuICAgICAgbGV0IGRpZmYgPSBmYWxzZVxuICAgICAgaWYgKGRhc2hQYXR0ZXJuLmxlbmd0aCA9PT0gdGhpcy5fZGFzaFBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGFzaFBhdHRlcm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoZGFzaFBhdHRlcm5baV0gIT09IHRoaXMuX2Rhc2hQYXR0ZXJuW2ldKSB7XG4gICAgICAgICAgICBkaWZmID0gdHJ1ZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9kYXNoUGF0dGVyblxuICAgICAgICB0aGlzLl9kYXNoUGF0dGVybiA9IGRhc2hQYXR0ZXJuLnNsaWNlKClcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwiZGFzaFBhdHRlcm5cIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJhbDogdGhpcy5fZGFzaFBhdHRlcm4uc2xpY2UoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGRhc2ggcGF0dGVyblxuICAgICAqIEByZXR1cm4ge251bWJlcltdfVxuICAgICAqL1xuICAgIGdldCBkYXNoUGF0dGVybigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXNoUGF0dGVybi5zbGljZSgpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBkYXNoIG9mZnNldFxuICAgICAqIEBwYXJhbSAge251bWJlcn0gZGFzaE9mZnNldFxuICAgICAqIEBmaXJlcyB7RXZlbnRlZFN0cm9rZVN0eWxlI2NoYW5nZWR9XG4gICAgICogQHJldHVybiB7RXZlbnRlZFN0cm9rZVN0eWxlfVxuICAgICAqL1xuICAgIHNldCBkYXNoT2Zmc2V0KGRhc2hPZmZzZXQpIHtcbiAgICAgIHZhbGlkYXRlRGFzaE9mZnNldChkYXNoT2Zmc2V0KVxuXG4gICAgICBpZiAoZGFzaE9mZnNldCAhPT0gdGhpcy5fZGFzaE9mZnNldCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fZGFzaE9mZnNldFxuICAgICAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gZGFzaE9mZnNldFxuXG4gICAgICAgIGlmICh0aGlzLl9kYXNoUGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBvbmx5IGZpcmUgaWYgZGFzaGluZyBpcyBhY3RpdmF0ZWRcbiAgICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgICBhdHRyOiBcImRhc2hPZmZzZXRcIixcbiAgICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgICBjdXJyYWw6IHRoaXMuX2Rhc2hPZmZzZXRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgZGFzaCBvZmZzZXRcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRhc2hPZmZzZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGFzaE9mZnNldFxuICAgIH1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3N0eWxlL3N0cm9rZS1zdHlsZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _interactUtils = __webpack_require__(20);\n\nvar InteractUtils = _interopRequireWildcard(_interactUtils);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _basicStyle = __webpack_require__(8);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _drawEngine = __webpack_require__(13);\n\nvar _drawEngine2 = _interopRequireDefault(_drawEngine);\n\nvar _mat2d = __webpack_require__(4);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _polyLine = __webpack_require__(10);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nvar _vertEditableShape = __webpack_require__(21);\n\nvar _vertEditableShape2 = _interopRequireDefault(_vertEditableShape);\n\nvar _xformShape = __webpack_require__(22);\n\nvar _xformShape2 = _interopRequireDefault(_xformShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar scaleSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpolygon style='fill:%23ffffff;' points='16,20 16,12 4,24 16,36 16,28 32,28 32,36 44,24 32,12 32,20 '/%3E%3Cpolygon points='14,22 14,17 7,24 14,31 14,26 34,26 34,31 41,24 34,17 34,22 '/%3E%3C/g%3E%3C/svg%3E\\\") no-repeat\";\n\nvar rotateSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpath style='fill:%23ffffff;' d='M25.9,4C16.6,4,8.8,11.2,7.4,20.8H6.7H3.3l1.6,2.9l3.8,7.1l1.8,3.3l1.8-3.3l3.8-7.1l1.6-2.9h-3.3h-0.1 c1.3-5.7,6.1-9.9,11.7-9.9c8,0,12.1,4.4,12.1,13.1c0,7.2-5.4,13.1-12.1,13.1h-2v2V42v2h2c10.4,0,18.8-9,18.8-20 C44.7,11.7,37.5,4,25.9,4L25.9,4z'/%3E%3Cpath d='M25.9,6c10.5,0,16.8,6.7,16.8,18c0,9.9-7.5,18-16.8,18v-2.9c7.8,0,14.1-6.8,14.1-15.1c0-5.6-1.8-15.1-14.1-15.1 c-7.4,0-13.4,6.1-14,13.9h2.4l-3.8,7.1l-3.8-7.1h2.5C9.7,13.4,17,6,25.9,6'/%3E%3C/g%3E%3C/svg%3E\\\") no-repeat\";\n\nvar addSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpolygon style='fill:%23ffffff;' points='31.2,28 24.8,28 24.8,32.8 20,32.8 20,39.2 24.8,39.2 24.8,44 31.2,44 31.2,39.2 36,39.2 36,32.8 31.2,32.8 '/%3E %3Cpolygon style='fill:%23ffffff' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='29.6,29.6 29.6,34.4 34.4,34.4 34.4,37.6 29.6,37.6 29.6,42.4 26.4,42.4 26.4,37.6 21.6,37.6 21.6,34.4 26.4,34.4 26.4,29.6 29.6,29.6  '/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar removeSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Crect style='fill:%23ffffff;' x='20' y='32.8' width='16' height='6.4'/%3E%3Cpolygon  style='fill:%23ffffff;' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='34.4,34.4 34.4,37.6 21.6,37.6 21.6,34.4 '/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar repositionSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath style='fill:%23ffffff;' d='M24,17.5c-3.6,0-6.5,2.9-6.5,6.5s2.9,6.5,6.5,6.5s6.5-2.9,6.5-6.5S27.6,17.5,24,17.5L24,17.5z'/%3E%3Cpath style='fill:%23ffffff;' d='M24,4L4,24l20,20l20-20L24,4z M31.5,31.5h-15v-15h15V31.5z'/%3E%3Cpolygon points='17,34 24,40.5 31,34  '/%3E%3Cpolygon points='31,14 24,7.5 17,14     '/%3E%3Cpolygon points='14,17 7.5,24 14,31   '/%3E%3Cpolygon points='34,31 40.5,24 34,17    '/%3E%3Cpath d='M24,20c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S21.8,20,24,20'/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar EventConstants = {\n  SELECTION_CHANGED: \"draw:selectionChanged\",\n  DRAG_BEGIN: \"draw:drag:begin\",\n  DRAG_END: \"draw:drag:end\"\n};\n\nvar Constants = {\n  SVG_OFFSET: -14,\n  QUICK_CLICK_TIME: 500,\n  RIGHT_ANGLE: 90,\n  STRAIGHT_ANGLE: 180,\n  FORTY_FIVE_ANGLE: 45\n};\n\nvar tmpPt1 = Point2d.create(0, 0);\nvar tmpPt2 = Point2d.create(0, 0);\n\nvar defaultXformStyle = {\n  fillColor: \"white\",\n  strokeColor: \"black\",\n  strokeWidth: 2\n};\n\nvar EventsTypes = {\n  MOUSEDOWN: \"mousedown\",\n  MOUSEUP: \"mouseup\",\n  MOUSEMOVE: \"mousemove\",\n  TOUCHSTART: \"touchstart\",\n  TOUCHEND: \"touchend\",\n  TOUCHMOVE: \"touchmove\"\n\n  // This method will Add clientX, clientY & offsetX and offsetY for Touch events\n};function getTouchCoordinates(event, canvas) {\n  event.clientX = event.touches[0].clientX;\n  event.clientY = event.touches[0].clientY;\n  var element = canvas.getBoundingClientRect();\n  event.offsetX = event.touches[0].clientX - element.left;\n  event.offsetY = event.touches[0].clientY - element.top;\n  return event;\n}\n\nfunction inCanvas(canvas, x, y) {\n  var domrect = canvas.getBoundingClientRect();\n  var localX = 0;\n  var localY = 0;\n  var isInCanvas = (localX = x - domrect.left - canvas.clientLeft) >= 0 && localX <= canvas.clientWidth && (localY = y - domrect.top - canvas.clientTop) >= 0 && localY <= canvas.clientHeight;\n  return isInCanvas;\n}\n\nfunction getLocalMousePos(out, elem, event) {\n  var domrect = elem.getBoundingClientRect();\n  out[0] = event.clientX - domrect.left - elem.clientLeft;\n  out[1] = event.clientY - domrect.top - elem.clientTop;\n}\n\nfunction transformSelectedShape(canvas, event, selectedInfo, camera) {\n  getLocalMousePos(tmpPt1, canvas, event);\n  Point2d.transformMat2d(tmpPt2, tmpPt1, camera.screenToWorldMatrix);\n  var shape = selectedInfo.shape;\n  if (shape instanceof _xformShape2.default) {\n    InteractUtils.transformXformShape(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  } else if (shape instanceof _vertEditableShape2.default) {\n    InteractUtils.translateVert(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  } else {\n    InteractUtils.translateShape(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  }\n}\n\nfunction addEventKeysToSelectedInfo(event, selectedInfo) {\n  selectedInfo.keys = {\n    altKey: event.altKey,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    metaKey: event.metaKey\n  };\n}\n\nfunction getSelectedObjsFromMap(selectionMap) {\n  var selectedObjs = [];\n  selectionMap.forEach(function (subshape, shape) {\n    selectedObjs.push(shape);\n  });\n  return selectedObjs;\n}\n\nfunction _selectShape(selectedShape, sortedShapes, currSelectedShapes, selectStyle, xformStyle, selectOpts) {\n  var fireObject = {\n    unselectedShapes: getSelectedObjsFromMap(currSelectedShapes)\n  };\n  clearSelectedShapes(currSelectedShapes);\n  selectedShape.save();\n  var maxZ = sortedShapes[sortedShapes.length - 1].zIndex;\n  selectedShape.zIndex = maxZ + 1;\n  _basicStyle2.default.copyBasicStyle(selectStyle, selectedShape);\n  selectedShape.selected = true;\n  // const dimensions = selectedShape.getDimensions()\n\n  var newSelectShape = null;\n  if (selectOpts.scalable || selectOpts.rotatable) {\n    newSelectShape = new _xformShape2.default(xformStyle || defaultXformStyle, selectOpts);\n    selectedShape.addChildXform(newSelectShape);\n  }\n  currSelectedShapes.set(selectedShape, newSelectShape);\n\n  fireObject.selectedShapes = [selectedShape];\n  return fireObject;\n}\n\nfunction clearSelectedShapes(selectedShapeMap) {\n  selectedShapeMap.forEach(function (selectedShape, shape) {\n    shape.restore();\n    shape.selected = false;\n    shape.removeChildXform(selectedShape);\n  });\n  selectedShapeMap.clear();\n}\n\nfunction clearSpecificShapes(selectedShapeMap, shapes) {\n  var clearedShapes = [];\n  shapes.forEach(function (shape) {\n    var selectedShape = selectedShapeMap.get(shape);\n    shape.restore();\n    shape.selected = false;\n    shape.removeChildXform(selectedShape);\n    selectedShapeMap.delete(shape);\n    clearedShapes.push(shape);\n  });\n  return clearedShapes;\n}\n\nvar hideCursor = function hideCursor() {\n  var cursor = document.getElementById(\"cursor\");\n  if (cursor !== null) {\n    cursor.style.display = \"none\";\n  }\n};\n\nvar showCursor = function showCursor() {\n  var cursor = document.getElementById(\"cursor\");\n  if (cursor !== null) {\n    cursor.style.display = \"block\";\n  }\n};\n\nvar hideCursorWithPointer = function hideCursorWithPointer(e) {\n  e.target.parentNode.style.cursor = \"default\";\n  hideCursor();\n};\n\nvar showCursorWithPointer = function showCursorWithPointer(e) {\n  e.target.parentNode.style.cursor = \"none\";\n  showCursor();\n};\n\n// understands how to return mouse coordinates as an object in the format {x: <X-COORD>, y: <Y-COORD>}\n// accepts a mouse event and a DOM element as arguments\nfunction getMouseCoordinates(e, target) {\n  var canvas = document.querySelector(\"\" + (\"#\" + target.id + \" canvas\"));\n\n  var coords = {\n    x: e.offsetX + canvas.offsetLeft,\n    y: e.offsetY + canvas.offsetTop\n  };\n\n  return coords;\n}\n\n// understands how to append custom cursors to the DOM\n// accepts a mouse event, a DOM element, a cursorStyle, and pixel offsets as arguments\nfunction appendCustomCursor(_event, target, cursorStyle) {\n  var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Constants.SVG_OFFSET;\n  var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Constants.SVG_OFFSET;\n\n  var cursor = document.getElementById(\"cursor\");\n  var mouse = getMouseCoordinates(_event, target);\n\n  if (cursor === null) {\n    var newCursor = document.createElement(\"span\");\n    newCursor.setAttribute(\"id\", \"cursor\");\n    newCursor.setAttribute(\"style\", \"position: absolute; top: \" + (mouse.y + \"px\") + \"; left: \" + (mouse.x + \"px\") + \"; width: 28px; height: 28px; background: \" + cursorStyle + \"; cursor: none; z-index: 10; pointer-events: none; transform: translate(\" + offsetX + \"px, \" + offsetY + \"px)\");\n    target.appendChild(newCursor);\n  } else if (cursor.style.background === cursorStyle) {\n    updateCursorPosition(_event, target);\n  } else {\n    cursor.style.background = cursorStyle;\n    updateCursorPosition(_event, target);\n  }\n}\n\n// understands how to remove the custom cursor from the DOM\nfunction removeCustomCursor() {\n  var cursor = document.getElementById(\"cursor\");\n  if (cursor !== null) {\n    cursor.parentNode.removeChild(cursor);\n  }\n}\n\n// understands how to change the position of the custom cursor on the page\n// accepts a mouse event and a DOM element as arguments\nfunction updateCursorPosition(_event, target) {\n  var cursor = document.getElementById(\"cursor\");\n  var mouse = getMouseCoordinates(_event, target);\n\n  if (cursor !== null) {\n    cursor.style.top = \"\" + (mouse.y + \"px\");\n    cursor.style.left = \"\" + (mouse.x + \"px\");\n  }\n}\n\nvar ShapeBuilder = function (_DrawEngine) {\n  _inherits(ShapeBuilder, _DrawEngine);\n\n  function ShapeBuilder() {\n    _classCallCheck(this, ShapeBuilder);\n\n    return _possibleConstructorReturn(this, (ShapeBuilder.__proto__ || Object.getPrototypeOf(ShapeBuilder)).apply(this, arguments));\n  }\n\n  _createClass(ShapeBuilder, [{\n    key: \"_touchstartCB\",\n    value: function _touchstartCB(event) {\n      this._mousedownCB(event);\n    }\n  }, {\n    key: \"_touchmoveCB\",\n    value: function _touchmoveCB(event) {\n      this._mousemoveCB(event);\n    }\n  }, {\n    key: \"_touchendCB\",\n    value: function _touchendCB(event) {\n      this._mouseupCB(event);\n    }\n  }, {\n    key: \"_mousedownCB\",\n    value: function _mousedownCB(event) {\n      this.setDenyMouseEventFlag(event);\n      if (this.denyMouseEvent && !event.touches) {\n        return;\n      }\n      if (event.touches) {\n        event = getTouchCoordinates(event, this._drawCanvas);\n        this.previousEventObj = event; // Assign event obj to variable to avoid the use it for touchend event\n      }\n\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY)) {\n        return;\n      }\n\n      this.timer = performance.now();\n\n      Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n      Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      var shapes = this.sortedShapes;\n      var i = -1;\n      var selectedShape = null;\n      var selectedInfo = null;\n      for (i = shapes.length - 1; i >= 0; i -= 1) {\n        var shapeInfo = this._objects.get(shapes[i]);\n        if (shapes[i].selected) {\n          selectedShape = this._selectedShapes.get(shapes[i]);\n          selectedInfo = shapeInfo;\n          var hitInfo = null;\n          if (selectedShape && (hitInfo = selectedShape.containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)).hit) {\n            if (selectedShape instanceof _vertEditableShape2.default && event.altKey && hitInfo.controlIndex < shapes[i].numVerts) {\n              shapes[i].removeVert(hitInfo.controlIndex);\n              selectedShape = null;\n            } else {\n              var localXform = selectedShape.parent.localXform;\n              var invLocalXform = _mat2d2.default.clone(localXform);\n              _mat2d2.default.invert(invLocalXform, invLocalXform);\n              var startObjPos = Point2d.clone(tmpPt2);\n              Point2d.transformMat2d(startObjPos, startObjPos, invLocalXform);\n              this._dragInfo = Object.assign({\n                rotate: Boolean(hitInfo.rotate),\n                controlIndex: hitInfo.controlIndex,\n                startObjectPos: startObjPos,\n                worldToObjectMatrix: invLocalXform,\n                startLocalPos: selectedShape.parent.getPosition(),\n                startLocalScale: selectedShape.parent.getScale(),\n                startLocalRot: selectedShape.parent.getRotation(),\n                shapeWidth: selectedShape.parent.width,\n                shapeHeight: selectedShape.parent.height\n              }, selectedInfo);\n            }\n            break;\n          } else if (shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n            selectedShape = shapes[i];\n            break;\n          }\n        }\n        // else if (shapeInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n        //   selectedShape = shapes[i]\n        //   selectedInfo = shapeInfo\n        //   const selectEventObj = selectShape(selectedShape, shapes, this._selectedShapes, this._selectStyle, this._xformStyle, selectedInfo)\n        //   this.fire(EventConstants.SELECTION_CHANGED, selectEventObj)\n        //   break\n        // }\n      }\n\n      if (i < 0 && this._selectedShapes.size) {\n        if (this._selectedShapes.size) {\n          this.fire(EventConstants.SELECTION_CHANGED, {\n            unselectedShapes: getSelectedObjsFromMap(this._selectedShapes),\n            selectedShapes: []\n          });\n        }\n        this._dragInfo = null;\n        clearSelectedShapes(this._selectedShapes);\n      } else if (selectedShape && selectedInfo && (selectedInfo.movable || selectedInfo.rotatable || selectedInfo.scalable)) {\n        var canvas = document.querySelector(\"\" + (\"#\" + this._parent.id + \" > canvas\"));\n        if (canvas === null) {\n          this._parent.addEventListener(\"mouseout\", hideCursor);\n          this._parent.addEventListener(\"mouseover\", showCursor);\n        } else {\n          canvas.addEventListener(\"mouseout\", hideCursorWithPointer);\n          canvas.addEventListener(\"mouseover\", showCursorWithPointer);\n        }\n        if (!this._dragInfo && selectedInfo.movable) {\n          this._dragInfo = {\n            startLocalPos: selectedShape.getPosition()\n          };\n        }\n\n        if (this._dragInfo) {\n          this._dragInfo.shape = selectedShape;\n          this._dragInfo.startPos = Point2d.clone(tmpPt1);\n          this._dragInfo.startWorldPos = Point2d.clone(tmpPt2);\n          this._dragInfo.objectToWorldMatrix = _mat2d2.default.clone(selectedShape.globalXform);\n          addEventKeysToSelectedInfo(event, this._dragInfo);\n          event.stopImmediatePropagation();\n          this.fire(EventConstants.DRAG_BEGIN, {\n            shapes: getSelectedObjsFromMap(this._selectedShapes)\n          });\n        }\n        if (!event.touches) {\n          event.preventDefault();\n        }\n      }\n    }\n  }, {\n    key: \"_mouseupCB\",\n    value: function _mouseupCB(event) {\n      if (this.denyMouseEvent && !event.touches) {\n        this.setDenyMouseEventFlag(event);\n        return; // Returning on next line to avoid ESLint error\n      }\n      if (event.touches) {\n        // Use previously assigned event obj to get the offsetX & Y and clientX & Y calculation\n        event = this.previousEventObj;\n      }\n\n      if (this._dragInfo && this._dragInfo.shape) {\n        event.stopImmediatePropagation();\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n        var canvas = document.querySelector(\"\" + (\"#\" + this._parent.id + \" > canvas\"));\n        if (canvas === null) {\n          this._parent.removeEventListener(\"mouseout\", hideCursor);\n          this._parent.removeEventListener(\"mouseover\", showCursor);\n        } else {\n          canvas.removeEventListener(\"mouseout\", hideCursorWithPointer);\n          canvas.removeEventListener(\"mouseover\", showCursorWithPointer);\n        }\n        this._dragInfo = null;\n        this.fire(EventConstants.DRAG_END, {\n          shapes: getSelectedObjsFromMap(this._selectedShapes)\n        });\n      } else if (performance.now() - this.timer < Constants.QUICK_CLICK_TIME) {\n        // this is a relatively quick click\n        Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n        Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n        var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n        var shapes = this.sortedShapes;\n        var selectedShape = null;\n        var selectedInfo = null;\n        for (var i = shapes.length - 1; i >= 0; i -= 1) {\n          selectedInfo = this._objects.get(shapes[i]);\n          if (selectedInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n            selectedShape = shapes[i];\n            break;\n          }\n        }\n        if (selectedShape && !selectedShape.selected) {\n          var selectEventObj = _selectShape(selectedShape, shapes, this._selectedShapes, this._selectStyle, this._xformStyle, selectedInfo);\n          this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n        } else {\n          // If user clicks anywhere outside then allow the movement of Base Map (Parents Container)\n          this._makeParentElementMovable();\n        }\n      }\n    }\n  }, {\n    key: \"_mousemoveCB\",\n    value: function _mousemoveCB(event) {\n      this.setDenyMouseEventFlag(event);\n      if (this.denyMouseEvent && !event.touches) {\n        return;\n      }\n\n      if (event.touches) {\n        event = getTouchCoordinates(event, this._drawCanvas);\n        this.previousEventObj = event; // Assign event obj to variable to avoid the use it for touchend event\n      }\n\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY) && !this._dragInfo) {\n        return;\n      }\n\n      if (this._dragInfo && this._dragInfo.shape) {\n        updateCursorPosition(event, this._parent);\n        addEventKeysToSelectedInfo(event, this._dragInfo);\n        transformSelectedShape(this._drawCanvas, event, this._dragInfo, this._camera);\n        event.stopImmediatePropagation();\n        if (!event.touches) {\n          event.preventDefault();\n        }\n      } else if (!event.buttons && this._selectedShapes.size) {\n        Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n        Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n        var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n        var shapes = this.sortedShapes;\n        var i = 0;\n        var flipy = this._camera.isYFlipped();\n        for (i = shapes.length - 1; i >= 0; i -= 1) {\n          if (shapes[i].selected) {\n            var selectInfo = this._objects.get(shapes[i]);\n            var selectedShape = this._selectedShapes.get(shapes[i]);\n            var hitInfo = null;\n            this._parent.style.cursor = \"none\";\n            // forEach not supported on nodelist in IE/Edge\n            for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n              this._parent.childNodes[j].style.cursor = \"none\";\n              if (this._parent.childNodes[j].nodeName.toLowerCase() !== \"canvas\") {\n                this._parent.childNodes[j].style.pointerEvents = \"none\";\n              }\n            }\n            if (selectedShape && (hitInfo = selectedShape.containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)).hit) {\n              if (selectedShape instanceof _xformShape2.default) {\n                if (hitInfo.rotate) {\n                  var degrees = shapes[i].getRotation();\n                  if (flipy) {\n                    degrees *= -1;\n                    if (hitInfo.controlIndex === 1) {\n                      degrees -= Constants.RIGHT_ANGLE;\n                    } else if (hitInfo.controlIndex === 0) {\n                      degrees += Constants.STRAIGHT_ANGLE;\n                    } else if (hitInfo.controlIndex === 2) {\n                      degrees += Constants.RIGHT_ANGLE;\n                    }\n                  } else if (hitInfo.controlIndex === 0) {\n                    degrees -= Constants.RIGHT_ANGLE;\n                  } else if (hitInfo.controlIndex === 1) {\n                    degrees += Constants.STRAIGHT_ANGLE;\n                  } else if (hitInfo.controlIndex === 3) {\n                    // eslint-disable-line no-magic-numbers\n                    degrees += Constants.RIGHT_ANGLE;\n                  }\n                  appendCustomCursor(event, this._parent, \"\" + rotateSvg.replace(/<degrees>/g, \"\" + degrees));\n                } else if (hitInfo.controlIndex < 4) {\n                  // eslint-disable-line no-magic-numbers\n                  if (hitInfo.controlIndex === 0 || hitInfo.controlIndex === 3) {\n                    // eslint-disable-line no-magic-numbers\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + (-shapes[i].getRotation() - Constants.FORTY_FIVE_ANGLE)));\n                  } else if (hitInfo.controlIndex === 1 || hitInfo.controlIndex === 2) {\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + (-shapes[i].getRotation() + Constants.FORTY_FIVE_ANGLE)));\n                  }\n                } else if (hitInfo.controlIndex % 2 === 0) {\n                  appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + -shapes[i].getRotation()));\n                } else {\n                  appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/<degrees>/g, \"\" + (-shapes[i].getRotation() + Constants.RIGHT_ANGLE)));\n                }\n              } else if (selectedShape instanceof _vertEditableShape2.default) {\n                this._parent.style.cursor = \"none\";\n                // forEach not supported on nodelist in IE/Edge\n                for (var _j = 0; _j < this._parent.childNodes.length; _j += 1) {\n                  this._parent.childNodes[_j].style.cursor = \"none\";\n                  if (this._parent.childNodes[_j].nodeName.toLowerCase() !== \"canvas\") {\n                    this._parent.childNodes[_j].style.pointerEvents = \"none\";\n                  }\n                }\n                if (hitInfo.controlIndex >= shapes[i].numVerts) {\n                  appendCustomCursor(event, this._parent, addSvg, -8, -6); // eslint-disable-line no-magic-numbers\n                } else if (event.altKey) {\n                  appendCustomCursor(event, this._parent, removeSvg, -8, -6); // eslint-disable-line no-magic-numbers\n                } else {\n                  appendCustomCursor(event, this._parent, repositionSvg, Constants.SVG_OFFSET, Constants.SVG_OFFSET);\n                }\n              }\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              break;\n            } else if (shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n              if (selectInfo && selectInfo.movable) {\n                var cursor = document.getElementById(\"cursor\");\n                if (cursor !== null) {\n                  cursor.parentNode.removeChild(cursor);\n                }\n                this._parent.style.cursor = \"move\";\n                for (var _j2 = 0; _j2 < this._parent.childNodes.length; _j2 += 1) {\n                  this._parent.childNodes[_j2].style.cursor = \"move\";\n                }\n                event.stopImmediatePropagation();\n                event.preventDefault();\n              }\n              break;\n            }\n          }\n        }\n\n        if (i < 0) {\n          removeCustomCursor();\n          this._parent.style.cursor = \"default\";\n          // forEach not supported on nodelist in IE/Edge\n          for (var _j3 = 0; _j3 < this._parent.childNodes.length; _j3 += 1) {\n            this._parent.childNodes[_j3].style.cursor = \"default\";\n            if (this._parent.childNodes[_j3].nodeName.toLowerCase() !== \"canvas\") {\n              this._parent.childNodes[_j3].style.pointerEvents = \"auto\";\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_clickCB\",\n    value: function _clickCB() {\n      // noop\n    }\n  }, {\n    key: \"_dblclickCB\",\n    value: function _dblclickCB(event) {\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY)) {\n        return;\n      }\n\n      Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n      Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      var shapes = this.sortedShapes;\n      var i = -1;\n      for (i = shapes.length - 1; i >= 0; i -= 1) {\n        var shapeInfo = this._objects.get(shapes[i]);\n        if (shapeInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n          if (shapeInfo.editable && shapes[i] instanceof _polyLine2.default) {\n            var selectedShape = shapes[i];\n            var doXform = false;\n            if (shapes[i].selected) {\n              var interactiveShape = this._selectedShapes.get(shapes[i]);\n              if (interactiveShape) {\n                selectedShape.restore();\n                selectedShape.removeChildXform(interactiveShape);\n                doXform = !(interactiveShape instanceof _xformShape2.default);\n              }\n            }\n\n            selectedShape.selected = true;\n            selectedShape.save();\n            var maxZ = shapes[shapes.length - 1].zIndex;\n            selectedShape.zIndex = maxZ + 1;\n            _basicStyle2.default.copyBasicStyle(this._selectStyle, selectedShape);\n            var newSelectShape = null;\n            if (doXform) {\n              if (shapeInfo.rotatable || shapeInfo.scalable) {\n                newSelectShape = new _xformShape2.default(this._xformStyle || defaultXformStyle, shapeInfo);\n                selectedShape.addChildXform(newSelectShape);\n              }\n            } else {\n              newSelectShape = new _vertEditableShape2.default(selectedShape, this._xformStyle);\n              selectedShape.addChildXform(newSelectShape);\n            }\n            this._selectedShapes.set(selectedShape, newSelectShape);\n          } else if (!shapes[i].selected) {\n            var selectEventObj = _selectShape(shapes[i], shapes, this._selectedShapes, this._selectStyle, this._xformStyle, shapeInfo);\n            this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n          }\n          break;\n        }\n      }\n\n      if (i < 0 && this._selectedShapes.size) {\n        if (this._selectedShapes.size) {\n          this.fire(EventConstants.SELECTION_CHANGED, {\n            unselectedShapes: getSelectedObjsFromMap(this._selectedShapes),\n            selectedShapes: []\n          });\n        }\n        this._dragInfo = null;\n        clearSelectedShapes(this._selectedShapes);\n      } else {\n        event.stopImmediatePropagation();\n      }\n      event.preventDefault();\n    }\n  }, {\n    key: \"_mouseoverCB\",\n    value: function _mouseoverCB() {\n      // noop\n    }\n  }, {\n    key: \"_mouseoutCB\",\n    value: function _mouseoutCB() {\n      // noop\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(parent, opts) {\n      this._activated = opts && opts.enableInteractions;\n      _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"_init\", this).call(this, parent, opts, this._activated);\n      var myevents = Object.getOwnPropertyNames(EventConstants).map(function (event) {\n        return EventConstants[event];\n      });\n      this.registerEvents(myevents);\n      this._dragInfo = null;\n      this._selectedShapes = new Map();\n      this._selectStyle = new _basicStyle2.default(opts && opts.selectStyle ? opts.selectStyle : {\n        fillColor: \"orange\"\n      });\n\n      this._xformStyle = new _basicStyle2.default(opts && opts.xformStyle ? opts.xformStyle : {\n        fillColor: \"white\",\n        strokeColor: \"black\",\n        strokeWidth: 2\n      });\n\n      this.timer = 0;\n    }\n\n    // This function allow the movement of Parent Container (In our case it is Map) when user clicks anywhere on Map except on Shape\n    // As well as it's changes the icon of mouse for Desktop devices\n\n  }, {\n    key: \"_makeParentElementMovable\",\n    value: function _makeParentElementMovable() {\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\"; // Change the Cursor icon for desktop device\n      for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n        this._parent.childNodes[j].style.cursor = \"default\"; // Change the Cursor icon for desktop device\n        if (this._parent.childNodes[j].nodeName.toLowerCase() !== \"canvas\") {\n          this._parent.childNodes[j].style.pointerEvents = \"auto\"; // Allow movemnet of parent container i.e Map\n        }\n      }\n    }\n  }, {\n    key: \"_renderShapes\",\n    value: function _renderShapes(ctx, drawShapes, camera) {\n      var _this2 = this;\n\n      var worldToScreenMat = camera.worldToScreenMatrix;\n      drawShapes.forEach(function (shape) {\n        if (shape.visible) {\n          shape.render(ctx, worldToScreenMat, _this2._styleState);\n          // shape.renderBounds(ctx, worldToScreenMat, boundsStrokeStyle)\n          if (shape.selected) {\n            var interacShape = _this2._selectedShapes.get(shape);\n            if (interacShape) {\n              interacShape.render(ctx, worldToScreenMat, _this2._styleState);\n              // interacShape.renderBounds(ctx, worldToScreenMat, boundsStrokeStyle)\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"selectShape\",\n    value: function selectShape(shape) {\n      var shapeInfo = this._objects.get(shape);\n      if (shapeInfo && shapeInfo.selectable) {\n        var selectEventObj = _selectShape(shape, this.sortedShapes, this._selectedShapes, this._selectStyle, this._xformStyle, shapeInfo);\n        this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (this._selectedShapes.size) {\n        var selectedShapes = getSelectedObjsFromMap(this._selectedShapes);\n        clearSelectedShapes(this._selectedShapes);\n        this.fire(EventConstants.SELECTION_CHANGED, {\n          unselectedShapes: selectedShapes,\n          selectedShapes: []\n        });\n        this._rerenderCb();\n      }\n    }\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape) {\n      var _this3 = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"addShape\", this).call(this, shapes);\n      shapes.forEach(function (newShape) {\n        var shapeInfo = _this3._objects.get(newShape);\n        if (shapeInfo) {\n          shapeInfo.selectable = opts && typeof opts.selectable !== \"undefined\" ? Boolean(opts.selectable) : true;\n          shapeInfo.movable = opts && typeof opts.movable !== \"undefined\" ? Boolean(opts.movable) : true;\n          shapeInfo.rotatable = opts && typeof opts.rotatable !== \"undefined\" ? Boolean(opts.rotatable) : true;\n          shapeInfo.scalable = opts && typeof opts.scalable !== \"undefined\" ? Boolean(opts.scalable) : true;\n          shapeInfo.uniformScaleOnly = opts && typeof opts.uniformScaleOnly !== \"undefined\" ? Boolean(opts.uniformScaleOnly) : false;\n          shapeInfo.centerScaleOnly = opts && typeof opts.centerScaleOnly !== \"undefined\" ? Boolean(opts.centerScaleOnly) : false;\n          shapeInfo.editable = opts && typeof opts.editable !== \"undefined\" ? Boolean(opts.editable) : true;\n        }\n      });\n\n      if (select) {\n        var selectEventObj = {\n          unselectedShapes: getSelectedObjsFromMap(this._selectedShapes)\n        };\n        var selectedShapes = [];\n        shapes.forEach(function (newShape) {\n          var shapeInfo = _this3._objects.get(newShape);\n          if (shapeInfo.selectable) {\n            _selectShape(newShape, _this3.sortedShapes, _this3._selectedShapes, _this3._selectStyle, _this3._xformStyle, shapeInfo);\n            selectedShapes.push(newShape);\n          }\n        });\n\n        if (selectedShapes.length) {\n          selectEventObj.selectedShapes = selectedShapes;\n          this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n      var selectClearedShapes = clearSpecificShapes(this._selectedShapes, shapes);\n      this.fire(EventConstants.SELECTION_CHANGED, {\n        unselectedShapes: selectClearedShapes,\n        selectedShapes: getSelectedObjsFromMap(this._selectedShapes)\n      });\n\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\";\n      // forEach not supported on nodelist in IE/Edge\n      for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n        this._parent.childNodes[j].style.cursor = \"default\";\n        this._parent.childNodes[j].style.pointerEvents = \"auto\";\n      }\n\n      return _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"deleteShape\", this).call(this, shapes);\n    }\n  }, {\n    key: \"deleteSelectedShapes\",\n    value: function deleteSelectedShapes() {\n      var selectedShapes = getSelectedObjsFromMap(this._selectedShapes);\n      clearSelectedShapes(this._selectedShapes);\n      this.fire(EventConstants.SELECTION_CHANGED, {\n        unselectedShapes: selectedShapes,\n        selectedShapes: []\n      });\n\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\";\n      // forEach not supported on nodelist in IE/Edge\n      for (var j = 0; j < this._parent.childNodes.length; j += 1) {\n        this._parent.childNodes[j].style.cursor = \"default\";\n        this._parent.childNodes[j].style.pointerEvents = \"auto\";\n      }\n\n      return _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"deleteShape\", this).call(this, selectedShapes);\n    }\n  }, {\n    key: \"enableInteractions\",\n    value: function enableInteractions() {\n      this._enableEvents();\n      this._activated = true;\n      return this;\n    }\n  }, {\n    key: \"disableInteractions\",\n    value: function disableInteractions() {\n      var clearSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (clearSelection) {\n        this.clearSelection();\n      }\n      this._disableEvents();\n      this._activated = false;\n      return this;\n    }\n\n    // This method is used to stop Mouse Event propagation Triggered from the Touch event\n\n  }, {\n    key: \"setDenyMouseEventFlag\",\n    value: function setDenyMouseEventFlag(event) {\n      if (event.touches) {\n        this.denyMouseEvent = true;\n      } else if (event.type === EventsTypes.MOUSEUP) {\n        // set the Flag false at the end of mouse event i.e on MouseUp Event\n        this.denyMouseEvent = false;\n      }\n    }\n  }, {\n    key: \"selectStyle\",\n    set: function set(selectStyle) {\n      _basicStyle2.default.copyBasicStyle(selectStyle, this._selectStyle);\n    },\n    get: function get() {\n      return this._selectStyle;\n    }\n  }, {\n    key: \"selectedShapes\",\n    get: function get() {\n      return getSelectedObjsFromMap(this._selectedShapes);\n    }\n  }, {\n    key: \"interactionsEnabled\",\n    get: function get() {\n      return this._activated;\n    }\n  }]);\n\n  return ShapeBuilder;\n}(_drawEngine2.default);\n\nexports.default = ShapeBuilder;\n\n\nObject.assign(EventConstants, _drawEngine2.default.EventConstants);\nShapeBuilder.EventConstants = EventConstants;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2hhcGUtYnVpbGRlci5qcz8yNjg0Il0sIm5hbWVzIjpbIkludGVyYWN0VXRpbHMiLCJQb2ludDJkIiwic2NhbGVTdmciLCJyb3RhdGVTdmciLCJhZGRTdmciLCJyZW1vdmVTdmciLCJyZXBvc2l0aW9uU3ZnIiwiRXZlbnRDb25zdGFudHMiLCJTRUxFQ1RJT05fQ0hBTkdFRCIsIkRSQUdfQkVHSU4iLCJEUkFHX0VORCIsIkNvbnN0YW50cyIsIlNWR19PRkZTRVQiLCJRVUlDS19DTElDS19USU1FIiwiUklHSFRfQU5HTEUiLCJTVFJBSUdIVF9BTkdMRSIsIkZPUlRZX0ZJVkVfQU5HTEUiLCJ0bXBQdDEiLCJjcmVhdGUiLCJ0bXBQdDIiLCJkZWZhdWx0WGZvcm1TdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZUNvbG9yIiwic3Ryb2tlV2lkdGgiLCJFdmVudHNUeXBlcyIsIk1PVVNFRE9XTiIsIk1PVVNFVVAiLCJNT1VTRU1PVkUiLCJUT1VDSFNUQVJUIiwiVE9VQ0hFTkQiLCJUT1VDSE1PVkUiLCJnZXRUb3VjaENvb3JkaW5hdGVzIiwiZXZlbnQiLCJjYW52YXMiLCJjbGllbnRYIiwidG91Y2hlcyIsImNsaWVudFkiLCJlbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwib2Zmc2V0WCIsImxlZnQiLCJvZmZzZXRZIiwidG9wIiwiaW5DYW52YXMiLCJ4IiwieSIsImRvbXJlY3QiLCJsb2NhbFgiLCJsb2NhbFkiLCJpc0luQ2FudmFzIiwiY2xpZW50TGVmdCIsImNsaWVudFdpZHRoIiwiY2xpZW50VG9wIiwiY2xpZW50SGVpZ2h0IiwiZ2V0TG9jYWxNb3VzZVBvcyIsIm91dCIsImVsZW0iLCJ0cmFuc2Zvcm1TZWxlY3RlZFNoYXBlIiwic2VsZWN0ZWRJbmZvIiwiY2FtZXJhIiwidHJhbnNmb3JtTWF0MmQiLCJzY3JlZW5Ub1dvcmxkTWF0cml4Iiwic2hhcGUiLCJYZm9ybVNoYXBlIiwidHJhbnNmb3JtWGZvcm1TaGFwZSIsIlZlcnRFZGl0YWJsZVNoYXBlIiwidHJhbnNsYXRlVmVydCIsInRyYW5zbGF0ZVNoYXBlIiwiYWRkRXZlbnRLZXlzVG9TZWxlY3RlZEluZm8iLCJrZXlzIiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5IiwibWV0YUtleSIsImdldFNlbGVjdGVkT2Jqc0Zyb21NYXAiLCJzZWxlY3Rpb25NYXAiLCJzZWxlY3RlZE9ianMiLCJmb3JFYWNoIiwic3Vic2hhcGUiLCJwdXNoIiwic2VsZWN0U2hhcGUiLCJzZWxlY3RlZFNoYXBlIiwic29ydGVkU2hhcGVzIiwiY3VyclNlbGVjdGVkU2hhcGVzIiwic2VsZWN0U3R5bGUiLCJ4Zm9ybVN0eWxlIiwic2VsZWN0T3B0cyIsImZpcmVPYmplY3QiLCJ1bnNlbGVjdGVkU2hhcGVzIiwiY2xlYXJTZWxlY3RlZFNoYXBlcyIsInNhdmUiLCJtYXhaIiwibGVuZ3RoIiwiekluZGV4IiwiQmFzaWNTdHlsZSIsImNvcHlCYXNpY1N0eWxlIiwic2VsZWN0ZWQiLCJuZXdTZWxlY3RTaGFwZSIsInNjYWxhYmxlIiwicm90YXRhYmxlIiwiYWRkQ2hpbGRYZm9ybSIsInNldCIsInNlbGVjdGVkU2hhcGVzIiwic2VsZWN0ZWRTaGFwZU1hcCIsInJlc3RvcmUiLCJyZW1vdmVDaGlsZFhmb3JtIiwiY2xlYXIiLCJjbGVhclNwZWNpZmljU2hhcGVzIiwic2hhcGVzIiwiY2xlYXJlZFNoYXBlcyIsImdldCIsImRlbGV0ZSIsImhpZGVDdXJzb3IiLCJjdXJzb3IiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3R5bGUiLCJkaXNwbGF5Iiwic2hvd0N1cnNvciIsImhpZGVDdXJzb3JXaXRoUG9pbnRlciIsImUiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwic2hvd0N1cnNvcldpdGhQb2ludGVyIiwiZ2V0TW91c2VDb29yZGluYXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpZCIsImNvb3JkcyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJhcHBlbmRDdXN0b21DdXJzb3IiLCJfZXZlbnQiLCJjdXJzb3JTdHlsZSIsIm1vdXNlIiwibmV3Q3Vyc29yIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImFwcGVuZENoaWxkIiwiYmFja2dyb3VuZCIsInVwZGF0ZUN1cnNvclBvc2l0aW9uIiwicmVtb3ZlQ3VzdG9tQ3Vyc29yIiwicmVtb3ZlQ2hpbGQiLCJTaGFwZUJ1aWxkZXIiLCJfbW91c2Vkb3duQ0IiLCJfbW91c2Vtb3ZlQ0IiLCJfbW91c2V1cENCIiwic2V0RGVueU1vdXNlRXZlbnRGbGFnIiwiZGVueU1vdXNlRXZlbnQiLCJfZHJhd0NhbnZhcyIsInByZXZpb3VzRXZlbnRPYmoiLCJ0aW1lciIsInBlcmZvcm1hbmNlIiwibm93IiwiX2NhbWVyYSIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJpIiwic2hhcGVJbmZvIiwiX29iamVjdHMiLCJfc2VsZWN0ZWRTaGFwZXMiLCJoaXRJbmZvIiwiY29udGFpbnNQb2ludCIsIl9kcmF3Q3R4IiwiaGl0IiwiY29udHJvbEluZGV4IiwibnVtVmVydHMiLCJyZW1vdmVWZXJ0IiwibG9jYWxYZm9ybSIsInBhcmVudCIsImludkxvY2FsWGZvcm0iLCJNYXQyZCIsImNsb25lIiwiaW52ZXJ0Iiwic3RhcnRPYmpQb3MiLCJfZHJhZ0luZm8iLCJPYmplY3QiLCJhc3NpZ24iLCJyb3RhdGUiLCJCb29sZWFuIiwic3RhcnRPYmplY3RQb3MiLCJ3b3JsZFRvT2JqZWN0TWF0cml4Iiwic3RhcnRMb2NhbFBvcyIsImdldFBvc2l0aW9uIiwic3RhcnRMb2NhbFNjYWxlIiwiZ2V0U2NhbGUiLCJzdGFydExvY2FsUm90IiwiZ2V0Um90YXRpb24iLCJzaGFwZVdpZHRoIiwid2lkdGgiLCJzaGFwZUhlaWdodCIsImhlaWdodCIsInNpemUiLCJmaXJlIiwibW92YWJsZSIsIl9wYXJlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwic3RhcnRQb3MiLCJzdGFydFdvcmxkUG9zIiwib2JqZWN0VG9Xb3JsZE1hdHJpeCIsImdsb2JhbFhmb3JtIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJjYW5jZWxhYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNlbGVjdGFibGUiLCJzZWxlY3RFdmVudE9iaiIsIl9zZWxlY3RTdHlsZSIsIl94Zm9ybVN0eWxlIiwiX21ha2VQYXJlbnRFbGVtZW50TW92YWJsZSIsImJ1dHRvbnMiLCJmbGlweSIsImlzWUZsaXBwZWQiLCJzZWxlY3RJbmZvIiwiaiIsImNoaWxkTm9kZXMiLCJub2RlTmFtZSIsInRvTG93ZXJDYXNlIiwicG9pbnRlckV2ZW50cyIsImRlZ3JlZXMiLCJyZXBsYWNlIiwiZWRpdGFibGUiLCJQb2x5TGluZSIsImRvWGZvcm0iLCJpbnRlcmFjdGl2ZVNoYXBlIiwib3B0cyIsIl9hY3RpdmF0ZWQiLCJlbmFibGVJbnRlcmFjdGlvbnMiLCJteWV2ZW50cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJtYXAiLCJyZWdpc3RlckV2ZW50cyIsIk1hcCIsImN0eCIsImRyYXdTaGFwZXMiLCJ3b3JsZFRvU2NyZWVuTWF0IiwidmlzaWJsZSIsInJlbmRlciIsIl9zdHlsZVN0YXRlIiwiaW50ZXJhY1NoYXBlIiwiX3JlcmVuZGVyQ2IiLCJzZWxlY3QiLCJBcnJheSIsImlzQXJyYXkiLCJuZXdTaGFwZSIsInVuaWZvcm1TY2FsZU9ubHkiLCJjZW50ZXJTY2FsZU9ubHkiLCJzZWxlY3RDbGVhcmVkU2hhcGVzIiwiX2VuYWJsZUV2ZW50cyIsImNsZWFyU2VsZWN0aW9uIiwiX2Rpc2FibGVFdmVudHMiLCJ0eXBlIiwiRHJhd0VuZ2luZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQTs7SUFBWUEsYTs7QUFDWjs7SUFBWUMsTzs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUMsV0FBVyxtV0FBakI7O0FBRUEsSUFBTUMsWUFBWSwrbkJBQWxCOztBQUVBLElBQU1DLFNBQVMsa2tCQUFmOztBQUVBLElBQU1DLFlBQVksMlpBQWxCOztBQUVBLElBQU1DLGdCQUFnQixzbEJBQXRCOztBQUVBLElBQU1DLGlCQUFpQjtBQUNyQkMscUJBQW1CLHVCQURFO0FBRXJCQyxjQUFZLGlCQUZTO0FBR3JCQyxZQUFVO0FBSFcsQ0FBdkI7O0FBTUEsSUFBTUMsWUFBWTtBQUNoQkMsY0FBWSxDQUFDLEVBREc7QUFFaEJDLG9CQUFrQixHQUZGO0FBR2hCQyxlQUFhLEVBSEc7QUFJaEJDLGtCQUFnQixHQUpBO0FBS2hCQyxvQkFBa0I7QUFMRixDQUFsQjs7QUFRQSxJQUFNQyxTQUFTaEIsUUFBUWlCLE1BQVIsQ0FBZSxDQUFmLEVBQWtCLENBQWxCLENBQWY7QUFDQSxJQUFNQyxTQUFTbEIsUUFBUWlCLE1BQVIsQ0FBZSxDQUFmLEVBQWtCLENBQWxCLENBQWY7O0FBRUEsSUFBTUUsb0JBQW9CO0FBQ3hCQyxhQUFXLE9BRGE7QUFFeEJDLGVBQWEsT0FGVztBQUd4QkMsZUFBYTtBQUhXLENBQTFCOztBQU1BLElBQU1DLGNBQWM7QUFDbEJDLGFBQVcsV0FETztBQUVsQkMsV0FBUyxTQUZTO0FBR2xCQyxhQUFXLFdBSE87QUFJbEJDLGNBQVksWUFKTTtBQUtsQkMsWUFBVSxVQUxRO0FBTWxCQyxhQUFXOztBQUdiO0FBVG9CLENBQXBCLENBVUEsU0FBU0MsbUJBQVQsQ0FBNkJDLEtBQTdCLEVBQW9DQyxNQUFwQyxFQUE0QztBQUMxQ0QsUUFBTUUsT0FBTixHQUFnQkYsTUFBTUcsT0FBTixDQUFjLENBQWQsRUFBaUJELE9BQWpDO0FBQ0FGLFFBQU1JLE9BQU4sR0FBZ0JKLE1BQU1HLE9BQU4sQ0FBYyxDQUFkLEVBQWlCQyxPQUFqQztBQUNBLE1BQU1DLFVBQVVKLE9BQU9LLHFCQUFQLEVBQWhCO0FBQ0FOLFFBQU1PLE9BQU4sR0FBZ0JQLE1BQU1HLE9BQU4sQ0FBYyxDQUFkLEVBQWlCRCxPQUFqQixHQUEyQkcsUUFBUUcsSUFBbkQ7QUFDQVIsUUFBTVMsT0FBTixHQUFnQlQsTUFBTUcsT0FBTixDQUFjLENBQWQsRUFBaUJDLE9BQWpCLEdBQTJCQyxRQUFRSyxHQUFuRDtBQUNBLFNBQU9WLEtBQVA7QUFDRDs7QUFFRCxTQUFTVyxRQUFULENBQWtCVixNQUFsQixFQUEwQlcsQ0FBMUIsRUFBNkJDLENBQTdCLEVBQWdDO0FBQzlCLE1BQU1DLFVBQVViLE9BQU9LLHFCQUFQLEVBQWhCO0FBQ0EsTUFBSVMsU0FBUyxDQUFiO0FBQ0EsTUFBSUMsU0FBUyxDQUFiO0FBQ0EsTUFBTUMsYUFBYyxDQUFDRixTQUFTSCxJQUFJRSxRQUFRTixJQUFaLEdBQW1CUCxPQUFPaUIsVUFBcEMsS0FBbUQsQ0FBbkQsSUFBd0RILFVBQVVkLE9BQU9rQixXQUF6RSxJQUF3RixDQUFDSCxTQUFTSCxJQUFJQyxRQUFRSixHQUFaLEdBQWtCVCxPQUFPbUIsU0FBbkMsS0FBaUQsQ0FBekksSUFBOElKLFVBQVVmLE9BQU9vQixZQUFuTDtBQUNBLFNBQU9KLFVBQVA7QUFDRDs7QUFFRCxTQUFTSyxnQkFBVCxDQUEwQkMsR0FBMUIsRUFBK0JDLElBQS9CLEVBQXFDeEIsS0FBckMsRUFBNEM7QUFDMUMsTUFBTWMsVUFBVVUsS0FBS2xCLHFCQUFMLEVBQWhCO0FBQ0FpQixNQUFJLENBQUosSUFBU3ZCLE1BQU1FLE9BQU4sR0FBZ0JZLFFBQVFOLElBQXhCLEdBQStCZ0IsS0FBS04sVUFBN0M7QUFDQUssTUFBSSxDQUFKLElBQVN2QixNQUFNSSxPQUFOLEdBQWdCVSxRQUFRSixHQUF4QixHQUE4QmMsS0FBS0osU0FBNUM7QUFDRDs7QUFFRCxTQUFTSyxzQkFBVCxDQUFnQ3hCLE1BQWhDLEVBQXdDRCxLQUF4QyxFQUErQzBCLFlBQS9DLEVBQTZEQyxNQUE3RCxFQUFxRTtBQUNuRUwsbUJBQWlCckMsTUFBakIsRUFBeUJnQixNQUF6QixFQUFpQ0QsS0FBakM7QUFDQS9CLFVBQVEyRCxjQUFSLENBQXVCekMsTUFBdkIsRUFBK0JGLE1BQS9CLEVBQXVDMEMsT0FBT0UsbUJBQTlDO0FBQ0EsTUFBTUMsUUFBUUosYUFBYUksS0FBM0I7QUFDQSxNQUFJQSxpQkFBaUJDLG9CQUFyQixFQUFpQztBQUMvQi9ELGtCQUFjZ0UsbUJBQWQsQ0FBa0NGLEtBQWxDLEVBQXlDSixZQUF6QyxFQUF1RHpDLE1BQXZELEVBQStERSxNQUEvRCxFQUF1RXdDLE1BQXZFO0FBQ0QsR0FGRCxNQUVPLElBQUlHLGlCQUFpQkcsMkJBQXJCLEVBQXdDO0FBQzdDakUsa0JBQWNrRSxhQUFkLENBQTRCSixLQUE1QixFQUFtQ0osWUFBbkMsRUFBaUR6QyxNQUFqRCxFQUF5REUsTUFBekQsRUFBaUV3QyxNQUFqRTtBQUNELEdBRk0sTUFFQTtBQUNMM0Qsa0JBQWNtRSxjQUFkLENBQTZCTCxLQUE3QixFQUFvQ0osWUFBcEMsRUFBa0R6QyxNQUFsRCxFQUEwREUsTUFBMUQsRUFBa0V3QyxNQUFsRTtBQUNEO0FBQ0Y7O0FBRUQsU0FBU1MsMEJBQVQsQ0FBb0NwQyxLQUFwQyxFQUEyQzBCLFlBQTNDLEVBQXlEO0FBQ3ZEQSxlQUFhVyxJQUFiLEdBQW9CO0FBQ2xCQyxZQUFRdEMsTUFBTXNDLE1BREk7QUFFbEJDLGFBQVN2QyxNQUFNdUMsT0FGRztBQUdsQkMsY0FBVXhDLE1BQU13QyxRQUhFO0FBSWxCQyxhQUFTekMsTUFBTXlDO0FBSkcsR0FBcEI7QUFNRDs7QUFFRCxTQUFTQyxzQkFBVCxDQUFnQ0MsWUFBaEMsRUFBOEM7QUFDNUMsTUFBTUMsZUFBZSxFQUFyQjtBQUNBRCxlQUFhRSxPQUFiLENBQXFCLFVBQUNDLFFBQUQsRUFBV2hCLEtBQVgsRUFBcUI7QUFDeENjLGlCQUFhRyxJQUFiLENBQWtCakIsS0FBbEI7QUFDRCxHQUZEO0FBR0EsU0FBT2MsWUFBUDtBQUNEOztBQUVELFNBQVNJLFlBQVQsQ0FBcUJDLGFBQXJCLEVBQW9DQyxZQUFwQyxFQUFrREMsa0JBQWxELEVBQXNFQyxXQUF0RSxFQUFtRkMsVUFBbkYsRUFBK0ZDLFVBQS9GLEVBQTJHO0FBQ3pHLE1BQU1DLGFBQWE7QUFDakJDLHNCQUFrQmQsdUJBQXVCUyxrQkFBdkI7QUFERCxHQUFuQjtBQUdBTSxzQkFBb0JOLGtCQUFwQjtBQUNBRixnQkFBY1MsSUFBZDtBQUNBLE1BQU1DLE9BQU9ULGFBQWFBLGFBQWFVLE1BQWIsR0FBc0IsQ0FBbkMsRUFBc0NDLE1BQW5EO0FBQ0FaLGdCQUFjWSxNQUFkLEdBQXVCRixPQUFPLENBQTlCO0FBQ0FHLHVCQUFXQyxjQUFYLENBQTBCWCxXQUExQixFQUF1Q0gsYUFBdkM7QUFDQUEsZ0JBQWNlLFFBQWQsR0FBeUIsSUFBekI7QUFDQTs7QUFFQSxNQUFJQyxpQkFBaUIsSUFBckI7QUFDQSxNQUFJWCxXQUFXWSxRQUFYLElBQXVCWixXQUFXYSxTQUF0QyxFQUFpRDtBQUMvQ0YscUJBQWlCLElBQUlsQyxvQkFBSixDQUFlc0IsY0FBY2pFLGlCQUE3QixFQUFnRGtFLFVBQWhELENBQWpCO0FBQ0FMLGtCQUFjbUIsYUFBZCxDQUE0QkgsY0FBNUI7QUFDRDtBQUNEZCxxQkFBbUJrQixHQUFuQixDQUF1QnBCLGFBQXZCLEVBQXNDZ0IsY0FBdEM7O0FBRUFWLGFBQVdlLGNBQVgsR0FBNEIsQ0FBQ3JCLGFBQUQsQ0FBNUI7QUFDQSxTQUFPTSxVQUFQO0FBQ0Q7O0FBRUQsU0FBU0UsbUJBQVQsQ0FBNkJjLGdCQUE3QixFQUErQztBQUM3Q0EsbUJBQWlCMUIsT0FBakIsQ0FBeUIsVUFBQ0ksYUFBRCxFQUFnQm5CLEtBQWhCLEVBQTBCO0FBQ2pEQSxVQUFNMEMsT0FBTjtBQUNBMUMsVUFBTWtDLFFBQU4sR0FBaUIsS0FBakI7QUFDQWxDLFVBQU0yQyxnQkFBTixDQUF1QnhCLGFBQXZCO0FBQ0QsR0FKRDtBQUtBc0IsbUJBQWlCRyxLQUFqQjtBQUNEOztBQUVELFNBQVNDLG1CQUFULENBQTZCSixnQkFBN0IsRUFBK0NLLE1BQS9DLEVBQXVEO0FBQ3JELE1BQU1DLGdCQUFnQixFQUF0QjtBQUNBRCxTQUFPL0IsT0FBUCxDQUFlLGlCQUFTO0FBQ3RCLFFBQU1JLGdCQUFnQnNCLGlCQUFpQk8sR0FBakIsQ0FBcUJoRCxLQUFyQixDQUF0QjtBQUNBQSxVQUFNMEMsT0FBTjtBQUNBMUMsVUFBTWtDLFFBQU4sR0FBaUIsS0FBakI7QUFDQWxDLFVBQU0yQyxnQkFBTixDQUF1QnhCLGFBQXZCO0FBQ0FzQixxQkFBaUJRLE1BQWpCLENBQXdCakQsS0FBeEI7QUFDQStDLGtCQUFjOUIsSUFBZCxDQUFtQmpCLEtBQW5CO0FBQ0QsR0FQRDtBQVFBLFNBQU8rQyxhQUFQO0FBQ0Q7O0FBRUQsSUFBTUcsYUFBYSxTQUFiQSxVQUFhLEdBQU07QUFDdkIsTUFBTUMsU0FBU0MsU0FBU0MsY0FBVCxDQUF3QixRQUF4QixDQUFmO0FBQ0EsTUFBSUYsV0FBVyxJQUFmLEVBQXFCO0FBQ25CQSxXQUFPRyxLQUFQLENBQWFDLE9BQWIsR0FBdUIsTUFBdkI7QUFDRDtBQUNGLENBTEQ7O0FBT0EsSUFBTUMsYUFBYSxTQUFiQSxVQUFhLEdBQU07QUFDdkIsTUFBTUwsU0FBU0MsU0FBU0MsY0FBVCxDQUF3QixRQUF4QixDQUFmO0FBQ0EsTUFBSUYsV0FBVyxJQUFmLEVBQXFCO0FBQ25CQSxXQUFPRyxLQUFQLENBQWFDLE9BQWIsR0FBdUIsT0FBdkI7QUFDRDtBQUNGLENBTEQ7O0FBT0EsSUFBTUUsd0JBQXdCLFNBQXhCQSxxQkFBd0IsQ0FBQ0MsQ0FBRCxFQUFPO0FBQ25DQSxJQUFFQyxNQUFGLENBQVNDLFVBQVQsQ0FBb0JOLEtBQXBCLENBQTBCSCxNQUExQixHQUFtQyxTQUFuQztBQUNBRDtBQUNELENBSEQ7O0FBS0EsSUFBTVcsd0JBQXdCLFNBQXhCQSxxQkFBd0IsQ0FBQ0gsQ0FBRCxFQUFPO0FBQ25DQSxJQUFFQyxNQUFGLENBQVNDLFVBQVQsQ0FBb0JOLEtBQXBCLENBQTBCSCxNQUExQixHQUFtQyxNQUFuQztBQUNBSztBQUNELENBSEQ7O0FBS0E7QUFDQTtBQUNBLFNBQVNNLG1CQUFULENBQTZCSixDQUE3QixFQUFnQ0MsTUFBaEMsRUFBd0M7QUFDdEMsTUFBTXhGLFNBQVNpRixTQUFTVyxhQUFULGFBQThCSixPQUFPSyxFQUFyQyxjQUFmOztBQUVBLE1BQU1DLFNBQVM7QUFDYm5GLE9BQUc0RSxFQUFFakYsT0FBRixHQUFZTixPQUFPK0YsVUFEVDtBQUVibkYsT0FBRzJFLEVBQUUvRSxPQUFGLEdBQVlSLE9BQU9nRztBQUZULEdBQWY7O0FBS0EsU0FBT0YsTUFBUDtBQUNEOztBQUVEO0FBQ0E7QUFDQSxTQUFTRyxrQkFBVCxDQUE0QkMsTUFBNUIsRUFBb0NWLE1BQXBDLEVBQTRDVyxXQUE1QyxFQUF5SDtBQUFBLE1BQWhFN0YsT0FBZ0UsdUVBQXRENUIsVUFBVUMsVUFBNEM7QUFBQSxNQUFoQzZCLE9BQWdDLHVFQUF0QjlCLFVBQVVDLFVBQVk7O0FBQ3ZILE1BQU1xRyxTQUFTQyxTQUFTQyxjQUFULENBQXdCLFFBQXhCLENBQWY7QUFDQSxNQUFNa0IsUUFBUVQsb0JBQW9CTyxNQUFwQixFQUE0QlYsTUFBNUIsQ0FBZDs7QUFFQSxNQUFJUixXQUFXLElBQWYsRUFBcUI7QUFDbkIsUUFBTXFCLFlBQVlwQixTQUFTcUIsYUFBVCxDQUF1QixNQUF2QixDQUFsQjtBQUNBRCxjQUFVRSxZQUFWLENBQXVCLElBQXZCLEVBQTZCLFFBQTdCO0FBQ0FGLGNBQVVFLFlBQVYsQ0FBdUIsT0FBdkIsaUNBQStESCxNQUFNeEYsQ0FBckUseUJBQXdGd0YsTUFBTXpGLENBQTlGLHlEQUErSXdGLFdBQS9JLGdGQUFxTzdGLE9BQXJPLFlBQW1QRSxPQUFuUDtBQUNBZ0YsV0FBT2dCLFdBQVAsQ0FBbUJILFNBQW5CO0FBQ0QsR0FMRCxNQUtPLElBQUlyQixPQUFPRyxLQUFQLENBQWFzQixVQUFiLEtBQTRCTixXQUFoQyxFQUE2QztBQUNsRE8seUJBQXFCUixNQUFyQixFQUE2QlYsTUFBN0I7QUFDRCxHQUZNLE1BRUE7QUFDTFIsV0FBT0csS0FBUCxDQUFhc0IsVUFBYixHQUEwQk4sV0FBMUI7QUFDQU8seUJBQXFCUixNQUFyQixFQUE2QlYsTUFBN0I7QUFDRDtBQUNGOztBQUVEO0FBQ0EsU0FBU21CLGtCQUFULEdBQThCO0FBQzVCLE1BQU0zQixTQUFTQyxTQUFTQyxjQUFULENBQXdCLFFBQXhCLENBQWY7QUFDQSxNQUFJRixXQUFXLElBQWYsRUFBcUI7QUFDbkJBLFdBQU9TLFVBQVAsQ0FBa0JtQixXQUFsQixDQUE4QjVCLE1BQTlCO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBO0FBQ0EsU0FBUzBCLG9CQUFULENBQThCUixNQUE5QixFQUFzQ1YsTUFBdEMsRUFBOEM7QUFDNUMsTUFBTVIsU0FBU0MsU0FBU0MsY0FBVCxDQUF3QixRQUF4QixDQUFmO0FBQ0EsTUFBTWtCLFFBQVFULG9CQUFvQk8sTUFBcEIsRUFBNEJWLE1BQTVCLENBQWQ7O0FBRUEsTUFBSVIsV0FBVyxJQUFmLEVBQXFCO0FBQ25CQSxXQUFPRyxLQUFQLENBQWExRSxHQUFiLFNBQXlCMkYsTUFBTXhGLENBQS9CO0FBQ0FvRSxXQUFPRyxLQUFQLENBQWE1RSxJQUFiLFNBQTBCNkYsTUFBTXpGLENBQWhDO0FBQ0Q7QUFDRjs7SUFFb0JrRyxZOzs7Ozs7Ozs7OztrQ0FFTDlHLEssRUFBTztBQUNuQixXQUFLK0csWUFBTCxDQUFrQi9HLEtBQWxCO0FBQ0Q7OztpQ0FFWUEsSyxFQUFPO0FBQ2xCLFdBQUtnSCxZQUFMLENBQWtCaEgsS0FBbEI7QUFDRDs7O2dDQUVXQSxLLEVBQU87QUFDakIsV0FBS2lILFVBQUwsQ0FBZ0JqSCxLQUFoQjtBQUNEOzs7aUNBRVlBLEssRUFBTztBQUNsQixXQUFLa0gscUJBQUwsQ0FBMkJsSCxLQUEzQjtBQUNBLFVBQUksS0FBS21ILGNBQUwsSUFBdUIsQ0FBQ25ILE1BQU1HLE9BQWxDLEVBQTJDO0FBQ3pDO0FBQ0Q7QUFDRCxVQUFJSCxNQUFNRyxPQUFWLEVBQW1CO0FBQ2pCSCxnQkFBUUQsb0JBQW9CQyxLQUFwQixFQUEyQixLQUFLb0gsV0FBaEMsQ0FBUjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCckgsS0FBeEIsQ0FGaUIsQ0FFYTtBQUMvQjs7QUFFRCxVQUFJLENBQUNXLFNBQVMsS0FBS3lHLFdBQWQsRUFBMkJwSCxNQUFNRSxPQUFqQyxFQUEwQ0YsTUFBTUksT0FBaEQsQ0FBTCxFQUErRDtBQUM3RDtBQUNEOztBQUVELFdBQUtrSCxLQUFMLEdBQWFDLFlBQVlDLEdBQVosRUFBYjs7QUFFQXZKLGNBQVFvRyxHQUFSLENBQVlwRixNQUFaLEVBQW9CZSxNQUFNTyxPQUExQixFQUFtQ1AsTUFBTVMsT0FBekM7QUFDQXhDLGNBQVEyRCxjQUFSLENBQXVCekMsTUFBdkIsRUFBK0JGLE1BQS9CLEVBQXVDLEtBQUt3SSxPQUFMLENBQWE1RixtQkFBcEQ7QUFDQSxVQUFNNkYsc0JBQXNCLEtBQUtELE9BQUwsQ0FBYUMsbUJBQXpDO0FBQ0EsVUFBTTlDLFNBQVMsS0FBSzFCLFlBQXBCO0FBQ0EsVUFBSXlFLElBQUksQ0FBQyxDQUFUO0FBQ0EsVUFBSTFFLGdCQUFnQixJQUFwQjtBQUNBLFVBQUl2QixlQUFlLElBQW5CO0FBQ0EsV0FBS2lHLElBQUkvQyxPQUFPaEIsTUFBUCxHQUFnQixDQUF6QixFQUE0QitELEtBQUssQ0FBakMsRUFBb0NBLEtBQUssQ0FBekMsRUFBNEM7QUFDMUMsWUFBTUMsWUFBWSxLQUFLQyxRQUFMLENBQWMvQyxHQUFkLENBQWtCRixPQUFPK0MsQ0FBUCxDQUFsQixDQUFsQjtBQUNBLFlBQUkvQyxPQUFPK0MsQ0FBUCxFQUFVM0QsUUFBZCxFQUF3QjtBQUN0QmYsMEJBQWdCLEtBQUs2RSxlQUFMLENBQXFCaEQsR0FBckIsQ0FBeUJGLE9BQU8rQyxDQUFQLENBQXpCLENBQWhCO0FBQ0FqRyx5QkFBZWtHLFNBQWY7QUFDQSxjQUFJRyxVQUFVLElBQWQ7QUFDQSxjQUFJOUUsaUJBQWlCLENBQUM4RSxVQUFVOUUsY0FBYytFLGFBQWQsQ0FBNEIvSSxNQUE1QixFQUFvQ0UsTUFBcEMsRUFBNEN1SSxtQkFBNUMsRUFBaUUsS0FBS08sUUFBdEUsQ0FBWCxFQUE0RkMsR0FBakgsRUFBc0g7QUFDcEgsZ0JBQUlqRix5QkFBeUJoQiwyQkFBekIsSUFBOENqQyxNQUFNc0MsTUFBcEQsSUFBOER5RixRQUFRSSxZQUFSLEdBQXVCdkQsT0FBTytDLENBQVAsRUFBVVMsUUFBbkcsRUFBNkc7QUFDM0d4RCxxQkFBTytDLENBQVAsRUFBVVUsVUFBVixDQUFxQk4sUUFBUUksWUFBN0I7QUFDQWxGLDhCQUFnQixJQUFoQjtBQUNELGFBSEQsTUFHTztBQUNMLGtCQUFNcUYsYUFBYXJGLGNBQWNzRixNQUFkLENBQXFCRCxVQUF4QztBQUNBLGtCQUFNRSxnQkFBZ0JDLGdCQUFNQyxLQUFOLENBQVlKLFVBQVosQ0FBdEI7QUFDQUcsOEJBQU1FLE1BQU4sQ0FBYUgsYUFBYixFQUE0QkEsYUFBNUI7QUFDQSxrQkFBTUksY0FBYzNLLFFBQVF5SyxLQUFSLENBQWN2SixNQUFkLENBQXBCO0FBQ0FsQixzQkFBUTJELGNBQVIsQ0FBdUJnSCxXQUF2QixFQUFvQ0EsV0FBcEMsRUFBaURKLGFBQWpEO0FBQ0EsbUJBQUtLLFNBQUwsR0FBaUJDLE9BQU9DLE1BQVAsQ0FBYztBQUM3QkMsd0JBQVFDLFFBQVFsQixRQUFRaUIsTUFBaEIsQ0FEcUI7QUFFN0JiLDhCQUFjSixRQUFRSSxZQUZPO0FBRzdCZSxnQ0FBZ0JOLFdBSGE7QUFJN0JPLHFDQUFxQlgsYUFKUTtBQUs3QlksK0JBQWVuRyxjQUFjc0YsTUFBZCxDQUFxQmMsV0FBckIsRUFMYztBQU03QkMsaUNBQWlCckcsY0FBY3NGLE1BQWQsQ0FBcUJnQixRQUFyQixFQU5ZO0FBTzdCQywrQkFBZXZHLGNBQWNzRixNQUFkLENBQXFCa0IsV0FBckIsRUFQYztBQVE3QkMsNEJBQVl6RyxjQUFjc0YsTUFBZCxDQUFxQm9CLEtBUko7QUFTN0JDLDZCQUFhM0csY0FBY3NGLE1BQWQsQ0FBcUJzQjtBQVRMLGVBQWQsRUFVZG5JLFlBVmMsQ0FBakI7QUFXRDtBQUNEO0FBQ0QsV0F2QkQsTUF1Qk8sSUFBSWtELE9BQU8rQyxDQUFQLEVBQVVLLGFBQVYsQ0FBd0IvSSxNQUF4QixFQUFnQ0UsTUFBaEMsRUFBd0N1SSxtQkFBeEMsRUFBNkQsS0FBS08sUUFBbEUsQ0FBSixFQUFpRjtBQUN0RmhGLDRCQUFnQjJCLE9BQU8rQyxDQUFQLENBQWhCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRCxVQUFJQSxJQUFJLENBQUosSUFBUyxLQUFLRyxlQUFMLENBQXFCZ0MsSUFBbEMsRUFBd0M7QUFDdEMsWUFBSSxLQUFLaEMsZUFBTCxDQUFxQmdDLElBQXpCLEVBQStCO0FBQzdCLGVBQUtDLElBQUwsQ0FBVXhMLGVBQWVDLGlCQUF6QixFQUE0QztBQUMxQ2dGLDhCQUFrQmQsdUJBQXVCLEtBQUtvRixlQUE1QixDQUR3QjtBQUUxQ3hELDRCQUFnQjtBQUYwQixXQUE1QztBQUlEO0FBQ0QsYUFBS3VFLFNBQUwsR0FBaUIsSUFBakI7QUFDQXBGLDRCQUFvQixLQUFLcUUsZUFBekI7QUFDRCxPQVRELE1BU08sSUFBSTdFLGlCQUFpQnZCLFlBQWpCLEtBQWtDQSxhQUFhc0ksT0FBYixJQUF3QnRJLGFBQWF5QyxTQUFyQyxJQUFrRHpDLGFBQWF3QyxRQUFqRyxDQUFKLEVBQWdIO0FBQ3JILFlBQU1qRSxTQUFTaUYsU0FBU1csYUFBVCxhQUE4QixLQUFLb0UsT0FBTCxDQUFhbkUsRUFBM0MsZ0JBQWY7QUFDQSxZQUFJN0YsV0FBVyxJQUFmLEVBQXFCO0FBQ25CLGVBQUtnSyxPQUFMLENBQWFDLGdCQUFiLENBQThCLFVBQTlCLEVBQTBDbEYsVUFBMUM7QUFDQSxlQUFLaUYsT0FBTCxDQUFhQyxnQkFBYixDQUE4QixXQUE5QixFQUEyQzVFLFVBQTNDO0FBQ0QsU0FIRCxNQUdPO0FBQ0xyRixpQkFBT2lLLGdCQUFQLENBQXdCLFVBQXhCLEVBQW9DM0UscUJBQXBDO0FBQ0F0RixpQkFBT2lLLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDdkUscUJBQXJDO0FBQ0Q7QUFDRCxZQUFJLENBQUMsS0FBS2tELFNBQU4sSUFBbUJuSCxhQUFhc0ksT0FBcEMsRUFBNkM7QUFDM0MsZUFBS25CLFNBQUwsR0FBaUI7QUFDZk8sMkJBQWVuRyxjQUFjb0csV0FBZDtBQURBLFdBQWpCO0FBR0Q7O0FBRUQsWUFBSSxLQUFLUixTQUFULEVBQW9CO0FBQ2xCLGVBQUtBLFNBQUwsQ0FBZS9HLEtBQWYsR0FBdUJtQixhQUF2QjtBQUNBLGVBQUs0RixTQUFMLENBQWVzQixRQUFmLEdBQTBCbE0sUUFBUXlLLEtBQVIsQ0FBY3pKLE1BQWQsQ0FBMUI7QUFDQSxlQUFLNEosU0FBTCxDQUFldUIsYUFBZixHQUErQm5NLFFBQVF5SyxLQUFSLENBQWN2SixNQUFkLENBQS9CO0FBQ0EsZUFBSzBKLFNBQUwsQ0FBZXdCLG1CQUFmLEdBQXFDNUIsZ0JBQU1DLEtBQU4sQ0FBWXpGLGNBQWNxSCxXQUExQixDQUFyQztBQUNBbEkscUNBQTJCcEMsS0FBM0IsRUFBa0MsS0FBSzZJLFNBQXZDO0FBQ0E3SSxnQkFBTXVLLHdCQUFOO0FBQ0EsZUFBS1IsSUFBTCxDQUFVeEwsZUFBZUUsVUFBekIsRUFBcUM7QUFDbkNtRyxvQkFBUWxDLHVCQUF1QixLQUFLb0YsZUFBNUI7QUFEMkIsV0FBckM7QUFHRDtBQUNELFlBQUksQ0FBQzlILE1BQU1HLE9BQVgsRUFBb0I7QUFDbEJILGdCQUFNd0ssY0FBTjtBQUNEO0FBQ0Y7QUFDRjs7OytCQUVVeEssSyxFQUFPO0FBQ2hCLFVBQUksS0FBS21ILGNBQUwsSUFBdUIsQ0FBQ25ILE1BQU1HLE9BQWxDLEVBQTJDO0FBQ3pDLGFBQUsrRyxxQkFBTCxDQUEyQmxILEtBQTNCO0FBQ0EsZUFGeUMsQ0FFbEM7QUFDUjtBQUNELFVBQUlBLE1BQU1HLE9BQVYsRUFBbUI7QUFDakI7QUFDQUgsZ0JBQVEsS0FBS3FILGdCQUFiO0FBQ0Q7O0FBRUQsVUFBSSxLQUFLd0IsU0FBTCxJQUFrQixLQUFLQSxTQUFMLENBQWUvRyxLQUFyQyxFQUE0QztBQUMxQzlCLGNBQU11Syx3QkFBTjtBQUNBLFlBQUl2SyxNQUFNeUssVUFBVixFQUFzQjtBQUNwQnpLLGdCQUFNd0ssY0FBTjtBQUNEO0FBQ0QsWUFBTXZLLFNBQVNpRixTQUFTVyxhQUFULGFBQThCLEtBQUtvRSxPQUFMLENBQWFuRSxFQUEzQyxnQkFBZjtBQUNBLFlBQUk3RixXQUFXLElBQWYsRUFBcUI7QUFDbkIsZUFBS2dLLE9BQUwsQ0FBYVMsbUJBQWIsQ0FBaUMsVUFBakMsRUFBNkMxRixVQUE3QztBQUNBLGVBQUtpRixPQUFMLENBQWFTLG1CQUFiLENBQWlDLFdBQWpDLEVBQThDcEYsVUFBOUM7QUFDRCxTQUhELE1BR087QUFDTHJGLGlCQUFPeUssbUJBQVAsQ0FBMkIsVUFBM0IsRUFBdUNuRixxQkFBdkM7QUFDQXRGLGlCQUFPeUssbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MvRSxxQkFBeEM7QUFDRDtBQUNELGFBQUtrRCxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsYUFBS2tCLElBQUwsQ0FBVXhMLGVBQWVHLFFBQXpCLEVBQW1DO0FBQ2pDa0csa0JBQVFsQyx1QkFBdUIsS0FBS29GLGVBQTVCO0FBRHlCLFNBQW5DO0FBR0QsT0FqQkQsTUFpQk8sSUFBSVAsWUFBWUMsR0FBWixLQUFvQixLQUFLRixLQUF6QixHQUFpQzNJLFVBQVVFLGdCQUEvQyxFQUFpRTtBQUN0RTtBQUNBWixnQkFBUW9HLEdBQVIsQ0FBWXBGLE1BQVosRUFBb0JlLE1BQU1PLE9BQTFCLEVBQW1DUCxNQUFNUyxPQUF6QztBQUNBeEMsZ0JBQVEyRCxjQUFSLENBQXVCekMsTUFBdkIsRUFBK0JGLE1BQS9CLEVBQXVDLEtBQUt3SSxPQUFMLENBQWE1RixtQkFBcEQ7QUFDQSxZQUFNNkYsc0JBQXNCLEtBQUtELE9BQUwsQ0FBYUMsbUJBQXpDO0FBQ0EsWUFBTTlDLFNBQVMsS0FBSzFCLFlBQXBCO0FBQ0EsWUFBSUQsZ0JBQWdCLElBQXBCO0FBQ0EsWUFBSXZCLGVBQWUsSUFBbkI7QUFDQSxhQUFLLElBQUlpRyxJQUFJL0MsT0FBT2hCLE1BQVAsR0FBZ0IsQ0FBN0IsRUFBZ0MrRCxLQUFLLENBQXJDLEVBQXdDQSxLQUFLLENBQTdDLEVBQWdEO0FBQzlDakcseUJBQWUsS0FBS21HLFFBQUwsQ0FBYy9DLEdBQWQsQ0FBa0JGLE9BQU8rQyxDQUFQLENBQWxCLENBQWY7QUFDQSxjQUFJakcsYUFBYWlKLFVBQWIsSUFBMkIvRixPQUFPK0MsQ0FBUCxFQUFVSyxhQUFWLENBQXdCL0ksTUFBeEIsRUFBZ0NFLE1BQWhDLEVBQXdDdUksbUJBQXhDLEVBQTZELEtBQUtPLFFBQWxFLENBQS9CLEVBQTRHO0FBQzFHaEYsNEJBQWdCMkIsT0FBTytDLENBQVAsQ0FBaEI7QUFDQTtBQUNEO0FBQ0Y7QUFDRCxZQUFJMUUsaUJBQWlCLENBQUNBLGNBQWNlLFFBQXBDLEVBQThDO0FBQzVDLGNBQU00RyxpQkFBaUI1SCxhQUFZQyxhQUFaLEVBQTJCMkIsTUFBM0IsRUFBbUMsS0FBS2tELGVBQXhDLEVBQXlELEtBQUsrQyxZQUE5RCxFQUE0RSxLQUFLQyxXQUFqRixFQUE4RnBKLFlBQTlGLENBQXZCO0FBQ0EsZUFBS3FJLElBQUwsQ0FBVXhMLGVBQWVDLGlCQUF6QixFQUE0Q29NLGNBQTVDO0FBQ0QsU0FIRCxNQUdPO0FBQ0w7QUFDQSxlQUFLRyx5QkFBTDtBQUNEO0FBQ0Y7QUFDRjs7O2lDQUVZL0ssSyxFQUFPO0FBQ2xCLFdBQUtrSCxxQkFBTCxDQUEyQmxILEtBQTNCO0FBQ0EsVUFBSSxLQUFLbUgsY0FBTCxJQUF1QixDQUFDbkgsTUFBTUcsT0FBbEMsRUFBMkM7QUFDekM7QUFDRDs7QUFFRCxVQUFJSCxNQUFNRyxPQUFWLEVBQW1CO0FBQ2pCSCxnQkFBUUQsb0JBQW9CQyxLQUFwQixFQUEyQixLQUFLb0gsV0FBaEMsQ0FBUjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCckgsS0FBeEIsQ0FGaUIsQ0FFYTtBQUMvQjs7QUFFRCxVQUFJLENBQUVXLFNBQVMsS0FBS3lHLFdBQWQsRUFBMkJwSCxNQUFNRSxPQUFqQyxFQUEwQ0YsTUFBTUksT0FBaEQsQ0FBRixJQUErRCxDQUFDLEtBQUt5SSxTQUF6RSxFQUFvRjtBQUNsRjtBQUNEOztBQUVELFVBQUksS0FBS0EsU0FBTCxJQUFrQixLQUFLQSxTQUFMLENBQWUvRyxLQUFyQyxFQUE0QztBQUMxQzZFLDZCQUFxQjNHLEtBQXJCLEVBQTRCLEtBQUtpSyxPQUFqQztBQUNBN0gsbUNBQTJCcEMsS0FBM0IsRUFBa0MsS0FBSzZJLFNBQXZDO0FBQ0FwSCwrQkFBdUIsS0FBSzJGLFdBQTVCLEVBQXlDcEgsS0FBekMsRUFBZ0QsS0FBSzZJLFNBQXJELEVBQWdFLEtBQUtwQixPQUFyRTtBQUNBekgsY0FBTXVLLHdCQUFOO0FBQ0EsWUFBSSxDQUFDdkssTUFBTUcsT0FBWCxFQUFvQjtBQUNsQkgsZ0JBQU13SyxjQUFOO0FBQ0Q7QUFDRixPQVJELE1BUU8sSUFBSSxDQUFDeEssTUFBTWdMLE9BQVAsSUFBa0IsS0FBS2xELGVBQUwsQ0FBcUJnQyxJQUEzQyxFQUFpRDtBQUN0RDdMLGdCQUFRb0csR0FBUixDQUFZcEYsTUFBWixFQUFvQmUsTUFBTU8sT0FBMUIsRUFBbUNQLE1BQU1TLE9BQXpDO0FBQ0F4QyxnQkFBUTJELGNBQVIsQ0FBdUJ6QyxNQUF2QixFQUErQkYsTUFBL0IsRUFBdUMsS0FBS3dJLE9BQUwsQ0FBYTVGLG1CQUFwRDtBQUNBLFlBQU02RixzQkFBc0IsS0FBS0QsT0FBTCxDQUFhQyxtQkFBekM7QUFDQSxZQUFNOUMsU0FBUyxLQUFLMUIsWUFBcEI7QUFDQSxZQUFJeUUsSUFBSSxDQUFSO0FBQ0EsWUFBTXNELFFBQVEsS0FBS3hELE9BQUwsQ0FBYXlELFVBQWIsRUFBZDtBQUNBLGFBQUt2RCxJQUFJL0MsT0FBT2hCLE1BQVAsR0FBZ0IsQ0FBekIsRUFBNEIrRCxLQUFLLENBQWpDLEVBQW9DQSxLQUFLLENBQXpDLEVBQTRDO0FBQzFDLGNBQUkvQyxPQUFPK0MsQ0FBUCxFQUFVM0QsUUFBZCxFQUF3QjtBQUN0QixnQkFBTW1ILGFBQWEsS0FBS3RELFFBQUwsQ0FBYy9DLEdBQWQsQ0FBa0JGLE9BQU8rQyxDQUFQLENBQWxCLENBQW5CO0FBQ0EsZ0JBQU0xRSxnQkFBZ0IsS0FBSzZFLGVBQUwsQ0FBcUJoRCxHQUFyQixDQUF5QkYsT0FBTytDLENBQVAsQ0FBekIsQ0FBdEI7QUFDQSxnQkFBSUksVUFBVSxJQUFkO0FBQ0EsaUJBQUtrQyxPQUFMLENBQWE3RSxLQUFiLENBQW1CSCxNQUFuQixHQUE0QixNQUE1QjtBQUNBO0FBQ0EsaUJBQUssSUFBSW1HLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLbkIsT0FBTCxDQUFhb0IsVUFBYixDQUF3QnpILE1BQTVDLEVBQW9Ed0gsS0FBSyxDQUF6RCxFQUE0RDtBQUMxRCxtQkFBS25CLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELENBQXhCLEVBQTJCaEcsS0FBM0IsQ0FBaUNILE1BQWpDLEdBQTBDLE1BQTFDO0FBQ0Esa0JBQUksS0FBS2dGLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELENBQXhCLEVBQTJCRSxRQUEzQixDQUFvQ0MsV0FBcEMsT0FBc0QsUUFBMUQsRUFBb0U7QUFDbEUscUJBQUt0QixPQUFMLENBQWFvQixVQUFiLENBQXdCRCxDQUF4QixFQUEyQmhHLEtBQTNCLENBQWlDb0csYUFBakMsR0FBaUQsTUFBakQ7QUFDRDtBQUNGO0FBQ0QsZ0JBQUl2SSxpQkFBaUIsQ0FBQzhFLFVBQVU5RSxjQUFjK0UsYUFBZCxDQUE0Qi9JLE1BQTVCLEVBQW9DRSxNQUFwQyxFQUE0Q3VJLG1CQUE1QyxFQUFpRSxLQUFLTyxRQUF0RSxDQUFYLEVBQTRGQyxHQUFqSCxFQUFzSDtBQUNwSCxrQkFBSWpGLHlCQUF5QmxCLG9CQUE3QixFQUF5QztBQUN2QyxvQkFBSWdHLFFBQVFpQixNQUFaLEVBQW9CO0FBQ2xCLHNCQUFJeUMsVUFBVTdHLE9BQU8rQyxDQUFQLEVBQVU4QixXQUFWLEVBQWQ7QUFDQSxzQkFBSXdCLEtBQUosRUFBVztBQUNUUSwrQkFBVyxDQUFDLENBQVo7QUFDQSx3QkFBSTFELFFBQVFJLFlBQVIsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDOUJzRCxpQ0FBVzlNLFVBQVVHLFdBQXJCO0FBQ0QscUJBRkQsTUFFTyxJQUFJaUosUUFBUUksWUFBUixLQUF5QixDQUE3QixFQUFnQztBQUNyQ3NELGlDQUFXOU0sVUFBVUksY0FBckI7QUFDRCxxQkFGTSxNQUVBLElBQUlnSixRQUFRSSxZQUFSLEtBQXlCLENBQTdCLEVBQWdDO0FBQ3JDc0QsaUNBQVc5TSxVQUFVRyxXQUFyQjtBQUNEO0FBQ0YsbUJBVEQsTUFTTyxJQUFJaUosUUFBUUksWUFBUixLQUF5QixDQUE3QixFQUFnQztBQUNyQ3NELCtCQUFXOU0sVUFBVUcsV0FBckI7QUFDRCxtQkFGTSxNQUVBLElBQUlpSixRQUFRSSxZQUFSLEtBQXlCLENBQTdCLEVBQWdDO0FBQ3JDc0QsK0JBQVc5TSxVQUFVSSxjQUFyQjtBQUNELG1CQUZNLE1BRUEsSUFBSWdKLFFBQVFJLFlBQVIsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFBRTtBQUN2Q3NELCtCQUFXOU0sVUFBVUcsV0FBckI7QUFDRDtBQUNEb0gscUNBQW1CbEcsS0FBbkIsRUFBMEIsS0FBS2lLLE9BQS9CLE9BQTJDOUwsVUFBVXVOLE9BQVYsQ0FBa0IsWUFBbEIsT0FBbUNELE9BQW5DLENBQTNDO0FBQ0QsaUJBbkJELE1BbUJPLElBQUkxRCxRQUFRSSxZQUFSLEdBQXVCLENBQTNCLEVBQThCO0FBQUU7QUFDckMsc0JBQUlKLFFBQVFJLFlBQVIsS0FBeUIsQ0FBekIsSUFBOEJKLFFBQVFJLFlBQVIsS0FBeUIsQ0FBM0QsRUFBOEQ7QUFBRTtBQUM5RGpDLHVDQUFtQmxHLEtBQW5CLEVBQTBCLEtBQUtpSyxPQUEvQixPQUEyQy9MLFNBQVN3TixPQUFULENBQWlCLFlBQWpCLFFBQWtDLENBQUM5RyxPQUFPK0MsQ0FBUCxFQUFVOEIsV0FBVixFQUFELEdBQTJCOUssVUFBVUssZ0JBQXZFLEVBQTNDO0FBQ0QsbUJBRkQsTUFFTyxJQUFJK0ksUUFBUUksWUFBUixLQUF5QixDQUF6QixJQUE4QkosUUFBUUksWUFBUixLQUF5QixDQUEzRCxFQUE4RDtBQUNuRWpDLHVDQUFtQmxHLEtBQW5CLEVBQTBCLEtBQUtpSyxPQUEvQixPQUEyQy9MLFNBQVN3TixPQUFULENBQWlCLFlBQWpCLFFBQWtDLENBQUM5RyxPQUFPK0MsQ0FBUCxFQUFVOEIsV0FBVixFQUFELEdBQTJCOUssVUFBVUssZ0JBQXZFLEVBQTNDO0FBQ0Q7QUFDRixpQkFOTSxNQU1BLElBQUkrSSxRQUFRSSxZQUFSLEdBQXVCLENBQXZCLEtBQTZCLENBQWpDLEVBQW9DO0FBQ3pDakMscUNBQW1CbEcsS0FBbkIsRUFBMEIsS0FBS2lLLE9BQS9CLE9BQTJDL0wsU0FBU3dOLE9BQVQsQ0FBaUIsWUFBakIsT0FBa0MsQ0FBQzlHLE9BQU8rQyxDQUFQLEVBQVU4QixXQUFWLEVBQW5DLENBQTNDO0FBQ0QsaUJBRk0sTUFFQTtBQUNMdkQscUNBQW1CbEcsS0FBbkIsRUFBMEIsS0FBS2lLLE9BQS9CLE9BQTJDL0wsU0FBU3dOLE9BQVQsQ0FBaUIsWUFBakIsUUFBa0MsQ0FBQzlHLE9BQU8rQyxDQUFQLEVBQVU4QixXQUFWLEVBQUQsR0FBMkI5SyxVQUFVRyxXQUF2RSxFQUEzQztBQUNEO0FBQ0YsZUEvQkQsTUErQk8sSUFBSW1FLHlCQUF5QmhCLDJCQUE3QixFQUFnRDtBQUNyRCxxQkFBS2dJLE9BQUwsQ0FBYTdFLEtBQWIsQ0FBbUJILE1BQW5CLEdBQTRCLE1BQTVCO0FBQ0E7QUFDQSxxQkFBSyxJQUFJbUcsS0FBSSxDQUFiLEVBQWdCQSxLQUFJLEtBQUtuQixPQUFMLENBQWFvQixVQUFiLENBQXdCekgsTUFBNUMsRUFBb0R3SCxNQUFLLENBQXpELEVBQTREO0FBQzFELHVCQUFLbkIsT0FBTCxDQUFhb0IsVUFBYixDQUF3QkQsRUFBeEIsRUFBMkJoRyxLQUEzQixDQUFpQ0gsTUFBakMsR0FBMEMsTUFBMUM7QUFDQSxzQkFBSSxLQUFLZ0YsT0FBTCxDQUFhb0IsVUFBYixDQUF3QkQsRUFBeEIsRUFBMkJFLFFBQTNCLENBQW9DQyxXQUFwQyxPQUFzRCxRQUExRCxFQUFvRTtBQUNsRSx5QkFBS3RCLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELEVBQXhCLEVBQTJCaEcsS0FBM0IsQ0FBaUNvRyxhQUFqQyxHQUFpRCxNQUFqRDtBQUNEO0FBQ0Y7QUFDRCxvQkFBSXpELFFBQVFJLFlBQVIsSUFBd0J2RCxPQUFPK0MsQ0FBUCxFQUFVUyxRQUF0QyxFQUFnRDtBQUM5Q2xDLHFDQUFtQmxHLEtBQW5CLEVBQTBCLEtBQUtpSyxPQUEvQixFQUF3QzdMLE1BQXhDLEVBQWdELENBQUMsQ0FBakQsRUFBb0QsQ0FBQyxDQUFyRCxFQUQ4QyxDQUNVO0FBQ3pELGlCQUZELE1BRU8sSUFBSTRCLE1BQU1zQyxNQUFWLEVBQWtCO0FBQ3ZCNEQscUNBQW1CbEcsS0FBbkIsRUFBMEIsS0FBS2lLLE9BQS9CLEVBQXdDNUwsU0FBeEMsRUFBbUQsQ0FBQyxDQUFwRCxFQUF1RCxDQUFDLENBQXhELEVBRHVCLENBQ29DO0FBQzVELGlCQUZNLE1BRUE7QUFDTDZILHFDQUFtQmxHLEtBQW5CLEVBQTBCLEtBQUtpSyxPQUEvQixFQUF3QzNMLGFBQXhDLEVBQXVESyxVQUFVQyxVQUFqRSxFQUE2RUQsVUFBVUMsVUFBdkY7QUFDRDtBQUNGO0FBQ0RvQixvQkFBTXVLLHdCQUFOO0FBQ0F2SyxvQkFBTXdLLGNBQU47QUFDQTtBQUNELGFBcERELE1Bb0RPLElBQUk1RixPQUFPK0MsQ0FBUCxFQUFVSyxhQUFWLENBQXdCL0ksTUFBeEIsRUFBZ0NFLE1BQWhDLEVBQXdDdUksbUJBQXhDLEVBQTZELEtBQUtPLFFBQWxFLENBQUosRUFBaUY7QUFDdEYsa0JBQUlrRCxjQUFjQSxXQUFXbkIsT0FBN0IsRUFBc0M7QUFDcEMsb0JBQU0vRSxTQUFTQyxTQUFTQyxjQUFULENBQXdCLFFBQXhCLENBQWY7QUFDQSxvQkFBSUYsV0FBVyxJQUFmLEVBQXFCO0FBQ25CQSx5QkFBT1MsVUFBUCxDQUFrQm1CLFdBQWxCLENBQThCNUIsTUFBOUI7QUFDRDtBQUNELHFCQUFLZ0YsT0FBTCxDQUFhN0UsS0FBYixDQUFtQkgsTUFBbkIsR0FBNEIsTUFBNUI7QUFDQSxxQkFBSyxJQUFJbUcsTUFBSSxDQUFiLEVBQWdCQSxNQUFJLEtBQUtuQixPQUFMLENBQWFvQixVQUFiLENBQXdCekgsTUFBNUMsRUFBb0R3SCxPQUFLLENBQXpELEVBQTREO0FBQzFELHVCQUFLbkIsT0FBTCxDQUFhb0IsVUFBYixDQUF3QkQsR0FBeEIsRUFBMkJoRyxLQUEzQixDQUFpQ0gsTUFBakMsR0FBMEMsTUFBMUM7QUFDRDtBQUNEakYsc0JBQU11Syx3QkFBTjtBQUNBdkssc0JBQU13SyxjQUFOO0FBQ0Q7QUFDRDtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxZQUFJN0MsSUFBSSxDQUFSLEVBQVc7QUFDVGY7QUFDQSxlQUFLcUQsT0FBTCxDQUFhN0UsS0FBYixDQUFtQkgsTUFBbkIsR0FBNEIsU0FBNUI7QUFDQTtBQUNBLGVBQUssSUFBSW1HLE1BQUksQ0FBYixFQUFnQkEsTUFBSSxLQUFLbkIsT0FBTCxDQUFhb0IsVUFBYixDQUF3QnpILE1BQTVDLEVBQW9Ed0gsT0FBSyxDQUF6RCxFQUE0RDtBQUMxRCxpQkFBS25CLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELEdBQXhCLEVBQTJCaEcsS0FBM0IsQ0FBaUNILE1BQWpDLEdBQTBDLFNBQTFDO0FBQ0EsZ0JBQUksS0FBS2dGLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELEdBQXhCLEVBQTJCRSxRQUEzQixDQUFvQ0MsV0FBcEMsT0FBc0QsUUFBMUQsRUFBb0U7QUFDbEUsbUJBQUt0QixPQUFMLENBQWFvQixVQUFiLENBQXdCRCxHQUF4QixFQUEyQmhHLEtBQTNCLENBQWlDb0csYUFBakMsR0FBaUQsTUFBakQ7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUNGOzs7K0JBRVU7QUFDVDtBQUNEOzs7Z0NBRVd4TCxLLEVBQU87QUFDakIsVUFBSSxDQUFDVyxTQUFTLEtBQUt5RyxXQUFkLEVBQTJCcEgsTUFBTUUsT0FBakMsRUFBMENGLE1BQU1JLE9BQWhELENBQUwsRUFBK0Q7QUFDN0Q7QUFDRDs7QUFFRG5DLGNBQVFvRyxHQUFSLENBQVlwRixNQUFaLEVBQW9CZSxNQUFNTyxPQUExQixFQUFtQ1AsTUFBTVMsT0FBekM7QUFDQXhDLGNBQVEyRCxjQUFSLENBQXVCekMsTUFBdkIsRUFBK0JGLE1BQS9CLEVBQXVDLEtBQUt3SSxPQUFMLENBQWE1RixtQkFBcEQ7QUFDQSxVQUFNNkYsc0JBQXNCLEtBQUtELE9BQUwsQ0FBYUMsbUJBQXpDO0FBQ0EsVUFBTTlDLFNBQVMsS0FBSzFCLFlBQXBCO0FBQ0EsVUFBSXlFLElBQUksQ0FBQyxDQUFUO0FBQ0EsV0FBS0EsSUFBSS9DLE9BQU9oQixNQUFQLEdBQWdCLENBQXpCLEVBQTRCK0QsS0FBSyxDQUFqQyxFQUFvQ0EsS0FBSyxDQUF6QyxFQUE0QztBQUMxQyxZQUFNQyxZQUFZLEtBQUtDLFFBQUwsQ0FBYy9DLEdBQWQsQ0FBa0JGLE9BQU8rQyxDQUFQLENBQWxCLENBQWxCO0FBQ0EsWUFBSUMsVUFBVStDLFVBQVYsSUFBd0IvRixPQUFPK0MsQ0FBUCxFQUFVSyxhQUFWLENBQXdCL0ksTUFBeEIsRUFBZ0NFLE1BQWhDLEVBQXdDdUksbUJBQXhDLEVBQTZELEtBQUtPLFFBQWxFLENBQTVCLEVBQXlHO0FBQ3ZHLGNBQUlMLFVBQVUrRCxRQUFWLElBQXNCL0csT0FBTytDLENBQVAsYUFBcUJpRSxrQkFBL0MsRUFBeUQ7QUFDdkQsZ0JBQU0zSSxnQkFBZ0IyQixPQUFPK0MsQ0FBUCxDQUF0QjtBQUNBLGdCQUFJa0UsVUFBVSxLQUFkO0FBQ0EsZ0JBQUlqSCxPQUFPK0MsQ0FBUCxFQUFVM0QsUUFBZCxFQUF3QjtBQUN0QixrQkFBTThILG1CQUFtQixLQUFLaEUsZUFBTCxDQUFxQmhELEdBQXJCLENBQXlCRixPQUFPK0MsQ0FBUCxDQUF6QixDQUF6QjtBQUNBLGtCQUFJbUUsZ0JBQUosRUFBc0I7QUFDcEI3SSw4QkFBY3VCLE9BQWQ7QUFDQXZCLDhCQUFjd0IsZ0JBQWQsQ0FBK0JxSCxnQkFBL0I7QUFDQUQsMEJBQVUsRUFBRUMsNEJBQTRCL0osb0JBQTlCLENBQVY7QUFDRDtBQUNGOztBQUVEa0IsMEJBQWNlLFFBQWQsR0FBeUIsSUFBekI7QUFDQWYsMEJBQWNTLElBQWQ7QUFDQSxnQkFBTUMsT0FBT2lCLE9BQU9BLE9BQU9oQixNQUFQLEdBQWdCLENBQXZCLEVBQTBCQyxNQUF2QztBQUNBWiwwQkFBY1ksTUFBZCxHQUF1QkYsT0FBTyxDQUE5QjtBQUNBRyxpQ0FBV0MsY0FBWCxDQUEwQixLQUFLOEcsWUFBL0IsRUFBNkM1SCxhQUE3QztBQUNBLGdCQUFJZ0IsaUJBQWlCLElBQXJCO0FBQ0EsZ0JBQUk0SCxPQUFKLEVBQWE7QUFDWCxrQkFBSWpFLFVBQVV6RCxTQUFWLElBQXVCeUQsVUFBVTFELFFBQXJDLEVBQStDO0FBQzdDRCxpQ0FBaUIsSUFBSWxDLG9CQUFKLENBQWUsS0FBSytJLFdBQUwsSUFBb0IxTCxpQkFBbkMsRUFBc0R3SSxTQUF0RCxDQUFqQjtBQUNBM0UsOEJBQWNtQixhQUFkLENBQTRCSCxjQUE1QjtBQUNEO0FBQ0YsYUFMRCxNQUtPO0FBQ0xBLCtCQUFpQixJQUFJaEMsMkJBQUosQ0FBc0JnQixhQUF0QixFQUFxQyxLQUFLNkgsV0FBMUMsQ0FBakI7QUFDQTdILDRCQUFjbUIsYUFBZCxDQUE0QkgsY0FBNUI7QUFDRDtBQUNELGlCQUFLNkQsZUFBTCxDQUFxQnpELEdBQXJCLENBQXlCcEIsYUFBekIsRUFBd0NnQixjQUF4QztBQUNELFdBNUJELE1BNEJPLElBQUksQ0FBQ1csT0FBTytDLENBQVAsRUFBVTNELFFBQWYsRUFBeUI7QUFDOUIsZ0JBQU00RyxpQkFBaUI1SCxhQUFZNEIsT0FBTytDLENBQVAsQ0FBWixFQUF1Qi9DLE1BQXZCLEVBQStCLEtBQUtrRCxlQUFwQyxFQUFxRCxLQUFLK0MsWUFBMUQsRUFBd0UsS0FBS0MsV0FBN0UsRUFBMEZsRCxTQUExRixDQUF2QjtBQUNBLGlCQUFLbUMsSUFBTCxDQUFVeEwsZUFBZUMsaUJBQXpCLEVBQTRDb00sY0FBNUM7QUFDRDtBQUNEO0FBQ0Q7QUFDRjs7QUFFRCxVQUFJakQsSUFBSSxDQUFKLElBQVMsS0FBS0csZUFBTCxDQUFxQmdDLElBQWxDLEVBQXdDO0FBQ3RDLFlBQUksS0FBS2hDLGVBQUwsQ0FBcUJnQyxJQUF6QixFQUErQjtBQUM3QixlQUFLQyxJQUFMLENBQVV4TCxlQUFlQyxpQkFBekIsRUFBNEM7QUFDMUNnRiw4QkFBa0JkLHVCQUF1QixLQUFLb0YsZUFBNUIsQ0FEd0I7QUFFMUN4RCw0QkFBZ0I7QUFGMEIsV0FBNUM7QUFJRDtBQUNELGFBQUt1RSxTQUFMLEdBQWlCLElBQWpCO0FBQ0FwRiw0QkFBb0IsS0FBS3FFLGVBQXpCO0FBQ0QsT0FURCxNQVNPO0FBQ0w5SCxjQUFNdUssd0JBQU47QUFDRDtBQUNEdkssWUFBTXdLLGNBQU47QUFDRDs7O21DQUVjO0FBQ2I7QUFDRDs7O2tDQUVhO0FBQ1o7QUFDRDs7OzBCQUVLakMsTSxFQUFRd0QsSSxFQUFNO0FBQ2xCLFdBQUtDLFVBQUwsR0FBbUJELFFBQVFBLEtBQUtFLGtCQUFoQztBQUNBLHdIQUFZMUQsTUFBWixFQUFvQndELElBQXBCLEVBQTBCLEtBQUtDLFVBQS9CO0FBQ0EsVUFBTUUsV0FBV3BELE9BQU9xRCxtQkFBUCxDQUEyQjVOLGNBQTNCLEVBQTJDNk4sR0FBM0MsQ0FBK0M7QUFBQSxlQUFTN04sZUFBZXlCLEtBQWYsQ0FBVDtBQUFBLE9BQS9DLENBQWpCO0FBQ0EsV0FBS3FNLGNBQUwsQ0FBb0JILFFBQXBCO0FBQ0EsV0FBS3JELFNBQUwsR0FBaUIsSUFBakI7QUFDQSxXQUFLZixlQUFMLEdBQXVCLElBQUl3RSxHQUFKLEVBQXZCO0FBQ0EsV0FBS3pCLFlBQUwsR0FBb0IsSUFBSS9HLG9CQUFKLENBQWdCaUksUUFBUUEsS0FBSzNJLFdBQWIsR0FBMkIySSxLQUFLM0ksV0FBaEMsR0FBOEM7QUFDaEYvRCxtQkFBVztBQURxRSxPQUE5RCxDQUFwQjs7QUFJQSxXQUFLeUwsV0FBTCxHQUFtQixJQUFJaEgsb0JBQUosQ0FBZ0JpSSxRQUFRQSxLQUFLMUksVUFBYixHQUEwQjBJLEtBQUsxSSxVQUEvQixHQUE0QztBQUM3RWhFLG1CQUFXLE9BRGtFO0FBRTdFQyxxQkFBYSxPQUZnRTtBQUc3RUMscUJBQWE7QUFIZ0UsT0FBNUQsQ0FBbkI7O0FBTUEsV0FBSytILEtBQUwsR0FBYSxDQUFiO0FBQ0Q7O0FBRUQ7QUFDQTs7OztnREFDNEI7QUFDMUJWO0FBQ0EsV0FBS3FELE9BQUwsQ0FBYTdFLEtBQWIsQ0FBbUJILE1BQW5CLEdBQTRCLFNBQTVCLENBRjBCLENBRVk7QUFDdEMsV0FBSyxJQUFJbUcsSUFBSSxDQUFiLEVBQWdCQSxJQUFJLEtBQUtuQixPQUFMLENBQWFvQixVQUFiLENBQXdCekgsTUFBNUMsRUFBb0R3SCxLQUFLLENBQXpELEVBQTREO0FBQzFELGFBQUtuQixPQUFMLENBQWFvQixVQUFiLENBQXdCRCxDQUF4QixFQUEyQmhHLEtBQTNCLENBQWlDSCxNQUFqQyxHQUEwQyxTQUExQyxDQUQwRCxDQUNOO0FBQ3BELFlBQUksS0FBS2dGLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELENBQXhCLEVBQTJCRSxRQUEzQixDQUFvQ0MsV0FBcEMsT0FBc0QsUUFBMUQsRUFBb0U7QUFDbEUsZUFBS3RCLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELENBQXhCLEVBQTJCaEcsS0FBM0IsQ0FBaUNvRyxhQUFqQyxHQUFpRCxNQUFqRCxDQURrRSxDQUNWO0FBQ3pEO0FBQ0Y7QUFDRjs7O2tDQUVhZSxHLEVBQUtDLFUsRUFBWTdLLE0sRUFBUTtBQUFBOztBQUNyQyxVQUFNOEssbUJBQW1COUssT0FBTytGLG1CQUFoQztBQUNBOEUsaUJBQVczSixPQUFYLENBQW1CLGlCQUFTO0FBQzFCLFlBQUlmLE1BQU00SyxPQUFWLEVBQW1CO0FBQ2pCNUssZ0JBQU02SyxNQUFOLENBQWFKLEdBQWIsRUFBa0JFLGdCQUFsQixFQUFvQyxPQUFLRyxXQUF6QztBQUNBO0FBQ0EsY0FBSTlLLE1BQU1rQyxRQUFWLEVBQW9CO0FBQ2xCLGdCQUFNNkksZUFBZSxPQUFLL0UsZUFBTCxDQUFxQmhELEdBQXJCLENBQXlCaEQsS0FBekIsQ0FBckI7QUFDQSxnQkFBSStLLFlBQUosRUFBa0I7QUFDaEJBLDJCQUFhRixNQUFiLENBQW9CSixHQUFwQixFQUF5QkUsZ0JBQXpCLEVBQTJDLE9BQUtHLFdBQWhEO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRixPQVpEO0FBYUQ7OztnQ0FjVzlLLEssRUFBTztBQUNqQixVQUFNOEYsWUFBWSxLQUFLQyxRQUFMLENBQWMvQyxHQUFkLENBQWtCaEQsS0FBbEIsQ0FBbEI7QUFDQSxVQUFJOEYsYUFBYUEsVUFBVStDLFVBQTNCLEVBQXVDO0FBQ3JDLFlBQU1DLGlCQUFpQjVILGFBQVlsQixLQUFaLEVBQW1CLEtBQUtvQixZQUF4QixFQUFzQyxLQUFLNEUsZUFBM0MsRUFBNEQsS0FBSytDLFlBQWpFLEVBQStFLEtBQUtDLFdBQXBGLEVBQWlHbEQsU0FBakcsQ0FBdkI7QUFDQSxhQUFLbUMsSUFBTCxDQUFVeEwsZUFBZUMsaUJBQXpCLEVBQTRDb00sY0FBNUM7QUFDRDtBQUNGOzs7cUNBRWdCO0FBQ2YsVUFBSSxLQUFLOUMsZUFBTCxDQUFxQmdDLElBQXpCLEVBQStCO0FBQzdCLFlBQU14RixpQkFBaUI1Qix1QkFBdUIsS0FBS29GLGVBQTVCLENBQXZCO0FBQ0FyRSw0QkFBb0IsS0FBS3FFLGVBQXpCO0FBQ0EsYUFBS2lDLElBQUwsQ0FBVXhMLGVBQWVDLGlCQUF6QixFQUE0QztBQUMxQ2dGLDRCQUFrQmMsY0FEd0I7QUFFMUNBLDBCQUFnQjtBQUYwQixTQUE1QztBQUlBLGFBQUt3SSxXQUFMO0FBQ0Q7QUFDRjs7OzZCQUVRaEwsSyxFQUFvQztBQUFBOztBQUFBLFVBQTdCaUssSUFBNkIsdUVBQXRCLElBQXNCO0FBQUEsVUFBaEJnQixNQUFnQix1RUFBUCxLQUFPOztBQUMzQyxVQUFJbkksU0FBUzlDLEtBQWI7QUFDQSxVQUFJLENBQUNrTCxNQUFNQyxPQUFOLENBQWNySSxNQUFkLENBQUwsRUFBNEI7QUFDMUJBLGlCQUFTLENBQUM5QyxLQUFELENBQVQ7QUFDRDs7QUFFRCwySEFBZThDLE1BQWY7QUFDQUEsYUFBTy9CLE9BQVAsQ0FBZSxvQkFBWTtBQUN6QixZQUFNK0UsWUFBWSxPQUFLQyxRQUFMLENBQWMvQyxHQUFkLENBQWtCb0ksUUFBbEIsQ0FBbEI7QUFDQSxZQUFJdEYsU0FBSixFQUFlO0FBQ2JBLG9CQUFVK0MsVUFBVixHQUF3Qm9CLFFBQVEsT0FBT0EsS0FBS3BCLFVBQVosS0FBMkIsV0FBbkMsR0FBaUQxQixRQUFROEMsS0FBS3BCLFVBQWIsQ0FBakQsR0FBNEUsSUFBcEc7QUFDQS9DLG9CQUFVb0MsT0FBVixHQUFxQitCLFFBQVEsT0FBT0EsS0FBSy9CLE9BQVosS0FBd0IsV0FBaEMsR0FBOENmLFFBQVE4QyxLQUFLL0IsT0FBYixDQUE5QyxHQUFzRSxJQUEzRjtBQUNBcEMsb0JBQVV6RCxTQUFWLEdBQXVCNEgsUUFBUSxPQUFPQSxLQUFLNUgsU0FBWixLQUEwQixXQUFsQyxHQUFnRDhFLFFBQVE4QyxLQUFLNUgsU0FBYixDQUFoRCxHQUEwRSxJQUFqRztBQUNBeUQsb0JBQVUxRCxRQUFWLEdBQXNCNkgsUUFBUSxPQUFPQSxLQUFLN0gsUUFBWixLQUF5QixXQUFqQyxHQUErQytFLFFBQVE4QyxLQUFLN0gsUUFBYixDQUEvQyxHQUF3RSxJQUE5RjtBQUNBMEQsb0JBQVV1RixnQkFBVixHQUE4QnBCLFFBQVEsT0FBT0EsS0FBS29CLGdCQUFaLEtBQWlDLFdBQXpDLEdBQXVEbEUsUUFBUThDLEtBQUtvQixnQkFBYixDQUF2RCxHQUF3RixLQUF0SDtBQUNBdkYsb0JBQVV3RixlQUFWLEdBQTZCckIsUUFBUSxPQUFPQSxLQUFLcUIsZUFBWixLQUFnQyxXQUF4QyxHQUFzRG5FLFFBQVE4QyxLQUFLcUIsZUFBYixDQUF0RCxHQUFzRixLQUFuSDtBQUNBeEYsb0JBQVUrRCxRQUFWLEdBQXNCSSxRQUFRLE9BQU9BLEtBQUtKLFFBQVosS0FBeUIsV0FBakMsR0FBK0MxQyxRQUFROEMsS0FBS0osUUFBYixDQUEvQyxHQUF3RSxJQUE5RjtBQUNEO0FBQ0YsT0FYRDs7QUFhQSxVQUFJb0IsTUFBSixFQUFZO0FBQ1YsWUFBTW5DLGlCQUFpQjtBQUNyQnBILDRCQUFrQmQsdUJBQXVCLEtBQUtvRixlQUE1QjtBQURHLFNBQXZCO0FBR0EsWUFBTXhELGlCQUFpQixFQUF2QjtBQUNBTSxlQUFPL0IsT0FBUCxDQUFlLG9CQUFZO0FBQ3pCLGNBQU0rRSxZQUFZLE9BQUtDLFFBQUwsQ0FBYy9DLEdBQWQsQ0FBa0JvSSxRQUFsQixDQUFsQjtBQUNBLGNBQUl0RixVQUFVK0MsVUFBZCxFQUEwQjtBQUN4QjNILHlCQUFZa0ssUUFBWixFQUFzQixPQUFLaEssWUFBM0IsRUFBeUMsT0FBSzRFLGVBQTlDLEVBQStELE9BQUsrQyxZQUFwRSxFQUFrRixPQUFLQyxXQUF2RixFQUFvR2xELFNBQXBHO0FBQ0F0RCwyQkFBZXZCLElBQWYsQ0FBb0JtSyxRQUFwQjtBQUNEO0FBQ0YsU0FORDs7QUFRQSxZQUFJNUksZUFBZVYsTUFBbkIsRUFBMkI7QUFDekJnSCx5QkFBZXRHLGNBQWYsR0FBZ0NBLGNBQWhDO0FBQ0EsZUFBS3lGLElBQUwsQ0FBVXhMLGVBQWVDLGlCQUF6QixFQUE0Q29NLGNBQTVDO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPLElBQVA7QUFDRDs7O2dDQUdXOUksSyxFQUFPO0FBQ2pCLFVBQUk4QyxTQUFTOUMsS0FBYjtBQUNBLFVBQUksQ0FBQ2tMLE1BQU1DLE9BQU4sQ0FBY3JJLE1BQWQsQ0FBTCxFQUE0QjtBQUMxQkEsaUJBQVMsQ0FBQzlDLEtBQUQsQ0FBVDtBQUNEO0FBQ0QsVUFBTXVMLHNCQUFzQjFJLG9CQUFvQixLQUFLbUQsZUFBekIsRUFBMENsRCxNQUExQyxDQUE1QjtBQUNBLFdBQUttRixJQUFMLENBQVV4TCxlQUFlQyxpQkFBekIsRUFBNEM7QUFDMUNnRiwwQkFBa0I2SixtQkFEd0I7QUFFMUMvSSx3QkFBZ0I1Qix1QkFBdUIsS0FBS29GLGVBQTVCO0FBRjBCLE9BQTVDOztBQUtBbEI7QUFDQSxXQUFLcUQsT0FBTCxDQUFhN0UsS0FBYixDQUFtQkgsTUFBbkIsR0FBNEIsU0FBNUI7QUFDQTtBQUNBLFdBQUssSUFBSW1HLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLbkIsT0FBTCxDQUFhb0IsVUFBYixDQUF3QnpILE1BQTVDLEVBQW9Ed0gsS0FBSyxDQUF6RCxFQUE0RDtBQUMxRCxhQUFLbkIsT0FBTCxDQUFhb0IsVUFBYixDQUF3QkQsQ0FBeEIsRUFBMkJoRyxLQUEzQixDQUFpQ0gsTUFBakMsR0FBMEMsU0FBMUM7QUFDQSxhQUFLZ0YsT0FBTCxDQUFhb0IsVUFBYixDQUF3QkQsQ0FBeEIsRUFBMkJoRyxLQUEzQixDQUFpQ29HLGFBQWpDLEdBQWlELE1BQWpEO0FBQ0Q7O0FBRUQscUlBQXlCNUcsTUFBekI7QUFDRDs7OzJDQUVzQjtBQUNyQixVQUFNTixpQkFBaUI1Qix1QkFBdUIsS0FBS29GLGVBQTVCLENBQXZCO0FBQ0FyRSwwQkFBb0IsS0FBS3FFLGVBQXpCO0FBQ0EsV0FBS2lDLElBQUwsQ0FBVXhMLGVBQWVDLGlCQUF6QixFQUE0QztBQUMxQ2dGLDBCQUFrQmMsY0FEd0I7QUFFMUNBLHdCQUFnQjtBQUYwQixPQUE1Qzs7QUFLQXNDO0FBQ0EsV0FBS3FELE9BQUwsQ0FBYTdFLEtBQWIsQ0FBbUJILE1BQW5CLEdBQTRCLFNBQTVCO0FBQ0E7QUFDQSxXQUFLLElBQUltRyxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS25CLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0J6SCxNQUE1QyxFQUFvRHdILEtBQUssQ0FBekQsRUFBNEQ7QUFDMUQsYUFBS25CLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELENBQXhCLEVBQTJCaEcsS0FBM0IsQ0FBaUNILE1BQWpDLEdBQTBDLFNBQTFDO0FBQ0EsYUFBS2dGLE9BQUwsQ0FBYW9CLFVBQWIsQ0FBd0JELENBQXhCLEVBQTJCaEcsS0FBM0IsQ0FBaUNvRyxhQUFqQyxHQUFpRCxNQUFqRDtBQUNEOztBQUVELHFJQUF5QmxILGNBQXpCO0FBQ0Q7Ozt5Q0FNb0I7QUFDbkIsV0FBS2dKLGFBQUw7QUFDQSxXQUFLdEIsVUFBTCxHQUFrQixJQUFsQjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7MENBRTBDO0FBQUEsVUFBdkJ1QixjQUF1Qix1RUFBTixJQUFNOztBQUN6QyxVQUFJQSxjQUFKLEVBQW9CO0FBQ2xCLGFBQUtBLGNBQUw7QUFDRDtBQUNELFdBQUtDLGNBQUw7QUFDQSxXQUFLeEIsVUFBTCxHQUFrQixLQUFsQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7OzBDQUNzQmhNLEssRUFBTztBQUMzQixVQUFJQSxNQUFNRyxPQUFWLEVBQW1CO0FBQ2pCLGFBQUtnSCxjQUFMLEdBQXNCLElBQXRCO0FBQ0QsT0FGRCxNQUVPLElBQUluSCxNQUFNeU4sSUFBTixLQUFlak8sWUFBWUUsT0FBL0IsRUFBd0M7QUFDN0M7QUFDQSxhQUFLeUgsY0FBTCxHQUFzQixLQUF0QjtBQUNEO0FBQ0Y7OztzQkEvSWUvRCxXLEVBQWE7QUFDM0JVLDJCQUFXQyxjQUFYLENBQTBCWCxXQUExQixFQUF1QyxLQUFLeUgsWUFBNUM7QUFDRCxLO3dCQUVpQjtBQUNoQixhQUFPLEtBQUtBLFlBQVo7QUFDRDs7O3dCQUVvQjtBQUNuQixhQUFPbkksdUJBQXVCLEtBQUtvRixlQUE1QixDQUFQO0FBQ0Q7Ozt3QkEwR3lCO0FBQ3hCLGFBQU8sS0FBS2tFLFVBQVo7QUFDRDs7OztFQWhpQnVDMEIsb0I7O2tCQUFyQjVHLFk7OztBQTRqQnJCZ0MsT0FBT0MsTUFBUCxDQUFjeEssY0FBZCxFQUE4Qm1QLHFCQUFXblAsY0FBekM7QUFDQXVJLGFBQWF2SSxjQUFiLEdBQThCQSxjQUE5QiIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEludGVyYWN0VXRpbHMgZnJvbSBcIi4uL2ludGVyYWN0aW9ucy9pbnRlcmFjdC11dGlsc1wiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IEJhc2ljU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2Jhc2ljLXN0eWxlXCJcbmltcG9ydCBEcmF3RW5naW5lIGZyb20gXCIuL2RyYXctZW5naW5lXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgUG9seUxpbmUgZnJvbSBcIi4uL3NoYXBlcy9wb2x5LWxpbmVcIlxuaW1wb3J0IFZlcnRFZGl0YWJsZVNoYXBlIGZyb20gXCIuLi9pbnRlcmFjdGlvbnMvdmVydC1lZGl0YWJsZS1zaGFwZVwiXG5pbXBvcnQgWGZvcm1TaGFwZSBmcm9tIFwiLi4vaW50ZXJhY3Rpb25zL3hmb3JtLXNoYXBlXCJcblxuY29uc3Qgc2NhbGVTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0NnIHRyYW5zZm9ybT0ncm90YXRlKDxkZWdyZWVzPiwyNCwyNCknJTNFJTNDcG9seWdvbiBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBwb2ludHM9JzE2LDIwIDE2LDEyIDQsMjQgMTYsMzYgMTYsMjggMzIsMjggMzIsMzYgNDQsMjQgMzIsMTIgMzIsMjAgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMTQsMjIgMTQsMTcgNywyNCAxNCwzMSAxNCwyNiAzNCwyNiAzNCwzMSA0MSwyNCAzNCwxNyAzNCwyMiAnLyUzRSUzQy9nJTNFJTNDL3N2ZyUzRVxcXCIpIG5vLXJlcGVhdFwiXG5cbmNvbnN0IHJvdGF0ZVN2ZyA9IFwidXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDQ4IDQ4JyUzRSUzQ2cgdHJhbnNmb3JtPSdyb3RhdGUoPGRlZ3JlZXM+LDI0LDI0KSclM0UlM0NwYXRoIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIGQ9J00yNS45LDRDMTYuNiw0LDguOCwxMS4yLDcuNCwyMC44SDYuN0gzLjNsMS42LDIuOWwzLjgsNy4xbDEuOCwzLjNsMS44LTMuM2wzLjgtNy4xbDEuNi0yLjloLTMuM2gtMC4xIGMxLjMtNS43LDYuMS05LjksMTEuNy05LjljOCwwLDEyLjEsNC40LDEyLjEsMTMuMWMwLDcuMi01LjQsMTMuMS0xMi4xLDEzLjFoLTJ2MlY0MnYyaDJjMTAuNCwwLDE4LjgtOSwxOC44LTIwIEM0NC43LDExLjcsMzcuNSw0LDI1LjksNEwyNS45LDR6Jy8lM0UlM0NwYXRoIGQ9J00yNS45LDZjMTAuNSwwLDE2LjgsNi43LDE2LjgsMThjMCw5LjktNy41LDE4LTE2LjgsMTh2LTIuOWM3LjgsMCwxNC4xLTYuOCwxNC4xLTE1LjFjMC01LjYtMS44LTE1LjEtMTQuMS0xNS4xIGMtNy40LDAtMTMuNCw2LjEtMTQsMTMuOWgyLjRsLTMuOCw3LjFsLTMuOC03LjFoMi41QzkuNywxMy40LDE3LDYsMjUuOSw2Jy8lM0UlM0MvZyUzRSUzQy9zdmclM0VcXFwiKSBuby1yZXBlYXRcIlxuXG5jb25zdCBhZGRTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0Nwb2x5Z29uIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIHBvaW50cz0nMzEuMiwyOCAyNC44LDI4IDI0LjgsMzIuOCAyMCwzMi44IDIwLDM5LjIgMjQuOCwzOS4yIDI0LjgsNDQgMzEuMiw0NCAzMS4yLDM5LjIgMzYsMzkuMiAzNiwzMi44IDMxLjIsMzIuOCAnLyUzRSAlM0Nwb2x5Z29uIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZicgcG9pbnRzPScxMiwzMiAxMiw0IDMyLjMsMjQuMyAyMCwyNC4zIDE5LjcsMjQuNiAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPScxMy44LDguMiAxMy44LDI3LjggMTksMjIuOCAxOS4yLDIyLjUgMjgsMjIuNSAnLyUzRSUzQ3BvbHlsaW5lIHBvaW50cz0nMjkuNiwyOS42IDI5LjYsMzQuNCAzNC40LDM0LjQgMzQuNCwzNy42IDI5LjYsMzcuNiAyOS42LDQyLjQgMjYuNCw0Mi40IDI2LjQsMzcuNiAyMS42LDM3LjYgMjEuNiwzNC40IDI2LjQsMzQuNCAyNi40LDI5LjYgMjkuNiwyOS42ICAnLyUzRSUzQy9zdmclM0VcXFwiKSBuby1yZXBlYXRcIlxuXG5jb25zdCByZW1vdmVTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0NyZWN0IHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIHg9JzIwJyB5PSczMi44JyB3aWR0aD0nMTYnIGhlaWdodD0nNi40Jy8lM0UlM0Nwb2x5Z29uICBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBwb2ludHM9JzEyLDMyIDEyLDQgMzIuMywyNC4zIDIwLDI0LjMgMTkuNywyNC42ICcvJTNFJTNDcG9seWdvbiBwb2ludHM9JzEzLjgsOC4yIDEzLjgsMjcuOCAxOSwyMi44IDE5LjIsMjIuNSAyOCwyMi41ICcvJTNFJTNDcG9seWxpbmUgcG9pbnRzPSczNC40LDM0LjQgMzQuNCwzNy42IDIxLjYsMzcuNiAyMS42LDM0LjQgJy8lM0UlM0Mvc3ZnJTNFXFxcIikgbm8tcmVwZWF0XCJcblxuY29uc3QgcmVwb3NpdGlvblN2ZyA9IFwidXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDQ4IDQ4JyUzRSUzQ3BhdGggc3R5bGU9J2ZpbGw6JTIzZmZmZmZmOycgZD0nTTI0LDE3LjVjLTMuNiwwLTYuNSwyLjktNi41LDYuNXMyLjksNi41LDYuNSw2LjVzNi41LTIuOSw2LjUtNi41UzI3LjYsMTcuNSwyNCwxNy41TDI0LDE3LjV6Jy8lM0UlM0NwYXRoIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIGQ9J00yNCw0TDQsMjRsMjAsMjBsMjAtMjBMMjQsNHogTTMxLjUsMzEuNWgtMTV2LTE1aDE1VjMxLjV6Jy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMTcsMzQgMjQsNDAuNSAzMSwzNCAgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMzEsMTQgMjQsNy41IDE3LDE0ICAgICAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPScxNCwxNyA3LjUsMjQgMTQsMzEgICAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPSczNCwzMSA0MC41LDI0IDM0LDE3ICAgICcvJTNFJTNDcGF0aCBkPSdNMjQsMjBjMi4yLDAsNCwxLjgsNCw0cy0xLjgsNC00LDRzLTQtMS44LTQtNFMyMS44LDIwLDI0LDIwJy8lM0UlM0Mvc3ZnJTNFXFxcIikgbm8tcmVwZWF0XCJcblxuY29uc3QgRXZlbnRDb25zdGFudHMgPSB7XG4gIFNFTEVDVElPTl9DSEFOR0VEOiBcImRyYXc6c2VsZWN0aW9uQ2hhbmdlZFwiLFxuICBEUkFHX0JFR0lOOiBcImRyYXc6ZHJhZzpiZWdpblwiLFxuICBEUkFHX0VORDogXCJkcmF3OmRyYWc6ZW5kXCJcbn1cblxuY29uc3QgQ29uc3RhbnRzID0ge1xuICBTVkdfT0ZGU0VUOiAtMTQsXG4gIFFVSUNLX0NMSUNLX1RJTUU6IDUwMCxcbiAgUklHSFRfQU5HTEU6IDkwLFxuICBTVFJBSUdIVF9BTkdMRTogMTgwLFxuICBGT1JUWV9GSVZFX0FOR0xFOiA0NVxufVxuXG5jb25zdCB0bXBQdDEgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuY29uc3QgdG1wUHQyID0gUG9pbnQyZC5jcmVhdGUoMCwgMClcblxuY29uc3QgZGVmYXVsdFhmb3JtU3R5bGUgPSB7XG4gIGZpbGxDb2xvcjogXCJ3aGl0ZVwiLFxuICBzdHJva2VDb2xvcjogXCJibGFja1wiLFxuICBzdHJva2VXaWR0aDogMlxufVxuXG5jb25zdCBFdmVudHNUeXBlcyA9IHtcbiAgTU9VU0VET1dOOiBcIm1vdXNlZG93blwiLFxuICBNT1VTRVVQOiBcIm1vdXNldXBcIixcbiAgTU9VU0VNT1ZFOiBcIm1vdXNlbW92ZVwiLFxuICBUT1VDSFNUQVJUOiBcInRvdWNoc3RhcnRcIixcbiAgVE9VQ0hFTkQ6IFwidG91Y2hlbmRcIixcbiAgVE9VQ0hNT1ZFOiBcInRvdWNobW92ZVwiXG59XG5cbi8vIFRoaXMgbWV0aG9kIHdpbGwgQWRkIGNsaWVudFgsIGNsaWVudFkgJiBvZmZzZXRYIGFuZCBvZmZzZXRZIGZvciBUb3VjaCBldmVudHNcbmZ1bmN0aW9uIGdldFRvdWNoQ29vcmRpbmF0ZXMoZXZlbnQsIGNhbnZhcykge1xuICBldmVudC5jbGllbnRYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYXG4gIGV2ZW50LmNsaWVudFkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFlcbiAgY29uc3QgZWxlbWVudCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBldmVudC5vZmZzZXRYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gZWxlbWVudC5sZWZ0XG4gIGV2ZW50Lm9mZnNldFkgPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFkgLSBlbGVtZW50LnRvcFxuICByZXR1cm4gZXZlbnRcbn1cblxuZnVuY3Rpb24gaW5DYW52YXMoY2FudmFzLCB4LCB5KSB7XG4gIGNvbnN0IGRvbXJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgbGV0IGxvY2FsWCA9IDBcbiAgbGV0IGxvY2FsWSA9IDBcbiAgY29uc3QgaXNJbkNhbnZhcyA9ICgobG9jYWxYID0geCAtIGRvbXJlY3QubGVmdCAtIGNhbnZhcy5jbGllbnRMZWZ0KSA+PSAwICYmIGxvY2FsWCA8PSBjYW52YXMuY2xpZW50V2lkdGggJiYgKGxvY2FsWSA9IHkgLSBkb21yZWN0LnRvcCAtIGNhbnZhcy5jbGllbnRUb3ApID49IDAgJiYgbG9jYWxZIDw9IGNhbnZhcy5jbGllbnRIZWlnaHQpXG4gIHJldHVybiBpc0luQ2FudmFzXG59XG5cbmZ1bmN0aW9uIGdldExvY2FsTW91c2VQb3Mob3V0LCBlbGVtLCBldmVudCkge1xuICBjb25zdCBkb21yZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICBvdXRbMF0gPSBldmVudC5jbGllbnRYIC0gZG9tcmVjdC5sZWZ0IC0gZWxlbS5jbGllbnRMZWZ0XG4gIG91dFsxXSA9IGV2ZW50LmNsaWVudFkgLSBkb21yZWN0LnRvcCAtIGVsZW0uY2xpZW50VG9wXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVNlbGVjdGVkU2hhcGUoY2FudmFzLCBldmVudCwgc2VsZWN0ZWRJbmZvLCBjYW1lcmEpIHtcbiAgZ2V0TG9jYWxNb3VzZVBvcyh0bXBQdDEsIGNhbnZhcywgZXZlbnQpXG4gIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodG1wUHQyLCB0bXBQdDEsIGNhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4KVxuICBjb25zdCBzaGFwZSA9IHNlbGVjdGVkSW5mby5zaGFwZVxuICBpZiAoc2hhcGUgaW5zdGFuY2VvZiBYZm9ybVNoYXBlKSB7XG4gICAgSW50ZXJhY3RVdGlscy50cmFuc2Zvcm1YZm9ybVNoYXBlKHNoYXBlLCBzZWxlY3RlZEluZm8sIHRtcFB0MSwgdG1wUHQyLCBjYW1lcmEpXG4gIH0gZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBWZXJ0RWRpdGFibGVTaGFwZSkge1xuICAgIEludGVyYWN0VXRpbHMudHJhbnNsYXRlVmVydChzaGFwZSwgc2VsZWN0ZWRJbmZvLCB0bXBQdDEsIHRtcFB0MiwgY2FtZXJhKVxuICB9IGVsc2Uge1xuICAgIEludGVyYWN0VXRpbHMudHJhbnNsYXRlU2hhcGUoc2hhcGUsIHNlbGVjdGVkSW5mbywgdG1wUHQxLCB0bXBQdDIsIGNhbWVyYSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudEtleXNUb1NlbGVjdGVkSW5mbyhldmVudCwgc2VsZWN0ZWRJbmZvKSB7XG4gIHNlbGVjdGVkSW5mby5rZXlzID0ge1xuICAgIGFsdEtleTogZXZlbnQuYWx0S2V5LFxuICAgIGN0cmxLZXk6IGV2ZW50LmN0cmxLZXksXG4gICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgIG1ldGFLZXk6IGV2ZW50Lm1ldGFLZXlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHNlbGVjdGlvbk1hcCkge1xuICBjb25zdCBzZWxlY3RlZE9ianMgPSBbXVxuICBzZWxlY3Rpb25NYXAuZm9yRWFjaCgoc3Vic2hhcGUsIHNoYXBlKSA9PiB7XG4gICAgc2VsZWN0ZWRPYmpzLnB1c2goc2hhcGUpXG4gIH0pXG4gIHJldHVybiBzZWxlY3RlZE9ianNcbn1cblxuZnVuY3Rpb24gc2VsZWN0U2hhcGUoc2VsZWN0ZWRTaGFwZSwgc29ydGVkU2hhcGVzLCBjdXJyU2VsZWN0ZWRTaGFwZXMsIHNlbGVjdFN0eWxlLCB4Zm9ybVN0eWxlLCBzZWxlY3RPcHRzKSB7XG4gIGNvbnN0IGZpcmVPYmplY3QgPSB7XG4gICAgdW5zZWxlY3RlZFNoYXBlczogZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcChjdXJyU2VsZWN0ZWRTaGFwZXMpXG4gIH1cbiAgY2xlYXJTZWxlY3RlZFNoYXBlcyhjdXJyU2VsZWN0ZWRTaGFwZXMpXG4gIHNlbGVjdGVkU2hhcGUuc2F2ZSgpXG4gIGNvbnN0IG1heFogPSBzb3J0ZWRTaGFwZXNbc29ydGVkU2hhcGVzLmxlbmd0aCAtIDFdLnpJbmRleFxuICBzZWxlY3RlZFNoYXBlLnpJbmRleCA9IG1heFogKyAxXG4gIEJhc2ljU3R5bGUuY29weUJhc2ljU3R5bGUoc2VsZWN0U3R5bGUsIHNlbGVjdGVkU2hhcGUpXG4gIHNlbGVjdGVkU2hhcGUuc2VsZWN0ZWQgPSB0cnVlXG4gIC8vIGNvbnN0IGRpbWVuc2lvbnMgPSBzZWxlY3RlZFNoYXBlLmdldERpbWVuc2lvbnMoKVxuXG4gIGxldCBuZXdTZWxlY3RTaGFwZSA9IG51bGxcbiAgaWYgKHNlbGVjdE9wdHMuc2NhbGFibGUgfHwgc2VsZWN0T3B0cy5yb3RhdGFibGUpIHtcbiAgICBuZXdTZWxlY3RTaGFwZSA9IG5ldyBYZm9ybVNoYXBlKHhmb3JtU3R5bGUgfHwgZGVmYXVsdFhmb3JtU3R5bGUsIHNlbGVjdE9wdHMpXG4gICAgc2VsZWN0ZWRTaGFwZS5hZGRDaGlsZFhmb3JtKG5ld1NlbGVjdFNoYXBlKVxuICB9XG4gIGN1cnJTZWxlY3RlZFNoYXBlcy5zZXQoc2VsZWN0ZWRTaGFwZSwgbmV3U2VsZWN0U2hhcGUpXG5cbiAgZmlyZU9iamVjdC5zZWxlY3RlZFNoYXBlcyA9IFtzZWxlY3RlZFNoYXBlXVxuICByZXR1cm4gZmlyZU9iamVjdFxufVxuXG5mdW5jdGlvbiBjbGVhclNlbGVjdGVkU2hhcGVzKHNlbGVjdGVkU2hhcGVNYXApIHtcbiAgc2VsZWN0ZWRTaGFwZU1hcC5mb3JFYWNoKChzZWxlY3RlZFNoYXBlLCBzaGFwZSkgPT4ge1xuICAgIHNoYXBlLnJlc3RvcmUoKVxuICAgIHNoYXBlLnNlbGVjdGVkID0gZmFsc2VcbiAgICBzaGFwZS5yZW1vdmVDaGlsZFhmb3JtKHNlbGVjdGVkU2hhcGUpXG4gIH0pXG4gIHNlbGVjdGVkU2hhcGVNYXAuY2xlYXIoKVxufVxuXG5mdW5jdGlvbiBjbGVhclNwZWNpZmljU2hhcGVzKHNlbGVjdGVkU2hhcGVNYXAsIHNoYXBlcykge1xuICBjb25zdCBjbGVhcmVkU2hhcGVzID0gW11cbiAgc2hhcGVzLmZvckVhY2goc2hhcGUgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkU2hhcGUgPSBzZWxlY3RlZFNoYXBlTWFwLmdldChzaGFwZSlcbiAgICBzaGFwZS5yZXN0b3JlKClcbiAgICBzaGFwZS5zZWxlY3RlZCA9IGZhbHNlXG4gICAgc2hhcGUucmVtb3ZlQ2hpbGRYZm9ybShzZWxlY3RlZFNoYXBlKVxuICAgIHNlbGVjdGVkU2hhcGVNYXAuZGVsZXRlKHNoYXBlKVxuICAgIGNsZWFyZWRTaGFwZXMucHVzaChzaGFwZSlcbiAgfSlcbiAgcmV0dXJuIGNsZWFyZWRTaGFwZXNcbn1cblxuY29uc3QgaGlkZUN1cnNvciA9ICgpID0+IHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjdXJzb3JcIilcbiAgaWYgKGN1cnNvciAhPT0gbnVsbCkge1xuICAgIGN1cnNvci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgfVxufVxuXG5jb25zdCBzaG93Q3Vyc29yID0gKCkgPT4ge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnNvclwiKVxuICBpZiAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgY3Vyc29yLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcbiAgfVxufVxuXG5jb25zdCBoaWRlQ3Vyc29yV2l0aFBvaW50ZXIgPSAoZSkgPT4ge1xuICBlLnRhcmdldC5wYXJlbnROb2RlLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gIGhpZGVDdXJzb3IoKVxufVxuXG5jb25zdCBzaG93Q3Vyc29yV2l0aFBvaW50ZXIgPSAoZSkgPT4ge1xuICBlLnRhcmdldC5wYXJlbnROb2RlLnN0eWxlLmN1cnNvciA9IFwibm9uZVwiXG4gIHNob3dDdXJzb3IoKVxufVxuXG4vLyB1bmRlcnN0YW5kcyBob3cgdG8gcmV0dXJuIG1vdXNlIGNvb3JkaW5hdGVzIGFzIGFuIG9iamVjdCBpbiB0aGUgZm9ybWF0IHt4OiA8WC1DT09SRD4sIHk6IDxZLUNPT1JEPn1cbi8vIGFjY2VwdHMgYSBtb3VzZSBldmVudCBhbmQgYSBET00gZWxlbWVudCBhcyBhcmd1bWVudHNcbmZ1bmN0aW9uIGdldE1vdXNlQ29vcmRpbmF0ZXMoZSwgdGFyZ2V0KSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCR7YCMke3RhcmdldC5pZH0gY2FudmFzYH1gKVxuXG4gIGNvbnN0IGNvb3JkcyA9IHtcbiAgICB4OiBlLm9mZnNldFggKyBjYW52YXMub2Zmc2V0TGVmdCxcbiAgICB5OiBlLm9mZnNldFkgKyBjYW52YXMub2Zmc2V0VG9wXG4gIH1cblxuICByZXR1cm4gY29vcmRzXG59XG5cbi8vIHVuZGVyc3RhbmRzIGhvdyB0byBhcHBlbmQgY3VzdG9tIGN1cnNvcnMgdG8gdGhlIERPTVxuLy8gYWNjZXB0cyBhIG1vdXNlIGV2ZW50LCBhIERPTSBlbGVtZW50LCBhIGN1cnNvclN0eWxlLCBhbmQgcGl4ZWwgb2Zmc2V0cyBhcyBhcmd1bWVudHNcbmZ1bmN0aW9uIGFwcGVuZEN1c3RvbUN1cnNvcihfZXZlbnQsIHRhcmdldCwgY3Vyc29yU3R5bGUsIG9mZnNldFggPSBDb25zdGFudHMuU1ZHX09GRlNFVCwgb2Zmc2V0WSA9IENvbnN0YW50cy5TVkdfT0ZGU0VUKSB7XG4gIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY3Vyc29yXCIpXG4gIGNvbnN0IG1vdXNlID0gZ2V0TW91c2VDb29yZGluYXRlcyhfZXZlbnQsIHRhcmdldClcblxuICBpZiAoY3Vyc29yID09PSBudWxsKSB7XG4gICAgY29uc3QgbmV3Q3Vyc29yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIilcbiAgICBuZXdDdXJzb3Iuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJjdXJzb3JcIilcbiAgICBuZXdDdXJzb3Iuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgYHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAke2Ake21vdXNlLnl9cHhgfTsgbGVmdDogJHtgJHttb3VzZS54fXB4YH07IHdpZHRoOiAyOHB4OyBoZWlnaHQ6IDI4cHg7IGJhY2tncm91bmQ6ICR7Y3Vyc29yU3R5bGV9OyBjdXJzb3I6IG5vbmU7IHotaW5kZXg6IDEwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgdHJhbnNmb3JtOiB0cmFuc2xhdGUoJHtvZmZzZXRYfXB4LCAke29mZnNldFl9cHgpYClcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobmV3Q3Vyc29yKVxuICB9IGVsc2UgaWYgKGN1cnNvci5zdHlsZS5iYWNrZ3JvdW5kID09PSBjdXJzb3JTdHlsZSkge1xuICAgIHVwZGF0ZUN1cnNvclBvc2l0aW9uKF9ldmVudCwgdGFyZ2V0KVxuICB9IGVsc2Uge1xuICAgIGN1cnNvci5zdHlsZS5iYWNrZ3JvdW5kID0gY3Vyc29yU3R5bGVcbiAgICB1cGRhdGVDdXJzb3JQb3NpdGlvbihfZXZlbnQsIHRhcmdldClcbiAgfVxufVxuXG4vLyB1bmRlcnN0YW5kcyBob3cgdG8gcmVtb3ZlIHRoZSBjdXN0b20gY3Vyc29yIGZyb20gdGhlIERPTVxuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tQ3Vyc29yKCkge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnNvclwiKVxuICBpZiAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgY3Vyc29yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3Vyc29yKVxuICB9XG59XG5cbi8vIHVuZGVyc3RhbmRzIGhvdyB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXN0b20gY3Vyc29yIG9uIHRoZSBwYWdlXG4vLyBhY2NlcHRzIGEgbW91c2UgZXZlbnQgYW5kIGEgRE9NIGVsZW1lbnQgYXMgYXJndW1lbnRzXG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JQb3NpdGlvbihfZXZlbnQsIHRhcmdldCkge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnNvclwiKVxuICBjb25zdCBtb3VzZSA9IGdldE1vdXNlQ29vcmRpbmF0ZXMoX2V2ZW50LCB0YXJnZXQpXG5cbiAgaWYgKGN1cnNvciAhPT0gbnVsbCkge1xuICAgIGN1cnNvci5zdHlsZS50b3AgPSBgJHtgJHttb3VzZS55fXB4YH1gXG4gICAgY3Vyc29yLnN0eWxlLmxlZnQgPSBgJHtgJHttb3VzZS54fXB4YH1gXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhcGVCdWlsZGVyIGV4dGVuZHMgRHJhd0VuZ2luZSB7XG5cbiAgX3RvdWNoc3RhcnRDQihldmVudCkge1xuICAgIHRoaXMuX21vdXNlZG93bkNCKGV2ZW50KVxuICB9XG5cbiAgX3RvdWNobW92ZUNCKGV2ZW50KSB7XG4gICAgdGhpcy5fbW91c2Vtb3ZlQ0IoZXZlbnQpXG4gIH1cblxuICBfdG91Y2hlbmRDQihldmVudCkge1xuICAgIHRoaXMuX21vdXNldXBDQihldmVudClcbiAgfVxuXG4gIF9tb3VzZWRvd25DQihldmVudCkge1xuICAgIHRoaXMuc2V0RGVueU1vdXNlRXZlbnRGbGFnKGV2ZW50KVxuICAgIGlmICh0aGlzLmRlbnlNb3VzZUV2ZW50ICYmICFldmVudC50b3VjaGVzKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIGV2ZW50ID0gZ2V0VG91Y2hDb29yZGluYXRlcyhldmVudCwgdGhpcy5fZHJhd0NhbnZhcylcbiAgICAgIHRoaXMucHJldmlvdXNFdmVudE9iaiA9IGV2ZW50IC8vIEFzc2lnbiBldmVudCBvYmogdG8gdmFyaWFibGUgdG8gYXZvaWQgdGhlIHVzZSBpdCBmb3IgdG91Y2hlbmQgZXZlbnRcbiAgICB9XG5cbiAgICBpZiAoIWluQ2FudmFzKHRoaXMuX2RyYXdDYW52YXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpbWVyID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCB0aGlzLl9jYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIGxldCBpID0gLTFcbiAgICBsZXQgc2VsZWN0ZWRTaGFwZSA9IG51bGxcbiAgICBsZXQgc2VsZWN0ZWRJbmZvID0gbnVsbFxuICAgIGZvciAoaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGVzW2ldKVxuICAgICAgaWYgKHNoYXBlc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZFNoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgc2VsZWN0ZWRJbmZvID0gc2hhcGVJbmZvXG4gICAgICAgIGxldCBoaXRJbmZvID0gbnVsbFxuICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSAmJiAoaGl0SW5mbyA9IHNlbGVjdGVkU2hhcGUuY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpLmhpdCkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZFNoYXBlIGluc3RhbmNlb2YgVmVydEVkaXRhYmxlU2hhcGUgJiYgZXZlbnQuYWx0S2V5ICYmIGhpdEluZm8uY29udHJvbEluZGV4IDwgc2hhcGVzW2ldLm51bVZlcnRzKSB7XG4gICAgICAgICAgICBzaGFwZXNbaV0ucmVtb3ZlVmVydChoaXRJbmZvLmNvbnRyb2xJbmRleClcbiAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUgPSBudWxsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsWGZvcm0gPSBzZWxlY3RlZFNoYXBlLnBhcmVudC5sb2NhbFhmb3JtXG4gICAgICAgICAgICBjb25zdCBpbnZMb2NhbFhmb3JtID0gTWF0MmQuY2xvbmUobG9jYWxYZm9ybSlcbiAgICAgICAgICAgIE1hdDJkLmludmVydChpbnZMb2NhbFhmb3JtLCBpbnZMb2NhbFhmb3JtKVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPYmpQb3MgPSBQb2ludDJkLmNsb25lKHRtcFB0MilcbiAgICAgICAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQoc3RhcnRPYmpQb3MsIHN0YXJ0T2JqUG9zLCBpbnZMb2NhbFhmb3JtKVxuICAgICAgICAgICAgdGhpcy5fZHJhZ0luZm8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgcm90YXRlOiBCb29sZWFuKGhpdEluZm8ucm90YXRlKSxcbiAgICAgICAgICAgICAgY29udHJvbEluZGV4OiBoaXRJbmZvLmNvbnRyb2xJbmRleCxcbiAgICAgICAgICAgICAgc3RhcnRPYmplY3RQb3M6IHN0YXJ0T2JqUG9zLFxuICAgICAgICAgICAgICB3b3JsZFRvT2JqZWN0TWF0cml4OiBpbnZMb2NhbFhmb3JtLFxuICAgICAgICAgICAgICBzdGFydExvY2FsUG9zOiBzZWxlY3RlZFNoYXBlLnBhcmVudC5nZXRQb3NpdGlvbigpLFxuICAgICAgICAgICAgICBzdGFydExvY2FsU2NhbGU6IHNlbGVjdGVkU2hhcGUucGFyZW50LmdldFNjYWxlKCksXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYWxSb3Q6IHNlbGVjdGVkU2hhcGUucGFyZW50LmdldFJvdGF0aW9uKCksXG4gICAgICAgICAgICAgIHNoYXBlV2lkdGg6IHNlbGVjdGVkU2hhcGUucGFyZW50LndpZHRoLFxuICAgICAgICAgICAgICBzaGFwZUhlaWdodDogc2VsZWN0ZWRTaGFwZS5wYXJlbnQuaGVpZ2h0XG4gICAgICAgICAgICB9LCBzZWxlY3RlZEluZm8pXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLmNvbnRhaW5zUG9pbnQodG1wUHQxLCB0bXBQdDIsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHRoaXMuX2RyYXdDdHgpKSB7XG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZSA9IHNoYXBlc1tpXVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgaWYgKHNoYXBlSW5mby5zZWxlY3RhYmxlICYmIHNoYXBlc1tpXS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkge1xuICAgICAgLy8gICBzZWxlY3RlZFNoYXBlID0gc2hhcGVzW2ldXG4gICAgICAvLyAgIHNlbGVjdGVkSW5mbyA9IHNoYXBlSW5mb1xuICAgICAgLy8gICBjb25zdCBzZWxlY3RFdmVudE9iaiA9IHNlbGVjdFNoYXBlKHNlbGVjdGVkU2hhcGUsIHNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzZWxlY3RlZEluZm8pXG4gICAgICAvLyAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwgc2VsZWN0RXZlbnRPYmopXG4gICAgICAvLyAgIGJyZWFrXG4gICAgICAvLyB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwICYmIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNpemUpIHtcbiAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgICAgIHVuc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpLFxuICAgICAgICAgIHNlbGVjdGVkU2hhcGVzOiBbXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ0luZm8gPSBudWxsXG4gICAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRTaGFwZSAmJiBzZWxlY3RlZEluZm8gJiYgKHNlbGVjdGVkSW5mby5tb3ZhYmxlIHx8IHNlbGVjdGVkSW5mby5yb3RhdGFibGUgfHwgc2VsZWN0ZWRJbmZvLnNjYWxhYmxlKSkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgJHtgIyR7dGhpcy5fcGFyZW50LmlkfSA+IGNhbnZhc2B9YClcbiAgICAgIGlmIChjYW52YXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBoaWRlQ3Vyc29yKVxuICAgICAgICB0aGlzLl9wYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBzaG93Q3Vyc29yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBoaWRlQ3Vyc29yV2l0aFBvaW50ZXIpXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHNob3dDdXJzb3JXaXRoUG9pbnRlcilcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZHJhZ0luZm8gJiYgc2VsZWN0ZWRJbmZvLm1vdmFibGUpIHtcbiAgICAgICAgdGhpcy5fZHJhZ0luZm8gPSB7XG4gICAgICAgICAgc3RhcnRMb2NhbFBvczogc2VsZWN0ZWRTaGFwZS5nZXRQb3NpdGlvbigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2RyYWdJbmZvKSB7XG4gICAgICAgIHRoaXMuX2RyYWdJbmZvLnNoYXBlID0gc2VsZWN0ZWRTaGFwZVxuICAgICAgICB0aGlzLl9kcmFnSW5mby5zdGFydFBvcyA9IFBvaW50MmQuY2xvbmUodG1wUHQxKVxuICAgICAgICB0aGlzLl9kcmFnSW5mby5zdGFydFdvcmxkUG9zID0gUG9pbnQyZC5jbG9uZSh0bXBQdDIpXG4gICAgICAgIHRoaXMuX2RyYWdJbmZvLm9iamVjdFRvV29ybGRNYXRyaXggPSBNYXQyZC5jbG9uZShzZWxlY3RlZFNoYXBlLmdsb2JhbFhmb3JtKVxuICAgICAgICBhZGRFdmVudEtleXNUb1NlbGVjdGVkSW5mbyhldmVudCwgdGhpcy5fZHJhZ0luZm8pXG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5EUkFHX0JFR0lOLCB7XG4gICAgICAgICAgc2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYgKCFldmVudC50b3VjaGVzKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfbW91c2V1cENCKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuZGVueU1vdXNlRXZlbnQgJiYgIWV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIHRoaXMuc2V0RGVueU1vdXNlRXZlbnRGbGFnKGV2ZW50KVxuICAgICAgcmV0dXJuIC8vIFJldHVybmluZyBvbiBuZXh0IGxpbmUgdG8gYXZvaWQgRVNMaW50IGVycm9yXG4gICAgfVxuICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICAvLyBVc2UgcHJldmlvdXNseSBhc3NpZ25lZCBldmVudCBvYmogdG8gZ2V0IHRoZSBvZmZzZXRYICYgWSBhbmQgY2xpZW50WCAmIFkgY2FsY3VsYXRpb25cbiAgICAgIGV2ZW50ID0gdGhpcy5wcmV2aW91c0V2ZW50T2JqXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RyYWdJbmZvICYmIHRoaXMuX2RyYWdJbmZvLnNoYXBlKSB7XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgaWYgKGV2ZW50LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgJHtgIyR7dGhpcy5fcGFyZW50LmlkfSA+IGNhbnZhc2B9YClcbiAgICAgIGlmIChjYW52YXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBoaWRlQ3Vyc29yKVxuICAgICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCBzaG93Q3Vyc29yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCBoaWRlQ3Vyc29yV2l0aFBvaW50ZXIpXG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHNob3dDdXJzb3JXaXRoUG9pbnRlcilcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYWdJbmZvID0gbnVsbFxuICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLkRSQUdfRU5ELCB7XG4gICAgICAgIHNoYXBlczogZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChwZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMudGltZXIgPCBDb25zdGFudHMuUVVJQ0tfQ0xJQ0tfVElNRSkge1xuICAgICAgLy8gdGhpcyBpcyBhIHJlbGF0aXZlbHkgcXVpY2sgY2xpY2tcbiAgICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodG1wUHQyLCB0bXBQdDEsIHRoaXMuX2NhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4KVxuICAgICAgY29uc3Qgd29ybGRUb1NjcmVlbk1hdHJpeCA9IHRoaXMuX2NhbWVyYS53b3JsZFRvU2NyZWVuTWF0cml4XG4gICAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgICAgbGV0IHNlbGVjdGVkU2hhcGUgPSBudWxsXG4gICAgICBsZXQgc2VsZWN0ZWRJbmZvID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzZWxlY3RlZEluZm8gPSB0aGlzLl9vYmplY3RzLmdldChzaGFwZXNbaV0pXG4gICAgICAgIGlmIChzZWxlY3RlZEluZm8uc2VsZWN0YWJsZSAmJiBzaGFwZXNbaV0uY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpIHtcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlID0gc2hhcGVzW2ldXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkU2hhcGUgJiYgIXNlbGVjdGVkU2hhcGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0RXZlbnRPYmogPSBzZWxlY3RTaGFwZShzZWxlY3RlZFNoYXBlLCBzaGFwZXMsIHRoaXMuX3NlbGVjdGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RTdHlsZSwgdGhpcy5feGZvcm1TdHlsZSwgc2VsZWN0ZWRJbmZvKVxuICAgICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuU0VMRUNUSU9OX0NIQU5HRUQsIHNlbGVjdEV2ZW50T2JqKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdXNlciBjbGlja3MgYW55d2hlcmUgb3V0c2lkZSB0aGVuIGFsbG93IHRoZSBtb3ZlbWVudCBvZiBCYXNlIE1hcCAoUGFyZW50cyBDb250YWluZXIpXG4gICAgICAgIHRoaXMuX21ha2VQYXJlbnRFbGVtZW50TW92YWJsZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX21vdXNlbW92ZUNCKGV2ZW50KSB7XG4gICAgdGhpcy5zZXREZW55TW91c2VFdmVudEZsYWcoZXZlbnQpXG4gICAgaWYgKHRoaXMuZGVueU1vdXNlRXZlbnQgJiYgIWV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChldmVudC50b3VjaGVzKSB7XG4gICAgICBldmVudCA9IGdldFRvdWNoQ29vcmRpbmF0ZXMoZXZlbnQsIHRoaXMuX2RyYXdDYW52YXMpXG4gICAgICB0aGlzLnByZXZpb3VzRXZlbnRPYmogPSBldmVudCAvLyBBc3NpZ24gZXZlbnQgb2JqIHRvIHZhcmlhYmxlIHRvIGF2b2lkIHRoZSB1c2UgaXQgZm9yIHRvdWNoZW5kIGV2ZW50XG4gICAgfVxuXG4gICAgaWYgKCEoaW5DYW52YXModGhpcy5fZHJhd0NhbnZhcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpICYmICF0aGlzLl9kcmFnSW5mbykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RyYWdJbmZvICYmIHRoaXMuX2RyYWdJbmZvLnNoYXBlKSB7XG4gICAgICB1cGRhdGVDdXJzb3JQb3NpdGlvbihldmVudCwgdGhpcy5fcGFyZW50KVxuICAgICAgYWRkRXZlbnRLZXlzVG9TZWxlY3RlZEluZm8oZXZlbnQsIHRoaXMuX2RyYWdJbmZvKVxuICAgICAgdHJhbnNmb3JtU2VsZWN0ZWRTaGFwZSh0aGlzLl9kcmF3Q2FudmFzLCBldmVudCwgdGhpcy5fZHJhZ0luZm8sIHRoaXMuX2NhbWVyYSlcbiAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICBpZiAoIWV2ZW50LnRvdWNoZXMpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWV2ZW50LmJ1dHRvbnMgJiYgdGhpcy5fc2VsZWN0ZWRTaGFwZXMuc2l6ZSkge1xuICAgICAgUG9pbnQyZC5zZXQodG1wUHQxLCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKVxuICAgICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0bXBQdDIsIHRtcFB0MSwgdGhpcy5fY2FtZXJhLnNjcmVlblRvV29ybGRNYXRyaXgpXG4gICAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc29ydGVkU2hhcGVzXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGNvbnN0IGZsaXB5ID0gdGhpcy5fY2FtZXJhLmlzWUZsaXBwZWQoKVxuICAgICAgZm9yIChpID0gc2hhcGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGlmIChzaGFwZXNbaV0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICBjb25zdCBzZWxlY3RJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGVzW2ldKVxuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkU2hhcGUgPSB0aGlzLl9zZWxlY3RlZFNoYXBlcy5nZXQoc2hhcGVzW2ldKVxuICAgICAgICAgIGxldCBoaXRJbmZvID0gbnVsbFxuICAgICAgICAgIHRoaXMuX3BhcmVudC5zdHlsZS5jdXJzb3IgPSBcIm5vbmVcIlxuICAgICAgICAgIC8vIGZvckVhY2ggbm90IHN1cHBvcnRlZCBvbiBub2RlbGlzdCBpbiBJRS9FZGdlXG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUuY3Vyc29yID0gXCJub25lXCJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSAmJiAoaGl0SW5mbyA9IHNlbGVjdGVkU2hhcGUuY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpLmhpdCkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkU2hhcGUgaW5zdGFuY2VvZiBYZm9ybVNoYXBlKSB7XG4gICAgICAgICAgICAgIGlmIChoaXRJbmZvLnJvdGF0ZSkge1xuICAgICAgICAgICAgICAgIGxldCBkZWdyZWVzID0gc2hhcGVzW2ldLmdldFJvdGF0aW9uKClcbiAgICAgICAgICAgICAgICBpZiAoZmxpcHkpIHtcbiAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgKj0gLTFcbiAgICAgICAgICAgICAgICAgIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWdyZWVzIC09IENvbnN0YW50cy5SSUdIVF9BTkdMRVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWdyZWVzICs9IENvbnN0YW50cy5TVFJBSUdIVF9BTkdMRVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBkZWdyZWVzICs9IENvbnN0YW50cy5SSUdIVF9BTkdMRVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgLT0gQ29uc3RhbnRzLlJJR0hUX0FOR0xFXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgZGVncmVlcyArPSBDb25zdGFudHMuU1RSQUlHSFRfQU5HTEVcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgZGVncmVlcyArPSBDb25zdGFudHMuUklHSFRfQU5HTEVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwZW5kQ3VzdG9tQ3Vyc29yKGV2ZW50LCB0aGlzLl9wYXJlbnQsIGAke3JvdGF0ZVN2Zy5yZXBsYWNlKC88ZGVncmVlcz4vZywgYCR7ZGVncmVlc31gKX1gKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhpdEluZm8uY29udHJvbEluZGV4IDwgNCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW1hZ2ljLW51bWJlcnNcbiAgICAgICAgICAgICAgICBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDAgfHwgaGl0SW5mby5jb250cm9sSW5kZXggPT09IDMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYCR7c2NhbGVTdmcucmVwbGFjZSgvPGRlZ3JlZXM+L2csIGAkey1zaGFwZXNbaV0uZ2V0Um90YXRpb24oKSAtIENvbnN0YW50cy5GT1JUWV9GSVZFX0FOR0xFfWApfWApXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMSB8fCBoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgYXBwZW5kQ3VzdG9tQ3Vyc29yKGV2ZW50LCB0aGlzLl9wYXJlbnQsIGAke3NjYWxlU3ZnLnJlcGxhY2UoLzxkZWdyZWVzPi9nLCBgJHstc2hhcGVzW2ldLmdldFJvdGF0aW9uKCkgKyBDb25zdGFudHMuRk9SVFlfRklWRV9BTkdMRX1gKX1gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYCR7c2NhbGVTdmcucmVwbGFjZSgvPGRlZ3JlZXM+L2csIGAkey1zaGFwZXNbaV0uZ2V0Um90YXRpb24oKX1gKX1gKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBgJHtzY2FsZVN2Zy5yZXBsYWNlKC88ZGVncmVlcz4vZywgYCR7LXNoYXBlc1tpXS5nZXRSb3RhdGlvbigpICsgQ29uc3RhbnRzLlJJR0hUX0FOR0xFfWApfWApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRTaGFwZSBpbnN0YW5jZW9mIFZlcnRFZGl0YWJsZVNoYXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5zdHlsZS5jdXJzb3IgPSBcIm5vbmVcIlxuICAgICAgICAgICAgICAvLyBmb3JFYWNoIG5vdCBzdXBwb3J0ZWQgb24gbm9kZWxpc3QgaW4gSUUvRWRnZVxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUuY3Vyc29yID0gXCJub25lXCJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJjYW52YXNcIikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA+PSBzaGFwZXNbaV0ubnVtVmVydHMpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYWRkU3ZnLCAtOCwgLTYpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbWFnaWMtbnVtYmVyc1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCByZW1vdmVTdmcsIC04LCAtNikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1tYWdpYy1udW1iZXJzXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ3VzdG9tQ3Vyc29yKGV2ZW50LCB0aGlzLl9wYXJlbnQsIHJlcG9zaXRpb25TdmcsIENvbnN0YW50cy5TVkdfT0ZGU0VULCBDb25zdGFudHMuU1ZHX09GRlNFVClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0uY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RJbmZvICYmIHNlbGVjdEluZm8ubW92YWJsZSkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImN1cnNvclwiKVxuICAgICAgICAgICAgICBpZiAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3Vyc29yKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5zdHlsZS5jdXJzb3IgPSBcIm1vdmVcIlxuICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUuY3Vyc29yID0gXCJtb3ZlXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgcmVtb3ZlQ3VzdG9tQ3Vyc29yKClcbiAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgICAgIC8vIGZvckVhY2ggbm90IHN1cHBvcnRlZCBvbiBub2RlbGlzdCBpbiBJRS9FZGdlXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIlxuICAgICAgICAgIGlmICh0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcImNhbnZhc1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfY2xpY2tDQigpIHtcbiAgICAvLyBub29wXG4gIH1cblxuICBfZGJsY2xpY2tDQihldmVudCkge1xuICAgIGlmICghaW5DYW52YXModGhpcy5fZHJhd0NhbnZhcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCB0aGlzLl9jYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIGxldCBpID0gLTFcbiAgICBmb3IgKGkgPSBzaGFwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgIGlmIChzaGFwZUluZm8uc2VsZWN0YWJsZSAmJiBzaGFwZXNbaV0uY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpIHtcbiAgICAgICAgaWYgKHNoYXBlSW5mby5lZGl0YWJsZSAmJiBzaGFwZXNbaV0gaW5zdGFuY2VvZiBQb2x5TGluZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkU2hhcGUgPSBzaGFwZXNbaV1cbiAgICAgICAgICBsZXQgZG9YZm9ybSA9IGZhbHNlXG4gICAgICAgICAgaWYgKHNoYXBlc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3RpdmVTaGFwZSA9IHRoaXMuX3NlbGVjdGVkU2hhcGVzLmdldChzaGFwZXNbaV0pXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmVTaGFwZSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZFNoYXBlLnJlc3RvcmUoKVxuICAgICAgICAgICAgICBzZWxlY3RlZFNoYXBlLnJlbW92ZUNoaWxkWGZvcm0oaW50ZXJhY3RpdmVTaGFwZSlcbiAgICAgICAgICAgICAgZG9YZm9ybSA9ICEoaW50ZXJhY3RpdmVTaGFwZSBpbnN0YW5jZW9mIFhmb3JtU2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZS5zZWxlY3RlZCA9IHRydWVcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlLnNhdmUoKVxuICAgICAgICAgIGNvbnN0IG1heFogPSBzaGFwZXNbc2hhcGVzLmxlbmd0aCAtIDFdLnpJbmRleFxuICAgICAgICAgIHNlbGVjdGVkU2hhcGUuekluZGV4ID0gbWF4WiArIDFcbiAgICAgICAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHRoaXMuX3NlbGVjdFN0eWxlLCBzZWxlY3RlZFNoYXBlKVxuICAgICAgICAgIGxldCBuZXdTZWxlY3RTaGFwZSA9IG51bGxcbiAgICAgICAgICBpZiAoZG9YZm9ybSkge1xuICAgICAgICAgICAgaWYgKHNoYXBlSW5mby5yb3RhdGFibGUgfHwgc2hhcGVJbmZvLnNjYWxhYmxlKSB7XG4gICAgICAgICAgICAgIG5ld1NlbGVjdFNoYXBlID0gbmV3IFhmb3JtU2hhcGUodGhpcy5feGZvcm1TdHlsZSB8fCBkZWZhdWx0WGZvcm1TdHlsZSwgc2hhcGVJbmZvKVxuICAgICAgICAgICAgICBzZWxlY3RlZFNoYXBlLmFkZENoaWxkWGZvcm0obmV3U2VsZWN0U2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdFNoYXBlID0gbmV3IFZlcnRFZGl0YWJsZVNoYXBlKHNlbGVjdGVkU2hhcGUsIHRoaXMuX3hmb3JtU3R5bGUpXG4gICAgICAgICAgICBzZWxlY3RlZFNoYXBlLmFkZENoaWxkWGZvcm0obmV3U2VsZWN0U2hhcGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNldChzZWxlY3RlZFNoYXBlLCBuZXdTZWxlY3RTaGFwZSlcbiAgICAgICAgfSBlbHNlIGlmICghc2hhcGVzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0RXZlbnRPYmogPSBzZWxlY3RTaGFwZShzaGFwZXNbaV0sIHNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzaGFwZUluZm8pXG4gICAgICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCBzZWxlY3RFdmVudE9iailcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIDwgMCAmJiB0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICBpZiAodGhpcy5fc2VsZWN0ZWRTaGFwZXMuc2l6ZSkge1xuICAgICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuU0VMRUNUSU9OX0NIQU5HRUQsIHtcbiAgICAgICAgICB1bnNlbGVjdGVkU2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKSxcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlczogW11cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYWdJbmZvID0gbnVsbFxuICAgICAgY2xlYXJTZWxlY3RlZFNoYXBlcyh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgX21vdXNlb3ZlckNCKCkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIF9tb3VzZW91dENCKCkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIF9pbml0KHBhcmVudCwgb3B0cykge1xuICAgIHRoaXMuX2FjdGl2YXRlZCA9IChvcHRzICYmIG9wdHMuZW5hYmxlSW50ZXJhY3Rpb25zKVxuICAgIHN1cGVyLl9pbml0KHBhcmVudCwgb3B0cywgdGhpcy5fYWN0aXZhdGVkKVxuICAgIGNvbnN0IG15ZXZlbnRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoRXZlbnRDb25zdGFudHMpLm1hcChldmVudCA9PiBFdmVudENvbnN0YW50c1tldmVudF0pXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50cyhteWV2ZW50cylcbiAgICB0aGlzLl9kcmFnSW5mbyA9IG51bGxcbiAgICB0aGlzLl9zZWxlY3RlZFNoYXBlcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX3NlbGVjdFN0eWxlID0gbmV3IEJhc2ljU3R5bGUoKG9wdHMgJiYgb3B0cy5zZWxlY3RTdHlsZSA/IG9wdHMuc2VsZWN0U3R5bGUgOiB7XG4gICAgICBmaWxsQ29sb3I6IFwib3JhbmdlXCJcbiAgICB9KSlcblxuICAgIHRoaXMuX3hmb3JtU3R5bGUgPSBuZXcgQmFzaWNTdHlsZSgob3B0cyAmJiBvcHRzLnhmb3JtU3R5bGUgPyBvcHRzLnhmb3JtU3R5bGUgOiB7XG4gICAgICBmaWxsQ29sb3I6IFwid2hpdGVcIixcbiAgICAgIHN0cm9rZUNvbG9yOiBcImJsYWNrXCIsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0pKVxuXG4gICAgdGhpcy50aW1lciA9IDBcbiAgfVxuXG4gIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdGhlIG1vdmVtZW50IG9mIFBhcmVudCBDb250YWluZXIgKEluIG91ciBjYXNlIGl0IGlzIE1hcCkgd2hlbiB1c2VyIGNsaWNrcyBhbnl3aGVyZSBvbiBNYXAgZXhjZXB0IG9uIFNoYXBlXG4gIC8vIEFzIHdlbGwgYXMgaXQncyBjaGFuZ2VzIHRoZSBpY29uIG9mIG1vdXNlIGZvciBEZXNrdG9wIGRldmljZXNcbiAgX21ha2VQYXJlbnRFbGVtZW50TW92YWJsZSgpIHtcbiAgICByZW1vdmVDdXN0b21DdXJzb3IoKVxuICAgIHRoaXMuX3BhcmVudC5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIiAvLyBDaGFuZ2UgdGhlIEN1cnNvciBpY29uIGZvciBkZXNrdG9wIGRldmljZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiIC8vIENoYW5nZSB0aGUgQ3Vyc29yIGljb24gZm9yIGRlc2t0b3AgZGV2aWNlXG4gICAgICBpZiAodGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJjYW52YXNcIikge1xuICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCIgLy8gQWxsb3cgbW92ZW1uZXQgb2YgcGFyZW50IGNvbnRhaW5lciBpLmUgTWFwXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3JlbmRlclNoYXBlcyhjdHgsIGRyYXdTaGFwZXMsIGNhbWVyYSkge1xuICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXQgPSBjYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgIGRyYXdTaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICBpZiAoc2hhcGUudmlzaWJsZSkge1xuICAgICAgICBzaGFwZS5yZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCB0aGlzLl9zdHlsZVN0YXRlKVxuICAgICAgICAvLyBzaGFwZS5yZW5kZXJCb3VuZHMoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCBib3VuZHNTdHJva2VTdHlsZSlcbiAgICAgICAgaWYgKHNoYXBlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgY29uc3QgaW50ZXJhY1NoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlKVxuICAgICAgICAgIGlmIChpbnRlcmFjU2hhcGUpIHtcbiAgICAgICAgICAgIGludGVyYWNTaGFwZS5yZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCB0aGlzLl9zdHlsZVN0YXRlKVxuICAgICAgICAgICAgLy8gaW50ZXJhY1NoYXBlLnJlbmRlckJvdW5kcyhjdHgsIHdvcmxkVG9TY3JlZW5NYXQsIGJvdW5kc1N0cm9rZVN0eWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBzZXQgc2VsZWN0U3R5bGUoc2VsZWN0U3R5bGUpIHtcbiAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHNlbGVjdFN0eWxlLCB0aGlzLl9zZWxlY3RTdHlsZSlcbiAgfVxuXG4gIGdldCBzZWxlY3RTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0U3R5bGVcbiAgfVxuXG4gIGdldCBzZWxlY3RlZFNoYXBlcygpIHtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgfVxuXG4gIHNlbGVjdFNoYXBlKHNoYXBlKSB7XG4gICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGUpXG4gICAgaWYgKHNoYXBlSW5mbyAmJiBzaGFwZUluZm8uc2VsZWN0YWJsZSkge1xuICAgICAgY29uc3Qgc2VsZWN0RXZlbnRPYmogPSBzZWxlY3RTaGFwZShzaGFwZSwgdGhpcy5zb3J0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RTdHlsZSwgdGhpcy5feGZvcm1TdHlsZSwgc2hhcGVJbmZvKVxuICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCBzZWxlY3RFdmVudE9iailcbiAgICB9XG4gIH1cblxuICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0ZWRTaGFwZXMuc2l6ZSkge1xuICAgICAgY29uc3Qgc2VsZWN0ZWRTaGFwZXMgPSBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgY2xlYXJTZWxlY3RlZFNoYXBlcyh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgICB1bnNlbGVjdGVkU2hhcGVzOiBzZWxlY3RlZFNoYXBlcyxcbiAgICAgICAgc2VsZWN0ZWRTaGFwZXM6IFtdXG4gICAgICB9KVxuICAgICAgdGhpcy5fcmVyZW5kZXJDYigpXG4gICAgfVxuICB9XG5cbiAgYWRkU2hhcGUoc2hhcGUsIG9wdHMgPSBudWxsLCBzZWxlY3QgPSBmYWxzZSkge1xuICAgIGxldCBzaGFwZXMgPSBzaGFwZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgICBzaGFwZXMgPSBbc2hhcGVdXG4gICAgfVxuXG4gICAgc3VwZXIuYWRkU2hhcGUoc2hhcGVzKVxuICAgIHNoYXBlcy5mb3JFYWNoKG5ld1NoYXBlID0+IHtcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KG5ld1NoYXBlKVxuICAgICAgaWYgKHNoYXBlSW5mbykge1xuICAgICAgICBzaGFwZUluZm8uc2VsZWN0YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLnNlbGVjdGFibGUgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMuc2VsZWN0YWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8ubW92YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLm1vdmFibGUgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMubW92YWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8ucm90YXRhYmxlID0gKG9wdHMgJiYgdHlwZW9mIG9wdHMucm90YXRhYmxlICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLnJvdGF0YWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8uc2NhbGFibGUgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy5zY2FsYWJsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IEJvb2xlYW4ob3B0cy5zY2FsYWJsZSkgOiB0cnVlKVxuICAgICAgICBzaGFwZUluZm8udW5pZm9ybVNjYWxlT25seSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLnVuaWZvcm1TY2FsZU9ubHkgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMudW5pZm9ybVNjYWxlT25seSkgOiBmYWxzZSlcbiAgICAgICAgc2hhcGVJbmZvLmNlbnRlclNjYWxlT25seSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLmNlbnRlclNjYWxlT25seSAhPT0gXCJ1bmRlZmluZWRcIiA/IEJvb2xlYW4ob3B0cy5jZW50ZXJTY2FsZU9ubHkpIDogZmFsc2UpXG4gICAgICAgIHNoYXBlSW5mby5lZGl0YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLmVkaXRhYmxlICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLmVkaXRhYmxlKSA6IHRydWUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGlmIChzZWxlY3QpIHtcbiAgICAgIGNvbnN0IHNlbGVjdEV2ZW50T2JqID0ge1xuICAgICAgICB1bnNlbGVjdGVkU2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRTaGFwZXMgPSBbXVxuICAgICAgc2hhcGVzLmZvckVhY2gobmV3U2hhcGUgPT4ge1xuICAgICAgICBjb25zdCBzaGFwZUluZm8gPSB0aGlzLl9vYmplY3RzLmdldChuZXdTaGFwZSlcbiAgICAgICAgaWYgKHNoYXBlSW5mby5zZWxlY3RhYmxlKSB7XG4gICAgICAgICAgc2VsZWN0U2hhcGUobmV3U2hhcGUsIHRoaXMuc29ydGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RlZFNoYXBlcywgdGhpcy5fc2VsZWN0U3R5bGUsIHRoaXMuX3hmb3JtU3R5bGUsIHNoYXBlSW5mbylcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlcy5wdXNoKG5ld1NoYXBlKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiAoc2VsZWN0ZWRTaGFwZXMubGVuZ3RoKSB7XG4gICAgICAgIHNlbGVjdEV2ZW50T2JqLnNlbGVjdGVkU2hhcGVzID0gc2VsZWN0ZWRTaGFwZXNcbiAgICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCBzZWxlY3RFdmVudE9iailcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cblxuICBkZWxldGVTaGFwZShzaGFwZSkge1xuICAgIGxldCBzaGFwZXMgPSBzaGFwZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgICBzaGFwZXMgPSBbc2hhcGVdXG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdENsZWFyZWRTaGFwZXMgPSBjbGVhclNwZWNpZmljU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzLCBzaGFwZXMpXG4gICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCB7XG4gICAgICB1bnNlbGVjdGVkU2hhcGVzOiBzZWxlY3RDbGVhcmVkU2hhcGVzLFxuICAgICAgc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpXG4gICAgfSlcblxuICAgIHJlbW92ZUN1c3RvbUN1cnNvcigpXG4gICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgLy8gZm9yRWFjaCBub3Qgc3VwcG9ydGVkIG9uIG5vZGVsaXN0IGluIElFL0VkZ2VcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIlxuICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbal0uc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZVNoYXBlKHNoYXBlcylcbiAgfVxuXG4gIGRlbGV0ZVNlbGVjdGVkU2hhcGVzKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkU2hhcGVzID0gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgdW5zZWxlY3RlZFNoYXBlczogc2VsZWN0ZWRTaGFwZXMsXG4gICAgICBzZWxlY3RlZFNoYXBlczogW11cbiAgICB9KVxuXG4gICAgcmVtb3ZlQ3VzdG9tQ3Vyc29yKClcbiAgICB0aGlzLl9wYXJlbnQuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCJcbiAgICAvLyBmb3JFYWNoIG5vdCBzdXBwb3J0ZWQgb24gbm9kZWxpc3QgaW4gSUUvRWRnZVxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2pdLnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tqXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCJcbiAgICB9XG5cbiAgICByZXR1cm4gc3VwZXIuZGVsZXRlU2hhcGUoc2VsZWN0ZWRTaGFwZXMpXG4gIH1cblxuICBnZXQgaW50ZXJhY3Rpb25zRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZhdGVkXG4gIH1cblxuICBlbmFibGVJbnRlcmFjdGlvbnMoKSB7XG4gICAgdGhpcy5fZW5hYmxlRXZlbnRzKClcbiAgICB0aGlzLl9hY3RpdmF0ZWQgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGRpc2FibGVJbnRlcmFjdGlvbnMoY2xlYXJTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgaWYgKGNsZWFyU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKClcbiAgICB9XG4gICAgdGhpcy5fZGlzYWJsZUV2ZW50cygpXG4gICAgdGhpcy5fYWN0aXZhdGVkID0gZmFsc2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzdG9wIE1vdXNlIEV2ZW50IHByb3BhZ2F0aW9uIFRyaWdnZXJlZCBmcm9tIHRoZSBUb3VjaCBldmVudFxuICBzZXREZW55TW91c2VFdmVudEZsYWcoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudG91Y2hlcykge1xuICAgICAgdGhpcy5kZW55TW91c2VFdmVudCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IEV2ZW50c1R5cGVzLk1PVVNFVVApIHtcbiAgICAgIC8vIHNldCB0aGUgRmxhZyBmYWxzZSBhdCB0aGUgZW5kIG9mIG1vdXNlIGV2ZW50IGkuZSBvbiBNb3VzZVVwIEV2ZW50XG4gICAgICB0aGlzLmRlbnlNb3VzZUV2ZW50ID0gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihFdmVudENvbnN0YW50cywgRHJhd0VuZ2luZS5FdmVudENvbnN0YW50cylcblNoYXBlQnVpbGRlci5FdmVudENvbnN0YW50cyA9IEV2ZW50Q29uc3RhbnRzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvc2hhcGUtYnVpbGRlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformXformShape = transformXformShape;\nexports.translateShape = translateShape;\nexports.translateVert = translateVert;\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _mat2d = __webpack_require__(4);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _vec2d = __webpack_require__(9);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction rotateOBBox(shape, parentShape, selectedInfo, screenPos, worldPos) {\n  var pt = [0, 0];\n  var scale = [0, 0];\n  _mat2d2.default.svd(pt, scale, null, selectedInfo.objectToWorldMatrix);\n  var startDir = [0, 0];\n  Point2d.sub(startDir, selectedInfo.startWorldPos, pt);\n  _vec2d2.default.normalize(startDir, startDir);\n  var dir = pt;\n  Point2d.sub(dir, worldPos, pt);\n  _vec2d2.default.normalize(dir, dir);\n  var angle = _vec2d2.default.angle(startDir, dir);\n\n  if (selectedInfo.keys.shiftKey) {\n    angle = Math.round(angle / Math.QUATER_PI) * Math.QUATER_PI;\n  }\n\n  // if (!camera.isYFlipped()) {\n  //   angle *= -1\n  // }\n\n  parentShape.setRotation(selectedInfo.startLocalRot + Math.RAD_TO_DEG * angle);\n}\n\nfunction transformXformShape(shape, selectedInfo, screenPos, worldPos, camera) {\n  var parentShape = shape.parent;\n  var objPos = [0, 0];\n  var deltaPos = [0, 0];\n  var deltaDims = [0, 0];\n\n  if (selectedInfo.rotate) {\n    rotateOBBox(shape, parentShape, selectedInfo, screenPos, worldPos, camera);\n    return;\n  }\n\n  var uniformScale = selectedInfo.keys.shiftKey || selectedInfo.uniformScaleOnly;\n  var centerScale = selectedInfo.keys.altKey || selectedInfo.centerScaleOnly;\n\n  // get the position of the shape at start of transform\n  var pt = [0, 0];\n  _mat2d2.default.svd(pt, null, null, selectedInfo.objectToWorldMatrix);\n\n  // get the mouse delta in world space\n  _vec2d2.default.sub(deltaPos, worldPos, selectedInfo.startWorldPos);\n\n  if (uniformScale && selectedInfo.controlIndex < 4) {\n    var xAxisDir = [selectedInfo.objectToWorldMatrix[0], selectedInfo.objectToWorldMatrix[1]];\n    var yAxisDir = [selectedInfo.objectToWorldMatrix[2], selectedInfo.objectToWorldMatrix[3]];\n    var diagDir = [0, 0];\n\n    if (selectedInfo.controlIndex < 2) {\n      _vec2d2.default.negate(xAxisDir, xAxisDir);\n    }\n    if (selectedInfo.controlIndex % 2 === 0) {\n      _vec2d2.default.negate(yAxisDir, yAxisDir);\n    }\n\n    _vec2d2.default.normalize(xAxisDir, xAxisDir);\n    _vec2d2.default.normalize(yAxisDir, yAxisDir);\n\n    _vec2d2.default.add(diagDir, xAxisDir, yAxisDir);\n    _vec2d2.default.normalize(diagDir, diagDir);\n\n    var cross = _vec2d2.default.cross2d(deltaPos, diagDir);\n    var axisToUse = null;\n    if (selectedInfo.controlIndex === 0 || selectedInfo.controlIndex === 3) {\n      axisToUse = yAxisDir;\n      if (cross < 0) {\n        axisToUse = xAxisDir;\n      }\n    } else {\n      axisToUse = xAxisDir;\n      if (cross < 0) {\n        axisToUse = yAxisDir;\n      }\n    }\n    var mindist = _vec2d2.default.dot(deltaPos, axisToUse);\n    mindist = Math.sign(mindist) * Math.sqrt(2 * mindist * mindist);\n    _vec2d2.default.scale(deltaPos, diagDir, mindist);\n    Point2d.addVec2(worldPos, selectedInfo.startWorldPos, deltaPos);\n  }\n\n  // first convert world point to object space\n  Point2d.copy(objPos, worldPos);\n  Point2d.transformMat2d(objPos, objPos, selectedInfo.worldToObjectMatrix);\n\n  // get the mouse delta in object space and multipy by the\n  // scale of the selected object at the start of the transform\n  // to get the scale delta in object space\n  _vec2d2.default.sub(deltaDims, objPos, selectedInfo.startObjectPos);\n\n  Point2d.copy(pt, selectedInfo.startLocalPos);\n\n  // now determine the transform direction depending\n  // on which control vertex of the object-oriented bounds\n  // was selected\n  var xScale = 0;\n  var yScale = 0;\n  if (selectedInfo.controlIndex < 4) {\n    // dragging a corner vertex\n    xScale = selectedInfo.controlIndex < 2 ? -1 : 1;\n    yScale = selectedInfo.controlIndex % 2 === 0 ? -1 : 1;\n\n    // can translate based on the mouse delta in world space\n    // This is done to offset the scale, which is done at\n    // the shape's center. This ultimately acts as a pivot\n    // for the transformation. Only do this if the alt key\n    // isn't pressed\n    if (!centerScale) {\n      Point2d.addVec2(pt, pt, _vec2d2.default.scale(deltaPos, deltaPos, 0.5));\n    }\n\n    parentShape.setPosition(pt);\n  } else {\n    // dragging a side vertex, which means we only scale in\n    // one dimension, rather than 2. So we need to figure\n    // out that direction based on the orientation of the\n    // shape\n    var idx = selectedInfo.controlIndex - 4;\n    var axisDir = [0, 0];\n    if (idx % 2 === 0) {\n      // scaling in the object's X direction\n      _vec2d2.default.set(axisDir, selectedInfo.objectToWorldMatrix[0], selectedInfo.objectToWorldMatrix[1]);\n      yScale = 0;\n      xScale = idx < 2 ? -1 : 1;\n      if (uniformScale) {\n        yScale = xScale;\n        deltaDims[1] = deltaDims[0];\n      }\n    } else {\n      // scaling in the object's Y direction\n      _vec2d2.default.set(axisDir, selectedInfo.objectToWorldMatrix[2], selectedInfo.objectToWorldMatrix[3]);\n      xScale = 0;\n      yScale = idx < 2 ? -1 : 1;\n      if (uniformScale) {\n        xScale = yScale;\n        deltaDims[0] = deltaDims[1];\n      }\n    }\n\n    // now find the pivot offset for the axis-aligned scale\n    if (!centerScale) {\n      _vec2d2.default.normalize(axisDir, axisDir);\n      _vec2d2.default.scale(axisDir, axisDir, _vec2d2.default.dot(deltaPos, axisDir));\n      Point2d.addVec2(pt, pt, _vec2d2.default.scale(axisDir, axisDir, 0.5));\n    }\n\n    parentShape.setPosition(pt);\n  }\n\n  if (centerScale) {\n    xScale *= 2;\n    yScale *= 2;\n  }\n\n  // perform the scale\n  parentShape.setScale([selectedInfo.startLocalScale[0] * (1 + xScale * deltaDims[0] / selectedInfo.shapeWidth), selectedInfo.startLocalScale[1] * (1 + yScale * deltaDims[1] / selectedInfo.shapeHeight)]);\n}\n\nfunction translateShape(shape, selectedInfo, screenPos, worldPos, camera) {\n  var diff = [0, 0];\n  var pt = [0, 0];\n  _mat2d2.default.svd(pt, null, null, selectedInfo.objectToWorldMatrix);\n  if (selectedInfo.keys.shiftKey) {\n    Point2d.sub(diff, screenPos, selectedInfo.startPos);\n    var angle = Math.atan2(diff[1], diff[0]);\n    angle = Math.round(angle / Math.QUATER_PI) * Math.QUATER_PI;\n    var transformDir = [Math.cos(angle), Math.sin(angle)];\n    _vec2d2.default.scale(diff, transformDir, _vec2d2.default.dot(diff, transformDir));\n    _vec2d2.default.transformMat2(diff, diff, camera.screenToWorldMatrix);\n  } else {\n    _vec2d2.default.sub(diff, worldPos, selectedInfo.startWorldPos);\n  }\n  Point2d.addVec2(pt, selectedInfo.startLocalPos, diff);\n\n  shape.setPosition(pt);\n}\n\nfunction translateVert(shape, selectedInfo, screenPos, worldPos) {\n  var parentShape = shape.parent;\n\n  // get the position of the shape at start of transform\n  // const pt = [0, 0]\n  // Mat2d.svd(pt, null, null, selectedInfo.objectToWorldMatrix)\n\n  // get the mouse delta in world space\n  // Vec2d.sub(deltaPos, worldPos, selectedInfo.startWorldPos)\n\n  // first convert world point to object space\n  // Point2d.copy(objPos, worldPos)\n  // Point2d.transformMat2d(objPos, objPos, selectedInfo.worldToObjectMatrix)\n\n  // get the diff\n  // const diff = objPos\n  // Point2d.sub(diff, objPos, selectedInfo.startObjectPos)\n\n  var numVerts = parentShape.numVerts;\n  if (selectedInfo.controlIndex >= numVerts) {\n    var idx1 = Math.min(selectedInfo.controlIndex - numVerts, numVerts - 1);\n    var idx2 = idx1 === numVerts - 1 ? 0 : idx1 + 1;\n    var pt = [0, 0];\n    var pt1 = [0, 0];\n    var pt2 = [0, 0];\n    var vec = [0, 0];\n    var verts = parentShape.vertsRef;\n    var xform = parentShape.globalXform;\n    Point2d.transformMat2d(pt1, verts[idx1], xform);\n    Point2d.transformMat2d(pt2, verts[idx2], xform);\n    Point2d.sub(vec, pt2, pt1);\n    _vec2d2.default.scale(vec, vec, 0.5);\n    Point2d.addVec2(pt, pt1, vec);\n    selectedInfo.controlIndex = parentShape.insertVert(idx1 + 1, pt);\n  } else {\n    parentShape.setVertPosition(selectedInfo.controlIndex, worldPos);\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3QtdXRpbHMuanM/NzE0YiJdLCJuYW1lcyI6WyJ0cmFuc2Zvcm1YZm9ybVNoYXBlIiwidHJhbnNsYXRlU2hhcGUiLCJ0cmFuc2xhdGVWZXJ0IiwiUG9pbnQyZCIsInJvdGF0ZU9CQm94Iiwic2hhcGUiLCJwYXJlbnRTaGFwZSIsInNlbGVjdGVkSW5mbyIsInNjcmVlblBvcyIsIndvcmxkUG9zIiwicHQiLCJzY2FsZSIsIk1hdDJkIiwic3ZkIiwib2JqZWN0VG9Xb3JsZE1hdHJpeCIsInN0YXJ0RGlyIiwic3ViIiwic3RhcnRXb3JsZFBvcyIsIlZlYzJkIiwibm9ybWFsaXplIiwiZGlyIiwiYW5nbGUiLCJrZXlzIiwic2hpZnRLZXkiLCJNYXRoIiwicm91bmQiLCJRVUFURVJfUEkiLCJzZXRSb3RhdGlvbiIsInN0YXJ0TG9jYWxSb3QiLCJSQURfVE9fREVHIiwiY2FtZXJhIiwicGFyZW50Iiwib2JqUG9zIiwiZGVsdGFQb3MiLCJkZWx0YURpbXMiLCJyb3RhdGUiLCJ1bmlmb3JtU2NhbGUiLCJ1bmlmb3JtU2NhbGVPbmx5IiwiY2VudGVyU2NhbGUiLCJhbHRLZXkiLCJjZW50ZXJTY2FsZU9ubHkiLCJjb250cm9sSW5kZXgiLCJ4QXhpc0RpciIsInlBeGlzRGlyIiwiZGlhZ0RpciIsIm5lZ2F0ZSIsImFkZCIsImNyb3NzIiwiY3Jvc3MyZCIsImF4aXNUb1VzZSIsIm1pbmRpc3QiLCJkb3QiLCJzaWduIiwic3FydCIsImFkZFZlYzIiLCJjb3B5IiwidHJhbnNmb3JtTWF0MmQiLCJ3b3JsZFRvT2JqZWN0TWF0cml4Iiwic3RhcnRPYmplY3RQb3MiLCJzdGFydExvY2FsUG9zIiwieFNjYWxlIiwieVNjYWxlIiwic2V0UG9zaXRpb24iLCJpZHgiLCJheGlzRGlyIiwic2V0Iiwic2V0U2NhbGUiLCJzdGFydExvY2FsU2NhbGUiLCJzaGFwZVdpZHRoIiwic2hhcGVIZWlnaHQiLCJkaWZmIiwic3RhcnRQb3MiLCJhdGFuMiIsInRyYW5zZm9ybURpciIsImNvcyIsInNpbiIsInRyYW5zZm9ybU1hdDIiLCJzY3JlZW5Ub1dvcmxkTWF0cml4IiwibnVtVmVydHMiLCJpZHgxIiwibWluIiwiaWR4MiIsInB0MSIsInB0MiIsInZlYyIsInZlcnRzIiwidmVydHNSZWYiLCJ4Zm9ybSIsImdsb2JhbFhmb3JtIiwiaW5zZXJ0VmVydCIsInNldFZlcnRQb3NpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7UUE2QmdCQSxtQixHQUFBQSxtQjtRQXVJQUMsYyxHQUFBQSxjO1FBbUJBQyxhLEdBQUFBLGE7O0FBckxoQjs7SUFBWUMsTzs7QUFDWjs7OztBQUNBOzs7Ozs7OztBQUVBLFNBQVNDLFdBQVQsQ0FBcUJDLEtBQXJCLEVBQTRCQyxXQUE1QixFQUF5Q0MsWUFBekMsRUFBdURDLFNBQXZELEVBQWtFQyxRQUFsRSxFQUE0RTtBQUMxRSxNQUFNQyxLQUFLLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWDtBQUNBLE1BQU1DLFFBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFkO0FBQ0FDLGtCQUFNQyxHQUFOLENBQVVILEVBQVYsRUFBY0MsS0FBZCxFQUFxQixJQUFyQixFQUEyQkosYUFBYU8sbUJBQXhDO0FBQ0EsTUFBTUMsV0FBVyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWpCO0FBQ0FaLFVBQVFhLEdBQVIsQ0FBWUQsUUFBWixFQUFzQlIsYUFBYVUsYUFBbkMsRUFBa0RQLEVBQWxEO0FBQ0FRLGtCQUFNQyxTQUFOLENBQWdCSixRQUFoQixFQUEwQkEsUUFBMUI7QUFDQSxNQUFNSyxNQUFNVixFQUFaO0FBQ0FQLFVBQVFhLEdBQVIsQ0FBWUksR0FBWixFQUFpQlgsUUFBakIsRUFBMkJDLEVBQTNCO0FBQ0FRLGtCQUFNQyxTQUFOLENBQWdCQyxHQUFoQixFQUFxQkEsR0FBckI7QUFDQSxNQUFJQyxRQUFRSCxnQkFBTUcsS0FBTixDQUFZTixRQUFaLEVBQXNCSyxHQUF0QixDQUFaOztBQUVBLE1BQUliLGFBQWFlLElB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Q0FBU3pFLGFBQWFrQyxZQUFiLEdBQTRCcUMsUUFBckMsRUFBK0NBLFdBQVcsQ0FBMUQsQ0FBYjtBQUNBLFFBQU1HLE9BQVFGLFNBQVNELFdBQVcsQ0FBcEIsR0FBd0IsQ0FBeEIsR0FBNEJDLE9BQU8sQ0FBakQ7QUFDQSxRQUFNckUsS0FBSyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVg7QUFDQSxRQUFNd0UsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQSxRQUFNQyxNQUFNLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBLFFBQU1DLE1BQU0sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0EsUUFBTUMsUUFBUS9FLFlBQVlnRixRQUExQjtBQUNBLFFBQU1DLFFBQVFqRixZQUFZa0YsV0FBMUI7QUFDQXJGLFlBQVFxRCxjQUFSLENBQXVCMEIsR0FBdkIsRUFBNEJHLE1BQU1OLElBQU4sQ0FBNUIsRUFBeUNRLEtBQXpDO0FBQ0FwRixZQUFRcUQsY0FBUixDQUF1QjJCLEdBQXZCLEVBQTRCRSxNQUFNSixJQUFOLENBQTVCLEVBQXlDTSxLQUF6QztBQUNBcEYsWUFBUWEsR0FBUixDQUFZb0UsR0FBWixFQUFpQkQsR0FBakIsRUFBc0JELEdBQXRCO0FBQ0FoRSxvQkFBTVAsS0FBTixDQUFZeUUsR0FBWixFQUFpQkEsR0FBakIsRUFBc0IsR0FBdEI7QUFDQWpGLFlBQVFtRCxPQUFSLENBQWdCNUMsRUFBaEIsRUFBb0J3RSxHQUFwQixFQUF5QkUsR0FBekI7QUFDQTdFLGlCQUFha0MsWUFBYixHQUE0Qm5DLFlBQVltRixVQUFaLENBQXVCVixPQUFPLENBQTlCLEVBQWlDckUsRUFBakMsQ0FBNUI7QUFDRCxHQWZELE1BZU87QUFDTEosZ0JBQVlvRixlQUFaLENBQTRCbkYsYUFBYWtDLFlBQXpDLEVBQXVEaEMsUUFBdkQ7QUFDRDtBQUNGIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tbWFnaWMtbnVtYmVycyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgUG9pbnQyZCBmcm9tIFwiLi4vY29yZS9wb2ludDJkXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgVmVjMmQgZnJvbSBcIi4uL2NvcmUvdmVjMmRcIlxuXG5mdW5jdGlvbiByb3RhdGVPQkJveChzaGFwZSwgcGFyZW50U2hhcGUsIHNlbGVjdGVkSW5mbywgc2NyZWVuUG9zLCB3b3JsZFBvcykge1xuICBjb25zdCBwdCA9IFswLCAwXVxuICBjb25zdCBzY2FsZSA9IFswLCAwXVxuICBNYXQyZC5zdmQocHQsIHNjYWxlLCBudWxsLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeClcbiAgY29uc3Qgc3RhcnREaXIgPSBbMCwgMF1cbiAgUG9pbnQyZC5zdWIoc3RhcnREaXIsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zLCBwdClcbiAgVmVjMmQubm9ybWFsaXplKHN0YXJ0RGlyLCBzdGFydERpcilcbiAgY29uc3QgZGlyID0gcHRcbiAgUG9pbnQyZC5zdWIoZGlyLCB3b3JsZFBvcywgcHQpXG4gIFZlYzJkLm5vcm1hbGl6ZShkaXIsIGRpcilcbiAgbGV0IGFuZ2xlID0gVmVjMmQuYW5nbGUoc3RhcnREaXIsIGRpcilcblxuICBpZiAoc2VsZWN0ZWRJbmZvLmtleXMuc2hpZnRLZXkpIHtcbiAgICBhbmdsZSA9IE1hdGgucm91bmQoYW5nbGUgLyBNYXRoLlFVQVRFUl9QSSkgKiBNYXRoLlFVQVRFUl9QSVxuICB9XG5cbiAgLy8gaWYgKCFjYW1lcmEuaXNZRmxpcHBlZCgpKSB7XG4gIC8vICAgYW5nbGUgKj0gLTFcbiAgLy8gfVxuXG4gIHBhcmVudFNoYXBlLnNldFJvdGF0aW9uKHNlbGVjdGVkSW5mby5zdGFydExvY2FsUm90ICsgTWF0aC5SQURfVE9fREVHICogYW5nbGUpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1YZm9ybVNoYXBlKHNoYXBlLCBzZWxlY3RlZEluZm8sIHNjcmVlblBvcywgd29ybGRQb3MsIGNhbWVyYSkge1xuICBjb25zdCBwYXJlbnRTaGFwZSA9IHNoYXBlLnBhcmVudFxuICBjb25zdCBvYmpQb3MgPSBbMCwgMF1cbiAgY29uc3QgZGVsdGFQb3MgPSBbMCwgMF1cbiAgY29uc3QgZGVsdGFEaW1zID0gWzAsIDBdXG5cbiAgaWYgKHNlbGVjdGVkSW5mby5yb3RhdGUpIHtcbiAgICByb3RhdGVPQkJveChzaGFwZSwgcGFyZW50U2hhcGUsIHNlbGVjdGVkSW5mbywgc2NyZWVuUG9zLCB3b3JsZFBvcywgY2FtZXJhKVxuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgdW5pZm9ybVNjYWxlID0gKHNlbGVjdGVkSW5mby5rZXlzLnNoaWZ0S2V5IHx8IHNlbGVjdGVkSW5mby51bmlmb3JtU2NhbGVPbmx5KVxuICBjb25zdCBjZW50ZXJTY2FsZSA9IChzZWxlY3RlZEluZm8ua2V5cy5hbHRLZXkgfHwgc2VsZWN0ZWRJbmZvLmNlbnRlclNjYWxlT25seSlcblxuICAvLyBnZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzaGFwZSBhdCBzdGFydCBvZiB0cmFuc2Zvcm1cbiAgY29uc3QgcHQgPSBbMCwgMF1cbiAgTWF0MmQuc3ZkKHB0LCBudWxsLCBudWxsLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeClcblxuICAvLyBnZXQgdGhlIG1vdXNlIGRlbHRhIGluIHdvcmxkIHNwYWNlXG4gIFZlYzJkLnN1YihkZWx0YVBvcywgd29ybGRQb3MsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zKVxuXG4gIGlmICh1bmlmb3JtU2NhbGUgJiYgc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDQpIHtcbiAgICBjb25zdCB4QXhpc0RpciA9IFtzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeFswXSwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMV1dXG4gICAgY29uc3QgeUF4aXNEaXIgPSBbc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMl0sIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzNdXVxuICAgIGNvbnN0IGRpYWdEaXIgPSBbMCwgMF1cblxuICAgIGlmIChzZWxlY3RlZEluZm8uY29udHJvbEluZGV4IDwgMikge1xuICAgICAgVmVjMmQubmVnYXRlKHhBeGlzRGlyLCB4QXhpc0RpcilcbiAgICB9XG4gICAgaWYgKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggJSAyID09PSAwKSB7XG4gICAgICBWZWMyZC5uZWdhdGUoeUF4aXNEaXIsIHlBeGlzRGlyKVxuICAgIH1cblxuICAgIFZlYzJkLm5vcm1hbGl6ZSh4QXhpc0RpciwgeEF4aXNEaXIpXG4gICAgVmVjMmQubm9ybWFsaXplKHlBeGlzRGlyLCB5QXhpc0RpcilcblxuICAgIFZlYzJkLmFkZChkaWFnRGlyLCB4QXhpc0RpciwgeUF4aXNEaXIpXG4gICAgVmVjMmQubm9ybWFsaXplKGRpYWdEaXIsIGRpYWdEaXIpXG5cbiAgICBjb25zdCBjcm9zcyA9IFZlYzJkLmNyb3NzMmQoZGVsdGFQb3MsIGRpYWdEaXIpXG4gICAgbGV0IGF4aXNUb1VzZSA9IG51bGxcbiAgICBpZiAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMCB8fCBzZWxlY3RlZEluZm8uY29udHJvbEluZGV4ID09PSAzKSB7XG4gICAgICBheGlzVG9Vc2UgPSB5QXhpc0RpclxuICAgICAgaWYgKGNyb3NzIDwgMCkge1xuICAgICAgICBheGlzVG9Vc2UgPSB4QXhpc0RpclxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBheGlzVG9Vc2UgPSB4QXhpc0RpclxuICAgICAgaWYgKGNyb3NzIDwgMCkge1xuICAgICAgICBheGlzVG9Vc2UgPSB5QXhpc0RpclxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbWluZGlzdCA9IFZlYzJkLmRvdChkZWx0YVBvcywgYXhpc1RvVXNlKVxuICAgIG1pbmRpc3QgPSBNYXRoLnNpZ24obWluZGlzdCkgKiBNYXRoLnNxcnQoMiAqIG1pbmRpc3QgKiBtaW5kaXN0KVxuICAgIFZlYzJkLnNjYWxlKGRlbHRhUG9zLCBkaWFnRGlyLCBtaW5kaXN0KVxuICAgIFBvaW50MmQuYWRkVmVjMih3b3JsZFBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0V29ybGRQb3MsIGRlbHRhUG9zKVxuICB9XG5cbiAgLy8gZmlyc3QgY29udmVydCB3b3JsZCBwb2ludCB0byBvYmplY3Qgc3BhY2VcbiAgUG9pbnQyZC5jb3B5KG9ialBvcywgd29ybGRQb3MpXG4gIFBvaW50MmQudHJhbnNmb3JtTWF0MmQob2JqUG9zLCBvYmpQb3MsIHNlbGVjdGVkSW5mby53b3JsZFRvT2JqZWN0TWF0cml4KVxuXG4gIC8vIGdldCB0aGUgbW91c2UgZGVsdGEgaW4gb2JqZWN0IHNwYWNlIGFuZCBtdWx0aXB5IGJ5IHRoZVxuICAvLyBzY2FsZSBvZiB0aGUgc2VsZWN0ZWQgb2JqZWN0IGF0IHRoZSBzdGFydCBvZiB0aGUgdHJhbnNmb3JtXG4gIC8vIHRvIGdldCB0aGUgc2NhbGUgZGVsdGEgaW4gb2JqZWN0IHNwYWNlXG4gIFZlYzJkLnN1YihkZWx0YURpbXMsIG9ialBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0T2JqZWN0UG9zKVxuXG4gIFBvaW50MmQuY29weShwdCwgc2VsZWN0ZWRJbmZvLnN0YXJ0TG9jYWxQb3MpXG5cbiAgLy8gbm93IGRldGVybWluZSB0aGUgdHJhbnNmb3JtIGRpcmVjdGlvbiBkZXBlbmRpbmdcbiAgLy8gb24gd2hpY2ggY29udHJvbCB2ZXJ0ZXggb2YgdGhlIG9iamVjdC1vcmllbnRlZCBib3VuZHNcbiAgLy8gd2FzIHNlbGVjdGVkXG4gIGxldCB4U2NhbGUgPSAwXG4gIGxldCB5U2NhbGUgPSAwXG4gIGlmIChzZWxlY3RlZEluZm8uY29udHJvbEluZGV4IDwgNCkge1xuICAgIC8vIGRyYWdnaW5nIGEgY29ybmVyIHZlcnRleFxuICAgIHhTY2FsZSA9IChzZWxlY3RlZEluZm8uY29udHJvbEluZGV4IDwgMiA/IC0xIDogMSlcbiAgICB5U2NhbGUgPSAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCAlIDIgPT09IDAgPyAtMSA6IDEpXG5cbiAgICAvLyBjYW4gdHJhbnNsYXRlIGJhc2VkIG9uIHRoZSBtb3VzZSBkZWx0YSBpbiB3b3JsZCBzcGFjZVxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byBvZmZzZXQgdGhlIHNjYWxlLCB3aGljaCBpcyBkb25lIGF0XG4gICAgLy8gdGhlIHNoYXBlJ3MgY2VudGVyLiBUaGlzIHVsdGltYXRlbHkgYWN0cyBhcyBhIHBpdm90XG4gICAgLy8gZm9yIHRoZSB0cmFuc2Zvcm1hdGlvbi4gT25seSBkbyB0aGlzIGlmIHRoZSBhbHQga2V5XG4gICAgLy8gaXNuJ3QgcHJlc3NlZFxuICAgIGlmICghY2VudGVyU2NhbGUpIHtcbiAgICAgIFBvaW50MmQuYWRkVmVjMihwdCwgcHQsIFZlYzJkLnNjYWxlKGRlbHRhUG9zLCBkZWx0YVBvcywgMC41KSlcbiAgICB9XG5cbiAgICBwYXJlbnRTaGFwZS5zZXRQb3NpdGlvbihwdClcbiAgfSBlbHNlIHtcbiAgICAvLyBkcmFnZ2luZyBhIHNpZGUgdmVydGV4LCB3aGljaCBtZWFucyB3ZSBvbmx5IHNjYWxlIGluXG4gICAgLy8gb25lIGRpbWVuc2lvbiwgcmF0aGVyIHRoYW4gMi4gU28gd2UgbmVlZCB0byBmaWd1cmVcbiAgICAvLyBvdXQgdGhhdCBkaXJlY3Rpb24gYmFzZWQgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZVxuICAgIC8vIHNoYXBlXG4gICAgY29uc3QgaWR4ID0gc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCAtIDRcbiAgICBjb25zdCBheGlzRGlyID0gWzAsIDBdXG4gICAgaWYgKGlkeCAlIDIgPT09IDApIHtcbiAgICAgIC8vIHNjYWxpbmcgaW4gdGhlIG9iamVjdCdzIFggZGlyZWN0aW9uXG4gICAgICBWZWMyZC5zZXQoYXhpc0Rpciwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMF0sIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzFdKVxuICAgICAgeVNjYWxlID0gMFxuICAgICAgeFNjYWxlID0gKGlkeCA8IDIgPyAtMSA6IDEpXG4gICAgICBpZiAodW5pZm9ybVNjYWxlKSB7XG4gICAgICAgIHlTY2FsZSA9IHhTY2FsZVxuICAgICAgICBkZWx0YURpbXNbMV0gPSBkZWx0YURpbXNbMF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2NhbGluZyBpbiB0aGUgb2JqZWN0J3MgWSBkaXJlY3Rpb25cbiAgICAgIFZlYzJkLnNldChheGlzRGlyLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeFsyXSwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbM10pXG4gICAgICB4U2NhbGUgPSAwXG4gICAgICB5U2NhbGUgPSAoaWR4IDwgMiA/IC0xIDogMSlcbiAgICAgIGlmICh1bmlmb3JtU2NhbGUpIHtcbiAgICAgICAgeFNjYWxlID0geVNjYWxlXG4gICAgICAgIGRlbHRhRGltc1swXSA9IGRlbHRhRGltc1sxXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdyBmaW5kIHRoZSBwaXZvdCBvZmZzZXQgZm9yIHRoZSBheGlzLWFsaWduZWQgc2NhbGVcbiAgICBpZiAoIWNlbnRlclNjYWxlKSB7XG4gICAgICBWZWMyZC5ub3JtYWxpemUoYXhpc0RpciwgYXhpc0RpcilcbiAgICAgIFZlYzJkLnNjYWxlKGF4aXNEaXIsIGF4aXNEaXIsIFZlYzJkLmRvdChkZWx0YVBvcywgYXhpc0RpcikpXG4gICAgICBQb2ludDJkLmFkZFZlYzIocHQsIHB0LCBWZWMyZC5zY2FsZShheGlzRGlyLCBheGlzRGlyLCAwLjUpKVxuICAgIH1cblxuICAgIHBhcmVudFNoYXBlLnNldFBvc2l0aW9uKHB0KVxuICB9XG5cbiAgaWYgKGNlbnRlclNjYWxlKSB7XG4gICAgeFNjYWxlICo9IDJcbiAgICB5U2NhbGUgKj0gMlxuICB9XG5cbiAgLy8gcGVyZm9ybSB0aGUgc2NhbGVcbiAgcGFyZW50U2hhcGUuc2V0U2NhbGUoW3NlbGVjdGVkSW5mby5zdGFydExvY2FsU2NhbGVbMF0gKiAoMSArIHhTY2FsZSAqIGRlbHRhRGltc1swXSAvIHNlbGVjdGVkSW5mby5zaGFwZVdpZHRoKSwgc2VsZWN0ZWRJbmZvLnN0YXJ0TG9jYWxTY2FsZVsxXSAqICgxICsgeVNjYWxlICogZGVsdGFEaW1zWzFdIC8gc2VsZWN0ZWRJbmZvLnNoYXBlSGVpZ2h0KV0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGVTaGFwZShzaGFwZSwgc2VsZWN0ZWRJbmZvLCBzY3JlZW5Qb3MsIHdvcmxkUG9zLCBjYW1lcmEpIHtcbiAgY29uc3QgZGlmZiA9IFswLCAwXVxuICBjb25zdCBwdCA9IFswLCAwXVxuICBNYXQyZC5zdmQocHQsIG51bGwsIG51bGwsIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4KVxuICBpZiAoc2VsZWN0ZWRJbmZvLmtleXMuc2hpZnRLZXkpIHtcbiAgICBQb2ludDJkLnN1YihkaWZmLCBzY3JlZW5Qb3MsIHNlbGVjdGVkSW5mby5zdGFydFBvcylcbiAgICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKGRpZmZbMV0sIGRpZmZbMF0pXG4gICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlIC8gTWF0aC5RVUFURVJfUEkpICogTWF0aC5RVUFURVJfUElcbiAgICBjb25zdCB0cmFuc2Zvcm1EaXIgPSBbTWF0aC5jb3MoYW5nbGUpLCBNYXRoLnNpbihhbmdsZSldXG4gICAgVmVjMmQuc2NhbGUoZGlmZiwgdHJhbnNmb3JtRGlyLCBWZWMyZC5kb3QoZGlmZiwgdHJhbnNmb3JtRGlyKSlcbiAgICBWZWMyZC50cmFuc2Zvcm1NYXQyKGRpZmYsIGRpZmYsIGNhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4KVxuICB9IGVsc2Uge1xuICAgIFZlYzJkLnN1YihkaWZmLCB3b3JsZFBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0V29ybGRQb3MpXG4gIH1cbiAgUG9pbnQyZC5hZGRWZWMyKHB0LCBzZWxlY3RlZEluZm8uc3RhcnRMb2NhbFBvcywgZGlmZilcblxuICBzaGFwZS5zZXRQb3NpdGlvbihwdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZVZlcnQoc2hhcGUsIHNlbGVjdGVkSW5mbywgc2NyZWVuUG9zLCB3b3JsZFBvcykge1xuICBjb25zdCBwYXJlbnRTaGFwZSA9IHNoYXBlLnBhcmVudFxuXG4gIC8vIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIHNoYXBlIGF0IHN0YXJ0IG9mIHRyYW5zZm9ybVxuICAvLyBjb25zdCBwdCA9IFswLCAwXVxuICAvLyBNYXQyZC5zdmQocHQsIG51bGwsIG51bGwsIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4KVxuXG4gIC8vIGdldCB0aGUgbW91c2UgZGVsdGEgaW4gd29ybGQgc3BhY2VcbiAgLy8gVmVjMmQuc3ViKGRlbHRhUG9zLCB3b3JsZFBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0V29ybGRQb3MpXG5cbiAgLy8gZmlyc3QgY29udmVydCB3b3JsZCBwb2ludCB0byBvYmplY3Qgc3BhY2VcbiAgLy8gUG9pbnQyZC5jb3B5KG9ialBvcywgd29ybGRQb3MpXG4gIC8vIFBvaW50MmQudHJhbnNmb3JtTWF0MmQob2JqUG9zLCBvYmpQb3MsIHNlbGVjdGVkSW5mby53b3JsZFRvT2JqZWN0TWF0cml4KVxuXG4gIC8vIGdldCB0aGUgZGlmZlxuICAvLyBjb25zdCBkaWZmID0gb2JqUG9zXG4gIC8vIFBvaW50MmQuc3ViKGRpZmYsIG9ialBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0T2JqZWN0UG9zKVxuXG4gIGNvbnN0IG51bVZlcnRzID0gcGFyZW50U2hhcGUubnVtVmVydHNcbiAgaWYgKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggPj0gbnVtVmVydHMpIHtcbiAgICBjb25zdCBpZHgxID0gTWF0aC5taW4oc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCAtIG51bVZlcnRzLCBudW1WZXJ0cyAtIDEpXG4gICAgY29uc3QgaWR4MiA9IChpZHgxID09PSBudW1WZXJ0cyAtIDEgPyAwIDogaWR4MSArIDEpXG4gICAgY29uc3QgcHQgPSBbMCwgMF1cbiAgICBjb25zdCBwdDEgPSBbMCwgMF1cbiAgICBjb25zdCBwdDIgPSBbMCwgMF1cbiAgICBjb25zdCB2ZWMgPSBbMCwgMF1cbiAgICBjb25zdCB2ZXJ0cyA9IHBhcmVudFNoYXBlLnZlcnRzUmVmXG4gICAgY29uc3QgeGZvcm0gPSBwYXJlbnRTaGFwZS5nbG9iYWxYZm9ybVxuICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQocHQxLCB2ZXJ0c1tpZHgxXSwgeGZvcm0pXG4gICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChwdDIsIHZlcnRzW2lkeDJdLCB4Zm9ybSlcbiAgICBQb2ludDJkLnN1Yih2ZWMsIHB0MiwgcHQxKVxuICAgIFZlYzJkLnNjYWxlKHZlYywgdmVjLCAwLjUpXG4gICAgUG9pbnQyZC5hZGRWZWMyKHB0LCBwdDEsIHZlYylcbiAgICBzZWxlY3RlZEluZm8uY29udHJvbEluZGV4ID0gcGFyZW50U2hhcGUuaW5zZXJ0VmVydChpZHgxICsgMSwgcHQpXG4gIH0gZWxzZSB7XG4gICAgcGFyZW50U2hhcGUuc2V0VmVydFBvc2l0aW9uKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXgsIHdvcmxkUG9zKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3QtdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

	eval("/* eslint-disable no-magic-numbers */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar VertEditableShape = function (_BaseShape) {\n  _inherits(VertEditableShape, _BaseShape);\n\n  function VertEditableShape(baseVertShape, opts) {\n    _classCallCheck(this, VertEditableShape);\n\n    var _this = _possibleConstructorReturn(this, (VertEditableShape.__proto__ || Object.getPrototypeOf(VertEditableShape)).call(this, opts));\n\n    _this._baseVertShape = baseVertShape;\n    _this._vertRadius = 4;\n    _this._transformedVerts = [];\n    _this._baseaabox = AABox2d.create();\n    _this._worldToScreenMatrix = _glMatrix.mat2d.create();\n    return _this;\n  }\n\n  _createClass(VertEditableShape, [{\n    key: \"_updateAABox\",\n    value: function _updateAABox(worldToScreenMatrix) {\n      var aabox = this._baseVertShape.aabox;\n      if (!AABox2d.equals(aabox, this._baseaabox) || !_glMatrix.mat2d.equals(worldToScreenMatrix, this._worldToScreenMatrix)) {\n        AABox2d.copy(this._baseaabox, aabox);\n        _glMatrix.mat2d.copy(this._worldToScreenMatrix, worldToScreenMatrix);\n        AABox2d.transformMat2d(this._aabox, this._baseaabox, this._worldToScreenMatrix);\n        var pad = this._vertRadius + this.strokeWidth;\n        AABox2d.expand(this._aabox, this._aabox, [pad, pad]);\n      }\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtnObj = {\n        hit: false,\n        controlIndex: -1\n      };\n\n      this._updateAABox(worldToScreenMatrix);\n      if (this.visible && AABox2d.containsPt(this._aabox, screenPt)) {\n        var aabox = AABox2d.create();\n        var pad = this._vertRadius + this.strokeWidth / 2;\n        var extents = [pad, pad];\n\n        var i = 0;\n        for (i = 0; i < this._transformedVerts.length; i += 1) {\n          AABox2d.initCenterExtents(aabox, this._transformedVerts[i], extents);\n          if (AABox2d.containsPt(aabox, screenPt)) {\n            rtnObj.hit = true;\n            rtnObj.controlIndex = i;\n            break;\n          }\n        }\n\n        if (!rtnObj.hit) {\n          var tmpPt = [0, 0];\n          var tmpVec = [0, 0];\n          var radius = ctx.lineWidth * 1.5;\n          _glMatrix.vec2.set(extents, radius, radius);\n          for (i = 0; i < this._transformedVerts.length - 1; i += 1) {\n            Point2d.sub(tmpVec, this._transformedVerts[i + 1], this._transformedVerts[i]);\n            _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n            Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n            AABox2d.initCenterExtents(aabox, tmpPt, extents);\n            if (AABox2d.containsPt(aabox, screenPt)) {\n              rtnObj.hit = true;\n              rtnObj.controlIndex = this._transformedVerts.length + i;\n              break;\n            }\n          }\n\n          if (i > 0 && i === this._transformedVerts.length - 1) {\n            Point2d.sub(tmpVec, this._transformedVerts[0], this._transformedVerts[i]);\n            _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n            Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n            AABox2d.initCenterExtents(aabox, tmpPt, extents);\n            if (AABox2d.containsPt(aabox, screenPt)) {\n              rtnObj.hit = true;\n              rtnObj.controlIndex = this._transformedVerts.length + i;\n            }\n          }\n        }\n      }\n\n      return rtnObj;\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      // we're storing our AABox in screen space here, so worldToScreenMatrix is\n      // unused\n      this._updateAABox(worldToScreenMatrix);\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      AABox2d.getCenter(center, this._aabox);\n      AABox2d.getExtents(extents, this._aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx) {\n      var _this2 = this;\n\n      ctx.save();\n\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      var objToScreenMatrix = this._baseVertShape._fullXform;\n      var verts = this._baseVertShape.vertsRef;\n      this._transformedVerts = new Array(verts.length);\n      var tmpPt = [0, 0];\n      var tmpVec = [0, 0];\n\n      ctx.beginPath();\n      var i = 0;\n      this._transformedVerts[i] = [0, 0];\n      Point2d.transformMat2d(this._transformedVerts[i], verts[i], objToScreenMatrix);\n\n      var radius = Math.max(ctx.lineWidth * 1.5, 2.5);\n      for (i = 0; i < verts.length - 1; i += 1) {\n        this._transformedVerts[i + 1] = [0, 0];\n        Point2d.transformMat2d(this._transformedVerts[i + 1], verts[i + 1], objToScreenMatrix);\n        Point2d.sub(tmpVec, this._transformedVerts[i + 1], this._transformedVerts[i]);\n        _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n        Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n\n        ctx.moveTo(tmpPt[0] + radius, tmpPt[1]);\n        ctx.arc(tmpPt[0], tmpPt[1], radius, 0, Math.TWO_PI);\n      }\n\n      if (i > 0) {\n        Point2d.sub(tmpVec, this._transformedVerts[0], this._transformedVerts[i]);\n        _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n        Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n        ctx.moveTo(tmpPt[0] + radius, tmpPt[1]);\n        ctx.arc(tmpPt[0], tmpPt[1], radius, 0, Math.TWO_PI);\n\n        // TODO(croot): Is this appropriate? Can the fill/stroke style\n        // be cross compatible? What about gradients/patterns?\n        // We can probably safely assume no gradients/patterns at\n        // this point\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n\n      this._transformedVerts.forEach(function (vert) {\n        ctx.moveTo(vert[0] + _this2._vertRadius, vert[1]);\n        ctx.arc(vert[0], vert[1], _this2._vertRadius, 0, Math.TWO_PI);\n      });\n\n      if (this.isFillVisible()) {\n        this.setFillCtx(ctx);\n        ctx.fill();\n      }\n\n      if (this.isStrokeVisible()) {\n        this.setStrokeCtx(ctx);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }]);\n\n  return VertEditableShape;\n}(_baseShape2.default);\n\nexports.default = VertEditableShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMvdmVydC1lZGl0YWJsZS1zaGFwZS5qcz80ZWQzIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJQb2ludDJkIiwiVmVydEVkaXRhYmxlU2hhcGUiLCJiYXNlVmVydFNoYXBlIiwib3B0cyIsIl9iYXNlVmVydFNoYXBlIiwiX3ZlcnRSYWRpdXMiLCJfdHJhbnNmb3JtZWRWZXJ0cyIsIl9iYXNlYWFib3giLCJjcmVhdGUiLCJfd29ybGRUb1NjcmVlbk1hdHJpeCIsIk1hdDJkIiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImFhYm94IiwiZXF1YWxzIiwiY29weSIsInRyYW5zZm9ybU1hdDJkIiwiX2FhYm94IiwicGFkIiwic3Ryb2tlV2lkdGgiLCJleHBhbmQiLCJzY3JlZW5QdCIsIndvcmxkUHQiLCJjdHgiLCJydG5PYmoiLCJoaXQiLCJjb250cm9sSW5kZXgiLCJfdXBkYXRlQUFCb3giLCJ2aXNpYmxlIiwiY29udGFpbnNQdCIsImV4dGVudHMiLCJpIiwibGVuZ3RoIiwiaW5pdENlbnRlckV4dGVudHMiLCJ0bXBQdCIsInRtcFZlYyIsInJhZGl1cyIsImxpbmVXaWR0aCIsIlZlYzJkIiwic2V0Iiwic3ViIiwic2NhbGUiLCJhZGRWZWMyIiwiYm91bmRzU3Ryb2tlU3R5bGUiLCJzYXZlIiwic2V0VHJhbnNmb3JtIiwic2V0U3Ryb2tlQ3R4IiwiY2VudGVyIiwiZ2V0Q2VudGVyIiwiZ2V0RXh0ZW50cyIsImJlZ2luUGF0aCIsInJlY3QiLCJzdHJva2UiLCJyZXN0b3JlIiwib2JqVG9TY3JlZW5NYXRyaXgiLCJfZnVsbFhmb3JtIiwidmVydHMiLCJ2ZXJ0c1JlZiIsIkFycmF5IiwiTWF0aCIsIm1heCIsIm1vdmVUbyIsImFyYyIsIlRXT19QSSIsImZpbGxTdHlsZSIsInN0cm9rZVN0eWxlIiwiZmlsbCIsImZvckVhY2giLCJ2ZXJ0IiwiaXNGaWxsVmlzaWJsZSIsInNldEZpbGxDdHgiLCJpc1N0cm9rZVZpc2libGUiLCJCYXNlU2hhcGUiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7O0lBQVlDLE87O0FBQ1o7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0lBRXFCQyxpQjs7O0FBQ25CLDZCQUFZQyxhQUFaLEVBQTJCQyxJQUEzQixFQUFpQztBQUFBOztBQUFBLHNJQUN6QkEsSUFEeUI7O0FBRS9CLFVBQUtDLGNBQUwsR0FBc0JGLGFBQXRCO0FBQ0EsVUFBS0csV0FBTCxHQUFtQixDQUFuQjtBQUNBLFVBQUtDLGlCQUFMLEdBQXlCLEVBQXpCO0FBQ0EsVUFBS0MsVUFBTCxHQUFrQlIsUUFBUVMsTUFBUixFQUFsQjtBQUNBLFVBQUtDLG9CQUFMLEdBQTRCQyxnQkFBTUYsTUFBTixFQUE1QjtBQU4rQjtBQU9oQzs7OztpQ0FFWUcsbUIsRUFBcUI7QUFDaEMsVUFBTUMsUUFBUSxLQUFLUixjQUFMLENBQW9CUSxLQUFsQztBQUNBLFVBQUksQ0FBQ2IsUUFBUWMsTUFBUixDQUFlRCxLQUFmLEVBQXNCLEtBQUtMLFVBQTNCLENBQUQsSUFBMkMsQ0FBQ0csZ0JBQU1HLE1BQU4sQ0FBYUYsbUJBQWIsRUFBa0MsS0FBS0Ysb0JBQXZDLENBQWhELEVBQThHO0FBQzVHVixnQkFBUWUsSUFBUixDQUFhLEtBQUtQLFVBQWxCLEVBQThCSyxLQUE5QjtBQUNBRix3QkFBTUksSUFBTixDQUFXLEtBQUtMLG9CQUFoQixFQUFzQ0UsbUJBQXRDO0FBQ0FaLGdCQUFRZ0IsY0FBUixDQUF1QixLQUFLQyxNQUE1QixFQUFvQyxLQUFLVCxVQUF6QyxFQUFxRCxLQUFLRSxvQkFBMUQ7QUFDQSxZQUFNUSxNQUFNLEtBQUtaLFdBQUwsR0FBbUIsS0FBS2EsV0FBcEM7QUFDQW5CLGdCQUFRb0IsTUFBUixDQUFlLEtBQUtILE1BQXBCLEVBQTRCLEtBQUtBLE1BQWpDLEVBQXlDLENBQUNDLEdBQUQsRUFBTUEsR0FBTixDQUF6QztBQUNEO0FBQ0Y7OztrQ0FFYUcsUSxFQUFVQyxPLEVBQVNWLG1CLEVBQXFCVyxHLEVBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFNQyxTQUFTO0FBQ2JDLGFBQUssS0FEUTtBQUViQyxzQkFBYyxDQUFDO0FBRkYsT0FBZjs7QUFLQSxXQUFLQyxZQUFMLENBQWtCZixtQkFBbEI7QUFDQSxVQUFJLEtBQUtnQixPQUFMLElBQWdCNUIsUUFBUTZCLFVBQVIsQ0FBbUIsS0FBS1osTUFBeEIsRUFBZ0NJLFFBQWhDLENBQXBCLEVBQStEO0FBQzdELFlBQU1SLFFBQVFiLFFBQVFTLE1BQVIsRUFBZDtBQUNBLFlBQU1TLE1BQU0sS0FBS1osV0FBTCxHQUFtQixLQUFLYSxXQUFMLEdBQW1CLENBQWxEO0FBQ0EsWUFBTVcsVUFBVSxDQUFDWixHQUFELEVBQU1BLEdBQU4sQ0FBaEI7O0FBRUEsWUFBSWEsSUFBSSxDQUFSO0FBQ0EsYUFBS0EsSUFBSSxDQUFULEVBQVlBLElBQUksS0FBS3hCLGlCQUFMLENBQXVCeUIsTUFBdkMsRUFBK0NELEtBQUssQ0FBcEQsRUFBdUQ7QUFDckQvQixrQkFBUWlDLGlCQUFSLENBQTBCcEIsS0FBMUIsRUFBaUMsS0FBS04saUJBQUwsQ0FBdUJ3QixDQUF2QixDQUFqQyxFQUE0REQsT0FBNUQ7QUFDQSxjQUFJOUIsUUFBUTZCLFVBQVIsQ0FBbUJoQixLQUFuQixFQUEwQlEsUUFBMUIsQ0FBSixFQUF5QztBQUN2Q0csbUJBQU9DLEdBQVAsR0FBYSxJQUFiO0FBQ0FELG1CQUFPRSxZQUFQLEdBQXNCSyxDQUF0QjtBQUNBO0FBQ0Q7QUFDRjs7QUFFRCxZQUFJLENBQUNQLE9BQU9DLEdBQVosRUFBaUI7QUFDZixjQUFNUyxRQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZDtBQUNBLGNBQU1DLFNBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFmO0FBQ0EsY0FBTUMsU0FBU2IsSUFBSWMsU0FBSixHQUFnQixHQUEvQjtBQUNBQyx5QkFBTUMsR0FBTixDQUFVVCxPQUFWLEVBQW1CTSxNQUFuQixFQUEyQkEsTUFBM0I7QUFDQSxlQUFLTCxJQUFJLENBQVQsRUFBWUEsSUFBSSxLQUFLeEIsaUJBQUwsQ0FBdUJ5QixNQUF2QixHQUFnQyxDQUFoRCxFQUFtREQsS0FBSyxDQUF4RCxFQUEyRDtBQUN6RDlCLG9CQUFRdUMsR0FBUixDQUFZTCxNQUFaLEVBQW9CLEtBQUs1QixpQkFBTCxDQUF1QndCLElBQUksQ0FBM0IsQ0FBcEIsRUFBbUQsS0FBS3hCLGlCQUFMLENBQXVCd0IsQ0FBdkIsQ0FBbkQ7QUFDQU8sMkJBQU1HLEtBQU4sQ0FBWU4sTUFBWixFQUFvQkEsTUFBcEIsRUFBNEIsR0FBNUI7QUFDQWxDLG9CQUFReUMsT0FBUixDQUFnQlIsS0FBaEIsRUFBdUIsS0FBSzNCLGlCQUFMLENBQXVCd0IsQ0FBdkIsQ0FBdkIsRUFBa0RJLE1BQWxEO0FBQ0FuQyxvQkFBUWlDLGlCQUFSLENBQTBCcEIsS0FBMUIsRUFBaUNxQixLQUFqQyxFQUF3Q0osT0FBeEM7QUFDQSxnQkFBSTlCLFFBQVE2QixVQUFSLENBQW1CaEIsS0FBbkIsRUFBMEJRLFFBQTFCLENBQUosRUFBeUM7QUFDdkNHLHFCQUFPQyxHQUFQLEdBQWEsSUFBYjtBQUNBRCxxQkFBT0UsWUFBUCxHQUFzQixLQUFLbkIsaUJBQUwsQ0FBdUJ5QixNQUF2QixHQUFnQ0QsQ0FBdEQ7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsY0FBSUEsSUFBSSxDQUFKLElBQVNBLE1BQU0sS0FBS3hCLGlCQUFMLENBQXVCeUIsTUFBdkIsR0FBZ0MsQ0FBbkQsRUFBc0Q7QUFDcEQvQixvQkFBUXVDLEdBQVIsQ0FBWUwsTUFBWixFQUFvQixLQUFLNUIsaUJBQUwsQ0FBdUIsQ0FBdkIsQ0FBcEIsRUFBK0MsS0FBS0EsaUJBQUwsQ0FBdUJ3QixDQUF2QixDQUEvQztBQUNBTywyQkFBTUcsS0FBTixDQUFZTixNQUFaLEVBQW9CQSxNQUFwQixFQUE0QixHQUE1QjtBQUNBbEMsb0JBQVF5QyxPQUFSLENBQWdCUixLQUFoQixFQUF1QixLQUFLM0IsaUJBQUwsQ0FBdUJ3QixDQUF2QixDQUF2QixFQUFrREksTUFBbEQ7QUFDQW5DLG9CQUFRaUMsaUJBQVIsQ0FBMEJwQixLQUExQixFQUFpQ3FCLEtBQWpDLEVBQXdDSixPQUF4QztBQUNBLGdCQUFJOUIsUUFBUTZCLFVBQVIsQ0FBbUJoQixLQUFuQixFQUEwQlEsUUFBMUIsQ0FBSixFQUF5QztBQUN2Q0cscUJBQU9DLEdBQVAsR0FBYSxJQUFiO0FBQ0FELHFCQUFPRSxZQUFQLEdBQXNCLEtBQUtuQixpQkFBTCxDQUF1QnlCLE1BQXZCLEdBQWdDRCxDQUF0RDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELGFBQU9QLE1BQVA7QUFDRDs7O2lDQUVZRCxHLEVBQUtYLG1CLEVBQXFCK0IsaUIsRUFBbUI7QUFDeEQ7QUFDQTtBQUNBLFdBQUtoQixZQUFMLENBQWtCZixtQkFBbEI7QUFDQVcsVUFBSXFCLElBQUo7QUFDQXJCLFVBQUlzQixZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDO0FBQ0FGLHdCQUFrQkcsWUFBbEIsQ0FBK0J2QixHQUEvQjtBQUNBLFVBQU13QixTQUFTLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZjtBQUNBLFVBQU1qQixVQUFVLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEI7QUFDQTlCLGNBQVFnRCxTQUFSLENBQWtCRCxNQUFsQixFQUEwQixLQUFLOUIsTUFBL0I7QUFDQWpCLGNBQVFpRCxVQUFSLENBQW1CbkIsT0FBbkIsRUFBNEIsS0FBS2IsTUFBakM7QUFDQU0sVUFBSTJCLFNBQUo7QUFDQTNCLFVBQUk0QixJQUFKLENBQVNKLE9BQU8sQ0FBUCxJQUFZakIsUUFBUSxDQUFSLENBQXJCLEVBQWlDaUIsT0FBTyxDQUFQLElBQVlqQixRQUFRLENBQVIsQ0FBN0MsRUFBeURBLFFBQVEsQ0FBUixJQUFhLENBQXRFLEVBQXlFQSxRQUFRLENBQVIsSUFBYSxDQUF0RjtBQUNBUCxVQUFJNkIsTUFBSjtBQUNBN0IsVUFBSThCLE9BQUo7QUFDRDs7OzJCQUVNOUIsRyxFQUFLO0FBQUE7O0FBQ1ZBLFVBQUlxQixJQUFKOztBQUVBckIsVUFBSXNCLFlBQUosQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEM7QUFDQSxVQUFNUyxvQkFBb0IsS0FBS2pELGNBQUwsQ0FBb0JrRCxVQUE5QztBQUNBLFVBQU1DLFFBQVEsS0FBS25ELGNBQUwsQ0FBb0JvRCxRQUFsQztBQUNBLFdBQUtsRCxpQkFBTCxHQUF5QixJQUFJbUQsS0FBSixDQUFVRixNQUFNeEIsTUFBaEIsQ0FBekI7QUFDQSxVQUFNRSxRQUFRLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBZDtBQUNBLFVBQU1DLFNBQVMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFmOztBQUVBWixVQUFJMkIsU0FBSjtBQUNBLFVBQUluQixJQUFJLENBQVI7QUFDQSxXQUFLeEIsaUJBQUwsQ0FBdUJ3QixDQUF2QixJQUE0QixDQUFDLENBQUQsRUFBSSxDQUFKLENBQTVCO0FBQ0E5QixjQUFRZSxjQUFSLENBQXVCLEtBQUtULGlCQUFMLENBQXVCd0IsQ0FBdkIsQ0FBdkIsRUFBa0R5QixNQUFNekIsQ0FBTixDQUFsRCxFQUE0RHVCLGlCQUE1RDs7QUFFQSxVQUFNbEIsU0FBU3VCLEtBQUtDLEdBQUwsQ0FBU3JDLElBQUljLFNBQUosR0FBZ0IsR0FBekIsRUFBOEIsR0FBOUIsQ0FBZjtBQUNBLFdBQUtOLElBQUksQ0FBVCxFQUFZQSxJQUFJeUIsTUFBTXhCLE1BQU4sR0FBZSxDQUEvQixFQUFrQ0QsS0FBSyxDQUF2QyxFQUEwQztBQUN4QyxhQUFLeEIsaUJBQUwsQ0FBdUJ3QixJQUFJLENBQTNCLElBQWdDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEM7QUFDQTlCLGdCQUFRZSxjQUFSLENBQXVCLEtBQUtULGlCQUFMLENBQXVCd0IsSUFBSSxDQUEzQixDQUF2QixFQUFzRHlCLE1BQU16QixJQUFJLENBQVYsQ0FBdEQsRUFBb0V1QixpQkFBcEU7QUFDQXJELGdCQUFRdUMsR0FBUixDQUFZTCxNQUFaLEVBQW9CLEtBQUs1QixpQkFBTCxDQUF1QndCLElBQUksQ0FBM0IsQ0FBcEIsRUFBbUQsS0FBS3hCLGlCQUFMLENBQXVCd0IsQ0FBdkIsQ0FBbkQ7QUFDQU8sdUJBQU1HLEtBQU4sQ0FBWU4sTUFBWixFQUFvQkEsTUFBcEIsRUFBNEIsR0FBNUI7QUFDQWxDLGdCQUFReUMsT0FBUixDQUFnQlIsS0FBaEIsRUFBdUIsS0FBSzNCLGlCQUFMLENBQXVCd0IsQ0FBdkIsQ0FBdkIsRUFBa0RJLE1BQWxEOztBQUVBWixZQUFJc0MsTUFBSixDQUFXM0IsTUFBTSxDQUFOLElBQVdFLE1BQXRCLEVBQThCRixNQUFNLENBQU4sQ0FBOUI7QUFDQVgsWUFBSXVDLEdBQUosQ0FBUTVCLE1BQU0sQ0FBTixDQUFSLEVBQWtCQSxNQUFNLENBQU4sQ0FBbEIsRUFBNEJFLE1BQTVCLEVBQW9DLENBQXBDLEVBQXVDdUIsS0FBS0ksTUFBNUM7QUFDRDs7QUFFRCxVQUFJaEMsSUFBSSxDQUFSLEVBQVc7QUFDVDlCLGdCQUFRdUMsR0FBUixDQUFZTCxNQUFaLEVBQW9CLEtBQUs1QixpQkFBTCxDQUF1QixDQUF2QixDQUFwQixFQUErQyxLQUFLQSxpQkFBTCxDQUF1QndCLENBQXZCLENBQS9DO0FBQ0FPLHVCQUFNRyxLQUFOLENBQVlOLE1BQVosRUFBb0JBLE1BQXBCLEVBQTRCLEdBQTVCO0FBQ0FsQyxnQkFBUXlDLE9BQVIsQ0FBZ0JSLEtBQWhCLEVBQXVCLEtBQUszQixpQkFBTCxDQUF1QndCLENBQXZCLENBQXZCLEVBQWtESSxNQUFsRDtBQUNBWixZQUFJc0MsTUFBSixDQUFXM0IsTUFBTSxDQUFOLElBQVdFLE1BQXRCLEVBQThCRixNQUFNLENBQU4sQ0FBOUI7QUFDQVgsWUFBSXVDLEdBQUosQ0FBUTVCLE1BQU0sQ0FBTixDQUFSLEVBQWtCQSxNQUFNLENBQU4sQ0FBbEIsRUFBNEJFLE1BQTVCLEVBQW9DLENBQXBDLEVBQXVDdUIsS0FBS0ksTUFBNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQXhDLFlBQUl5QyxTQUFKLEdBQWdCekMsSUFBSTBDLFdBQXBCO0FBQ0ExQyxZQUFJMkMsSUFBSjtBQUNEOztBQUVEM0MsVUFBSTJCLFNBQUo7O0FBRUEsV0FBSzNDLGlCQUFMLENBQXVCNEQsT0FBdkIsQ0FBK0IsZ0JBQVE7QUFDckM1QyxZQUFJc0MsTUFBSixDQUFXTyxLQUFLLENBQUwsSUFBVSxPQUFLOUQsV0FBMUIsRUFBdUM4RCxLQUFLLENBQUwsQ0FBdkM7QUFDQTdDLFlBQUl1QyxHQUFKLENBQVFNLEtBQUssQ0FBTCxDQUFSLEVBQWlCQSxLQUFLLENBQUwsQ0FBakIsRUFBMEIsT0FBSzlELFdBQS9CLEVBQTRDLENBQTVDLEVBQStDcUQsS0FBS0ksTUFBcEQ7QUFDRCxPQUhEOztBQUtBLFVBQUksS0FBS00sYUFBTCxFQUFKLEVBQTBCO0FBQ3hCLGFBQUtDLFVBQUwsQ0FBZ0IvQyxHQUFoQjtBQUNBQSxZQUFJMkMsSUFBSjtBQUNEOztBQUVELFVBQUksS0FBS0ssZUFBTCxFQUFKLEVBQTRCO0FBQzFCLGFBQUt6QixZQUFMLENBQWtCdkIsR0FBbEI7QUFDQUEsWUFBSTZCLE1BQUo7QUFDRDs7QUFFRDdCLFVBQUk4QixPQUFKO0FBQ0Q7Ozs7RUE3SjRDbUIsbUI7O2tCQUExQnRFLGlCIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tbWFnaWMtbnVtYmVycyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQge21hdDJkIGFzIE1hdDJkLCB2ZWMyIGFzIFZlYzJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSBcIi4uL3NoYXBlcy9iYXNlLXNoYXBlXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydEVkaXRhYmxlU2hhcGUgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICBjb25zdHJ1Y3RvcihiYXNlVmVydFNoYXBlLCBvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9iYXNlVmVydFNoYXBlID0gYmFzZVZlcnRTaGFwZVxuICAgIHRoaXMuX3ZlcnRSYWRpdXMgPSA0XG4gICAgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cyA9IFtdXG4gICAgdGhpcy5fYmFzZWFhYm94ID0gQUFCb3gyZC5jcmVhdGUoKVxuICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuICB9XG5cbiAgX3VwZGF0ZUFBQm94KHdvcmxkVG9TY3JlZW5NYXRyaXgpIHtcbiAgICBjb25zdCBhYWJveCA9IHRoaXMuX2Jhc2VWZXJ0U2hhcGUuYWFib3hcbiAgICBpZiAoIUFBQm94MmQuZXF1YWxzKGFhYm94LCB0aGlzLl9iYXNlYWFib3gpIHx8ICFNYXQyZC5lcXVhbHMod29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCkpIHtcbiAgICAgIEFBQm94MmQuY29weSh0aGlzLl9iYXNlYWFib3gsIGFhYm94KVxuICAgICAgTWF0MmQuY29weSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB3b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgICAgQUFCb3gyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl9hYWJveCwgdGhpcy5fYmFzZWFhYm94LCB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgICAgY29uc3QgcGFkID0gdGhpcy5fdmVydFJhZGl1cyArIHRoaXMuc3Ryb2tlV2lkdGhcbiAgICAgIEFBQm94MmQuZXhwYW5kKHRoaXMuX2FhYm94LCB0aGlzLl9hYWJveCwgW3BhZCwgcGFkXSlcbiAgICB9XG4gIH1cblxuICBjb250YWluc1BvaW50KHNjcmVlblB0LCB3b3JsZFB0LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBjdHgpIHtcbiAgICAvLyBTaG91bGQgd2UgdXBkYXRlIGhlcmUsIG9yIGlzIGl0IHNhZmUgdG9cbiAgICAvLyBzYXkgdGhhdCB0aGlzIGlzIHN0YXRlZnVsLCBtZWFuaW5nIGEgcmVuZGVyXG4gICAgLy8gc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgYmVmb3JlaGFuZCB3aGljaFxuICAgIC8vIHdvdWxkJ3ZlIHVwZGF0ZWQgaXRzIHN0YXRlXG4gICAgY29uc3QgcnRuT2JqID0ge1xuICAgICAgaGl0OiBmYWxzZSxcbiAgICAgIGNvbnRyb2xJbmRleDogLTFcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGVBQUJveCh3b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgIGlmICh0aGlzLnZpc2libGUgJiYgQUFCb3gyZC5jb250YWluc1B0KHRoaXMuX2FhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgIGNvbnN0IGFhYm94ID0gQUFCb3gyZC5jcmVhdGUoKVxuICAgICAgY29uc3QgcGFkID0gdGhpcy5fdmVydFJhZGl1cyArIHRoaXMuc3Ryb2tlV2lkdGggLyAyXG4gICAgICBjb25zdCBleHRlbnRzID0gW3BhZCwgcGFkXVxuXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHMoYWFib3gsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIGV4dGVudHMpXG4gICAgICAgIGlmIChBQUJveDJkLmNvbnRhaW5zUHQoYWFib3gsIHNjcmVlblB0KSkge1xuICAgICAgICAgIHJ0bk9iai5oaXQgPSB0cnVlXG4gICAgICAgICAgcnRuT2JqLmNvbnRyb2xJbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcnRuT2JqLmhpdCkge1xuICAgICAgICBjb25zdCB0bXBQdCA9IFswLCAwXVxuICAgICAgICBjb25zdCB0bXBWZWMgPSBbMCwgMF1cbiAgICAgICAgY29uc3QgcmFkaXVzID0gY3R4LmxpbmVXaWR0aCAqIDEuNVxuICAgICAgICBWZWMyZC5zZXQoZXh0ZW50cywgcmFkaXVzLCByYWRpdXMpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICAgIFBvaW50MmQuc3ViKHRtcFZlYywgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0sIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0pXG4gICAgICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgICAgICBQb2ludDJkLmFkZFZlYzIodG1wUHQsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIHRtcFZlYylcbiAgICAgICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKGFhYm94LCB0bXBQdCwgZXh0ZW50cylcbiAgICAgICAgICBpZiAoQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgICAgICAgIHJ0bk9iai5oaXQgPSB0cnVlXG4gICAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cy5sZW5ndGggKyBpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCAmJiBpID09PSB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBQb2ludDJkLnN1Yih0bXBWZWMsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbMF0sIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0pXG4gICAgICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgICAgICBQb2ludDJkLmFkZFZlYzIodG1wUHQsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIHRtcFZlYylcbiAgICAgICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKGFhYm94LCB0bXBQdCwgZXh0ZW50cylcbiAgICAgICAgICBpZiAoQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgICAgICAgIHJ0bk9iai5oaXQgPSB0cnVlXG4gICAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cy5sZW5ndGggKyBpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ0bk9ialxuICB9XG5cbiAgcmVuZGVyQm91bmRzKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgYm91bmRzU3Ryb2tlU3R5bGUpIHtcbiAgICAvLyB3ZSdyZSBzdG9yaW5nIG91ciBBQUJveCBpbiBzY3JlZW4gc3BhY2UgaGVyZSwgc28gd29ybGRUb1NjcmVlbk1hdHJpeCBpc1xuICAgIC8vIHVudXNlZFxuICAgIHRoaXMuX3VwZGF0ZUFBQm94KHdvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgY3R4LnNhdmUoKVxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBib3VuZHNTdHJva2VTdHlsZS5zZXRTdHJva2VDdHgoY3R4KVxuICAgIGNvbnN0IGNlbnRlciA9IFswLCAwXVxuICAgIGNvbnN0IGV4dGVudHMgPSBbMCwgMF1cbiAgICBBQUJveDJkLmdldENlbnRlcihjZW50ZXIsIHRoaXMuX2FhYm94KVxuICAgIEFBQm94MmQuZ2V0RXh0ZW50cyhleHRlbnRzLCB0aGlzLl9hYWJveClcbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBjdHgucmVjdChjZW50ZXJbMF0gLSBleHRlbnRzWzBdLCBjZW50ZXJbMV0gLSBleHRlbnRzWzFdLCBleHRlbnRzWzBdICogMiwgZXh0ZW50c1sxXSAqIDIpXG4gICAgY3R4LnN0cm9rZSgpXG4gICAgY3R4LnJlc3RvcmUoKVxuICB9XG5cbiAgcmVuZGVyKGN0eCkge1xuICAgIGN0eC5zYXZlKClcblxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjb25zdCBvYmpUb1NjcmVlbk1hdHJpeCA9IHRoaXMuX2Jhc2VWZXJ0U2hhcGUuX2Z1bGxYZm9ybVxuICAgIGNvbnN0IHZlcnRzID0gdGhpcy5fYmFzZVZlcnRTaGFwZS52ZXJ0c1JlZlxuICAgIHRoaXMuX3RyYW5zZm9ybWVkVmVydHMgPSBuZXcgQXJyYXkodmVydHMubGVuZ3RoKVxuICAgIGNvbnN0IHRtcFB0ID0gWzAsIDBdXG4gICAgY29uc3QgdG1wVmVjID0gWzAsIDBdXG5cbiAgICBjdHguYmVnaW5QYXRoKClcbiAgICBsZXQgaSA9IDBcbiAgICB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldID0gWzAsIDBdXG4gICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldLCB2ZXJ0c1tpXSwgb2JqVG9TY3JlZW5NYXRyaXgpXG5cbiAgICBjb25zdCByYWRpdXMgPSBNYXRoLm1heChjdHgubGluZVdpZHRoICogMS41LCAyLjUpXG4gICAgZm9yIChpID0gMDsgaSA8IHZlcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0gPSBbMCwgMF1cbiAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0sIHZlcnRzW2kgKyAxXSwgb2JqVG9TY3JlZW5NYXRyaXgpXG4gICAgICBQb2ludDJkLnN1Yih0bXBWZWMsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaSArIDFdLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldKVxuICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgIFBvaW50MmQuYWRkVmVjMih0bXBQdCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgdG1wVmVjKVxuXG4gICAgICBjdHgubW92ZVRvKHRtcFB0WzBdICsgcmFkaXVzLCB0bXBQdFsxXSlcbiAgICAgIGN0eC5hcmModG1wUHRbMF0sIHRtcFB0WzFdLCByYWRpdXMsIDAsIE1hdGguVFdPX1BJKVxuICAgIH1cblxuICAgIGlmIChpID4gMCkge1xuICAgICAgUG9pbnQyZC5zdWIodG1wVmVjLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzWzBdLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldKVxuICAgICAgVmVjMmQuc2NhbGUodG1wVmVjLCB0bXBWZWMsIDAuNSlcbiAgICAgIFBvaW50MmQuYWRkVmVjMih0bXBQdCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgdG1wVmVjKVxuICAgICAgY3R4Lm1vdmVUbyh0bXBQdFswXSArIHJhZGl1cywgdG1wUHRbMV0pXG4gICAgICBjdHguYXJjKHRtcFB0WzBdLCB0bXBQdFsxXSwgcmFkaXVzLCAwLCBNYXRoLlRXT19QSSlcblxuICAgICAgLy8gVE9ETyhjcm9vdCk6IElzIHRoaXMgYXBwcm9wcmlhdGU/IENhbiB0aGUgZmlsbC9zdHJva2Ugc3R5bGVcbiAgICAgIC8vIGJlIGNyb3NzIGNvbXBhdGlibGU/IFdoYXQgYWJvdXQgZ3JhZGllbnRzL3BhdHRlcm5zP1xuICAgICAgLy8gV2UgY2FuIHByb2JhYmx5IHNhZmVseSBhc3N1bWUgbm8gZ3JhZGllbnRzL3BhdHRlcm5zIGF0XG4gICAgICAvLyB0aGlzIHBvaW50XG4gICAgICBjdHguZmlsbFN0eWxlID0gY3R4LnN0cm9rZVN0eWxlXG4gICAgICBjdHguZmlsbCgpXG4gICAgfVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpXG5cbiAgICB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmZvckVhY2godmVydCA9PiB7XG4gICAgICBjdHgubW92ZVRvKHZlcnRbMF0gKyB0aGlzLl92ZXJ0UmFkaXVzLCB2ZXJ0WzFdKVxuICAgICAgY3R4LmFyYyh2ZXJ0WzBdLCB2ZXJ0WzFdLCB0aGlzLl92ZXJ0UmFkaXVzLCAwLCBNYXRoLlRXT19QSSlcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMuaXNGaWxsVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLnNldEZpbGxDdHgoY3R4KVxuICAgICAgY3R4LmZpbGwoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmlzU3Ryb2tlVmlzaWJsZSgpKSB7XG4gICAgICB0aGlzLnNldFN0cm9rZUN0eChjdHgpXG4gICAgICBjdHguc3Ryb2tlKClcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2ludGVyYWN0aW9ucy92ZXJ0LWVkaXRhYmxlLXNoYXBlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _transform2d = __webpack_require__(11);\n\nvar _mat2d = __webpack_require__(4);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _rect = __webpack_require__(15);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _vec2d = __webpack_require__(9);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Constants = {\n  SIDES: 4\n};\n\nfunction drawOBBoxModifierRect(ctx, pt, objToScreenMat, modifierSize, modifierHalfSize, modifierRotation, scale) {\n  Point2d.transformMat2d(pt, pt, objToScreenMat);\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.translate(pt[0], pt[1]);\n  ctx.rotate(modifierRotation[1]);\n  ctx.scale(scale[0], scale[1]);\n  ctx.rotate(modifierRotation[0]);\n  ctx.translate(-pt[0], -pt[1]);\n  ctx.rect(pt[0] - modifierHalfSize, pt[1] - modifierHalfSize, modifierSize, modifierSize);\n\n  // ctx.moveTo(pt[0], pt[1])\n  // ctx.lineTo(pt[0], pt[1] + 20)\n  // ctx.moveTo(pt[0], pt[1])\n  // ctx.lineTo(pt[0] + 20, pt[1])\n\n  // ctx.font = \"24px serif\"\n  // ctx.fillText(text, pt[0], pt[1])\n}\n\nfunction isPointInOBBoxModifierRect(screenPt, modifierPt, objToScreenMat, modifierMat, halfBoxSz, boxSz, padBoxSz, padBoxRadius, xScale, yScale) {\n  var hit = false;\n  var rotate = false;\n  Point2d.transformMat2d(modifierPt, modifierPt, objToScreenMat);\n  if (Point2d.distance(modifierPt, screenPt) <= padBoxRadius) {\n    _vec2d2.default.negate(modifierPt, modifierPt);\n    modifierMat[4] = modifierMat[0] * modifierPt[0] + modifierMat[2] * modifierPt[1];\n    modifierMat[5] = modifierMat[1] * modifierPt[0] + modifierMat[3] * modifierPt[1];\n\n    var x = 0;\n    var y = 0;\n    Point2d.transformMat2d(modifierPt, screenPt, modifierMat);\n    if (Math.abs(modifierPt[0]) <= halfBoxSz && Math.abs(modifierPt[1]) <= halfBoxSz || Boolean(xScale) && Boolean(yScale) && (rotate = (x = xScale * modifierPt[0]) > -halfBoxSz && x <= padBoxSz && (y = yScale * modifierPt[1]) > -halfBoxSz && y <= padBoxSz)) {\n      hit = true;\n    }\n  }\n  return {\n    hit: hit,\n    rotate: rotate\n  };\n}\n\nvar XformShape = function (_Rect) {\n  _inherits(XformShape, _Rect);\n\n  function XformShape(opts) {\n    var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      scalable: true,\n      rotatable: true\n    };\n\n    _classCallCheck(this, XformShape);\n\n    var _this = _possibleConstructorReturn(this, (XformShape.__proto__ || Object.getPrototypeOf(XformShape)).call(this, opts));\n\n    _this._interactiveBoxSize = 8;\n    _this._interactiveBoxPadding = 10;\n    if (opts && typeof opts.vertexSize !== \"undefined\") {\n      _this._interactiveBoxSize = opts.vertexSize;\n    }\n\n    _this._scalable = true;\n    _this._rotatable = true;\n    if (selectOpts) {\n      if (typeof selectOpts.scalable !== \"undefined\") {\n        _this._scalable = Boolean(selectOpts.scalable);\n      }\n\n      if (typeof selectOpts.rotatable !== \"undefined\") {\n        _this._rotatable = Boolean(selectOpts.rotatable);\n      }\n    }\n    return _this;\n  }\n\n  _createClass(XformShape, [{\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtnObj = {\n        hit: false,\n        rotate: false,\n        controlIndex: -1\n      };\n\n      var aabox = this.aabox;\n      if ((this._rotatable || this._scalable) && this.visible && AABox2d.containsPt(aabox, screenPt)) {\n        var scale = [0, 0];\n        var rot = [0, 0];\n        _mat2d2.default.svd(null, scale, rot, this._fullXform);\n        var mat = _mat2d2.default.create();\n\n        scale[0] = scale[0] < 0 ? -1 : 1;\n        scale[1] = scale[1] < 0 ? -1 : 1;\n\n        if (scale[0] * scale[1] > 0) {\n          _vec2d2.default.negate(rot, rot);\n        }\n\n        _mat2d2.default.rotate(mat, mat, rot[1]);\n        _mat2d2.default.scale(mat, mat, scale);\n        _mat2d2.default.rotate(mat, mat, rot[0]);\n\n        var boxPadding = this._rotatable ? this._interactiveBoxPadding : 0;\n        var halfBoxSz = this._interactiveBoxSize / 2;\n        var halfWidth = this.width / 2;\n        var halfHeight = this.height / 2;\n        var pt = [0, 0];\n        var padSz = halfBoxSz + boxPadding;\n        var padRadius = Math.sqrt(2 * padSz * padSz);\n        var xScale = 0;\n        var yScale = 0;\n\n        for (var i = 0; i < Constants.SIDES; i += 1) {\n          xScale = i < 2 ? -1 : 1;\n          yScale = i % 2 === 0 ? -1 : 1;\n          Point2d.set(pt, xScale * halfWidth, yScale * halfHeight);\n          rtnObj = isPointInOBBoxModifierRect(screenPt, pt, this._fullXform, mat, halfBoxSz, this._interactiveBoxSize, padSz, padRadius, xScale, yScale, scale);\n          if (rtnObj.hit) {\n            rtnObj.controlIndex = i;\n            break;\n          }\n        }\n\n        if (!rtnObj.hit && this._scalable) {\n          for (var _i = 0; _i < Constants.SIDES; _i += 1) {\n            xScale = _i % 2 === 0 ? _i < 2 ? -1 : 1 : 0;\n            yScale = _i % 2 === 0 ? 0 : _i < 2 ? -1 : 1;\n            Point2d.set(pt, xScale * halfWidth, yScale * halfHeight);\n            rtnObj = isPointInOBBoxModifierRect(screenPt, pt, this._fullXform, mat, halfBoxSz, this._interactiveBoxSize, padSz, padRadius, xScale, yScale, scale);\n            if (rtnObj.hit) {\n              rtnObj.controlIndex = _i + Constants.SIDES;\n              break;\n            }\n          }\n        }\n\n        if (rtnObj.rotate && !this._rotatable) {\n          rtnObj.rotate = false;\n        } else if (!rtnObj.rotate && !this._scalable) {\n          rtnObj.rotate = true;\n        }\n      }\n\n      return rtnObj;\n    }\n  }, {\n    key: \"_updatelocalxform\",\n    value: function _updatelocalxform(force) {\n      if (this._lxformDirty || force) {\n        var pos = Point2d.clone(this._pos);\n        Point2d.addVec2(pos, pos, this._parent.pivotRef);\n        (0, _transform2d.buildXformMatrix)(this._localXform, this._rotDeg, this._scale, pos, this._pivot);\n        if (this._localXformUpdated) {\n          this._localXformUpdated();\n        }\n        this._lxformDirty = false;\n      }\n    }\n  }, {\n    key: \"_updateglobalxform\",\n    value: function _updateglobalxform() {\n      if (this._lxformDirty || this._xformDirty) {\n        this._updatelocalxform(true);\n        if (this._parent) {\n          _mat2d2.default.multiply(this._globalXform, this._parent.globalXform, this._localXform);\n        } else {\n          _mat2d2.default.copy(this._globalXform, this._localXform);\n        }\n        if (this._globalXformUpdated) {\n          this._globalXformUpdated();\n        }\n        this._xformDirty = false;\n      }\n    }\n  }, {\n    key: \"_updateAABox\",\n    value: function _updateAABox() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (force || this._geomDirty || this._boundsOutOfDate) {\n        var boxPadding = this._rotatable ? this._interactiveBoxPadding : 0;\n        var padding = boxPadding + this._interactiveBoxSize / 2;\n        AABox2d.initCenterExtents(this._aabox, [0, 0], [this.width / 2, this.height / 2]);\n        AABox2d.transformMat2d(this._aabox, this._aabox, this._fullXform);\n        AABox2d.expand(this._aabox, this._aabox, [padding, padding]);\n        this._aaboxUpdated = true;\n        this._geomDirty = this._boundsOutOfDate = false;\n      }\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      // we're storing our AABox in screen space here, so worldToScreenMatrix is\n      // unused\n      var aabox = this.aabox;\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      AABox2d.getCenter(center, aabox);\n      AABox2d.getExtents(extents, aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      if (!this.parent || typeof this.parent.width === \"undefined\" || this.parent.height === \"undefined\") {\n        return;\n      }\n\n      this._aaboxUpdated = false;\n      // do not fill the primary rectangle\n      _get(XformShape.prototype.__proto__ || Object.getPrototypeOf(XformShape.prototype), \"render\", this).call(this, ctx, worldToScreenMatrix, styleState, false);\n      if (!this._aaboxUpdated) {\n        this._updateAABox(true);\n      }\n\n      var scale = [0, 0];\n      var rot = [0, 0];\n      _mat2d2.default.svd(null, scale, rot, this._fullXform);\n      scale[0] = scale[0] < 0 ? -1 : 1;\n      scale[1] = scale[1] < 0 ? -1 : 1;\n\n      var halfBoxSz = this._interactiveBoxSize / 2;\n      var halfWidth = this.width / 2;\n      var halfHeight = this.height / 2;\n      var pt = [halfWidth, halfHeight];\n\n      ctx.save();\n\n      ctx.beginPath();\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"3\");\n\n      Point2d.set(pt, halfWidth, -halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"2\");\n\n      Point2d.set(pt, -halfWidth, -halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"0\");\n\n      Point2d.set(pt, -halfWidth, halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"1\");\n\n      if (this._scalable) {\n        Point2d.set(pt, 0, halfHeight);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, 0, -halfHeight);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, halfWidth, 0);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, -halfWidth, 0);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n      }\n\n      if (this.isFillVisible()) {\n        styleState.setFillStyle(ctx, this);\n        ctx.fill();\n      }\n\n      if (this.isStrokeVisible()) {\n        styleState.setStrokeStyle(ctx, this);\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.parent && this.parent.width !== \"undefined\" ? this.parent.width : 0;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.parent && this.parent.height !== \"undefined\" ? this.parent.height : 0;\n    }\n  }]);\n\n  return XformShape;\n}(_rect2.default);\n\nexports.default = XformShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMveGZvcm0tc2hhcGUuanM/MmU2MyJdLCJuYW1lcyI6WyJBQUJveDJkIiwiUG9pbnQyZCIsIkNvbnN0YW50cyIsIlNJREVTIiwiZHJhd09CQm94TW9kaWZpZXJSZWN0IiwiY3R4IiwicHQiLCJvYmpUb1NjcmVlbk1hdCIsIm1vZGlmaWVyU2l6ZSIsIm1vZGlmaWVySGFsZlNpemUiLCJtb2RpZmllclJvdGF0aW9uIiwic2NhbGUiLCJ0cmFuc2Zvcm1NYXQyZCIsInNldFRyYW5zZm9ybSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlY3QiLCJpc1BvaW50SW5PQkJveE1vZGlmaWVyUmVjdCIsInNjcmVlblB0IiwibW9kaWZpZXJQdCIsIm1vZGlmaWVyTWF0IiwiaGFsZkJveFN6IiwiYm94U3oiLCJwYWRCb3hTeiIsInBhZEJveFJhZGl1cyIsInhTY2FsZSIsInlTY2FsZSIsImhpdCIsImRpc3RhbmNlIiwiVmVjMmQiLCJuZWdhdGUiLCJ4IiwieSIsIk1hdGgiLCJhYnMiLCJCb29sZWFuIiwiWGZvcm1TaGFwZSIsIm9wdHMiLCJzZWxlY3RPcHRzIiwic2NhbGFibGUiLCJyb3RhdGFibGUiLCJfaW50ZXJhY3RpdmVCb3hTaXplIiwiX2ludGVyYWN0aXZlQm94UGFkZGluZyIsInZlcnRleFNpemUiLCJfc2NhbGFibGUiLCJfcm90YXRhYmxlIiwicnRuT2JqIiwiY29udHJvbEluZGV4IiwiYWFib3giLCJ2aXNpYmxlIiwiY29udGFpbnNQdCIsInJvdCIsIk1hdDJkIiwic3ZkIiwiX2Z1bGxYZm9ybSIsIm1hdCIsImNyZWF0ZSIsImJveFBhZGRpbmciLCJoYWxmV2lkdGgiLCJ3aWR0aCIsImhhbGZIZWlnaHQiLCJoZWlnaHQiLCJwYWRTeiIsInBhZFJhZGl1cyIsInNxcnQiLCJpIiwic2V0IiwiZm9yY2UiLCJfbHhmb3JtRGlydHkiLCJwb3MiLCJjbG9uZSIsIl9wb3MiLCJhZGRWZWMyIiwiX3BhcmVudCIsInBpdm90UmVmIiwiX2xvY2FsWGZvcm0iLCJfcm90RGVnIiwiX3NjYWxlIiwiX3Bpdm90IiwiX2xvY2FsWGZvcm1VcGRhdGVkIiwiX3hmb3JtRGlydHkiLCJfdXBkYXRlbG9jYWx4Zm9ybSIsIm11bHRpcGx5IiwiX2dsb2JhbFhmb3JtIiwiZ2xvYmFsWGZvcm0iLCJjb3B5IiwiX2dsb2JhbFhmb3JtVXBkYXRlZCIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwicGFkZGluZyIsImluaXRDZW50ZXJFeHRlbnRzIiwiX2FhYm94IiwiZXhwYW5kIiwiX2FhYm94VXBkYXRlZCIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJib3VuZHNTdHJva2VTdHlsZSIsInNhdmUiLCJzZXRTdHJva2VDdHgiLCJjZW50ZXIiLCJleHRlbnRzIiwiZ2V0Q2VudGVyIiwiZ2V0RXh0ZW50cyIsImJlZ2luUGF0aCIsInN0cm9rZSIsInJlc3RvcmUiLCJzdHlsZVN0YXRlIiwicGFyZW50IiwiX3VwZGF0ZUFBQm94IiwiaXNGaWxsVmlzaWJsZSIsInNldEZpbGxTdHlsZSIsImZpbGwiLCJpc1N0cm9rZVZpc2libGUiLCJzZXRTdHJva2VTdHlsZSIsIlJlY3QiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7O0lBQVlDLE87O0FBQ1o7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBLElBQU1DLFlBQVk7QUFDaEJDLFNBQU87QUFEUyxDQUFsQjs7QUFJQSxTQUFTQyxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLEVBQXBDLEVBQXdDQyxjQUF4QyxFQUF3REMsWUFBeEQsRUFBc0VDLGdCQUF0RSxFQUF3RkMsZ0JBQXhGLEVBQTBHQyxLQUExRyxFQUFpSDtBQUMvR1YsVUFBUVcsY0FBUixDQUF1Qk4sRUFBdkIsRUFBMkJBLEVBQTNCLEVBQStCQyxjQUEvQjtBQUNBRixNQUFJUSxZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZC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SXlHLElBQUo7QUFDRDs7QUFFRCxVQUFJLEtBQUtDLGVBQUwsRUFBSixFQUE0QjtBQUMxQk4sbUJBQVdPLGNBQVgsQ0FBMEIzRyxHQUExQixFQUErQixJQUEvQjtBQUNBQSxZQUFJUSxZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDO0FBQ0FSLFlBQUlrRyxNQUFKO0FBQ0Q7O0FBRURsRyxVQUFJbUcsT0FBSjtBQUNEOzs7d0JBeEZXO0FBQ1YsYUFBUSxLQUFLRSxNQUFMLElBQWUsS0FBS0EsTUFBTCxDQUFZL0MsS0FBWixLQUFzQixXQUFyQyxHQUFtRCxLQUFLK0MsTUFBTCxDQUFZL0MsS0FBL0QsR0FBdUUsQ0FBL0U7QUFDRDs7O3dCQUVZO0FBQ1gsYUFBUSxLQUFLK0MsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWTdDLE1BQVosS0FBdUIsV0FBdEMsR0FBb0QsS0FBSzZDLE1BQUwsQ0FBWTdDLE1BQWhFLEdBQXlFLENBQWpGO0FBQ0Q7Ozs7RUFoSnFDb0QsYzs7a0JBQW5CN0UsVSIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IHtcbiAgYnVpbGRYZm9ybU1hdHJpeFxufSBmcm9tIFwiLi4vc2hhcGVzL3RyYW5zZm9ybTJkXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vc2hhcGVzL3JlY3RcIlxuaW1wb3J0IFZlYzJkIGZyb20gXCIuLi9jb3JlL3ZlYzJkXCJcblxuY29uc3QgQ29uc3RhbnRzID0ge1xuICBTSURFUzogNFxufVxuXG5mdW5jdGlvbiBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgb2JqVG9TY3JlZW5NYXQsIG1vZGlmaWVyU2l6ZSwgbW9kaWZpZXJIYWxmU2l6ZSwgbW9kaWZpZXJSb3RhdGlvbiwgc2NhbGUpIHtcbiAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChwdCwgcHQsIG9ialRvU2NyZWVuTWF0KVxuICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gIGN0eC50cmFuc2xhdGUocHRbMF0sIHB0WzFdKVxuICBjdHgucm90YXRlKG1vZGlmaWVyUm90YXRpb25bMV0pXG4gIGN0eC5zY2FsZShzY2FsZVswXSwgc2NhbGVbMV0pXG4gIGN0eC5yb3RhdGUobW9kaWZpZXJSb3RhdGlvblswXSlcbiAgY3R4LnRyYW5zbGF0ZSgtcHRbMF0sIC1wdFsxXSlcbiAgY3R4LnJlY3QocHRbMF0gLSBtb2RpZmllckhhbGZTaXplLCBwdFsxXSAtIG1vZGlmaWVySGFsZlNpemUsIG1vZGlmaWVyU2l6ZSwgbW9kaWZpZXJTaXplKVxuXG4gIC8vIGN0eC5tb3ZlVG8ocHRbMF0sIHB0WzFdKVxuICAvLyBjdHgubGluZVRvKHB0WzBdLCBwdFsxXSArIDIwKVxuICAvLyBjdHgubW92ZVRvKHB0WzBdLCBwdFsxXSlcbiAgLy8gY3R4LmxpbmVUbyhwdFswXSArIDIwLCBwdFsxXSlcblxuICAvLyBjdHguZm9udCA9IFwiMjRweCBzZXJpZlwiXG4gIC8vIGN0eC5maWxsVGV4dCh0ZXh0LCBwdFswXSwgcHRbMV0pXG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRJbk9CQm94TW9kaWZpZXJSZWN0KHNjcmVlblB0LCBtb2RpZmllclB0LCBvYmpUb1NjcmVlbk1hdCwgbW9kaWZpZXJNYXQsIGhhbGZCb3hTeiwgYm94U3osIHBhZEJveFN6LCBwYWRCb3hSYWRpdXMsIHhTY2FsZSwgeVNjYWxlKSB7XG4gIGxldCBoaXQgPSBmYWxzZVxuICBsZXQgcm90YXRlID0gZmFsc2VcbiAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChtb2RpZmllclB0LCBtb2RpZmllclB0LCBvYmpUb1NjcmVlbk1hdClcbiAgaWYgKFBvaW50MmQuZGlzdGFuY2UobW9kaWZpZXJQdCwgc2NyZWVuUHQpIDw9IHBhZEJveFJhZGl1cykge1xuICAgIFZlYzJkLm5lZ2F0ZShtb2RpZmllclB0LCBtb2RpZmllclB0KVxuICAgIG1vZGlmaWVyTWF0WzRdID0gbW9kaWZpZXJNYXRbMF0gKiBtb2RpZmllclB0WzBdICsgbW9kaWZpZXJNYXRbMl0gKiBtb2RpZmllclB0WzFdXG4gICAgbW9kaWZpZXJNYXRbNV0gPSBtb2RpZmllck1hdFsxXSAqIG1vZGlmaWVyUHRbMF0gKyBtb2RpZmllck1hdFszXSAqIG1vZGlmaWVyUHRbMV1cblxuICAgIGxldCB4ID0gMFxuICAgIGxldCB5ID0gMFxuICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQobW9kaWZpZXJQdCwgc2NyZWVuUHQsIG1vZGlmaWVyTWF0KVxuICAgIGlmICgoTWF0aC5hYnMobW9kaWZpZXJQdFswXSkgPD0gaGFsZkJveFN6ICYmIE1hdGguYWJzKG1vZGlmaWVyUHRbMV0pIDw9IGhhbGZCb3hTeikgfHxcbiAgICAgIChCb29sZWFuKHhTY2FsZSkgJiYgQm9vbGVhbih5U2NhbGUpICYmXG4gICAgICAgIChyb3RhdGUgPSAoKHggPSB4U2NhbGUgKiBtb2RpZmllclB0WzBdKSA+IC1oYWxmQm94U3ogJiYgeCA8PSBwYWRCb3hTeiAmJlxuICAgICAgICAgICh5ID0geVNjYWxlICogbW9kaWZpZXJQdFsxXSkgPiAtaGFsZkJveFN6ICYmIHkgPD0gcGFkQm94U3opKSkpIHtcbiAgICAgIGhpdCA9IHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBoaXQsXG4gICAgcm90YXRlXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWGZvcm1TaGFwZSBleHRlbmRzIFJlY3Qge1xuICBjb25zdHJ1Y3RvcihvcHRzLCBzZWxlY3RPcHRzID0ge1xuICAgIHNjYWxhYmxlOiB0cnVlLFxuICAgIHJvdGF0YWJsZTogdHJ1ZVxuICB9KSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUgPSA4XG4gICAgdGhpcy5faW50ZXJhY3RpdmVCb3hQYWRkaW5nID0gMTBcbiAgICBpZiAob3B0cyAmJiB0eXBlb2Ygb3B0cy52ZXJ0ZXhTaXplICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUgPSBvcHRzLnZlcnRleFNpemVcbiAgICB9XG5cbiAgICB0aGlzLl9zY2FsYWJsZSA9IHRydWVcbiAgICB0aGlzLl9yb3RhdGFibGUgPSB0cnVlXG4gICAgaWYgKHNlbGVjdE9wdHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0T3B0cy5zY2FsYWJsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLl9zY2FsYWJsZSA9IEJvb2xlYW4oc2VsZWN0T3B0cy5zY2FsYWJsZSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RPcHRzLnJvdGF0YWJsZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLl9yb3RhdGFibGUgPSBCb29sZWFuKHNlbGVjdE9wdHMucm90YXRhYmxlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnRhaW5zUG9pbnQoc2NyZWVuUHQpIHtcbiAgICAvLyBTaG91bGQgd2UgdXBkYXRlIGhlcmUsIG9yIGlzIGl0IHNhZmUgdG9cbiAgICAvLyBzYXkgdGhhdCB0aGlzIGlzIHN0YXRlZnVsLCBtZWFuaW5nIGEgcmVuZGVyXG4gICAgLy8gc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgYmVmb3JlaGFuZCB3aGljaFxuICAgIC8vIHdvdWxkJ3ZlIHVwZGF0ZWQgaXRzIHN0YXRlXG4gICAgbGV0IHJ0bk9iaiA9IHtcbiAgICAgIGhpdDogZmFsc2UsXG4gICAgICByb3RhdGU6IGZhbHNlLFxuICAgICAgY29udHJvbEluZGV4OiAtMVxuICAgIH1cblxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuICAgIGlmICgodGhpcy5fcm90YXRhYmxlIHx8IHRoaXMuX3NjYWxhYmxlKSAmJiB0aGlzLnZpc2libGUgJiYgQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gWzAsIDBdXG4gICAgICBjb25zdCByb3QgPSBbMCwgMF1cbiAgICAgIE1hdDJkLnN2ZChudWxsLCBzY2FsZSwgcm90LCB0aGlzLl9mdWxsWGZvcm0pXG4gICAgICBjb25zdCBtYXQgPSBNYXQyZC5jcmVhdGUoKVxuXG4gICAgICBzY2FsZVswXSA9IChzY2FsZVswXSA8IDAgPyAtMSA6IDEpXG4gICAgICBzY2FsZVsxXSA9IChzY2FsZVsxXSA8IDAgPyAtMSA6IDEpXG5cbiAgICAgIGlmIChzY2FsZVswXSAqIHNjYWxlWzFdID4gMCkge1xuICAgICAgICBWZWMyZC5uZWdhdGUocm90LCByb3QpXG4gICAgICB9XG5cbiAgICAgIE1hdDJkLnJvdGF0ZShtYXQsIG1hdCwgcm90WzFdKVxuICAgICAgTWF0MmQuc2NhbGUobWF0LCBtYXQsIHNjYWxlKVxuICAgICAgTWF0MmQucm90YXRlKG1hdCwgbWF0LCByb3RbMF0pXG5cbiAgICAgIGNvbnN0IGJveFBhZGRpbmcgPSAodGhpcy5fcm90YXRhYmxlID8gdGhpcy5faW50ZXJhY3RpdmVCb3hQYWRkaW5nIDogMClcbiAgICAgIGNvbnN0IGhhbGZCb3hTeiA9IHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSAvIDJcbiAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMud2lkdGggLyAyXG4gICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyAyXG4gICAgICBjb25zdCBwdCA9IFswLCAwXVxuICAgICAgY29uc3QgcGFkU3ogPSBoYWxmQm94U3ogKyBib3hQYWRkaW5nXG4gICAgICBjb25zdCBwYWRSYWRpdXMgPSBNYXRoLnNxcnQoMiAqIHBhZFN6ICogcGFkU3opXG4gICAgICBsZXQgeFNjYWxlID0gMFxuICAgICAgbGV0IHlTY2FsZSA9IDBcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBDb25zdGFudHMuU0lERVM7IGkgKz0gMSkge1xuICAgICAgICB4U2NhbGUgPSAoaSA8IDIgPyAtMSA6IDEpXG4gICAgICAgIHlTY2FsZSA9IChpICUgMiA9PT0gMCA/IC0xIDogMSlcbiAgICAgICAgUG9pbnQyZC5zZXQocHQsIHhTY2FsZSAqIGhhbGZXaWR0aCwgeVNjYWxlICogaGFsZkhlaWdodClcbiAgICAgICAgcnRuT2JqID0gaXNQb2ludEluT0JCb3hNb2RpZmllclJlY3Qoc2NyZWVuUHQsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIG1hdCwgaGFsZkJveFN6LCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIHBhZFN6LCBwYWRSYWRpdXMsIHhTY2FsZSwgeVNjYWxlLCBzY2FsZSlcbiAgICAgICAgaWYgKHJ0bk9iai5oaXQpIHtcbiAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gaVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFydG5PYmouaGl0ICYmIHRoaXMuX3NjYWxhYmxlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ29uc3RhbnRzLlNJREVTOyBpICs9IDEpIHtcbiAgICAgICAgICB4U2NhbGUgPSAoaSAlIDIgPT09IDAgPyAoaSA8IDIgPyAtMSA6IDEpIDogMClcbiAgICAgICAgICB5U2NhbGUgPSAoaSAlIDIgPT09IDAgPyAwIDogKGkgPCAyID8gLTEgOiAxKSlcbiAgICAgICAgICBQb2ludDJkLnNldChwdCwgeFNjYWxlICogaGFsZldpZHRoLCB5U2NhbGUgKiBoYWxmSGVpZ2h0KVxuICAgICAgICAgIHJ0bk9iaiA9IGlzUG9pbnRJbk9CQm94TW9kaWZpZXJSZWN0KHNjcmVlblB0LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCBtYXQsIGhhbGZCb3hTeiwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBwYWRTeiwgcGFkUmFkaXVzLCB4U2NhbGUsIHlTY2FsZSwgc2NhbGUpXG4gICAgICAgICAgaWYgKHJ0bk9iai5oaXQpIHtcbiAgICAgICAgICAgIHJ0bk9iai5jb250cm9sSW5kZXggPSBpICsgQ29uc3RhbnRzLlNJREVTXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocnRuT2JqLnJvdGF0ZSAmJiAhdGhpcy5fcm90YXRhYmxlKSB7XG4gICAgICAgIHJ0bk9iai5yb3RhdGUgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmICghcnRuT2JqLnJvdGF0ZSAmJiAhdGhpcy5fc2NhbGFibGUpIHtcbiAgICAgICAgcnRuT2JqLnJvdGF0ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnRuT2JqXG4gIH1cblxuICBfdXBkYXRlbG9jYWx4Zm9ybShmb3JjZSkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCBmb3JjZSkge1xuICAgICAgY29uc3QgcG9zID0gUG9pbnQyZC5jbG9uZSh0aGlzLl9wb3MpXG4gICAgICBQb2ludDJkLmFkZFZlYzIocG9zLCBwb3MsIHRoaXMuX3BhcmVudC5waXZvdFJlZilcbiAgICAgIGJ1aWxkWGZvcm1NYXRyaXgodGhpcy5fbG9jYWxYZm9ybSwgdGhpcy5fcm90RGVnLCB0aGlzLl9zY2FsZSwgcG9zLCB0aGlzLl9waXZvdClcbiAgICAgIGlmICh0aGlzLl9sb2NhbFhmb3JtVXBkYXRlZCkge1xuICAgICAgICB0aGlzLl9sb2NhbFhmb3JtVXBkYXRlZCgpXG4gICAgICB9XG4gICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZWdsb2JhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCB0aGlzLl94Zm9ybURpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVsb2NhbHhmb3JtKHRydWUpXG4gICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgIE1hdDJkLm11bHRpcGx5KHRoaXMuX2dsb2JhbFhmb3JtLCB0aGlzLl9wYXJlbnQuZ2xvYmFsWGZvcm0sIHRoaXMuX2xvY2FsWGZvcm0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNYXQyZC5jb3B5KHRoaXMuX2dsb2JhbFhmb3JtLCB0aGlzLl9sb2NhbFhmb3JtKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2dsb2JhbFhmb3JtVXBkYXRlZCkge1xuICAgICAgICB0aGlzLl9nbG9iYWxYZm9ybVVwZGF0ZWQoKVxuICAgICAgfVxuICAgICAgdGhpcy5feGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgfVxuICB9XG5cblxuICBfdXBkYXRlQUFCb3goZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmIChmb3JjZSB8fCB0aGlzLl9nZW9tRGlydHkgfHwgdGhpcy5fYm91bmRzT3V0T2ZEYXRlKSB7XG4gICAgICBjb25zdCBib3hQYWRkaW5nID0gKHRoaXMuX3JvdGF0YWJsZSA/IHRoaXMuX2ludGVyYWN0aXZlQm94UGFkZGluZyA6IDApXG4gICAgICBjb25zdCBwYWRkaW5nID0gYm94UGFkZGluZyArIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSAvIDJcbiAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHModGhpcy5fYWFib3gsIFswLCAwXSwgW3RoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDJdKVxuICAgICAgQUFCb3gyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl9hYWJveCwgdGhpcy5fYWFib3gsIHRoaXMuX2Z1bGxYZm9ybSlcbiAgICAgIEFBQm94MmQuZXhwYW5kKHRoaXMuX2FhYm94LCB0aGlzLl9hYWJveCwgW3BhZGRpbmcsIHBhZGRpbmddKVxuICAgICAgdGhpcy5fYWFib3hVcGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC53aWR0aCAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMucGFyZW50LndpZHRoIDogMClcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oZWlnaHQgIT09IFwidW5kZWZpbmVkXCIgPyB0aGlzLnBhcmVudC5oZWlnaHQgOiAwKVxuICB9XG5cbiAgcmVuZGVyQm91bmRzKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgYm91bmRzU3Ryb2tlU3R5bGUpIHtcbiAgICAvLyB3ZSdyZSBzdG9yaW5nIG91ciBBQUJveCBpbiBzY3JlZW4gc3BhY2UgaGVyZSwgc28gd29ybGRUb1NjcmVlbk1hdHJpeCBpc1xuICAgIC8vIHVudXNlZFxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgYm91bmRzU3Ryb2tlU3R5bGUuc2V0U3Ryb2tlQ3R4KGN0eClcbiAgICBjb25zdCBjZW50ZXIgPSBbMCwgMF1cbiAgICBjb25zdCBleHRlbnRzID0gWzAsIDBdXG4gICAgQUFCb3gyZC5nZXRDZW50ZXIoY2VudGVyLCBhYWJveClcbiAgICBBQUJveDJkLmdldEV4dGVudHMoZXh0ZW50cywgYWFib3gpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LnJlY3QoY2VudGVyWzBdIC0gZXh0ZW50c1swXSwgY2VudGVyWzFdIC0gZXh0ZW50c1sxXSwgZXh0ZW50c1swXSAqIDIsIGV4dGVudHNbMV0gKiAyKVxuICAgIGN0eC5zdHJva2UoKVxuICAgIGN0eC5yZXN0b3JlKClcbiAgfVxuXG4gIHJlbmRlcihjdHgsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHN0eWxlU3RhdGUpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50IHx8IHR5cGVvZiB0aGlzLnBhcmVudC53aWR0aCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLnBhcmVudC5oZWlnaHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2FhYm94VXBkYXRlZCA9IGZhbHNlXG4gICAgLy8gZG8gbm90IGZpbGwgdGhlIHByaW1hcnkgcmVjdGFuZ2xlXG4gICAgc3VwZXIucmVuZGVyKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgc3R5bGVTdGF0ZSwgZmFsc2UpXG4gICAgaWYgKCF0aGlzLl9hYWJveFVwZGF0ZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFBQm94KHRydWUpXG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgICBjb25zdCByb3QgPSBbMCwgMF1cbiAgICBNYXQyZC5zdmQobnVsbCwgc2NhbGUsIHJvdCwgdGhpcy5fZnVsbFhmb3JtKVxuICAgIHNjYWxlWzBdID0gKHNjYWxlWzBdIDwgMCA/IC0xIDogMSlcbiAgICBzY2FsZVsxXSA9IChzY2FsZVsxXSA8IDAgPyAtMSA6IDEpXG5cbiAgICBjb25zdCBoYWxmQm94U3ogPSB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUgLyAyXG4gICAgY29uc3QgaGFsZldpZHRoID0gdGhpcy53aWR0aCAvIDJcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyAyXG4gICAgY29uc3QgcHQgPSBbaGFsZldpZHRoLCBoYWxmSGVpZ2h0XVxuXG4gICAgY3R4LnNhdmUoKVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUsIFwiM1wiKVxuXG4gICAgUG9pbnQyZC5zZXQocHQsIGhhbGZXaWR0aCwgLWhhbGZIZWlnaHQpXG4gICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUsIFwiMlwiKVxuXG4gICAgUG9pbnQyZC5zZXQocHQsIC1oYWxmV2lkdGgsIC1oYWxmSGVpZ2h0KVxuICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlLCBcIjBcIilcblxuICAgIFBvaW50MmQuc2V0KHB0LCAtaGFsZldpZHRoLCBoYWxmSGVpZ2h0KVxuICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlLCBcIjFcIilcblxuICAgIGlmICh0aGlzLl9zY2FsYWJsZSkge1xuICAgICAgUG9pbnQyZC5zZXQocHQsIDAsIGhhbGZIZWlnaHQpXG4gICAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSlcblxuICAgICAgUG9pbnQyZC5zZXQocHQsIDAsIC1oYWxmSGVpZ2h0KVxuICAgICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUpXG5cbiAgICAgIFBvaW50MmQuc2V0KHB0LCBoYWxmV2lkdGgsIDApXG4gICAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSlcblxuICAgICAgUG9pbnQyZC5zZXQocHQsIC1oYWxmV2lkdGgsIDApXG4gICAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ZpbGxWaXNpYmxlKCkpIHtcbiAgICAgIHN0eWxlU3RhdGUuc2V0RmlsbFN0eWxlKGN0eCwgdGhpcylcbiAgICAgIGN0eC5maWxsKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1N0cm9rZVZpc2libGUoKSkge1xuICAgICAgc3R5bGVTdGF0ZS5zZXRTdHJva2VTdHlsZShjdHgsIHRoaXMpXG4gICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgICBjdHguc3Ryb2tlKClcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2ludGVyYWN0aW9ucy94Zm9ybS1zaGFwZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} CircleOptions\n * @property {number} [radius=10] Radius of the circle in world-space coordinates\n */\n\n/**\n * @class Shape class describing a circle\n * @extends {BaseShape}\n */\nvar Circle = function (_BaseShape) {\n  _inherits(Circle, _BaseShape);\n\n  /**\n   * Creates a new Circle shape\n   * @param  {CircleOptions} [opts]\n   * @return {Circle}\n   */\n  function Circle(opts) {\n    _classCallCheck(this, Circle);\n\n    var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, opts));\n\n    _this._radius = 10;\n    if (typeof opts.radius !== \"undefined\") {\n      _this.radius = opts.radius;\n    }\n    AABox2d.initCenterExtents(_this._aabox, [0, 0], [_this._radius, _this._radius]);\n    return _this;\n  }\n\n  /**\n   * Sets the radius of the circle\n   * @param  {number} radius Radius of circle in world-space coordinates\n   * @return {Circle}        this\n   * @fires {Shape#geomChanged}\n   * @throws {Error} If radius is not a valid number\n   */\n\n\n  _createClass(Circle, [{\n    key: \"getDimensions\",\n\n\n    /**\n     * Gets the untransformed width/height of the circle\n     * @return {Vec2d} Width/height of the circle, untransformed\n     */\n    value: function getDimensions() {\n      var diameter = this.radius * 2;\n      return [diameter, diameter];\n    }\n\n    /**\n     * Gets the untransformed width of the circle\n     * @return {number}\n     */\n\n  }, {\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        var pos = this._pos;\n        var scale = this._scale;\n        var rot = _math2.default.DEG_TO_RAD * this._rotDeg;\n        var cossqr = _math2.default.pow(_math2.default.cos(rot), 2);\n        var sinsqr = _math2.default.pow(_math2.default.sin(rot), 2);\n        var asqr = _math2.default.pow(scale[0] * this._radius, 2);\n        var bsqr = _math2.default.pow(scale[1] * this._radius, 2);\n        var A = _math2.default.sqrt(bsqr * sinsqr + asqr * cossqr);\n        var B = _math2.default.sqrt(asqr * sinsqr + bsqr * cossqr);\n        AABox2d.initCenterExtents(this._aabox, pos, [A, B]);\n        this._geomDirty = false;\n        this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the circle using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.arc(0, 0, this._radius, 0, _math2.default.TWO_PI, false);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Circle\", // NOTE: this much match the name of the class\n        radius: this.radius\n      }, _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"radius\",\n    set: function set(radius) {\n      if (typeof radius !== \"number\") {\n        throw new Error(\"Radius must be a number\");\n      }\n\n      if (radius !== this._radius) {\n        var prev = this._radius;\n        this._radius = radius;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"radius\",\n          prevVal: prev,\n          currVal: this._radius\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets the current radius of the circle\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._radius;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.radius * 2;\n    }\n\n    /**\n     * Gets the untransformed height of the circle\n     * @return {number}\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.radius * 2;\n    }\n  }]);\n\n  return Circle;\n}(_baseShape2.default);\n\nexports.default = Circle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvY2lyY2xlLmpzP2FkOWQiXSwibmFtZXMiOlsiQUFCb3gyZCIsIkNpcmNsZSIsIm9wdHMiLCJfcmFkaXVzIiwicmFkaXVzIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJkaWFtZXRlciIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwicG9zIiwiX3BvcyIsInNjYWxlIiwiX3NjYWxlIiwicm90IiwiTWF0aCIsIkRFR19UT19SQUQiLCJfcm90RGVnIiwiY29zc3FyIiwicG93IiwiY29zIiwic2luc3FyIiwic2luIiwiYXNxciIsImJzcXIiLCJBIiwic3FydCIsIkIiLCJjdHgiLCJhcmMiLCJUV09fUEkiLCJPYmplY3QiLCJhc3NpZ24iLCJ0eXBlIiwiRXJyb3IiLCJwcmV2IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsIkJhc2VTaGFwZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7QUFFQTs7SUFBWUEsTzs7QUFDWjs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7OztBQUtBOzs7O0lBSXFCQyxNOzs7QUFDbkI7Ozs7O0FBS0Esa0JBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFBQSxnSEFDVkEsSUFEVTs7QUFFaEIsVUFBS0MsT0FBTCxHQUFlLEVBQWY7QUFDQSxRQUFJLE9BQU9ELEtBQUtFLE1BQVosS0FBdUIsV0FBM0IsRUFBd0M7QUFDdEMsWUFBS0EsTUFBTCxHQUFjRixLQUFLRSxNQUFuQjtBQUNEO0FBQ0RKLFlBQVFLLGlCQUFSLENBQTBCLE1BQUtDLE1BQS9CLEVBQXVDLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBdkMsRUFBK0MsQ0FBQyxNQUFLSCxPQUFOLEVBQWUsTUFBS0EsT0FBcEIsQ0FBL0M7QUFOZ0I7QUFPakI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFtQ0E7Ozs7b0NBSWdCO0FBQ2QsVUFBTUksV0FBVyxLQUFLSCxNQUFMLEdBQWMsQ0FBL0I7QUFDQSxhQUFPLENBQUNHLFFBQUQsRUFBV0EsUUFBWCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQWdCQTs7Ozs7bUNBS2U7QUFDYixVQUFJLEtBQUtDLFVBQUwsSUFBbUIsS0FBS0MsZ0JBQTVCLEVBQThDO0FBQzVDLFlBQU1DLE1BQU0sS0FBS0MsSUFBakI7QUFDQSxZQUFNQyxRQUFRLEtBQUtDLE1BQW5CO0FBQ0EsWUFBTUMsTUFBTUMsZUFBS0MsVUFBTCxHQUFrQixLQUFLQyxPQUFuQztBQUNBLFlBQU1DLFNBQVNILGVBQUtJLEdBQUwsQ0FBU0osZUFBS0ssR0FBTCxDQUFTTixHQUFULENBQVQsRUFBd0IsQ0FBeEIsQ0FBZjtBQUNBLFlBQU1PLFNBQVNOLGVBQUtJLEdBQUwsQ0FBU0osZUFBS08sR0FBTCxDQUFTUixHQUFULENBQVQsRUFBd0IsQ0FBeEIsQ0FBZjtBQUNBLFlBQU1TLE9BQU9SLGVBQUtJLEdBQUwsQ0FBU1AsTUFBTSxDQUFOLElBQVcsS0FBS1QsT0FBekIsRUFBa0MsQ0FBbEMsQ0FBYjtBQUNBLFlBQU1xQixPQUFPVCxlQUFLSSxHQUFMLENBQVNQLE1BQU0sQ0FBTixJQUFXLEtBQUtULE9BQXpCLEVBQWtDLENBQWxDLENBQWI7QUFDQSxZQUFNc0IsSUFBSVYsZUFBS1csSUFBTCxDQUFVRixPQUFPSCxNQUFQLEdBQWdCRSxPQUFPTCxNQUFqQyxDQUFWO0FBQ0EsWUFBTVMsSUFBSVosZUFBS1csSUFBTCxDQUFVSCxPQUFPRixNQUFQLEdBQWdCRyxPQUFPTixNQUFqQyxDQUFWO0FBQ0FsQixnQkFBUUssaUJBQVIsQ0FBMEIsS0FBS0MsTUFBL0IsRUFBdUNJLEdBQXZDLEVBQTRDLENBQUNlLENBQUQsRUFBSUUsQ0FBSixDQUE1QztBQUNBLGFBQUtuQixVQUFMLEdBQWtCLEtBQWxCO0FBQ0EsYUFBS0MsZ0JBQUwsR0FBd0IsS0FBeEI7QUFDRDtBQUNGOztBQUVEOzs7Ozs7Ozs7MEJBTU1tQixHLEVBQUs7QUFDVEEsVUFBSUMsR0FBSixDQUFRLENBQVIsRUFBVyxDQUFYLEVBQWMsS0FBSzFCLE9BQW5CLEVBQTRCLENBQTVCLEVBQStCWSxlQUFLZSxNQUFwQyxFQUE0QyxLQUE1QztBQUNEOztBQUVEOzs7Ozs7Ozs2QkFLUztBQUNQLGFBQU9DLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxRQURhLEVBQ0g7QUFDaEI3QixnQkFBUSxLQUFLQTtBQUZNLE9BQWQseUdBQVA7QUFJRDs7O3NCQS9GVUEsTSxFQUFRO0FBQ2pCLFVBQUksT0FBT0EsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixjQUFNLElBQUk4QixLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUk5QixXQUFXLEtBQUtELE9BQXBCLEVBQTZCO0FBQzNCLFlBQU1nQyxPQUFPLEtBQUtoQyxPQUFsQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUMsTUFBZjtBQUNBLGFBQUtJLFVBQUwsR0FBa0IsSUFBbEIsQ0FIMkIsQ0FHSjs7QUFFdkIsYUFBSzRCLElBQUwsQ0FBVSxjQUFWLEVBQTBCO0FBQ3hCQyxnQkFBTSxRQURrQjtBQUV4QkMsbUJBQVNILElBRmU7QUFHeEJJLG1CQUFTLEtBQUtwQztBQUhVLFNBQTFCO0FBS0Q7O0FBRUQsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlhO0FBQ1gsYUFBTyxLQUFLQSxPQUFaO0FBQ0Q7Ozt3QkFlVztBQUNWLGFBQU8sS0FBS0MsTUFBTCxHQUFjLENBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7d0JBSWE7QUFDWCxhQUFPLEtBQUtBLE1BQUwsR0FBYyxDQUFyQjtBQUNEOzs7O0VBekVpQ29DLG1COztrQkFBZnZDLE0iLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcbmltcG9ydCBNYXRoIGZyb20gXCIuLi9tYXRoL21hdGhcIlxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IENpcmNsZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkaXVzPTEwXSBSYWRpdXMgb2YgdGhlIGNpcmNsZSBpbiB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICovXG5cbi8qKlxuICogQGNsYXNzIFNoYXBlIGNsYXNzIGRlc2NyaWJpbmcgYSBjaXJjbGVcbiAqIEBleHRlbmRzIHtCYXNlU2hhcGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENpcmNsZSBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IENpcmNsZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtDaXJjbGVPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7Q2lyY2xlfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5fcmFkaXVzID0gMTBcbiAgICBpZiAodHlwZW9mIG9wdHMucmFkaXVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzXG4gICAgfVxuICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHModGhpcy5fYWFib3gsIFswLCAwXSwgW3RoaXMuX3JhZGl1cywgdGhpcy5fcmFkaXVzXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHJhZGl1cyBSYWRpdXMgb2YgY2lyY2xlIGluIHdvcmxkLXNwYWNlIGNvb3JkaW5hdGVzXG4gICAqIEByZXR1cm4ge0NpcmNsZX0gICAgICAgIHRoaXNcbiAgICogQGZpcmVzIHtTaGFwZSNnZW9tQ2hhbmdlZH1cbiAgICogQHRocm93cyB7RXJyb3J9IElmIHJhZGl1cyBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICovXG4gIHNldCByYWRpdXMocmFkaXVzKSB7XG4gICAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhZGl1cyBtdXN0IGJlIGEgbnVtYmVyXCIpXG4gICAgfVxuXG4gICAgaWYgKHJhZGl1cyAhPT0gdGhpcy5fcmFkaXVzKSB7XG4gICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcmFkaXVzXG4gICAgICB0aGlzLl9yYWRpdXMgPSByYWRpdXNcbiAgICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWUgLy8gZGlydHkgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSBmaXJpbmcgZXZlbnRcblxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tXCIsIHtcbiAgICAgICAgYXR0cjogXCJyYWRpdXNcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogdGhpcy5fcmFkaXVzXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgcmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLl9yYWRpdXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bnRyYW5zZm9ybWVkIHdpZHRoL2hlaWdodCBvZiB0aGUgY2lyY2xlXG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9oZWlnaHQgb2YgdGhlIGNpcmNsZSwgdW50cmFuc2Zvcm1lZFxuICAgKi9cbiAgZ2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBkaWFtZXRlciA9IHRoaXMucmFkaXVzICogMlxuICAgIHJldHVybiBbZGlhbWV0ZXIsIGRpYW1ldGVyXVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIGNpcmNsZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzICogMlxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVudHJhbnNmb3JtZWQgaGVpZ2h0IG9mIHRoZSBjaXJjbGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5yYWRpdXMgKiAyXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCByZXF1aXJlcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fZ2VvbURpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSkge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5fcG9zXG4gICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX3NjYWxlXG4gICAgICBjb25zdCByb3QgPSBNYXRoLkRFR19UT19SQUQgKiB0aGlzLl9yb3REZWdcbiAgICAgIGNvbnN0IGNvc3NxciA9IE1hdGgucG93KE1hdGguY29zKHJvdCksIDIpXG4gICAgICBjb25zdCBzaW5zcXIgPSBNYXRoLnBvdyhNYXRoLnNpbihyb3QpLCAyKVxuICAgICAgY29uc3QgYXNxciA9IE1hdGgucG93KHNjYWxlWzBdICogdGhpcy5fcmFkaXVzLCAyKVxuICAgICAgY29uc3QgYnNxciA9IE1hdGgucG93KHNjYWxlWzFdICogdGhpcy5fcmFkaXVzLCAyKVxuICAgICAgY29uc3QgQSA9IE1hdGguc3FydChic3FyICogc2luc3FyICsgYXNxciAqIGNvc3NxcilcbiAgICAgIGNvbnN0IEIgPSBNYXRoLnNxcnQoYXNxciAqIHNpbnNxciArIGJzcXIgKiBjb3NzcXIpXG4gICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBwb3MsIFtBLCBCXSlcbiAgICAgIHRoaXMuX2dlb21EaXJ0eSA9IGZhbHNlXG4gICAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgY2lyY2xlIHVzaW5nIGEgMmQgcmVuZGVyaW5nIGNvbnRleHQuIENhbGxlZCBieSB0aGUgQmFzZVNoYXBlXG4gICAqIGNsYXNzXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4IDJkIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX2RyYXcoY3R4KSB7XG4gICAgY3R4LmFyYygwLCAwLCB0aGlzLl9yYWRpdXMsIDAsIE1hdGguVFdPX1BJLCBmYWxzZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgdG8gY29udmVydCB0aGUgc2hhcGUgdG8gYSBzZXJpYWxpemFibGUgSlNPTiBvYmplY3RcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7XG4gICAgICB0eXBlOiBcIkNpcmNsZVwiLCAvLyBOT1RFOiB0aGlzIG11Y2ggbWF0Y2ggdGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgICByYWRpdXM6IHRoaXMucmFkaXVzXG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL2NpcmNsZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _mat2d = __webpack_require__(4);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} PointOptions\n * @property {number} [size=5] Size of the point in pixels\n */\n\n/**\n * @class Point shape class. A point differs from a circle in that\n *        a point's size is defined in screen/pixel space whereas\n *        a circle is defined in world space.\n * @extends {BaseShape}\n */\nvar Point = function (_BaseShape) {\n  _inherits(Point, _BaseShape);\n\n  /**\n   * Creates a new point shape\n   * @param  {PointOptions} [opts]\n   * @return {Point}\n   */\n  function Point(opts) {\n    _classCallCheck(this, Point);\n\n    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, opts));\n\n    _this._size = 5;\n    if (typeof opts.size !== \"undefined\") {\n      _this.size = opts.size;\n    }\n    AABox2d.initCenterExtents(_this._aabox, [0, 0], [_this._radius, _this._radius]);\n    _this.translate(opts.x || 0, opts.y || 0);\n    return _this;\n  }\n\n  /**\n   * Sets the size of the point\n   * @param  {nuber} size Size of the point in pixels\n   * @return {Pixel}      this\n   * @fires {Shape#geomChanged}\n   * @throws {Error} If size is not a valid number\n   */\n\n\n  _createClass(Point, [{\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        var pos = this._pos;\n        var scale = this._scale;\n        var rot = _math2.default.DEG_TO_RAD * this._rotDeg;\n        var cossqr = _math2.default.pow(_math2.default.cos(rot), 2);\n        var sinsqr = _math2.default.pow(_math2.default.sin(rot), 2);\n        var asqr = _math2.default.pow(scale[0] * this._size, 2);\n        var bsqr = _math2.default.pow(scale[1] * this._size, 2);\n        var A = _math2.default.sqrt(bsqr * sinsqr + asqr * cossqr);\n        var B = _math2.default.sqrt(asqr * sinsqr + bsqr * cossqr);\n        AABox2d.initCenterExtents(this._aabox, pos, [A, B]);\n        this._geomDirty = false;\n        this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the point using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      var pos = [0, 0];\n      _mat2d2.default.svd(pos, null, null, this._fullXform);\n      ctx.arc(pos[0], pos[1], this._size, 0, _math2.default.TWO_PI, false);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Point\", // NOTE: this much match the name of the class\n        size: this.size\n      }, _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"size\",\n    set: function set(size) {\n      if (typeof size !== \"number\") {\n        throw new Error(\"Radius must be a number\");\n      }\n\n      if (size !== this._size) {\n        var prev = this._size;\n        this._size = size;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"size\",\n          prevVal: prev,\n          currVal: this._size\n        });\n      }\n    }\n\n    /**\n     * Gets the current size of the point\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._size;\n    }\n  }]);\n\n  return Point;\n}(_baseShape2.default);\n\nexports.default = Point;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9pbnQuanM/OWY2OSJdLCJuYW1lcyI6WyJBQUJveDJkIiwiUG9pbnQiLCJvcHRzIiwiX3NpemUiLCJzaXplIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJfcmFkaXVzIiwidHJhbnNsYXRlIiwieCIsInkiLCJfZ2VvbURpcnR5IiwiX2JvdW5kc091dE9mRGF0ZSIsInBvcyIsIl9wb3MiLCJzY2FsZSIsIl9zY2FsZSIsInJvdCIsIk1hdGgiLCJERUdfVE9fUkFEIiwiX3JvdERlZyIsImNvc3NxciIsInBvdyIsImNvcyIsInNpbnNxciIsInNpbiIsImFzcXIiLCJic3FyIiwiQSIsInNxcnQiLCJCIiwiY3R4Iiwic2V0VHJhbnNmb3JtIiwiTWF0MmQiLCJzdmQiLCJfZnVsbFhmb3JtIiwiYXJjIiwiVFdPX1BJIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsIkVycm9yIiwicHJldiIsImZpcmUiLCJhdHRyIiwicHJldlZhbCIsImN1cnJWYWwiLCJCYXNlU2hhcGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7OztBQUtBOzs7Ozs7SUFNcUJDLEs7OztBQUNuQjs7Ozs7QUFLQSxpQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLDhHQUNWQSxJQURVOztBQUVoQixVQUFLQyxLQUFMLEdBQWEsQ0FBYjtBQUNBLFFBQUksT0FBT0QsS0FBS0UsSUFBWixLQUFxQixXQUF6QixFQUFzQztBQUNwQyxZQUFLQSxJQUFMLEdBQVlGLEtBQUtFLElBQWpCO0FBQ0Q7QUFDREosWUFBUUssaUJBQVIsQ0FBMEIsTUFBS0MsTUFBL0IsRUFBdUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUF2QyxFQUErQyxDQUFDLE1BQUtDLE9BQU4sRUFBZSxNQUFLQSxPQUFwQixDQUEvQztBQUNBLFVBQUtDLFNBQUwsQ0FBZU4sS0FBS08sQ0FBTCxJQUFVLENBQXpCLEVBQTRCUCxLQUFLUSxDQUFMLElBQVUsQ0FBdEM7QUFQZ0I7QUFRakI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7Ozs7O21DQUtlO0FBQ2IsVUFBSSxLQUFLQyxVQUFMLElBQW1CLEtBQUtDLGdCQUE1QixFQUE4QztBQUM1QyxZQUFNQyxNQUFNLEtBQUtDLElBQWpCO0FBQ0EsWUFBTUMsUUFBUSxLQUFLQyxNQUFuQjtBQUNBLFlBQU1DLE1BQU1DLGVBQUtDLFVBQUwsR0FBa0IsS0FBS0MsT0FBbkM7QUFDQSxZQUFNQyxTQUFTSCxlQUFLSSxHQUFMLENBQVNKLGVBQUtLLEdBQUwsQ0FBU04sR0FBVCxDQUFULEVBQXdCLENBQXhCLENBQWY7QUFDQSxZQUFNTyxTQUFTTixlQUFLSSxHQUFMLENBQVNKLGVBQUtPLEdBQUwsQ0FBU1IsR0FBVCxDQUFULEVBQXdCLENBQXhCLENBQWY7QUFDQSxZQUFNUyxPQUFPUixlQUFLSSxHQUFMLENBQVNQLE1BQU0sQ0FBTixJQUFXLEtBQUtaLEtBQXpCLEVBQWdDLENBQWhDLENBQWI7QUFDQSxZQUFNd0IsT0FBT1QsZUFBS0ksR0FBTCxDQUFTUCxNQUFNLENBQU4sSUFBVyxLQUFLWixLQUF6QixFQUFnQyxDQUFoQyxDQUFiO0FBQ0EsWUFBTXlCLElBQUlWLGVBQUtXLElBQUwsQ0FBVUYsT0FBT0gsTUFBUCxHQUFnQkUsT0FBT0wsTUFBakMsQ0FBVjtBQUNBLFlBQU1TLElBQUlaLGVBQUtXLElBQUwsQ0FBVUgsT0FBT0YsTUFBUCxHQUFnQkcsT0FBT04sTUFBakMsQ0FBVjtBQUNBckIsZ0JBQVFLLGlCQUFSLENBQTBCLEtBQUtDLE1BQS9CLEVBQXVDTyxHQUF2QyxFQUE0QyxDQUFDZSxDQUFELEVBQUlFLENBQUosQ0FBNUM7QUFDQSxhQUFLbkIsVUFBTCxHQUFrQixLQUFsQjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCLEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OzBCQU1NbUIsRyxFQUFLO0FBQ1RBLFVBQUlDLFlBQUosQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEM7QUFDQSxVQUFNbkIsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQW9CLHNCQUFNQyxHQUFOLENBQVVyQixHQUFWLEVBQWUsSUFBZixFQUFxQixJQUFyQixFQUEyQixLQUFLc0IsVUFBaEM7QUFDQUosVUFBSUssR0FBSixDQUFRdkIsSUFBSSxDQUFKLENBQVIsRUFBZ0JBLElBQUksQ0FBSixDQUFoQixFQUF3QixLQUFLVixLQUE3QixFQUFvQyxDQUFwQyxFQUF1Q2UsZUFBS21CLE1BQTVDLEVBQW9ELEtBQXBEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZCQUtTO0FBQ1AsYUFBT0MsT0FBT0MsTUFBUCxDQUFjO0FBQ25CQyxjQUFNLE9BRGEsRUFDSjtBQUNmcEMsY0FBTSxLQUFLQTtBQUZRLE9BQWQsdUdBQVA7QUFJRDs7O3NCQXZFUUEsSSxFQUFNO0FBQ2IsVUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLGNBQU0sSUFBSXFDLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7O0FBRUQsVUFBSXJDLFNBQVMsS0FBS0QsS0FBbEIsRUFBeUI7QUFDdkIsWUFBTXVDLE9BQU8sS0FBS3ZDLEtBQWxCO0FBQ0EsYUFBS0EsS0FBTCxHQUFhQyxJQUFiO0FBQ0EsYUFBS08sVUFBTCxHQUFrQixJQUFsQixDQUh1QixDQUdBOztBQUV2QixhQUFLZ0MsSUFBTCxDQUFVLGNBQVYsRUFBMEI7QUFDeEJDLGdCQUFNLE1BRGtCO0FBRXhCQyxtQkFBU0gsSUFGZTtBQUd4QkksbUJBQVMsS0FBSzNDO0FBSFUsU0FBMUI7QUFLRDtBQUNGOztBQUVEOzs7Ozt3QkFJVztBQUNULGFBQU8sS0FBS0EsS0FBWjtBQUNEOzs7O0VBL0NnQzRDLG1COztrQkFBZDlDLEsiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQb2ludE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZT01XSBTaXplIG9mIHRoZSBwb2ludCBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBQb2ludCBzaGFwZSBjbGFzcy4gQSBwb2ludCBkaWZmZXJzIGZyb20gYSBjaXJjbGUgaW4gdGhhdFxuICogICAgICAgIGEgcG9pbnQncyBzaXplIGlzIGRlZmluZWQgaW4gc2NyZWVuL3BpeGVsIHNwYWNlIHdoZXJlYXNcbiAqICAgICAgICBhIGNpcmNsZSBpcyBkZWZpbmVkIGluIHdvcmxkIHNwYWNlLlxuICogQGV4dGVuZHMge0Jhc2VTaGFwZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwb2ludCBzaGFwZVxuICAgKiBAcGFyYW0gIHtQb2ludE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3NpemUgPSA1XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZVxuICAgIH1cbiAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c10pXG4gICAgdGhpcy50cmFuc2xhdGUob3B0cy54IHx8IDAsIG9wdHMueSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHBvaW50XG4gICAqIEBwYXJhbSAge251YmVyfSBzaXplIFNpemUgb2YgdGhlIHBvaW50IGluIHBpeGVsc1xuICAgKiBAcmV0dXJuIHtQaXhlbH0gICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzaXplIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgKi9cbiAgc2V0IHNpemUoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFkaXVzIG11c3QgYmUgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSAhPT0gdGhpcy5fc2l6ZSkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3NpemVcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwic2l6ZVwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl9zaXplXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHBvaW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCByZXF1aXJlcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fZ2VvbURpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSkge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5fcG9zXG4gICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX3NjYWxlXG4gICAgICBjb25zdCByb3QgPSBNYXRoLkRFR19UT19SQUQgKiB0aGlzLl9yb3REZWdcbiAgICAgIGNvbnN0IGNvc3NxciA9IE1hdGgucG93KE1hdGguY29zKHJvdCksIDIpXG4gICAgICBjb25zdCBzaW5zcXIgPSBNYXRoLnBvdyhNYXRoLnNpbihyb3QpLCAyKVxuICAgICAgY29uc3QgYXNxciA9IE1hdGgucG93KHNjYWxlWzBdICogdGhpcy5fc2l6ZSwgMilcbiAgICAgIGNvbnN0IGJzcXIgPSBNYXRoLnBvdyhzY2FsZVsxXSAqIHRoaXMuX3NpemUsIDIpXG4gICAgICBjb25zdCBBID0gTWF0aC5zcXJ0KGJzcXIgKiBzaW5zcXIgKyBhc3FyICogY29zc3FyKVxuICAgICAgY29uc3QgQiA9IE1hdGguc3FydChhc3FyICogc2luc3FyICsgYnNxciAqIGNvc3NxcilcbiAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHModGhpcy5fYWFib3gsIHBvcywgW0EsIEJdKVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gZmFsc2VcbiAgICAgIHRoaXMuX2JvdW5kc091dE9mRGF0ZSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBwb2ludCB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjb25zdCBwb3MgPSBbMCwgMF1cbiAgICBNYXQyZC5zdmQocG9zLCBudWxsLCBudWxsLCB0aGlzLl9mdWxsWGZvcm0pXG4gICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgdGhpcy5fc2l6ZSwgMCwgTWF0aC5UV09fUEksIGZhbHNlKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBjb252ZXJ0IHRoZSBzaGFwZSB0byBhIHNlcmlhbGl6YWJsZSBKU09OIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IFwiUG9pbnRcIiwgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgc2l6ZTogdGhpcy5zaXplXG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3BvaW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _polyLine = __webpack_require__(10);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Constants = {\n  MINIMUM_POINTS: 3\n};\n\nvar Poly = function (_PolyLine) {\n  _inherits(Poly, _PolyLine);\n\n  function Poly(opts) {\n    _classCallCheck(this, Poly);\n\n    var _this = _possibleConstructorReturn(this, (Poly.__proto__ || Object.getPrototypeOf(Poly)).call(this, opts));\n\n    if (_this._verts.length < Constants.MINIMUM_POINTS) {\n      throw new Error(\"Poly shapes must be initialized with an array of 2d points and contain at least 3 points\");\n    }\n    return _this;\n  }\n\n  _createClass(Poly, [{\n    key: \"removeVert\",\n    value: function removeVert(vertIndex) {\n      if (this._verts.length < Constants.MINIMUM_POINTS) {\n        throw new Error(\"Cannot remove vertex \" + vertIndex + \". It would result in a poly with < 3 points. A poly must contain at least 3 points.\");\n      }\n\n      _get(Poly.prototype.__proto__ || Object.getPrototypeOf(Poly.prototype), \"removeVert\", this).call(this, vertIndex);\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      var rtn = false;\n      if (this._verts.length >= Constants.MINIMUM_POINTS) {\n        ctx.moveTo(this._verts[0][0], this._verts[0][1]);\n        for (var i = 1; i < this._verts.length; i += 1) {\n          ctx.lineTo(this._verts[i][0], this._verts[i][1]);\n        }\n        ctx.closePath();\n        rtn = true;\n      }\n      return rtn;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign(_get(Poly.prototype.__proto__ || Object.getPrototypeOf(Poly.prototype), \"toJSON\", this).call(this), {\n        type: \"Poly\" // NOTE: this much match the name of the class\n        // This is also supplied after the super.toJSON()\n        // so that this type overrides the parent class's\n        // type\n      });\n    }\n  }]);\n\n  return Poly;\n}(_polyLine2.default);\n\nexports.default = Poly;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9seS5qcz8zNmZiIl0sIm5hbWVzIjpbIkNvbnN0YW50cyIsIk1JTklNVU1fUE9JTlRTIiwiUG9seSIsIm9wdHMiLCJfdmVydHMiLCJsZW5ndGgiLCJFcnJvciIsInZlcnRJbmRleCIsImN0eCIsInJ0biIsIm1vdmVUbyIsImkiLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJPYmplY3QiLCJhc3NpZ24iLCJ0eXBlIiwiUG9seUxpbmUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7OztBQUVBLElBQU1BLFlBQVk7QUFDaEJDLGtCQUFnQjtBQURBLENBQWxCOztJQUlxQkMsSTs7O0FBQ25CLGdCQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsNEdBQ1ZBLElBRFU7O0FBRWhCLFFBQUksTUFBS0MsTUFBTCxDQUFZQyxNQUFaLEdBQXFCTCxVQUFVQyxjQUFuQyxFQUFtRDtBQUNqRCxZQUFNLElBQUlLLEtBQUosQ0FBVSwwRkFBVixDQUFOO0FBQ0Q7QUFKZTtBQUtqQjs7OzsrQkFFVUMsUyxFQUFXO0FBQ3BCLFVBQUksS0FBS0gsTUFBTCxDQUFZQyxNQUFaLEdBQXFCTCxVQUFVQyxjQUFuQyxFQUFtRDtBQUNqRCxjQUFNLElBQUlLLEtBQUosMkJBQWtDQyxTQUFsQyx5RkFBTjtBQUNEOztBQUVELDZHQUFpQkEsU0FBakI7QUFDRDs7OzBCQUdLQyxHLEVBQUs7QUFDVCxVQUFJQyxNQUFNLEtBQVY7QUFDQSxVQUFJLEtBQUtMLE1BQUwsQ0FBWUMsTUFBWixJQUFzQkwsVUFBVUMsY0FBcEMsRUFBb0Q7QUFDbERPLFlBQUlFLE1BQUosQ0FBVyxLQUFLTixNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBWCxFQUE4QixLQUFLQSxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsQ0FBOUI7QUFDQSxhQUFLLElBQUlPLElBQUksQ0FBYixFQUFnQkEsSUFBSSxLQUFLUCxNQUFMLENBQVlDLE1BQWhDLEVBQXdDTSxLQUFLLENBQTdDLEVBQWdEO0FBQzlDSCxjQUFJSSxNQUFKLENBQVcsS0FBS1IsTUFBTCxDQUFZTyxDQUFaLEVBQWUsQ0FBZixDQUFYLEVBQThCLEtBQUtQLE1BQUwsQ0FBWU8sQ0FBWixFQUFlLENBQWYsQ0FBOUI7QUFDRDtBQUNESCxZQUFJSyxTQUFKO0FBQ0FKLGNBQU0sSUFBTjtBQUNEO0FBQ0QsYUFBT0EsR0FBUDtBQUNEOzs7NkJBRVE7QUFDUCxhQUFPSyxPQUFPQyxNQUFQLHFHQUE4QjtBQUNuQ0MsY0FBTSxNQUQ2QixDQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUpzQixPQUE5QixDQUFQO0FBTUQ7Ozs7RUFyQytCQyxrQjs7a0JBQWJmLEkiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgUG9seUxpbmUgZnJvbSBcIi4vcG9seS1saW5lXCJcblxuY29uc3QgQ29uc3RhbnRzID0ge1xuICBNSU5JTVVNX1BPSU5UUzogM1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5IGV4dGVuZHMgUG9seUxpbmUge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICBpZiAodGhpcy5fdmVydHMubGVuZ3RoIDwgQ29uc3RhbnRzLk1JTklNVU1fUE9JTlRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb2x5IHNoYXBlcyBtdXN0IGJlIGluaXRpYWxpemVkIHdpdGggYW4gYXJyYXkgb2YgMmQgcG9pbnRzIGFuZCBjb250YWluIGF0IGxlYXN0IDMgcG9pbnRzXCIpXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlVmVydCh2ZXJ0SW5kZXgpIHtcbiAgICBpZiAodGhpcy5fdmVydHMubGVuZ3RoIDwgQ29uc3RhbnRzLk1JTklNVU1fUE9JTlRTKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgdmVydGV4ICR7dmVydEluZGV4fS4gSXQgd291bGQgcmVzdWx0IGluIGEgcG9seSB3aXRoIDwgMyBwb2ludHMuIEEgcG9seSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgMyBwb2ludHMuYClcbiAgICB9XG5cbiAgICBzdXBlci5yZW1vdmVWZXJ0KHZlcnRJbmRleClcbiAgfVxuXG5cbiAgX2RyYXcoY3R4KSB7XG4gICAgbGV0IHJ0biA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA+PSBDb25zdGFudHMuTUlOSU1VTV9QT0lOVFMpIHtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5fdmVydHNbMF1bMF0sIHRoaXMuX3ZlcnRzWzBdWzFdKVxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl92ZXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjdHgubGluZVRvKHRoaXMuX3ZlcnRzW2ldWzBdLCB0aGlzLl92ZXJ0c1tpXVsxXSlcbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZVBhdGgoKVxuICAgICAgcnRuID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gcnRuXG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oc3VwZXIudG9KU09OKCksIHtcbiAgICAgIHR5cGU6IFwiUG9seVwiIC8vIE5PVEU6IHRoaXMgbXVjaCBtYXRjaCB0aGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFsc28gc3VwcGxpZWQgYWZ0ZXIgdGhlIHN1cGVyLnRvSlNPTigpXG4gICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB0aGlzIHR5cGUgb3ZlcnJpZGVzIHRoZSBwYXJlbnQgY2xhc3Mnc1xuICAgICAgICAgICAgICAgICAgIC8vIHR5cGVcbiAgICB9KVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaGFwZXMvcG9seS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 26 */
/***/ (function(module, exports) {

	eval("/* eslint-disable func-names */\n\"use strict\";\n\n/**\n * Gets the pixel ratio of a specific HTML canvas 2d context\n * @param  {CanvasRenderingContext2D} canvasCtx\n * @return {number}           pixel ratio of the canvas 2d context\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPixelRatio = getPixelRatio;\nexports.makeCanvasAutoHighDPI = makeCanvasAutoHighDPI;\nfunction getPixelRatio(canvasCtx) {\n  var backingStore = canvasCtx.backingStorePixelRatio || canvasCtx.webkitBackingStorePixelRatio || canvasCtx.mozBackingStorePixelRatio || canvasCtx.msBackingStorePixelRatio || canvasCtx.oBackingStorePixelRatio || canvasCtx.backingStorePixelRatio || 1;\n\n  return (window.devicePixelRatio || 1) / backingStore;\n}\n\n/**\n * Wraps certain canvas 2d context APIs to handle\n * displays with high per-pixel ratios. This is useful\n * so that the API can be called with screen-space coordinates\n * and the wrappers modify the arguments of those APIs to properly\n * handle displays with high pixel densities\n * @param  {CanvasRenderingContext2D} canvasCtx\n * @return {number}           pixel ratio of the wrapped canvas context\n */\nfunction makeCanvasAutoHighDPI(canvasCtx) {\n  var pixelRatio = getPixelRatio(canvasCtx);\n\n  if (pixelRatio === 1) {\n    return 1;\n  }\n\n  var allRatioArgs = [\"fillRect\", \"clearRect\", \"strokeRect\",\n  // \"moveTo\",\n  // \"lineTo\",\n  // \"arcTo\",\n  // \"bezierCurveTo\",\n  \"isPointInPath\", \"isPointInStroke\"\n  // \"quadraticCurveTo\",\n  // \"rect\",\n  // \"translate\",\n  // \"createRadialGradient\",\n  // \"createLinearGradient\"\n  ];\n\n  allRatioArgs.forEach(function (funcName) {\n    canvasCtx[funcName] = function (_super) {\n      return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        args = args.map(function (a) {\n          return a * pixelRatio;\n        });\n\n        return _super.apply(this, args);\n      };\n    }(canvasCtx[funcName]);\n  });\n\n  // const ratioArgsByIndex = {\n  //   arc: [0, 1, 2]\n  // }\n\n  // Object.getOwnPropertyNames(ratioArgsByIndex).forEach(funcName => {\n  //   const value = ratioArgsByIndex[funcName]\n  //   canvasCtx[funcName] = (function(_super) {\n  //     return function(...args) {\n  //       let i = 0\n  //       let len = 0\n  //       for (i = 0, len = value.length; i < len; i += 1) {\n  //         args[value[i]] *= pixelRatio\n  //       }\n  //       return _super.apply(this, args)\n  //     }\n  //   })(canvasCtx[funcName])\n  // })\n\n  // // Stroke lineWidth adjustment\n  // canvasCtx.stroke = (function(_super) {\n  //   return function(...args) {\n  //     this.lineWidth *= pixelRatio\n  //     _super.apply(this, args)\n  //     this.lineWidth /= pixelRatio\n  //   }\n  // })(canvasCtx.stroke)\n\n  // // Text\n  // //\n  // canvasCtx.fillText = (function(_super) {\n  //   return function(...args) {\n  //     args[1] *= pixelRatio // x\n  //     args[2] *= pixelRatio // y\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m * pixelRatio) + u\n  //       }\n  //     )\n\n  //     _super.apply(this, args)\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m / pixelRatio) + u\n  //       }\n  //     )\n  //   }\n  // })(canvasCtx.fillText)\n\n  // canvasCtx.strokeText = (function(_super) {\n  //   return function(...args) {\n  //     args[1] *= pixelRatio // x\n  //     args[2] *= pixelRatio // y\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m * pixelRatio) + u\n  //       }\n  //     )\n\n  //     _super.apply(this, args)\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m / pixelRatio) + u\n  //       }\n  //     )\n  //   }\n  // })(canvasCtx.strokeText)\n\n\n  var setTransformArgs = [pixelRatio, 0, 0, pixelRatio, 0, 0];\n  canvasCtx.setTransform = function (_super) {\n    return function () {\n      _super.apply(this, setTransformArgs);\n      this.transform.apply(this, arguments);\n    };\n  }(canvasCtx.setTransform);\n\n  return pixelRatio;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2NhbnZhcy11dGlscy5qcz84MjExIl0sIm5hbWVzIjpbImdldFBpeGVsUmF0aW8iLCJtYWtlQ2FudmFzQXV0b0hpZ2hEUEkiLCJjYW52YXNDdHgiLCJiYWNraW5nU3RvcmUiLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJwaXhlbFJhdGlvIiwiYWxsUmF0aW9BcmdzIiwiZm9yRWFjaCIsImZ1bmNOYW1lIiwiX3N1cGVyIiwiYXJncyIsIm1hcCIsImEiLCJhcHBseSIsInNldFRyYW5zZm9ybUFyZ3MiLCJzZXRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztRQUtnQkEsYSxHQUFBQSxhO1FBb0JBQyxxQixHQUFBQSxxQjtBQXBCVCxTQUFTRCxhQUFULENBQXVCRSxTQUF2QixFQUFrQztBQUN2QyxNQUFNQyxlQUFlRCxVQUFVRSxzQkFBVixJQUNuQkYsVUFBVUcsNEJBRFMsSUFFbkJILFVBQVVJLHlCQUZTLElBR25CSixVQUFVSyx3QkFIUyxJQUluQkwsVUFBVU0sdUJBSlMsSUFLbkJOLFVBQVVFLHNCQUxTLElBS2lCLENBTHRDOztBQU9BLFNBQU8sQ0FBQ0ssT0FBT0MsZ0JBQVAsSUFBMkIsQ0FBNUIsSUFBaUNQLFlBQXhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNPLFNBQVNGLHFCQUFULENBQStCQyxTQUEvQixFQUEwQztBQUMvQyxNQUFNUyxhQUFhWCxjQUFjRSxTQUFkLENBQW5COztBQUVBLE1BQUlTLGVBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsV0FBTyxDQUFQO0FBQ0Q7O0FBRUQsTUFBTUMsZUFBZSxDQUNuQixVQURtQixFQUVuQixXQUZtQixFQUduQixZQUhtQjtBQUluQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQVJtQixFQVNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkbUIsR0FBckI7O0FBaUJBQSxlQUFhQyxPQUFiLENBQXFCLG9CQUFZO0FBQy9CWCxjQUFVWSxRQUFWLElBQXVCLFVBQVNDLE1BQVQsRUFBaUI7QUFDdEMsYUFBTyxZQUFrQjtBQUFBLDBDQUFOQyxJQUFNO0FBQU5BLGNBQU07QUFBQTs7QUFDdkJBLGVBQU9BLEtBQUtDLEdBQUwsQ0FBUyxVQUFDQyxDQUFEO0FBQUEsaUJBQU9BLElBQUlQLFVBQVg7QUFBQSxTQUFULENBQVA7O0FBRUEsZUFBT0ksT0FBT0ksS0FBUCxDQUFhLElBQWIsRUFBbUJILElBQW5CLENBQVA7QUFDRCxPQUpEO0FBS0QsS0FOcUIsQ0FNbkJkLFVBQVVZLFFBQVYsQ0FObUIsQ0FBdEI7QUFPRCxHQVJEOztBQVVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsTUFBTU0sbUJBQW1CLENBQUNULFVBQUQsRUFBYSxDQUFiLEVBQWdCLENBQWhCLEVBQW1CQSxVQUFuQixFQUErQixDQUEvQixFQUFrQyxDQUFsQyxDQUF6QjtBQUNBVCxZQUFVbUIsWUFBVixHQUEwQixVQUFTTixNQUFULEVBQWlCO0FBQ3pDLFdBQU8sWUFBa0I7QUFDdkJBLGFBQU9JLEtBQVAsQ0FBYSxJQUFiLEVBQW1CQyxnQkFBbkI7QUFDQSxXQUFLRSxTQUFMO0FBQ0QsS0FIRDtBQUlELEdBTHdCLENBS3RCcEIsVUFBVW1CLFlBTFksQ0FBekI7O0FBT0EsU0FBT1YsVUFBUDtBQUNEIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZnVuYy1uYW1lcyAqL1xuXCJ1c2Ugc3RyaWN0XCJcblxuLyoqXG4gKiBHZXRzIHRoZSBwaXhlbCByYXRpbyBvZiBhIHNwZWNpZmljIEhUTUwgY2FudmFzIDJkIGNvbnRleHRcbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY2FudmFzQ3R4XG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzIDJkIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oY2FudmFzQ3R4KSB7XG4gIGNvbnN0IGJhY2tpbmdTdG9yZSA9IGNhbnZhc0N0eC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY2FudmFzQ3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgIGNhbnZhc0N0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxXG5cbiAgcmV0dXJuICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAvIGJhY2tpbmdTdG9yZVxufVxuXG4vKipcbiAqIFdyYXBzIGNlcnRhaW4gY2FudmFzIDJkIGNvbnRleHQgQVBJcyB0byBoYW5kbGVcbiAqIGRpc3BsYXlzIHdpdGggaGlnaCBwZXItcGl4ZWwgcmF0aW9zLiBUaGlzIGlzIHVzZWZ1bFxuICogc28gdGhhdCB0aGUgQVBJIGNhbiBiZSBjYWxsZWQgd2l0aCBzY3JlZW4tc3BhY2UgY29vcmRpbmF0ZXNcbiAqIGFuZCB0aGUgd3JhcHBlcnMgbW9kaWZ5IHRoZSBhcmd1bWVudHMgb2YgdGhvc2UgQVBJcyB0byBwcm9wZXJseVxuICogaGFuZGxlIGRpc3BsYXlzIHdpdGggaGlnaCBwaXhlbCBkZW5zaXRpZXNcbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY2FudmFzQ3R4XG4gKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICBwaXhlbCByYXRpbyBvZiB0aGUgd3JhcHBlZCBjYW52YXMgY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUNhbnZhc0F1dG9IaWdoRFBJKGNhbnZhc0N0eCkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbyhjYW52YXNDdHgpXG5cbiAgaWYgKHBpeGVsUmF0aW8gPT09IDEpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgY29uc3QgYWxsUmF0aW9BcmdzID0gW1xuICAgIFwiZmlsbFJlY3RcIixcbiAgICBcImNsZWFyUmVjdFwiLFxuICAgIFwic3Ryb2tlUmVjdFwiLFxuICAgIC8vIFwibW92ZVRvXCIsXG4gICAgLy8gXCJsaW5lVG9cIixcbiAgICAvLyBcImFyY1RvXCIsXG4gICAgLy8gXCJiZXppZXJDdXJ2ZVRvXCIsXG4gICAgXCJpc1BvaW50SW5QYXRoXCIsXG4gICAgXCJpc1BvaW50SW5TdHJva2VcIlxuICAgIC8vIFwicXVhZHJhdGljQ3VydmVUb1wiLFxuICAgIC8vIFwicmVjdFwiLFxuICAgIC8vIFwidHJhbnNsYXRlXCIsXG4gICAgLy8gXCJjcmVhdGVSYWRpYWxHcmFkaWVudFwiLFxuICAgIC8vIFwiY3JlYXRlTGluZWFyR3JhZGllbnRcIlxuICBdXG5cbiAgYWxsUmF0aW9BcmdzLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAgIGNhbnZhc0N0eFtmdW5jTmFtZV0gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBhcmdzID0gYXJncy5tYXAoKGEpID0+IGEgKiBwaXhlbFJhdGlvKVxuXG4gICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcbiAgICAgIH1cbiAgICB9KShjYW52YXNDdHhbZnVuY05hbWVdKVxuICB9KVxuXG4gIC8vIGNvbnN0IHJhdGlvQXJnc0J5SW5kZXggPSB7XG4gIC8vICAgYXJjOiBbMCwgMSwgMl1cbiAgLy8gfVxuXG4gIC8vIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHJhdGlvQXJnc0J5SW5kZXgpLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAvLyAgIGNvbnN0IHZhbHVlID0gcmF0aW9BcmdzQnlJbmRleFtmdW5jTmFtZV1cbiAgLy8gICBjYW52YXNDdHhbZnVuY05hbWVdID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAvLyAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgLy8gICAgICAgbGV0IGkgPSAwXG4gIC8vICAgICAgIGxldCBsZW4gPSAwXG4gIC8vICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gIC8vICAgICAgICAgYXJnc1t2YWx1ZVtpXV0gKj0gcGl4ZWxSYXRpb1xuICAvLyAgICAgICB9XG4gIC8vICAgICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcbiAgLy8gICAgIH1cbiAgLy8gICB9KShjYW52YXNDdHhbZnVuY05hbWVdKVxuICAvLyB9KVxuXG4gIC8vIC8vIFN0cm9rZSBsaW5lV2lkdGggYWRqdXN0bWVudFxuICAvLyBjYW52YXNDdHguc3Ryb2tlID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAvLyAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIC8vICAgICB0aGlzLmxpbmVXaWR0aCAqPSBwaXhlbFJhdGlvXG4gIC8vICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcbiAgLy8gICAgIHRoaXMubGluZVdpZHRoIC89IHBpeGVsUmF0aW9cbiAgLy8gICB9XG4gIC8vIH0pKGNhbnZhc0N0eC5zdHJva2UpXG5cbiAgLy8gLy8gVGV4dFxuICAvLyAvL1xuICAvLyBjYW52YXNDdHguZmlsbFRleHQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gIC8vICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgLy8gICAgIGFyZ3NbMV0gKj0gcGl4ZWxSYXRpbyAvLyB4XG4gIC8vICAgICBhcmdzWzJdICo9IHBpeGVsUmF0aW8gLy8geVxuXG4gIC8vICAgICB0aGlzLmZvbnQgPSB0aGlzLmZvbnQucmVwbGFjZShcbiAgLy8gICAgICAgLyhcXGQrKShweHxlbXxyZW18cHQpL2csXG4gIC8vICAgICAgIGZ1bmN0aW9uKHcsIG0sIHUpIHtcbiAgLy8gICAgICAgICByZXR1cm4gKG0gKiBwaXhlbFJhdGlvKSArIHVcbiAgLy8gICAgICAgfVxuICAvLyAgICAgKVxuXG4gIC8vICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcblxuICAvLyAgICAgdGhpcy5mb250ID0gdGhpcy5mb250LnJlcGxhY2UoXG4gIC8vICAgICAgIC8oXFxkKykocHh8ZW18cmVtfHB0KS9nLFxuICAvLyAgICAgICBmdW5jdGlvbih3LCBtLCB1KSB7XG4gIC8vICAgICAgICAgcmV0dXJuIChtIC8gcGl4ZWxSYXRpbykgKyB1XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIClcbiAgLy8gICB9XG4gIC8vIH0pKGNhbnZhc0N0eC5maWxsVGV4dClcblxuICAvLyBjYW52YXNDdHguc3Ryb2tlVGV4dCA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgLy8gICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAvLyAgICAgYXJnc1sxXSAqPSBwaXhlbFJhdGlvIC8vIHhcbiAgLy8gICAgIGFyZ3NbMl0gKj0gcGl4ZWxSYXRpbyAvLyB5XG5cbiAgLy8gICAgIHRoaXMuZm9udCA9IHRoaXMuZm9udC5yZXBsYWNlKFxuICAvLyAgICAgICAvKFxcZCspKHB4fGVtfHJlbXxwdCkvZyxcbiAgLy8gICAgICAgZnVuY3Rpb24odywgbSwgdSkge1xuICAvLyAgICAgICAgIHJldHVybiAobSAqIHBpeGVsUmF0aW8pICsgdVxuICAvLyAgICAgICB9XG4gIC8vICAgICApXG5cbiAgLy8gICAgIF9zdXBlci5hcHBseSh0aGlzLCBhcmdzKVxuXG4gIC8vICAgICB0aGlzLmZvbnQgPSB0aGlzLmZvbnQucmVwbGFjZShcbiAgLy8gICAgICAgLyhcXGQrKShweHxlbXxyZW18cHQpL2csXG4gIC8vICAgICAgIGZ1bmN0aW9uKHcsIG0sIHUpIHtcbiAgLy8gICAgICAgICByZXR1cm4gKG0gLyBwaXhlbFJhdGlvKSArIHVcbiAgLy8gICAgICAgfVxuICAvLyAgICAgKVxuICAvLyAgIH1cbiAgLy8gfSkoY2FudmFzQ3R4LnN0cm9rZVRleHQpXG5cblxuICBjb25zdCBzZXRUcmFuc2Zvcm1BcmdzID0gW3BpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDBdXG4gIGNhbnZhc0N0eC5zZXRUcmFuc2Zvcm0gPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgIF9zdXBlci5hcHBseSh0aGlzLCBzZXRUcmFuc2Zvcm1BcmdzKVxuICAgICAgdGhpcy50cmFuc2Zvcm0oLi4uYXJncylcbiAgICB9XG4gIH0pKGNhbnZhc0N0eC5zZXRUcmFuc2Zvcm0pXG5cbiAgcmV0dXJuIHBpeGVsUmF0aW9cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3V0aWwvY2FudmFzLXV0aWxzLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 27 */
/***/ (function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Binds a this arg to a list of different function names.\n * This is most widely used to bind a this to member functions\n * that are used as callbacks in some fashion\n * @param  {string[]} funcNames array of member function names that are part of thisArg\n * @param  {Object} thisArg   object to bind\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bindAll = bindAll;\nfunction bindAll(funcNames, thisArg) {\n  funcNames.forEach(function (funcName) {\n    if (!thisArg[funcName]) {\n      return;\n    }\n    thisArg[funcName] = thisArg[funcName].bind(thisArg);\n  });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL3V0aWxzLmpzPzMxMzEiXSwibmFtZXMiOlsiYmluZEFsbCIsImZ1bmNOYW1lcyIsInRoaXNBcmciLCJmb3JFYWNoIiwiZnVuY05hbWUiLCJiaW5kIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7UUFPZ0JBLE8sR0FBQUEsTztBQUFULFNBQVNBLE9BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCQyxPQUE1QixFQUFxQztBQUMxQ0QsWUFBVUUsT0FBVixDQUFrQixvQkFBWTtBQUM1QixRQUFJLENBQUNELFFBQVFFLFFBQVIsQ0FBTCxFQUF3QjtBQUN0QjtBQUNEO0FBQ0RGLFlBQVFFLFFBQVIsSUFBb0JGLFFBQVFFLFFBQVIsRUFBa0JDLElBQWxCLENBQXVCSCxPQUF2QixDQUFwQjtBQUNELEdBTEQ7QUFNRCIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbi8qKlxuICogQmluZHMgYSB0aGlzIGFyZyB0byBhIGxpc3Qgb2YgZGlmZmVyZW50IGZ1bmN0aW9uIG5hbWVzLlxuICogVGhpcyBpcyBtb3N0IHdpZGVseSB1c2VkIHRvIGJpbmQgYSB0aGlzIHRvIG1lbWJlciBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIHVzZWQgYXMgY2FsbGJhY2tzIGluIHNvbWUgZmFzaGlvblxuICogQHBhcmFtICB7c3RyaW5nW119IGZ1bmNOYW1lcyBhcnJheSBvZiBtZW1iZXIgZnVuY3Rpb24gbmFtZXMgdGhhdCBhcmUgcGFydCBvZiB0aGlzQXJnXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRoaXNBcmcgICBvYmplY3QgdG8gYmluZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEFsbChmdW5jTmFtZXMsIHRoaXNBcmcpIHtcbiAgZnVuY05hbWVzLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAgIGlmICghdGhpc0FyZ1tmdW5jTmFtZV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzQXJnW2Z1bmNOYW1lXSA9IHRoaXNBcmdbZnVuY05hbWVdLmJpbmQodGhpc0FyZylcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3V0aWwvdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _aggregation2 = __webpack_require__(7);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _transform2d = __webpack_require__(11);\n\nvar _eventHandler = __webpack_require__(12);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _mat2d = __webpack_require__(4);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Camera modification event\n * @event EventedCamera#changed\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * @class Base camera class for 2d screen projections\n *        The base class is used only for the NDC to screen space trasform\n * @extends {EventHandler}\n */\nvar BaseCamera2d = function (_EventHandler) {\n  _inherits(BaseCamera2d, _EventHandler);\n\n  /**\n   * Constructs a new 2d camera\n   * @param  {AABox2d}  viewport           Initial camera viewport boundary, in pixels\n   * @param  {Vec2d}  projectionDimensions The width and height of the viewport in world coordinates\n   * @param  {Boolean} [flipY=false]       Whether world y coordinates are flipped, if false\n   *                                       the top of the viewport window is smaller in y, and the bottom\n   *                                       is larger. If true, the bottom has smaller y coords, and the top\n   *                                       larger\n   * @return {BaseCamera2d}\n   */\n  function BaseCamera2d(viewport, projectionDimensions) {\n    var flipY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, BaseCamera2d);\n\n    var _this = _possibleConstructorReturn(this, (BaseCamera2d.__proto__ || Object.getPrototypeOf(BaseCamera2d)).call(this, [\"changed\", \"changed:xform\"]));\n    // initialize modify events\n\n\n    _this._viewport = AABox2d.clone(viewport);\n    _this._projectionDimensions = _glMatrix.vec2.clone(projectionDimensions);\n    _this._yflip = flipY;\n\n    // stores the NDC space to screen space matrix\n    // NDC (normalized device coordinates) is the space\n    // where the left edge of the window is -1, the right edge is 1\n    // the top edge is -1, and the bottom edge is 1.\n    _this._screenMatrix = _mat2d2.default.create();\n\n    // this flag is dirty whenever the attributes for the\n    // ndc-to-screen projection are modified\n    _this._screenDirty = true;\n    return _this;\n  }\n\n  /**\n   * Returns true if the world Y coordinates go from negative to positive\n   * in a bottom to top fashion in screen space, false otherwise.\n   * @return {Boolean}\n   */\n\n\n  _createClass(BaseCamera2d, [{\n    key: \"isYFlipped\",\n    value: function isYFlipped() {\n      return this._yflip;\n    }\n\n    /**\n     * Sets the camera's screen-space viewport bounds\n     * @param  {AABox2d} viewport\n     * @fires  EventedCamera#changed\n     * @return {BaseCamera2d}\n     */\n\n  }, {\n    key: \"viewport\",\n    set: function set(viewport) {\n      if (!AABox2d.equals(viewport, this._viewport)) {\n        var prev = AABox2d.clone(this._viewport);\n        AABox2d.copy(this._viewport, viewport);\n        this._screenDirty = true;\n        this._worldToScreenOutdated = true;\n        this.fire(\"changed\", {\n          attr: \"viewport\",\n          prevVal: prev,\n          currVal: viewport\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets a copy of the camera's current viewport\n     * @return {AABox2d}\n     */\n    ,\n    get: function get() {\n      return AABox2d.clone(this._viewport);\n    }\n\n    /**\n     * Gets a reference to the camera's current viewport\n     * @return {AABox2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"viewportRef\",\n    get: function get() {\n      return this._viewport;\n    }\n\n    /**\n     * Gets the current NDC to screen space transform matrix\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"screenMatrix\",\n    get: function get() {\n      if (this._screenDirty) {\n        var center = [0, 0];\n        var extents = [0, 0];\n        AABox2d.getCenter(center, this._viewport);\n        AABox2d.getExtents(extents, this._viewport);\n        _mat2d2.default.set(this._screenMatrix, extents[0], 0, 0, extents[1], center[0], center[1]);\n        this._worldToScreenOutdated = true;\n        this._screenDirty = false;\n      }\n      return this._screenMatrix;\n    }\n  }]);\n\n  return BaseCamera2d;\n}(_eventHandler2.default);\n\n/**\n * @class Main 2d camera class to manage othographic 2d projections\n * @extends {BaseCamera2d}\n * @mixin {EventedTransform2d}\n */\n\n\nvar Camera2d = function (_aggregation) {\n  _inherits(Camera2d, _aggregation);\n\n  /**\n   * Creates a new Camera2d object\n   * @param  {AABox2d} viewport             The camera's viewport bounds in pixel space\n   * @param  {Vec2d} projectionDimensions The width/height of the camera's viewport in world coordinates\n   * @param  {Boolean} flipY              True if the direction from negative to positive Y coordinates\n   *                                      go from the bottom to top of the window. False means Y coords\n   *                                      from negative to positive values go from the top to the bottom\n   * @return {Camera2d}\n   */\n  function Camera2d(viewport, projectionDimensions, flipY) {\n    _classCallCheck(this, Camera2d);\n\n    var _this2 = _possibleConstructorReturn(this, (Camera2d.__proto__ || Object.getPrototypeOf(Camera2d)).call(this, viewport, projectionDimensions, flipY));\n\n    _this2._viewMatrix = _mat2d2.default.create();\n    _this2._viewDirty = true;\n    _this2._projMatrix = _mat2d2.default.create();\n    _this2._projDirty = true;\n    return _this2;\n  }\n\n  /**\n   * Sets the projection dimensions of the camera's view. This is the width/height\n   * in world space coordiantes of the camera's view.\n   * @param  {Vec2d} projectionDimensions\n   * @return {Camera2d} this\n   */\n\n\n  _createClass(Camera2d, [{\n    key: \"_localXformUpdated\",\n\n\n    /**\n     * Called when the local transform (does not include parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the view-to-screen space\n     * transformation needs updating\n     * @private\n     */\n    value: function _localXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Called when the global matrix (includes parent transforms) of the\n     * Transform2d mixin is modified. Used to be notified internally that\n     * the view-to-screen space transformation needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_globalXformUpdated\",\n    value: function _globalXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Gets the transformation matrix from world space to view/camera space\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"_matricesDirty\",\n\n\n    /**\n     * Returns true if any of the dirty flags are active\n     * @return {Boolean}\n     * @private\n     */\n    value: function _matricesDirty() {\n      return this._boundsOutOfDate || this._lxformDirty || this._xformDirty || this._viewDirty || this._projDirty || this._screenDirty;\n    }\n\n    /**\n     * Gets the transformation matrix from world space to screen space.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"projectionDimensions\",\n    set: function set(projectionDimensions) {\n      if (!_glMatrix.vec2.equals(projectionDimensions, this._projectionDimensions)) {\n        var prev = _glMatrix.vec2.clone(this._projectionDimensions);\n        AABox2d.copy(this._projectionDimensions, projectionDimensions);\n        this._viewDirty = true;\n        this._projDirty = true;\n        // this._yflip = this._projectionDimensions[3] < this._projectionDimensions[1]\n        this.fire(\"changed\", {\n          attr: \"projectionDimensions\",\n          prevVal: prev,\n          currVal: projectionDimensions\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets a copy of the camera's current projection dimensions\n     * @return {Vec2d}\n     */\n    ,\n    get: function get() {\n      return _glMatrix.vec2.clone(this._projectionDimensions);\n    }\n\n    /**\n     * Gets a reference to the camera's current projection dimensions\n     * @return {Vec2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"projectionDimensionsRef\",\n    get: function get() {\n      return this._projectionDimensions;\n    }\n  }, {\n    key: \"viewMatrix\",\n    get: function get() {\n      if (this._viewDirty || this._boundsOutOfDate || this._xformDirty || this._lxformDirty) {\n        // the matrix has been marked dirty, so recalculate\n        var pos = [0, 0];\n        var scale = [0, 0];\n        var rot = [0, 0];\n        var xform = this.globalXform;\n        _mat2d2.default.svd(pos, scale, rot, xform);\n        _mat2d2.default.fromTranslation(this._viewMatrix, _glMatrix.vec2.negate(pos, pos));\n        _mat2d2.default.rotate(this._viewMatrix, this._viewMatrix, -rot[0]);\n        _mat2d2.default.scale(this._viewMatrix, this._viewMatrix, scale);\n        _mat2d2.default.rotate(this._viewMatrix, this._viewMatrix, -rot[1]);\n        this._worldToScreenOutdated = true;\n        this._viewDirty = false;\n      }\n      return this._viewMatrix;\n    }\n\n    /**\n     * Gets the orthographic projection transformation matrix from\n     * view to NDC (normalized device coordinates) space\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"projMatrix\",\n    get: function get() {\n      if (this._projDirty) {\n        var flip = this._yflip ? -1 : 1;\n        _mat2d2.default.set(this._projMatrix, 2.0 / this._projectionDimensions[0], 0, 0, flip * 2.0 / this._projectionDimensions[1], 0, 0);\n        this._worldToScreenOutdated = true;\n        this._projDirty = false;\n      }\n      return this._projMatrix;\n    }\n  }, {\n    key: \"worldToScreenMatrix\",\n    get: function get() {\n      if (!this._worldToScreenMatrix || this._worldToScreenOutdated || this._matricesDirty()) {\n        if (!this._worldToScreenMatrix) {\n          this._worldToScreenMatrix = _mat2d2.default.create();\n        }\n        _mat2d2.default.copy(this._worldToScreenMatrix, this.viewMatrix);\n        _mat2d2.default.multiply(this._worldToScreenMatrix, this.projMatrix, this._worldToScreenMatrix);\n        _mat2d2.default.multiply(this._worldToScreenMatrix, this.screenMatrix, this._worldToScreenMatrix);\n        this._worldToScreenOutdated = false;\n        this._screenToWorldOutdated = true;\n      }\n      return this._worldToScreenMatrix;\n    }\n\n    /**\n     * Gets teh transform matrix from screen space to world space.\n     * @return {[type]} [description]\n     */\n\n  }, {\n    key: \"screenToWorldMatrix\",\n    get: function get() {\n      if (!this._screenToWorld || this._screenToWorldOutdated || this._matricesDirty()) {\n        if (!this._screenToWorld) {\n          this._screenToWorld = _mat2d2.default.create();\n        }\n        _mat2d2.default.copy(this._screenToWorld, this.worldToScreenMatrix);\n        _mat2d2.default.invert(this._screenToWorld, this._screenToWorld);\n        this._screenToWorldOutdated = false;\n      }\n      return this._screenToWorld;\n    }\n  }]);\n\n  return Camera2d;\n}((0, _aggregation3.default)(BaseCamera2d, (0, _transform2d.createEventedTransform2dMixin)(\"changed:xform\")));\n\nexports.default = Camera2d;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L2NhbWVyYTJkLmpzP2YyYWUiXSwibmFtZXMiOlsiQUFCb3gyZCIsIkJhc2VDYW1lcmEyZCIsInZpZXdwb3J0IiwicHJvamVjdGlvbkRpbWVuc2lvbnMiLCJmbGlwWSIsIl92aWV3cG9ydCIsImNsb25lIiwiX3Byb2plY3Rpb25EaW1lbnNpb25zIiwiVmVjMmQiLCJfeWZsaXAiLCJfc2NyZWVuTWF0cml4IiwiTWF0MmQiLCJjcmVhdGUiLCJfc2NyZWVuRGlydHkiLCJlcXVhbHMiLCJwcmV2IiwiY29weSIsIl93b3JsZFRvU2NyZWVuT3V0ZGF0ZWQiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwiY2VudGVyIiwiZXh0ZW50cyIsImdldENlbnRlciIsImdldEV4dGVudHMiLCJzZXQiLCJFdmVudEhhbmRsZXIiLCJDYW1lcmEyZCIsIl92aWV3TWF0cml4IiwiX3ZpZXdEaXJ0eSIsIl9wcm9qTWF0cml4IiwiX3Byb2pEaXJ0eSIsIl9ib3VuZHNPdXRPZkRhdGUiLCJfbHhmb3JtRGlydHkiLCJfeGZvcm1EaXJ0eSIsInBvcyIsInNjYWxlIiwicm90IiwieGZvcm0iLCJnbG9iYWxYZm9ybSIsInN2ZCIsImZyb21UcmFuc2xhdGlvbiIsIm5lZ2F0ZSIsInJvdGF0ZSIsImZsaXAiLCJfd29ybGRUb1NjcmVlbk1hdHJpeCIsIl9tYXRyaWNlc0RpcnR5Iiwidmlld01hdHJpeCIsIm11bHRpcGx5IiwicHJvak1hdHJpeCIsInNjcmVlbk1hdHJpeCIsIl9zY3JlZW5Ub1dvcmxkT3V0ZGF0ZWQiLCJfc2NyZWVuVG9Xb3JsZCIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJpbnZlcnQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7Ozs7O0FBU0E7Ozs7O0lBS01DLFk7OztBQUNKOzs7Ozs7Ozs7O0FBVUEsd0JBQVlDLFFBQVosRUFBc0JDLG9CQUF0QixFQUEyRDtBQUFBLFFBQWZDLEtBQWUsdUVBQVAsS0FBTzs7QUFBQTs7QUFBQSw0SEFFbkQsQ0FBQyxTQUFELEVBQVksZUFBWixDQUZtRDtBQUN6RDs7O0FBR0EsVUFBS0MsU0FBTCxHQUFpQkwsUUFBUU0sS0FBUixDQUFjSixRQUFkLENBQWpCO0FBQ0EsVUFBS0sscUJBQUwsR0FBNkJDLGVBQU1GLEtBQU4sQ0FBWUgsb0JBQVosQ0FBN0I7QUFDQSxVQUFLTSxNQUFMLEdBQWNMLEtBQWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFLTSxhQUFMLEdBQXFCQyxnQkFBTUMsTUFBTixFQUFyQjs7QUFFQTtBQUNBO0FBQ0EsVUFBS0MsWUFBTCxHQUFvQixJQUFwQjtBQWhCeUQ7QUFpQjFEOztBQUVEOzs7Ozs7Ozs7aUNBS2E7QUFDWCxhQUFPLEtBQUtKLE1BQVo7QUFDRDs7QUFFRDs7Ozs7Ozs7O3NCQU1hUCxRLEVBQVU7QUFDckIsVUFBSSxDQUFDRixRQUFRYyxNQUFSLENBQWVaLFFBQWYsRUFBeUIsS0FBS0csU0FBOUIsQ0FBTCxFQUErQztBQUM3QyxZQUFNVSxPQUFPZixRQUFRTSxLQUFSLENBQWMsS0FBS0QsU0FBbkIsQ0FBYjtBQUNBTCxnQkFBUWdCLElBQVIsQ0FBYSxLQUFLWCxTQUFsQixFQUE2QkgsUUFBN0I7QUFDQSxhQUFLVyxZQUFMLEdBQW9CLElBQXBCO0FBQ0EsYUFBS0ksc0JBQUwsR0FBOEIsSUFBOUI7QUFDQSxhQUFLQyxJQUFMLENBQVUsU0FBVixFQUFxQjtBQUNuQkMsZ0JBQU0sVUFEYTtBQUVuQkMsbUJBQVNMLElBRlU7QUFHbkJNLG1CQUFTbkI7QUFIVSxTQUFyQjtBQUtEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUllO0FBQ2IsYUFBT0YsUUFBUU0sS0FBUixDQUFjLEtBQUtELFNBQW5CLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7d0JBS2tCO0FBQ2hCLGFBQU8sS0FBS0EsU0FBWjtBQUNEOztBQUVEOzs7Ozs7O3dCQUltQjtBQUNqQixVQUFJLEtBQUtRLFlBQVQsRUFBdUI7QUFDckIsWUFBTVMsU0FBUyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWY7QUFDQSxZQUFNQyxVQUFVLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBaEI7QUFDQXZCLGdCQUFRd0IsU0FBUixDQUFrQkYsTUFBbEIsRUFBMEIsS0FBS2pCLFNBQS9CO0FBQ0FMLGdCQUFReUIsVUFBUixDQUFtQkYsT0FBbkIsRUFBNEIsS0FBS2xCLFNBQWpDO0FBQ0FNLHdCQUFNZSxHQUFOLENBQVUsS0FBS2hCLGFBQWYsRUFBOEJhLFFBQVEsQ0FBUixDQUE5QixFQUEwQyxDQUExQyxFQUE2QyxDQUE3QyxFQUFnREEsUUFBUSxDQUFSLENBQWhELEVBQTRERCxPQUFPLENBQVAsQ0FBNUQsRUFBdUVBLE9BQU8sQ0FBUCxDQUF2RTtBQUNBLGFBQUtMLHNCQUFMLEdBQThCLElBQTlCO0FBQ0EsYUFBS0osWUFBTCxHQUFvQixLQUFwQjtBQUNEO0FBQ0QsYUFBTyxLQUFLSCxhQUFaO0FBQ0Q7Ozs7RUE1RndCaUIsc0I7O0FBK0YzQjs7Ozs7OztJQUtxQkMsUTs7O0FBR25COzs7Ozs7Ozs7QUFTQSxvQkFBWTFCLFFBQVosRUFBc0JDLG9CQUF0QixFQUE0Q0MsS0FBNUMsRUFBbUQ7QUFBQTs7QUFBQSxxSEFDM0NGLFFBRDJDLEVBQ2pDQyxvQkFEaUMsRUFDWEMsS0FEVzs7QUFHakQsV0FBS3lCLFdBQUwsR0FBbUJsQixnQkFBTUMsTUFBTixFQUFuQjtBQUNBLFdBQUtrQixVQUFMLEdBQWtCLElBQWxCO0FBQ0EsV0FBS0MsV0FBTCxHQUFtQnBCLGdCQUFNQyxNQUFOLEVBQW5CO0FBQ0EsV0FBS29CLFVBQUwsR0FBa0IsSUFBbEI7QUFOaUQ7QUFPbEQ7O0FBRUQ7Ozs7Ozs7Ozs7OztBQXVDQTs7Ozs7O3lDQU1xQjtBQUNuQixXQUFLQyxnQkFBTCxHQUF3QixJQUF4QjtBQUNEOztBQUVEOzs7Ozs7Ozs7MENBTXNCO0FBQ3BCLFdBQUtBLGdCQUFMLEdBQXdCLElBQXhCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQXFDQTs7Ozs7cUNBS2lCO0FBQ2YsYUFBTyxLQUFLQSxnQkFBTCxJQUF5QixLQUFLQyxZQUE5QixJQUE4QyxLQUFLQyxXQUFuRCxJQUFrRSxLQUFLTCxVQUF2RSxJQUFxRixLQUFLRSxVQUExRixJQUF3RyxLQUFLbkIsWUFBcEg7QUFDRDs7QUFFRDs7Ozs7OztzQkFuR3lCVixvQixFQUFzQjtBQUM3QyxVQUFJLENBQUNLLGVBQU1NLE1BQU4sQ0FBYVgsb0JBQWIsRUFBbUMsS0FBS0kscUJBQXhDLENBQUwsRUFBcUU7QUFDbkUsWUFBTVEsT0FBT1AsZUFBTUYsS0FBTixDQUFZLEtBQUtDLHFCQUFqQixDQUFiO0FBQ0FQLGdCQUFRZ0IsSUFBUixDQUFhLEtBQUtULHFCQUFsQixFQUF5Q0osb0JBQXpDO0FBQ0EsYUFBSzJCLFVBQUwsR0FBa0IsSUFBbEI7QUFDQSxhQUFLRSxVQUFMLEdBQWtCLElBQWxCO0FBQ0U7QUFDRixhQUFLZCxJQUFMLENBQVUsU0FBVixFQUFxQjtBQUNuQkMsZ0JBQU0sc0JBRGE7QUFFbkJDLG1CQUFTTCxJQUZVO0FBR25CTSxtQkFBU2xCO0FBSFUsU0FBckI7QUFLRDtBQUNELGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJMkI7QUFDekIsYUFBT0ssZUFBTUYsS0FBTixDQUFZLEtBQUtDLHFCQUFqQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3dCQUs4QjtBQUM1QixhQUFPLEtBQUtBLHFCQUFaO0FBQ0Q7Ozt3QkEwQmdCO0FBQ2YsVUFBSSxLQUFLdUIsVUFBTCxJQUFtQixLQUFLRyxnQkFBeEIsSUFBNEMsS0FBS0UsV0FBakQsSUFBZ0UsS0FBS0QsWUFBekUsRUFBdUY7QUFDckY7QUFDQSxZQUFNRSxNQUFNLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBLFlBQU1DLFFBQVEsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFkO0FBQ0EsWUFBTUMsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQSxZQUFNQyxRQUFRLEtBQUtDLFdBQW5CO0FBQ0E3Qix3QkFBTThCLEdBQU4sQ0FBVUwsR0FBVixFQUFlQyxLQUFmLEVBQXNCQyxHQUF0QixFQUEyQkMsS0FBM0I7QUFDQTVCLHdCQUFNK0IsZUFBTixDQUFzQixLQUFLYixXQUEzQixFQUF3Q3JCLGVBQU1tQyxNQUFOLENBQWFQLEdBQWIsRUFBa0JBLEdBQWxCLENBQXhDO0FBQ0F6Qix3QkFBTWlDLE1BQU4sQ0FBYSxLQUFLZixXQUFsQixFQUErQixLQUFLQSxXQUFwQyxFQUFpRCxDQUFDUyxJQUFJLENBQUosQ0FBbEQ7QUFDQTNCLHdCQUFNMEIsS0FBTixDQUFZLEtBQUtSLFdBQWpCLEVBQThCLEtBQUtBLFdBQW5DLEVBQWdEUSxLQUFoRDtBQUNBMUIsd0JBQU1pQyxNQUFOLENBQWEsS0FBS2YsV0FBbEIsRUFBK0IsS0FBS0EsV0FBcEMsRUFBaUQsQ0FBQ1MsSUFBSSxDQUFKLENBQWxEO0FBQ0EsYUFBS3JCLHNCQUFMLEdBQThCLElBQTlCO0FBQ0EsYUFBS2EsVUFBTCxHQUFrQixLQUFsQjtBQUNEO0FBQ0QsYUFBTyxLQUFLRCxXQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3dCQUtpQjtBQUNmLFVBQUksS0FBS0csVUFBVCxFQUFxQjtBQUNuQixZQUFNYSxPQUFRLEtBQUtwQyxNQUFMLEdBQWMsQ0FBQyxDQUFmLEdBQW1CLENBQWpDO0FBQ0FFLHdCQUFNZSxHQUFOLENBQVUsS0FBS0ssV0FBZixFQUE0QixNQUFNLEtBQUt4QixxQkFBTCxDQUEyQixDQUEzQixDQUFsQyxFQUFpRSxDQUFqRSxFQUFvRSxDQUFwRSxFQUF1RXNDLE9BQU8sR0FBUCxHQUFhLEtBQUt0QyxxQkFBTCxDQUEyQixDQUEzQixDQUFwRixFQUFtSCxDQUFuSCxFQUFzSCxDQUF0SDtBQUNBLGFBQUtVLHNCQUFMLEdBQThCLElBQTlCO0FBQ0EsYUFBS2UsVUFBTCxHQUFrQixLQUFsQjtBQUNEO0FBQ0QsYUFBTyxLQUFLRCxXQUFaO0FBQ0Q7Ozt3QkFleUI7QUFDeEIsVUFBSSxDQUFDLEtBQUtlLG9CQUFOLElBQThCLEtBQUs3QixzQkFBbkMsSUFBNkQsS0FBSzhCLGNBQUwsRUFBakUsRUFBd0Y7QUFDdEYsWUFBSSxDQUFDLEtBQUtELG9CQUFWLEVBQWdDO0FBQzlCLGVBQUtBLG9CQUFMLEdBQTRCbkMsZ0JBQU1DLE1BQU4sRUFBNUI7QUFDRDtBQUNERCx3QkFBTUssSUFBTixDQUFXLEtBQUs4QixvQkFBaEIsRUFBc0MsS0FBS0UsVUFBM0M7QUFDQXJDLHdCQUFNc0MsUUFBTixDQUFlLEtBQUtILG9CQUFwQixFQUEwQyxLQUFLSSxVQUEvQyxFQUEyRCxLQUFLSixvQkFBaEU7QUFDQW5DLHdCQUFNc0MsUUFBTixDQUFlLEtBQUtILG9CQUFwQixFQUEwQyxLQUFLSyxZQUEvQyxFQUE2RCxLQUFLTCxvQkFBbEU7QUFDQSxhQUFLN0Isc0JBQUwsR0FBOEIsS0FBOUI7QUFDQSxhQUFLbUMsc0JBQUwsR0FBOEIsSUFBOUI7QUFDRDtBQUNELGFBQU8sS0FBS04sb0JBQVo7QUFDRDs7QUFFRDs7Ozs7Ozt3QkFJMEI7QUFDeEIsVUFBSSxDQUFDLEtBQUtPLGNBQU4sSUFBd0IsS0FBS0Qsc0JBQTdCLElBQXVELEtBQUtMLGNBQUwsRUFBM0QsRUFBa0Y7QUFDaEYsWUFBSSxDQUFDLEtBQUtNLGNBQVYsRUFBMEI7QUFDeEIsZUFBS0EsY0FBTCxHQUFzQjFDLGdCQUFNQyxNQUFOLEVBQXRCO0FBQ0Q7QUFDREQsd0JBQU1LLElBQU4sQ0FBVyxLQUFLcUMsY0FBaEIsRUFBZ0MsS0FBS0MsbUJBQXJDO0FBQ0EzQyx3QkFBTTRDLE1BQU4sQ0FBYSxLQUFLRixjQUFsQixFQUFrQyxLQUFLQSxjQUF2QztBQUNBLGFBQUtELHNCQUFMLEdBQThCLEtBQTlCO0FBQ0Q7QUFDRCxhQUFPLEtBQUtDLGNBQVo7QUFDRDs7OztFQTlKbUMsMkJBQVlwRCxZQUFaLEVBQ3BDLGdEQUE4QixlQUE5QixDQURvQyxDOztrQkFBakIyQixRIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCBhZ2dyZWdhdGlvbiBmcm9tIFwiLi4vdXRpbC9hZ2dyZWdhdGlvblwiXG5pbXBvcnQge2NyZWF0ZUV2ZW50ZWRUcmFuc2Zvcm0yZE1peGlufSBmcm9tIFwiLi4vc2hhcGVzL3RyYW5zZm9ybTJkXCJcbmltcG9ydCBFdmVudEhhbmRsZXIgZnJvbSBcIi4uL3V0aWwvZXZlbnQtaGFuZGxlclwiXG5pbXBvcnQgTWF0MmQgZnJvbSBcIi4uL2NvcmUvbWF0MmRcIlxuaW1wb3J0IHt2ZWMyIGFzIFZlYzJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuLyoqXG4gKiBDYW1lcmEgbW9kaWZpY2F0aW9uIGV2ZW50XG4gKiBAZXZlbnQgRXZlbnRlZENhbWVyYSNjaGFuZ2VkXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICogQHByb3BlcnR5IHt9IGN1cnJWYWwgVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwb3N0IG1vZGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQGNsYXNzIEJhc2UgY2FtZXJhIGNsYXNzIGZvciAyZCBzY3JlZW4gcHJvamVjdGlvbnNcbiAqICAgICAgICBUaGUgYmFzZSBjbGFzcyBpcyB1c2VkIG9ubHkgZm9yIHRoZSBOREMgdG8gc2NyZWVuIHNwYWNlIHRyYXNmb3JtXG4gKiBAZXh0ZW5kcyB7RXZlbnRIYW5kbGVyfVxuICovXG5jbGFzcyBCYXNlQ2FtZXJhMmQgZXh0ZW5kcyBFdmVudEhhbmRsZXIge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyAyZCBjYW1lcmFcbiAgICogQHBhcmFtICB7QUFCb3gyZH0gIHZpZXdwb3J0ICAgICAgICAgICBJbml0aWFsIGNhbWVyYSB2aWV3cG9ydCBib3VuZGFyeSwgaW4gcGl4ZWxzXG4gICAqIEBwYXJhbSAge1ZlYzJkfSAgcHJvamVjdGlvbkRpbWVuc2lvbnMgVGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHZpZXdwb3J0IGluIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtmbGlwWT1mYWxzZV0gICAgICAgV2hldGhlciB3b3JsZCB5IGNvb3JkaW5hdGVzIGFyZSBmbGlwcGVkLCBpZiBmYWxzZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSB0b3Agb2YgdGhlIHZpZXdwb3J0IHdpbmRvdyBpcyBzbWFsbGVyIGluIHksIGFuZCB0aGUgYm90dG9tXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbGFyZ2VyLiBJZiB0cnVlLCB0aGUgYm90dG9tIGhhcyBzbWFsbGVyIHkgY29vcmRzLCBhbmQgdGhlIHRvcFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhcmdlclxuICAgKiBAcmV0dXJuIHtCYXNlQ2FtZXJhMmR9XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2aWV3cG9ydCwgcHJvamVjdGlvbkRpbWVuc2lvbnMsIGZsaXBZID0gZmFsc2UpIHtcbiAgICAvLyBpbml0aWFsaXplIG1vZGlmeSBldmVudHNcbiAgICBzdXBlcihbXCJjaGFuZ2VkXCIsIFwiY2hhbmdlZDp4Zm9ybVwiXSlcblxuICAgIHRoaXMuX3ZpZXdwb3J0ID0gQUFCb3gyZC5jbG9uZSh2aWV3cG9ydClcbiAgICB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucyA9IFZlYzJkLmNsb25lKHByb2plY3Rpb25EaW1lbnNpb25zKVxuICAgIHRoaXMuX3lmbGlwID0gZmxpcFlcblxuICAgIC8vIHN0b3JlcyB0aGUgTkRDIHNwYWNlIHRvIHNjcmVlbiBzcGFjZSBtYXRyaXhcbiAgICAvLyBOREMgKG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzKSBpcyB0aGUgc3BhY2VcbiAgICAvLyB3aGVyZSB0aGUgbGVmdCBlZGdlIG9mIHRoZSB3aW5kb3cgaXMgLTEsIHRoZSByaWdodCBlZGdlIGlzIDFcbiAgICAvLyB0aGUgdG9wIGVkZ2UgaXMgLTEsIGFuZCB0aGUgYm90dG9tIGVkZ2UgaXMgMS5cbiAgICB0aGlzLl9zY3JlZW5NYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuXG4gICAgLy8gdGhpcyBmbGFnIGlzIGRpcnR5IHdoZW5ldmVyIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGVcbiAgICAvLyBuZGMtdG8tc2NyZWVuIHByb2plY3Rpb24gYXJlIG1vZGlmaWVkXG4gICAgdGhpcy5fc2NyZWVuRGlydHkgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB3b3JsZCBZIGNvb3JkaW5hdGVzIGdvIGZyb20gbmVnYXRpdmUgdG8gcG9zaXRpdmVcbiAgICogaW4gYSBib3R0b20gdG8gdG9wIGZhc2hpb24gaW4gc2NyZWVuIHNwYWNlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBpc1lGbGlwcGVkKCkge1xuICAgIHJldHVybiB0aGlzLl95ZmxpcFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNhbWVyYSdzIHNjcmVlbi1zcGFjZSB2aWV3cG9ydCBib3VuZHNcbiAgICogQHBhcmFtICB7QUFCb3gyZH0gdmlld3BvcnRcbiAgICogQGZpcmVzICBFdmVudGVkQ2FtZXJhI2NoYW5nZWRcbiAgICogQHJldHVybiB7QmFzZUNhbWVyYTJkfVxuICAgKi9cbiAgc2V0IHZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgaWYgKCFBQUJveDJkLmVxdWFscyh2aWV3cG9ydCwgdGhpcy5fdmlld3BvcnQpKSB7XG4gICAgICBjb25zdCBwcmV2ID0gQUFCb3gyZC5jbG9uZSh0aGlzLl92aWV3cG9ydClcbiAgICAgIEFBQm94MmQuY29weSh0aGlzLl92aWV3cG9ydCwgdmlld3BvcnQpXG4gICAgICB0aGlzLl9zY3JlZW5EaXJ0eSA9IHRydWVcbiAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCA9IHRydWVcbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWRcIiwge1xuICAgICAgICBhdHRyOiBcInZpZXdwb3J0XCIsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IHZpZXdwb3J0XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBjb3B5IG9mIHRoZSBjYW1lcmEncyBjdXJyZW50IHZpZXdwb3J0XG4gICAqIEByZXR1cm4ge0FBQm94MmR9XG4gICAqL1xuICBnZXQgdmlld3BvcnQoKSB7XG4gICAgcmV0dXJuIEFBQm94MmQuY2xvbmUodGhpcy5fdmlld3BvcnQpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgY2FtZXJhJ3MgY3VycmVudCB2aWV3cG9ydFxuICAgKiBAcmV0dXJuIHtBQUJveDJkfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCB2aWV3cG9ydFJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlld3BvcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IE5EQyB0byBzY3JlZW4gc3BhY2UgdHJhbnNmb3JtIG1hdHJpeFxuICAgKiBAcmV0dXJuIHtNYXQyZH1cbiAgICovXG4gIGdldCBzY3JlZW5NYXRyaXgoKSB7XG4gICAgaWYgKHRoaXMuX3NjcmVlbkRpcnR5KSB7XG4gICAgICBjb25zdCBjZW50ZXIgPSBbMCwgMF1cbiAgICAgIGNvbnN0IGV4dGVudHMgPSBbMCwgMF1cbiAgICAgIEFBQm94MmQuZ2V0Q2VudGVyKGNlbnRlciwgdGhpcy5fdmlld3BvcnQpXG4gICAgICBBQUJveDJkLmdldEV4dGVudHMoZXh0ZW50cywgdGhpcy5fdmlld3BvcnQpXG4gICAgICBNYXQyZC5zZXQodGhpcy5fc2NyZWVuTWF0cml4LCBleHRlbnRzWzBdLCAwLCAwLCBleHRlbnRzWzFdLCBjZW50ZXJbMF0sIGNlbnRlclsxXSlcbiAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3NjcmVlbkRpcnR5ID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NjcmVlbk1hdHJpeFxuICB9XG59XG5cbi8qKlxuICogQGNsYXNzIE1haW4gMmQgY2FtZXJhIGNsYXNzIHRvIG1hbmFnZSBvdGhvZ3JhcGhpYyAyZCBwcm9qZWN0aW9uc1xuICogQGV4dGVuZHMge0Jhc2VDYW1lcmEyZH1cbiAqIEBtaXhpbiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYW1lcmEyZCBleHRlbmRzIGFnZ3JlZ2F0aW9uKEJhc2VDYW1lcmEyZCxcbiAgY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4oXCJjaGFuZ2VkOnhmb3JtXCIpKSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQ2FtZXJhMmQgb2JqZWN0XG4gICAqIEBwYXJhbSAge0FBQm94MmR9IHZpZXdwb3J0ICAgICAgICAgICAgIFRoZSBjYW1lcmEncyB2aWV3cG9ydCBib3VuZHMgaW4gcGl4ZWwgc3BhY2VcbiAgICogQHBhcmFtICB7VmVjMmR9IHByb2plY3Rpb25EaW1lbnNpb25zIFRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIGNhbWVyYSdzIHZpZXdwb3J0IGluIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGZsaXBZICAgICAgICAgICAgICBUcnVlIGlmIHRoZSBkaXJlY3Rpb24gZnJvbSBuZWdhdGl2ZSB0byBwb3NpdGl2ZSBZIGNvb3JkaW5hdGVzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbyBmcm9tIHRoZSBib3R0b20gdG8gdG9wIG9mIHRoZSB3aW5kb3cuIEZhbHNlIG1lYW5zIFkgY29vcmRzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIG5lZ2F0aXZlIHRvIHBvc2l0aXZlIHZhbHVlcyBnbyBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbVxuICAgKiBAcmV0dXJuIHtDYW1lcmEyZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZpZXdwb3J0LCBwcm9qZWN0aW9uRGltZW5zaW9ucywgZmxpcFkpIHtcbiAgICBzdXBlcih2aWV3cG9ydCwgcHJvamVjdGlvbkRpbWVuc2lvbnMsIGZsaXBZKVxuXG4gICAgdGhpcy5fdmlld01hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fdmlld0RpcnR5ID0gdHJ1ZVxuICAgIHRoaXMuX3Byb2pNYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuICAgIHRoaXMuX3Byb2pEaXJ0eSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9qZWN0aW9uIGRpbWVuc2lvbnMgb2YgdGhlIGNhbWVyYSdzIHZpZXcuIFRoaXMgaXMgdGhlIHdpZHRoL2hlaWdodFxuICAgKiBpbiB3b3JsZCBzcGFjZSBjb29yZGlhbnRlcyBvZiB0aGUgY2FtZXJhJ3Mgdmlldy5cbiAgICogQHBhcmFtICB7VmVjMmR9IHByb2plY3Rpb25EaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge0NhbWVyYTJkfSB0aGlzXG4gICAqL1xuICBzZXQgcHJvamVjdGlvbkRpbWVuc2lvbnMocHJvamVjdGlvbkRpbWVuc2lvbnMpIHtcbiAgICBpZiAoIVZlYzJkLmVxdWFscyhwcm9qZWN0aW9uRGltZW5zaW9ucywgdGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnMpKSB7XG4gICAgICBjb25zdCBwcmV2ID0gVmVjMmQuY2xvbmUodGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnMpXG4gICAgICBBQUJveDJkLmNvcHkodGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnMsIHByb2plY3Rpb25EaW1lbnNpb25zKVxuICAgICAgdGhpcy5fdmlld0RpcnR5ID0gdHJ1ZVxuICAgICAgdGhpcy5fcHJvakRpcnR5ID0gdHJ1ZVxuICAgICAgICAvLyB0aGlzLl95ZmxpcCA9IHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zWzNdIDwgdGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnNbMV1cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWRcIiwge1xuICAgICAgICBhdHRyOiBcInByb2plY3Rpb25EaW1lbnNpb25zXCIsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IHByb2plY3Rpb25EaW1lbnNpb25zXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBjb3B5IG9mIHRoZSBjYW1lcmEncyBjdXJyZW50IHByb2plY3Rpb24gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICovXG4gIGdldCBwcm9qZWN0aW9uRGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4gVmVjMmQuY2xvbmUodGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnMpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgY2FtZXJhJ3MgY3VycmVudCBwcm9qZWN0aW9uIGRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7VmVjMmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0IHByb2plY3Rpb25EaW1lbnNpb25zUmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9uc1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBsb2NhbCB0cmFuc2Zvcm0gKGRvZXMgbm90IGluY2x1ZGUgcGFyZW50IHRyYW5zZm9ybXMpIG9mIHRoZSBUcmFuc2Zvcm0yZFxuICAgKiBtaXhpbiBpcyBtb2RpZmllZC4gVXNlZCB0byBiZSBub3RpZmllZCBpbnRlcm5hbGx5IHRoYXQgdGhlIHZpZXctdG8tc2NyZWVuIHNwYWNlXG4gICAqIHRyYW5zZm9ybWF0aW9uIG5lZWRzIHVwZGF0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbG9jYWxYZm9ybVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBnbG9iYWwgbWF0cml4IChpbmNsdWRlcyBwYXJlbnQgdHJhbnNmb3Jtcykgb2YgdGhlXG4gICAqIFRyYW5zZm9ybTJkIG1peGluIGlzIG1vZGlmaWVkLiBVc2VkIHRvIGJlIG5vdGlmaWVkIGludGVybmFsbHkgdGhhdFxuICAgKiB0aGUgdmlldy10by1zY3JlZW4gc3BhY2UgdHJhbnNmb3JtYXRpb24gbmVlZHMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nbG9iYWxYZm9ybVVwZGF0ZWQoKSB7XG4gICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmcm9tIHdvcmxkIHNwYWNlIHRvIHZpZXcvY2FtZXJhIHNwYWNlXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IHZpZXdNYXRyaXgoKSB7XG4gICAgaWYgKHRoaXMuX3ZpZXdEaXJ0eSB8fCB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgfHwgdGhpcy5feGZvcm1EaXJ0eSB8fCB0aGlzLl9seGZvcm1EaXJ0eSkge1xuICAgICAgLy8gdGhlIG1hdHJpeCBoYXMgYmVlbiBtYXJrZWQgZGlydHksIHNvIHJlY2FsY3VsYXRlXG4gICAgICBjb25zdCBwb3MgPSBbMCwgMF1cbiAgICAgIGNvbnN0IHNjYWxlID0gWzAsIDBdXG4gICAgICBjb25zdCByb3QgPSBbMCwgMF1cbiAgICAgIGNvbnN0IHhmb3JtID0gdGhpcy5nbG9iYWxYZm9ybVxuICAgICAgTWF0MmQuc3ZkKHBvcywgc2NhbGUsIHJvdCwgeGZvcm0pXG4gICAgICBNYXQyZC5mcm9tVHJhbnNsYXRpb24odGhpcy5fdmlld01hdHJpeCwgVmVjMmQubmVnYXRlKHBvcywgcG9zKSlcbiAgICAgIE1hdDJkLnJvdGF0ZSh0aGlzLl92aWV3TWF0cml4LCB0aGlzLl92aWV3TWF0cml4LCAtcm90WzBdKVxuICAgICAgTWF0MmQuc2NhbGUodGhpcy5fdmlld01hdHJpeCwgdGhpcy5fdmlld01hdHJpeCwgc2NhbGUpXG4gICAgICBNYXQyZC5yb3RhdGUodGhpcy5fdmlld01hdHJpeCwgdGhpcy5fdmlld01hdHJpeCwgLXJvdFsxXSlcbiAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3ZpZXdEaXJ0eSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl92aWV3TWF0cml4XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgb3J0aG9ncmFwaGljIHByb2plY3Rpb24gdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb21cbiAgICogdmlldyB0byBOREMgKG5vcm1hbGl6ZWQgZGV2aWNlIGNvb3JkaW5hdGVzKSBzcGFjZVxuICAgKiBAcmV0dXJuIHtNYXQyZH1cbiAgICovXG4gIGdldCBwcm9qTWF0cml4KCkge1xuICAgIGlmICh0aGlzLl9wcm9qRGlydHkpIHtcbiAgICAgIGNvbnN0IGZsaXAgPSAodGhpcy5feWZsaXAgPyAtMSA6IDEpXG4gICAgICBNYXQyZC5zZXQodGhpcy5fcHJvak1hdHJpeCwgMi4wIC8gdGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnNbMF0sIDAsIDAsIGZsaXAgKiAyLjAgLyB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9uc1sxXSwgMCwgMClcbiAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCA9IHRydWVcbiAgICAgIHRoaXMuX3Byb2pEaXJ0eSA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9qTWF0cml4XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGFueSBvZiB0aGUgZGlydHkgZmxhZ3MgYXJlIGFjdGl2ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hdHJpY2VzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kc091dE9mRGF0ZSB8fCB0aGlzLl9seGZvcm1EaXJ0eSB8fCB0aGlzLl94Zm9ybURpcnR5IHx8IHRoaXMuX3ZpZXdEaXJ0eSB8fCB0aGlzLl9wcm9qRGlydHkgfHwgdGhpcy5fc2NyZWVuRGlydHlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZnJvbSB3b3JsZCBzcGFjZSB0byBzY3JlZW4gc3BhY2UuXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IHdvcmxkVG9TY3JlZW5NYXRyaXgoKSB7XG4gICAgaWYgKCF0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4IHx8IHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCB8fCB0aGlzLl9tYXRyaWNlc0RpcnR5KCkpIHtcbiAgICAgIGlmICghdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCkge1xuICAgICAgICB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4ID0gTWF0MmQuY3JlYXRlKClcbiAgICAgIH1cbiAgICAgIE1hdDJkLmNvcHkodGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy52aWV3TWF0cml4KVxuICAgICAgTWF0MmQubXVsdGlwbHkodGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5wcm9qTWF0cml4LCB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgICAgTWF0MmQubXVsdGlwbHkodGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5zY3JlZW5NYXRyaXgsIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICB0aGlzLl93b3JsZFRvU2NyZWVuT3V0ZGF0ZWQgPSBmYWxzZVxuICAgICAgdGhpcy5fc2NyZWVuVG9Xb3JsZE91dGRhdGVkID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGVoIHRyYW5zZm9ybSBtYXRyaXggZnJvbSBzY3JlZW4gc3BhY2UgdG8gd29ybGQgc3BhY2UuXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgZ2V0IHNjcmVlblRvV29ybGRNYXRyaXgoKSB7XG4gICAgaWYgKCF0aGlzLl9zY3JlZW5Ub1dvcmxkIHx8IHRoaXMuX3NjcmVlblRvV29ybGRPdXRkYXRlZCB8fCB0aGlzLl9tYXRyaWNlc0RpcnR5KCkpIHtcbiAgICAgIGlmICghdGhpcy5fc2NyZWVuVG9Xb3JsZCkge1xuICAgICAgICB0aGlzLl9zY3JlZW5Ub1dvcmxkID0gTWF0MmQuY3JlYXRlKClcbiAgICAgIH1cbiAgICAgIE1hdDJkLmNvcHkodGhpcy5fc2NyZWVuVG9Xb3JsZCwgdGhpcy53b3JsZFRvU2NyZWVuTWF0cml4KVxuICAgICAgTWF0MmQuaW52ZXJ0KHRoaXMuX3NjcmVlblRvV29ybGQsIHRoaXMuX3NjcmVlblRvV29ybGQpXG4gICAgICB0aGlzLl9zY3JlZW5Ub1dvcmxkT3V0ZGF0ZWQgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuVG9Xb3JsZFxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi92aWV3L2NhbWVyYTJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n;\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === \"object\") {\n        module.exports = factory();\n    } else {\n        root.ResizeSensor = factory();\n    }\n}(this, function () {\n\n    //Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n        return null;\n    }\n    // Only used for the dirty checking, so the event callback count is limted to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n    var requestAnimationFrame = window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        function (fn) {\n            return window.setTimeout(fn, 20);\n        };\n\n    /**\n     * Iterate over each of the provided element(s).\n     *\n     * @param {HTMLElement|HTMLElement[]} elements\n     * @param {Function}                  callback\n     */\n    function forEachElement(elements, callback){\n        var elementsType = Object.prototype.toString.call(elements);\n        var isCollectionTyped = ('[object Array]' === elementsType\n            || ('[object NodeList]' === elementsType)\n            || ('[object HTMLCollection]' === elementsType)\n            || ('[object Object]' === elementsType)\n            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools\n        );\n        var i = 0, j = elements.length;\n        if (isCollectionTyped) {\n            for (; i < j; i++) {\n                callback(elements[i]);\n            }\n        } else {\n            callback(elements);\n        }\n    }\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            var q = [];\n            this.add = function(ev) {\n                q.push(ev);\n            };\n\n            var i, j;\n            this.call = function() {\n                for (i = 0, j = q.length; i < j; i++) {\n                    q[i].call();\n                }\n            };\n\n            this.remove = function(ev) {\n                var newQueue = [];\n                for(i = 0, j = q.length; i < j; i++) {\n                    if(q[i] !== ev) newQueue.push(q[i]);\n                }\n                q = newQueue;\n            }\n\n            this.length = function() {\n                return q.length;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} element\n         * @param {String}      prop\n         * @returns {String|Number}\n         */\n        function getComputedStyle(element, prop) {\n            if (element.currentStyle) {\n                return element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\n            } else {\n                return element.style[prop];\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element.resizedAttached) {\n                element.resizedAttached = new EventQueue();\n                element.resizedAttached.add(resized);\n            } else if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.className = 'resize-sensor';\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n            element.resizeSensor.style.cssText = style;\n            element.resizeSensor.innerHTML =\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n            element.appendChild(element.resizeSensor);\n\n            if (getComputedStyle(element, 'position') == 'static') {\n                element.style.position = 'relative';\n            }\n\n            var expand = element.resizeSensor.childNodes[0];\n            var expandChild = expand.childNodes[0];\n            var shrink = element.resizeSensor.childNodes[1];\n            var dirty, rafId, newWidth, newHeight;\n            var lastWidth = element.offsetWidth;\n            var lastHeight = element.offsetHeight;\n\n            var reset = function() {\n                expandChild.style.width = '100000px';\n                expandChild.style.height = '100000px';\n\n                expand.scrollLeft = 100000;\n                expand.scrollTop = 100000;\n\n                shrink.scrollLeft = 100000;\n                shrink.scrollTop = 100000;\n            };\n\n            reset();\n\n            var onResized = function() {\n                rafId = 0;\n\n                if (!dirty) return;\n\n                lastWidth = newWidth;\n                lastHeight = newHeight;\n\n                if (element.resizedAttached) {\n                    element.resizedAttached.call();\n                }\n            };\n\n            var onScroll = function() {\n                newWidth = element.offsetWidth;\n                newHeight = element.offsetHeight;\n                dirty = newWidth != lastWidth || newHeight != lastHeight;\n\n                if (dirty && !rafId) {\n                    rafId = requestAnimationFrame(onResized);\n                }\n\n                reset();\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n        }\n\n        forEachElement(element, function(elem){\n            attachResizeEvent(elem, callback);\n        });\n\n        this.detach = function(ev) {\n            ResizeSensor.detach(element, ev);\n        };\n    };\n\n    ResizeSensor.detach = function(element, ev) {\n        forEachElement(element, function(elem){\n            if(elem.resizedAttached && typeof ev == \"function\"){\n                elem.resizedAttached.remove(ev);\n                if(elem.resizedAttached.length()) return;\n            }\n            if (elem.resizeSensor) {\n                if (elem.contains(elem.resizeSensor)) {\n                    elem.removeChild(elem.resizeSensor);\n                }\n                delete elem.resizeSensor;\n                delete elem.resizedAttached;\n            }\n        });\n    };\n\n    return ResizeSensor;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9jc3MtZWxlbWVudC1xdWVyaWVzL3NyYy9SZXNpemVTZW5zb3IuanM/MTljOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUyxRQUFRLFVBQVUsV0FBVyxrQkFBa0IsYUFBYSxvQkFBb0I7QUFDckksaURBQWlELFNBQVMsUUFBUSxnQkFBZ0I7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXG4gKiBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb24gYW5kIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllcy9ibG9iL21hc3Rlci9MSUNFTlNFLlxuICovXG47XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5SZXNpemVTZW5zb3IgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL01ha2Ugc3VyZSBpdCBkb2VzIG5vdCB0aHJvdyBpbiBhIFNTUiAoU2VydmVyIFNpZGUgUmVuZGVyaW5nKSBzaXR1YXRpb25cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gT25seSB1c2VkIGZvciB0aGUgZGlydHkgY2hlY2tpbmcsIHNvIHRoZSBldmVudCBjYWxsYmFjayBjb3VudCBpcyBsaW10ZWQgdG8gbWF4IDEgY2FsbCBwZXIgZnBzIHBlciBzZW5zb3IuXG4gICAgLy8gSW4gY29tYmluYXRpb24gd2l0aCB0aGUgZXZlbnQgYmFzZWQgcmVzaXplIHNlbnNvciB0aGlzIHNhdmVzIGNwdSB0aW1lLCBiZWNhdXNlIHRoZSBzZW5zb3IgaXMgdG9vIGZhc3QgYW5kXG4gICAgLy8gd291bGQgZ2VuZXJhdGUgdG9vIG1hbnkgdW5uZWNlc3NhcnkgZXZlbnRzLlxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgMjApO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIGVhY2ggb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxFbGVtZW50W119IGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hFbGVtZW50KGVsZW1lbnRzLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBlbGVtZW50c1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpO1xuICAgICAgICB2YXIgaXNDb2xsZWN0aW9uVHlwZWQgPSAoJ1tvYmplY3QgQXJyYXldJyA9PT0gZWxlbWVudHNUeXBlXG4gICAgICAgICAgICB8fCAoJ1tvYmplY3QgTm9kZUxpc3RdJyA9PT0gZWxlbWVudHNUeXBlKVxuICAgICAgICAgICAgfHwgKCdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScgPT09IGVsZW1lbnRzVHlwZSlcbiAgICAgICAgICAgIHx8ICgnW29iamVjdCBPYmplY3RdJyA9PT0gZWxlbWVudHNUeXBlKVxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgalF1ZXJ5ICYmIGVsZW1lbnRzIGluc3RhbmNlb2YgalF1ZXJ5KSAvL2pxdWVyeVxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgRWxlbWVudHMgJiYgZWxlbWVudHMgaW5zdGFuY2VvZiBFbGVtZW50cykgLy9tb290b29sc1xuICAgICAgICApO1xuICAgICAgICB2YXIgaSA9IDAsIGogPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlZCkge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBmb3IgZGltZW5zaW9uIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfEVsZW1lbnRzfGpRdWVyeX0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUmVzaXplU2Vuc29yID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcbiAgICAgICAgICAgIHZhciBxID0gW107XG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgcS5wdXNoKGV2KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBpLCBqO1xuICAgICAgICAgICAgdGhpcy5jYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHEubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFbaV0uY2FsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDAsIGogPSBxLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZihxW2ldICE9PSBldikgbmV3UXVldWUucHVzaChxW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcSA9IG5ld1F1ZXVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIHByb3BcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICByZXNpemVkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50LCByZXNpemVkKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQgPSBuZXcgRXZlbnRRdWV1ZSgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuY2xhc3NOYW1lID0gJ3Jlc2l6ZS1zZW5zb3InO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyc7XG4gICAgICAgICAgICB2YXIgc3R5bGVDaGlsZCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7JztcblxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3ItZXhwYW5kXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlQ2hpbGQgKyAnXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVzaXplLXNlbnNvci1zaHJpbmtcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCInICsgc3R5bGVDaGlsZCArICcgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJVwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50LnJlc2l6ZVNlbnNvcik7XG5cbiAgICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICdwb3NpdGlvbicpID09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHBhbmQgPSBlbGVtZW50LnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkID0gZXhwYW5kLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB2YXIgc2hyaW5rID0gZWxlbWVudC5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgICAgIHZhciBkaXJ0eSwgcmFmSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGFzdFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBsYXN0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoID0gJzEwMDAwMHB4JztcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAnMTAwMDAwcHgnO1xuXG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbFRvcCA9IDEwMDAwMDtcblxuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNldCgpO1xuXG4gICAgICAgICAgICB2YXIgb25SZXNpemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmFmSWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJ0eSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgbGFzdFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IG5ld0hlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5jYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGRpcnR5ID0gbmV3V2lkdGggIT0gbGFzdFdpZHRoIHx8IG5ld0hlaWdodCAhPSBsYXN0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5ICYmICFyYWZJZCkge1xuICAgICAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvblJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhZGRFdmVudChleHBhbmQsICdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgICAgICBhZGRFdmVudChzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kZXRhY2ggPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50LCBldik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFJlc2l6ZVNlbnNvci5kZXRhY2ggPSBmdW5jdGlvbihlbGVtZW50LCBldikge1xuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGlmKGVsZW0ucmVzaXplZEF0dGFjaGVkICYmIHR5cGVvZiBldiA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICAgICAgICAgIGVsZW0ucmVzaXplZEF0dGFjaGVkLnJlbW92ZShldik7XG4gICAgICAgICAgICAgICAgaWYoZWxlbS5yZXNpemVkQXR0YWNoZWQubGVuZ3RoKCkpIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLnJlc2l6ZVNlbnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLmNvbnRhaW5zKGVsZW0ucmVzaXplU2Vuc29yKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNoaWxkKGVsZW0ucmVzaXplU2Vuc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplU2Vuc29yO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtLnJlc2l6ZWRBdHRhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXNpemVTZW5zb3I7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWVsZW1lbnQtcXVlcmllcy9zcmMvUmVzaXplU2Vuc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 30 */
/***/ (function(module, exports) {

	eval("module.exports = {\n\t\"name\": \"@mapd/mapd-draw\",\n\t\"description\": \"A Utility Library for drawing and interacting with shapes using canvas\",\n\t\"version\": \"1.1.0\",\n\t\"homepage\": \"https://omnisci.com\",\n\t\"bugs\": \"https://github.com/omnisci/mapd-draw/issues\",\n\t\"main\": \"dist/mapd-draw.js\",\n\t\"author\": \"MapD Technologies\",\n\t\"license\": \"MIT\",\n\t\"engines\": {\n\t\t\"node\": \">=4.0.0\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/omnisci/mapd-draw.git\"\n\t},\n\t\"dependencies\": {\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"css-element-queries\": \"^0.4.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"babel-core\": \"^6.10.4\",\n\t\t\"babel-eslint\": \"^10.0.1\",\n\t\t\"babel-loader\": \"^6.2.4\",\n\t\t\"babel-preset-es2015\": \"^6.9.0\",\n\t\t\"babel-preset-stage-0\": \"^6.5.0\",\n\t\t\"babel-register\": \"^6.24.1\",\n\t\t\"chai\": \"^3.5.0\",\n\t\t\"eslint\": \"^3.0.1\",\n\t\t\"eslint-plugin-react\": \"^7.12.4\",\n\t\t\"http-server\": \"^0.11.1\",\n\t\t\"json-loader\": \"0.5.4\",\n\t\t\"mocha\": \"^6.0.2\",\n\t\t\"pre-commit\": \"^1.2.2\",\n\t\t\"webpack\": \"^1.13.1\"\n\t},\n\t\"scripts\": {\n\t\t\"build\": \"npm run build:prod; npm run build:dev\",\n\t\t\"build:prod\": \"npm run webpack\",\n\t\t\"build:dev\": \"npm run webpack:dev\",\n\t\t\"clean\": \"bash scripts/clean.sh\",\n\t\t\"eslint\": \"eslint -c ./.eslintrc.json\",\n\t\t\"lint-fix\": \"eslint --fix $(find src -name \\\"*.js\\\" ! -name '*.spec.js')\",\n\t\t\"lint\": \"eslint $(find src -name \\\"*.js\\\" ! -name '*.spec.js')\",\n\t\t\"start\": \"npm run build; http-server -p 8080 -o;\",\n\t\t\"watch:dev\": \"node node_modules/webpack/bin/webpack.js --progress --colors --watch --config webpack.dev.config.js\",\n\t\t\"webpack\": \"node node_modules/webpack/bin/webpack.js\",\n\t\t\"webpack:dev\": \"node node_modules/webpack/bin/webpack.js --config webpack.dev.config.js\",\n\t\t\"test\": \"mocha --recursive --require babel-register\"\n\t},\n\t\"pre-commit\": [\n\t\t\"lint\",\n\t\t\"test\"\n\t]\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vcGFja2FnZS5qc29uPzBmYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwiQG1hcGQvbWFwZC1kcmF3XCIsXG5cdFwiZGVzY3JpcHRpb25cIjogXCJBIFV0aWxpdHkgTGlicmFyeSBmb3IgZHJhd2luZyBhbmQgaW50ZXJhY3Rpbmcgd2l0aCBzaGFwZXMgdXNpbmcgY2FudmFzXCIsXG5cdFwidmVyc2lvblwiOiBcIjEuMS4wXCIsXG5cdFwiaG9tZXBhZ2VcIjogXCJodHRwczovL29tbmlzY2kuY29tXCIsXG5cdFwiYnVnc1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9vbW5pc2NpL21hcGQtZHJhdy9pc3N1ZXNcIixcblx0XCJtYWluXCI6IFwiZGlzdC9tYXBkLWRyYXcuanNcIixcblx0XCJhdXRob3JcIjogXCJNYXBEIFRlY2hub2xvZ2llc1wiLFxuXHRcImxpY2Vuc2VcIjogXCJNSVRcIixcblx0XCJlbmdpbmVzXCI6IHtcblx0XHRcIm5vZGVcIjogXCI+PTQuMC4wXCJcblx0fSxcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vb21uaXNjaS9tYXBkLWRyYXcuZ2l0XCJcblx0fSxcblx0XCJkZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiZ2wtbWF0cml4XCI6IFwiXjIuMy4yXCIsXG5cdFx0XCJjc3MtZWxlbWVudC1xdWVyaWVzXCI6IFwiXjAuNC4wXCJcblx0fSxcblx0XCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuXHRcdFwiYmFiZWwtY29yZVwiOiBcIl42LjEwLjRcIixcblx0XHRcImJhYmVsLWVzbGludFwiOiBcIl4xMC4wLjFcIixcblx0XHRcImJhYmVsLWxvYWRlclwiOiBcIl42LjIuNFwiLFxuXHRcdFwiYmFiZWwtcHJlc2V0LWVzMjAxNVwiOiBcIl42LjkuMFwiLFxuXHRcdFwiYmFiZWwtcHJlc2V0LXN0YWdlLTBcIjogXCJeNi41LjBcIixcblx0XHRcImJhYmVsLXJlZ2lzdGVyXCI6IFwiXjYuMjQuMVwiLFxuXHRcdFwiY2hhaVwiOiBcIl4zLjUuMFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiXjMuMC4xXCIsXG5cdFx0XCJlc2xpbnQtcGx1Z2luLXJlYWN0XCI6IFwiXjcuMTIuNFwiLFxuXHRcdFwiaHR0cC1zZXJ2ZXJcIjogXCJeMC4xMS4xXCIsXG5cdFx0XCJqc29uLWxvYWRlclwiOiBcIjAuNS40XCIsXG5cdFx0XCJtb2NoYVwiOiBcIl42LjAuMlwiLFxuXHRcdFwicHJlLWNvbW1pdFwiOiBcIl4xLjIuMlwiLFxuXHRcdFwid2VicGFja1wiOiBcIl4xLjEzLjFcIlxuXHR9LFxuXHRcInNjcmlwdHNcIjoge1xuXHRcdFwiYnVpbGRcIjogXCJucG0gcnVuIGJ1aWxkOnByb2Q7IG5wbSBydW4gYnVpbGQ6ZGV2XCIsXG5cdFx0XCJidWlsZDpwcm9kXCI6IFwibnBtIHJ1biB3ZWJwYWNrXCIsXG5cdFx0XCJidWlsZDpkZXZcIjogXCJucG0gcnVuIHdlYnBhY2s6ZGV2XCIsXG5cdFx0XCJjbGVhblwiOiBcImJhc2ggc2NyaXB0cy9jbGVhbi5zaFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiZXNsaW50IC1jIC4vLmVzbGludHJjLmpzb25cIixcblx0XHRcImxpbnQtZml4XCI6IFwiZXNsaW50IC0tZml4ICQoZmluZCBzcmMgLW5hbWUgXFxcIiouanNcXFwiICEgLW5hbWUgJyouc3BlYy5qcycpXCIsXG5cdFx0XCJsaW50XCI6IFwiZXNsaW50ICQoZmluZCBzcmMgLW5hbWUgXFxcIiouanNcXFwiICEgLW5hbWUgJyouc3BlYy5qcycpXCIsXG5cdFx0XCJzdGFydFwiOiBcIm5wbSBydW4gYnVpbGQ7IGh0dHAtc2VydmVyIC1wIDgwODAgLW87XCIsXG5cdFx0XCJ3YXRjaDpkZXZcIjogXCJub2RlIG5vZGVfbW9kdWxlcy93ZWJwYWNrL2Jpbi93ZWJwYWNrLmpzIC0tcHJvZ3Jlc3MgLS1jb2xvcnMgLS13YXRjaCAtLWNvbmZpZyB3ZWJwYWNrLmRldi5jb25maWcuanNcIixcblx0XHRcIndlYnBhY2tcIjogXCJub2RlIG5vZGVfbW9kdWxlcy93ZWJwYWNrL2Jpbi93ZWJwYWNrLmpzXCIsXG5cdFx0XCJ3ZWJwYWNrOmRldlwiOiBcIm5vZGUgbm9kZV9tb2R1bGVzL3dlYnBhY2svYmluL3dlYnBhY2suanMgLS1jb25maWcgd2VicGFjay5kZXYuY29uZmlnLmpzXCIsXG5cdFx0XCJ0ZXN0XCI6IFwibW9jaGEgLS1yZWN1cnNpdmUgLS1yZXF1aXJlIGJhYmVsLXJlZ2lzdGVyXCJcblx0fSxcblx0XCJwcmUtY29tbWl0XCI6IFtcblx0XHRcImxpbnRcIixcblx0XHRcInRlc3RcIlxuXHRdXG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ])
});
;