(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["MapdDraw"] = factory();
	else
		root["MapdDraw"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleHull_2D = exports.Math = exports.Point = exports.PolyLine = exports.Poly = exports.Rect = exports.Circle = exports.Vec2d = exports.BasicStyle = exports.Mat2 = exports.Point2d = exports.Mat2d = exports.AABox2d = exports.DrawEngine = exports.ShapeBuilder = exports.version = undefined;\n\nvar _package = __webpack_require__(39);\n\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function get() {\n    return _package.version;\n  }\n});\n\nvar _glMatrix = __webpack_require__(1);\n\nObject.defineProperty(exports, \"Mat2\", {\n  enumerable: true,\n  get: function get() {\n    return _glMatrix.mat2;\n  }\n});\n\nvar _convexHull = __webpack_require__(12);\n\nObject.defineProperty(exports, \"simpleHull_2D\", {\n  enumerable: true,\n  get: function get() {\n    return _convexHull.simpleHull_2D;\n  }\n});\n\nvar _shapeBuilder = __webpack_require__(23);\n\nvar _shapeBuilder2 = _interopRequireDefault(_shapeBuilder);\n\nvar _drawEngine = __webpack_require__(16);\n\nvar _drawEngine2 = _interopRequireDefault(_drawEngine);\n\nvar _aabox2d = __webpack_require__(2);\n\nvar _AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _mat2d = __webpack_require__(7);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar _Point2d = _interopRequireWildcard(_point2d);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _vec2d = __webpack_require__(11);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nvar _circle = __webpack_require__(27);\n\nvar _circle2 = _interopRequireDefault(_circle);\n\nvar _rect = __webpack_require__(17);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _poly = __webpack_require__(29);\n\nvar _poly2 = _interopRequireDefault(_poly);\n\nvar _polyLine = __webpack_require__(13);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nvar _point = __webpack_require__(28);\n\nvar _point2 = _interopRequireDefault(_point);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.ShapeBuilder = _shapeBuilder2.default;\nexports.DrawEngine = _drawEngine2.default;\nexports.AABox2d = _AABox2d;\nexports.Mat2d = _mat2d2.default;\nexports.Point2d = _Point2d;\nexports.BasicStyle = _basicStyle2.default;\nexports.Vec2d = _vec2d2.default;\nexports.Circle = _circle2.default;\nexports.Rect = _rect2.default;\nexports.Poly = _poly2.default;\nexports.PolyLine = _polyLine2.default;\nexports.Point = _point2.default;\nexports.Math = _math2.default;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXBkLWRyYXcuanM/NGY3OSJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwibWF0MiIsInNpbXBsZUh1bGxfMkQiLCJTaGFwZUJ1aWxkZXIiLCJEcmF3RW5naW5lIiwiQUFCb3gyZCIsIk1hdDJkIiwiUG9pbnQyZCIsIkJhc2ljU3R5bGUiLCJWZWMyZCIsIkNpcmNsZSIsIlJlY3QiLCJQb2x5IiwiUG9seUxpbmUiLCJQb2ludCIsIk1hdGgiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7b0JBR0VBLE87Ozs7Ozs7OztxQkFVQUMsSTs7Ozs7Ozs7O3VCQVlBQyxhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUFsQktDLFk7UUFDQUMsVTtRQUNLQyxPO1FBQ0xDLEs7UUFDS0MsTztRQUtMQyxVO1FBQ0FDLEs7UUFDQUMsTTtRQUNBQyxJO1FBQ0FDLEk7UUFDQUMsUTtRQUNBQyxLO1FBQ0FDLEkiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmV4cG9ydCB7XG4gIHZlcnNpb25cbn1cbmZyb20gXCIuLi9wYWNrYWdlLmpzb25cIlxuXG5leHBvcnQgU2hhcGVCdWlsZGVyIGZyb20gXCIuL2VuZ2luZS9zaGFwZS1idWlsZGVyXCJcbmV4cG9ydCBEcmF3RW5naW5lIGZyb20gXCIuL2VuZ2luZS9kcmF3LWVuZ2luZVwiXG5leHBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuL2NvcmUvYWFib3gyZFwiXG5leHBvcnQgTWF0MmQgZnJvbSBcIi4vY29yZS9tYXQyZFwiXG5leHBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuL2NvcmUvcG9pbnQyZFwiXG5leHBvcnQge1xuICBtYXQyIGFzIE1hdDJcbn1cbmZyb20gXCJnbC1tYXRyaXhcIlxuZXhwb3J0IEJhc2ljU3R5bGUgZnJvbSBcIi4vc3R5bGUvYmFzaWMtc3R5bGVcIlxuZXhwb3J0IFZlYzJkIGZyb20gXCIuL2NvcmUvdmVjMmRcIlxuZXhwb3J0IENpcmNsZSBmcm9tIFwiLi9zaGFwZXMvY2lyY2xlXCJcbmV4cG9ydCBSZWN0IGZyb20gXCIuL3NoYXBlcy9yZWN0XCJcbmV4cG9ydCBQb2x5IGZyb20gXCIuL3NoYXBlcy9wb2x5XCJcbmV4cG9ydCBQb2x5TGluZSBmcm9tIFwiLi9zaGFwZXMvcG9seS1saW5lXCJcbmV4cG9ydCBQb2ludCBmcm9tIFwiLi9zaGFwZXMvcG9pbnRcIlxuZXhwb3J0IE1hdGggZnJvbSBcIi4vbWF0aC9tYXRoXCJcbmV4cG9ydCB7XG4gIHNpbXBsZUh1bGxfMkRcbn1cbmZyb20gXCIuL21hdGgvY29udmV4LWh1bGxcIlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbWFwZC1kcmF3LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * @fileoverview gl-matrix - High performance matrix and vector operations\n * @author Brandon Jones\n * @author Colin MacKenzie IV\n * @version 2.3.2\n */\n\n/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n// END HEADER\n\nexports.glMatrix = __webpack_require__(4);\nexports.mat2 = __webpack_require__(34);\nexports.mat2d = __webpack_require__(35);\nexports.mat3 = __webpack_require__(20);\nexports.mat4 = __webpack_require__(36);\nexports.quat = __webpack_require__(37);\nexports.vec2 = __webpack_require__(38);\nexports.vec3 = __webpack_require__(21);\nexports.vec4 = __webpack_require__(22);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC5qcz9jNzBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZW92ZXJ2aWV3IGdsLW1hdHJpeCAtIEhpZ2ggcGVyZm9ybWFuY2UgbWF0cml4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICogQGF1dGhvciBCcmFuZG9uIEpvbmVzXG4gKiBAYXV0aG9yIENvbGluIE1hY0tlbnppZSBJVlxuICogQHZlcnNpb24gMi4zLjJcbiAqL1xuXG4vKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuLy8gRU5EIEhFQURFUlxuXG5leHBvcnRzLmdsTWF0cml4ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L2NvbW1vbi5qc1wiKTtcbmV4cG9ydHMubWF0MiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyLmpzXCIpO1xuZXhwb3J0cy5tYXQyZCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQyZC5qc1wiKTtcbmV4cG9ydHMubWF0MyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQzLmpzXCIpO1xuZXhwb3J0cy5tYXQ0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L21hdDQuanNcIik7XG5leHBvcnRzLnF1YXQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvcXVhdC5qc1wiKTtcbmV4cG9ydHMudmVjMiA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMyLmpzXCIpO1xuZXhwb3J0cy52ZWMzID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzMuanNcIik7XG5leHBvcnRzLnZlYzQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjNC5qc1wiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MAXY = exports.MAXX = exports.MINY = exports.MINX = undefined;\nexports.set = set;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.initEmpty = initEmpty;\nexports.initInfinity = initInfinity;\nexports.initSizeFromOrigin = initSizeFromOrigin;\nexports.initSizeFromLocation = initSizeFromLocation;\nexports.initCenterExtents = initCenterExtents;\nexports.isEmpty = isEmpty;\nexports.isInfinite = isInfinite;\nexports.equals = equals;\nexports.getSize = getSize;\nexports.getExtents = getExtents;\nexports.getCenter = getCenter;\nexports.expand = expand;\nexports.area = area;\nexports.hull = hull;\nexports.intersection = intersection;\nexports.overlaps = overlaps;\nexports.contains = contains;\nexports.containsPt = containsPt;\nexports.encapsulatePt = encapsulatePt;\nexports.translate = translate;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\n\nvar _glMatrix = __webpack_require__(1);\n\nvar MINX = exports.MINX = 0;\nvar MINY = exports.MINY = 1;\nvar MAXX = exports.MAXX = 2;\nvar MAXY = exports.MAXY = 3;\n\n/**\n * Sets the boundaries of an existing 2d axis-aligned bounding box\n * If arguments are not supplied, the aabox is initialized as empty.\n * @param {AABox2d} out  AAbox2d to set\n * @param {Number} [minx = Infinity] Minimum x-axis value\n * @param {Number} [miny = Infinity] Minimum y-axis value\n * @param {Number} [maxx = -Infinity] Maximum x-axis value\n * @param {Number} [maxy = -Infinity] Maximum y-axis value\n * @return {AABox2d}    bounds referenced by out arg\n */\nfunction set(out, minx, miny, maxx, maxy) {\n  out[MINX] = typeof minx === \"number\" ? minx : Infinity;\n  out[MINY] = typeof miny === \"number\" ? miny : Infinity;\n  out[MAXX] = typeof maxx === \"number\" ? maxx : -Infinity;\n  out[MAXY] = typeof maxy === \"number\" ? maxy : -Infinity;\n  return out;\n}\n\n/**\n * Creates a new 2d axis-aligned bounding box object\n * with optional boundaries. If boundaries are not supplied,\n * the aabox is initialized as empty.\n * @param  {Number} [minx = Infinity] Minimum x-axis value\n * @param  {Number} [miny = Infinity] Minimum y-axis value\n * @param  {Number} [maxx = -Infinity] Maximum x-axis value\n * @param  {Number} [maxy = -Infinity] Maximum y-axis value\n * @return {AABox2d}      New AABox2d object\n */\nfunction create(minx, miny, maxx, maxy) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(4);\n  return set(out, minx, miny, maxx, maxy);\n}\n\n/**\n * Creates a new 2d axis-aligned bounding box with boundaries copied\n * from an existing aabox.\n * @param  {AABox2d} box existing bounds to copy boundaries from\n * @return {AABox2d}     new AABox2d object\n */\nfunction clone(box) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(4);\n  out[MINX] = box[MINX];\n  out[MINY] = box[MINY];\n  out[MAXX] = box[MAXX];\n  out[MAXY] = box[MAXY];\n  return out;\n}\n\n/**\n * Copies the boundaries from one existing aabox to another.\n * @param  {AABox2d} out bounds to copy to\n * @param  {AABox2d} box bounds to copy from\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction copy(out, box) {\n  out[MINX] = box[MINX];\n  out[MINY] = box[MINY];\n  out[MAXX] = box[MAXX];\n  out[MAXY] = box[MAXY];\n  return out;\n}\n\n/**\n * Re-initializes an existing aabox as empty.\n * An aabox is empty if the minimum value in either of\n * its dimensions exceeds its respective max value.\n * In this case, the minumums will be set to +Infinity\n * and the maximums to -Infinity\n * @param  {AABox2d} out existing bounds to re-initialize as empty\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction initEmpty(out) {\n  out[MINX] = Infinity;\n  out[MINY] = Infinity;\n  out[MAXX] = -Infinity;\n  out[MAXY] = -Infinity;\n  return out;\n}\n\n/**\n * Re-initializes an existing aabox to infinity, ultimately encompassing\n * all numeric values.\n * @param  {AABox2d} out existing bounds to initialize to infinity\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction initInfinity(out) {\n  out[MINX] = -Infinity;\n  out[MINY] = -Infinity;\n  out[MAXX] = Infinity;\n  out[MAXY] = Infinity;\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its top-left corner set to be the origin ([0, 0]),\n * an extends outwards in each dimension by its respective size.\n *   minx: 0\n *   miny: 0\n *   maxx: sizes[x]\n *   maxy: sizes[y]\n * @param  {AABox2d} out   existing bounds to re-initialize\n * @param  {Vec2d} sizes   new width/height of the bounds\n * @return {AABox2d}       bounds referenced by out arg\n */\nfunction initSizeFromOrigin(out, sizes) {\n  if (sizes[0] < 0) {\n    out[MINX] = -sizes[0];\n    out[MAXX] = 0;\n  } else {\n    out[MINX] = 0;\n    out[MAXX] = sizes[0];\n  }\n  if (sizes[1] < 0) {\n    out[MINY] = -sizes[1];\n    out[MAXY] = 0;\n  } else {\n    out[MINY] = 0;\n    out[MAXY] = sizes[1];\n  }\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its top-left corner set to be an existing pt and with\n * bounds extending outwards in each dimension by its respective size.\n *   minx: pt[x]\n *   miny: pt[y]\n *   maxx: pt[x] + sizes[x]\n *   maxy: pt[y] + sizes[y]\n * @param  {AABox2d} out   existing bounds to re-initialize\n * @param  {Point2d} pt    new position of the top-left corner of the bounds\n * @param  {Vec2d} sizes   new width/height of the bounds\n * @return {AABox2d}       bounds referenced by out arg\n */\nfunction initSizeFromLocation(out, pt, sizes) {\n  for (var i = 0; i < 2; i += 1) {\n    if (sizes[i] < 0) {\n      out[i] = pt[i] - sizes[i];\n      out[i + 2] = pt[i];\n    } else {\n      out[i] = pt[i];\n      out[i + 2] = pt[i] + sizes[i];\n    }\n  }\n  return out;\n}\n\n/**\n * Initializes an existing aabox with its center set to a specific pt and with bounds\n * extending outward in each dimension so that the aabox's width and height are a\n * specific size\n * @param  {AABox2d} out    existing bounds to re-initialize\n * @param  {Point2d} center new center of the bounds\n * @param  {Vec2d} sizes  new width/height of the bounds\n * @return {AABox2d}        bounds referenced by out arg\n */\nfunction initCenterExtents(out, center, sizes) {\n  for (var i = 0; i < 2; i += 1) {\n    if (sizes[i] < 0) {\n      out[i] = center[i] + sizes[i];\n      out[i + 2] = center[i] - sizes[i];\n    } else {\n      out[i] = center[i] - sizes[i];\n      out[i + 2] = center[i] + sizes[i];\n    }\n  }\n  return out;\n}\n\n/**\n * Returns true if the aabox is empty\n * @param  {AABox2d}  box\n * @return {Boolean}     true if box is empty, false otherwise\n */\nfunction isEmpty(box) {\n  return box[MINX] > box[MAXX] || box[MINY] > box[MAXY];\n}\n\n/**\n * Returns true if an aabox is infinite in either dimension\n * @param  {AABox2d}  box Existing aabox to check\n * @return {Boolean}     True if box extends to +/- inifinity in either dimension, false otherwise\n */\nfunction isInfinite(box) {\n  return !isFinite(box[MINX]) || !isFinite(box[MINY]) || !isFinite(box[MAXX]) || !isFinite(box[MAXY]);\n}\n\n/**\n * Returns true if one aabox approximately equals another\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   true if a ~= b\n */\nfunction equals(a, b) {\n  var a0 = a[0];\n  var a1 = a[1];\n  var a2 = a[2];\n  var a3 = a[3];\n  var b0 = b[0];\n  var b1 = b[1];\n  var b2 = b[2];\n  var b3 = b[3];\n  return Math.abs(a0 - b0) <= _glMatrix.glMatrix.EPSILON && Math.abs(a1 - b1) <= _glMatrix.glMatrix.EPSILON && Math.abs(a2 - b2) <= _glMatrix.glMatrix.EPSILON && Math.abs(a3 - b3) <= _glMatrix.glMatrix.EPSILON;\n}\n\n/**\n * Returns the width/height of an existing aabox\n * @param  {Vec2d} out 2d vector to store the width/height of an existing aabox\n * @param  {AABox2d} box bounds to extract the width/height from\n * @return {Vec2d}     vector referenced by the out arg\n */\nfunction getSize(out, box) {\n  return _glMatrix.vec2.set(out, box[MAXX] - box[MINX], box[MAXY] - box[MINY]);\n}\n\n/**\n * Returns the extents of an existing aabox.\n * Extents is the size of a bounds in each dimension starting at the center\n * of the bounds. (i.e. extents = [width / 2, height / 2])\n * @param  {Vec2d} out 2d vector to store the extents of an existing aabox\n * @param  {AABox2d} box bounds to extract the extents from\n * @return {Vec2d}     vector referenced by the out arg\n */\nfunction getExtents(out, box) {\n  getSize(out, box);\n  return _glMatrix.vec2.scale(out, out, 0.5);\n}\n\n/**\n * Returns the center of an existing aabox\n * @param  {Point2d} out point to store the center of an existing bounds\n * @param  {AABox2d} box bounds to extract the center from\n * @return {Point2d}     point referenced by the out arg\n */\nfunction getCenter(out, box) {\n  getExtents(out, box);\n  out[MINX] += box[MINX];\n  out[MINY] += box[MINY];\n  return out;\n}\n\n/**\n * Expands an existing aabox by a specified size in each dimension.\n * @param  {AABox2d} out        bounds to store the resulting operation in\n * @param  {AABox2d} box        starting bounds to expand\n * @param  {Vec2d} expandSize   size to expand in each dimension\n * @return {AABox2d}            bounds referenced by the out arg\n */\nfunction expand(out, box, expandSize) {\n  out[MINX] = box[MINX] - expandSize[0];\n  out[MAXX] = box[MAXX] + expandSize[0];\n  out[MINY] = box[MINY] - expandSize[1];\n  out[MAXY] = box[MAXY] + expandSize[1];\n}\n\n/**\n * Computes the area of an existing aabox\n * @param  {AABox2d} box\n * @return {Number}     area of the bounds\n */\nfunction area(box) {\n  return (box[MAXX] - box[MINX]) * (box[MAXY] - box[MINY]);\n}\n\n/**\n * Calculates the hull of two aaboxes. The hull is the smallest bounds that contains\n * both of the aaboxes\n * @param  {AABox2d} out bounds to store the resulting operation in\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction hull(out, a, b) {\n  return create(Math.min(a[MINX], b[MINX]), Math.min(a[MINY], b[MINY]), Math.max(a[MAXX], b[MAXX]), Math.max(a[MAXY], b[MAXY]));\n}\n\n/**\n * Calculates the intersection of two existing bounds.\n * @param  {AABox2d} out bounds to store the resulting operation in\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction intersection(out, a, b) {\n  var boxToUse = out;\n  if (out === a) {\n    boxToUse = create();\n  }\n\n  var minindex = MINX;\n  var maxindex = MAXX;\n  for (; minindex <= MINY; minindex += 1, maxindex += 1) {\n    if (a[maxindex] < b[minindex] || a[minindex] > b[maxindex]) {\n      break;\n    }\n\n    boxToUse[minindex] = Math.max(a[minindex], b[minindex]);\n    boxToUse[maxindex] = Math.min(a[maxindex], b[maxindex]);\n  }\n\n  if (minindex !== MINY + 1) {\n    initEmpty(boxToUse);\n  }\n\n  if (out === a) {\n    copy(out, boxToUse);\n  }\n\n  return out;\n}\n\n/**\n * Returns true if one bounds overlaps another in any way (non-inclusive).\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   Returns true if a overlaps b, false otherwise\n */\nfunction overlaps(a, b) {\n  return !(a[MAXX] <= b[MINX] || a[MINX] >= b[MAXX] || a[MAXY] <= b[MINY] || a[MINY] >= b[MAXY]);\n}\n\n/**\n * Returns true if one bounds full contains another (inclusive).\n * @param  {AABox2d} a\n * @param  {AABox2d} b\n * @return {Boolean}   true if a fully contains b.\n */\nfunction contains(a, b) {\n  return !(b[MINX] < a[MINX] || b[MAXX] > a[MAXX] || b[MINY] < a[MINY] || b[MAXY] > a[MAXY]);\n}\n\n/**\n * Returns true if an existing bounds contains a specific point (inclusive)\n * @param  {AABox2d} box\n * @param  {Point2d} pt\n * @return {Boolean}     Returns true if pt is inside of box, false otherwise\n */\nfunction containsPt(box, pt) {\n  return pt[MINX] >= box[MINX] && pt[MINX] <= box[MAXX] && pt[MINY] >= box[MINY] && pt[MINY] <= box[MAXY];\n}\n\n/**\n * Extends an existing bounds so that it would contain a specific point\n * @param  {AABox2d} out Bounds containing the operation result\n * @param  {AABox2d} box Starting bounds to possibly extend\n * @param  {Point2d} pt  Point to encapsulate in box\n * @return {AAbox2d}     bounds referenced by out arg\n */\nfunction encapsulatePt(out, box, pt) {\n  if (out !== box) {\n    copy(out, box);\n  }\n  if (isEmpty(box)) {\n    out[MINX] = pt[MINX];\n    out[MAXX] = pt[MINX];\n    out[MINY] = pt[MINY];\n    out[MAXY] = pt[MINY];\n  } else {\n    if (pt[MINX] < out[MINX]) {\n      out[MINX] = pt[MINX];\n    } else if (pt[MINX] > out[MAXX]) {\n      out[MAXX] = pt[MINX];\n    }\n\n    if (pt[MINY] < out[MINY]) {\n      out[MINY] = pt[MINY];\n    } else if (pt[MINY] > out[MAXY]) {\n      out[MAXY] = pt[MINY];\n    }\n  }\n  return out;\n}\n\n/**\n * Translates an existing bounds by a specified offset it each dimension\n * @param  {AABox2d} out bounds resulting from the operation\n * @param  {AABox2d} box starting bounds\n * @param  {Vec2d} pos   translation in each dimension\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction translate(out, box, pos) {\n  out[MINX] = box[MINX] + pos[0];\n  out[MINY] = box[MINY] + pos[1];\n  out[MAXX] = box[MAXX] + pos[0];\n  out[MAXY] = box[MAXY] + pos[1];\n}\n\nfunction transform(out, box, mat, xformFunc) {\n  var boxToUse = out;\n  if (out === box) {\n    boxToUse = create();\n  }\n  initEmpty(boxToUse);\n\n  var pt1 = _glMatrix.vec2.set(_glMatrix.vec2.create(), box[MINX], box[MINY]);\n  var pt2 = _glMatrix.vec2.create();\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINX] = box[MAXX];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINY] = box[MAXY];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  pt1[MINX] = box[MINX];\n  xformFunc(pt2, pt1, mat);\n  encapsulatePt(boxToUse, boxToUse, pt2);\n  if (out === box) {\n    copy(out, boxToUse);\n  }\n  return out;\n}\n\n/**\n * Transforms an existing bounds by a 2x2 matrix\n * @param  {AABox2d} out bounds to contain the operation result\n * @param  {AABox2d} box bounds to transform\n * @param  {Mat2} mat 2x2 matrix transformation\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction transformMat2(out, box, mat) {\n  return transform(out, box, mat, _glMatrix.vec2.transformMat2);\n}\n\n/**\n * Transforms an existing bounds by a 2x3 matrix.\n * A 2x3 matrix is a 2x2 matrix with a translation component.\n * @param  {AABox2d} out bounds to hold the operation result\n * @param  {AABox2d} box bounds to transform\n * @param  {Mat2d} mat   2x3 matrix\n * @return {AABox2d}     bounds referenced by out arg\n */\nfunction transformMat2d(out, box, mat) {\n  return transform(out, box, mat, _glMatrix.vec2.transformMat2d);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL2FhYm94MmQuanM/MDZlMCJdLCJuYW1lcyI6WyJzZXQiLCJjcmVhdGUiLCJjbG9uZSIsImNvcHkiLCJpbml0RW1wdHkiLCJpbml0SW5maW5pdHkiLCJpbml0U2l6ZUZyb21PcmlnaW4iLCJpbml0U2l6ZUZyb21Mb2NhdGlvbiIsImluaXRDZW50ZXJFeHRlbnRzIiwiaXNFbXB0eSIsImlzSW5maW5pdGUiLCJlcXVhbHMiLCJnZXRTaXplIiwiZ2V0RXh0ZW50cyIsImdldENlbnRlciIsImV4cGFuZCIsImFyZWEiLCJodWxsIiwiaW50ZXJzZWN0aW9uIiwib3ZlcmxhcHMiLCJjb250YWlucyIsImNvbnRhaW5zUHQiLCJlbmNhcHN1bGF0ZVB0IiwidHJhbnNsYXRlIiwidHJhbnNmb3JtTWF0MiIsInRyYW5zZm9ybU1hdDJkIiwiTUlOWCIsIk1JTlkiLCJNQVhYIiwiTUFYWSIsIm91dCIsIm1pbngiLCJtaW55IiwibWF4eCIsIm1heHkiLCJJbmZpbml0eSIsIkFSUkFZX1RZUEUiLCJib3giLCJzaXplcyIsInB0IiwiaSIsImNlbnRlciIsImlzRmluaXRlIiwiYSIsImIiLCJhMCIsImExIiwiYTIiLCJhMyIsImIwIiwiYjEiLCJiMiIsImIzIiwiTWF0aCIsImFicyIsIkVQU0lMT04iLCJzY2FsZSIsImV4cGFuZFNpemUiLCJtaW4iLCJtYXgiLCJib3hUb1VzZSIsIm1pbmluZGV4IiwibWF4aW5kZXgiLCJwb3MiLCJ0cmFuc2Zvcm0iLCJtYXQiLCJ4Zm9ybUZ1bmMiLCJwdDEiLCJwdDIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7UUFtQmdCQSxHLEdBQUFBLEc7UUFrQkFDLE0sR0FBQUEsTTtRQVdBQyxLLEdBQUFBLEs7UUFlQUMsSSxHQUFBQSxJO1FBaUJBQyxTLEdBQUFBLFM7UUFjQUMsWSxHQUFBQSxZO1FBbUJBQyxrQixHQUFBQSxrQjtRQThCQUMsb0IsR0FBQUEsb0I7UUFzQkFDLGlCLEdBQUFBLGlCO1FBa0JBQyxPLEdBQUFB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LEVBQTRCTyxHQUE1QixFQUFpQzRCLEdBQWpDLEVBQXNDO0FBQzNDLFNBQU9ELFVBQVVsQyxHQUFWLEVBQWVPLEdBQWYsRUFBb0I0QixHQUFwQixFQUF5QixlQUFNekMsYUFBL0IsQ0FBUDtBQUNEOztBQUVEOzs7Ozs7OztBQVFPLFNBQVNDLGNBQVQsQ0FBd0JLLEdBQXhCLEVBQTZCTyxHQUE3QixFQUFrQzRCLEdBQWxDLEVBQXVDO0FBQzVDLFNBQU9ELFVBQVVsQyxHQUFWLEVBQWVPLEdBQWYsRUFBb0I0QixHQUFwQixFQUF5QixlQUFNeEMsY0FBL0IsQ0FBUDtBQUNEIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQge2dsTWF0cml4LCB2ZWMyIGFzIFZlYzJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuZXhwb3J0IGNvbnN0IE1JTlggPSAwXG5leHBvcnQgY29uc3QgTUlOWSA9IDFcbmV4cG9ydCBjb25zdCBNQVhYID0gMlxuZXhwb3J0IGNvbnN0IE1BWFkgPSAzXG5cbi8qKlxuICogU2V0cyB0aGUgYm91bmRhcmllcyBvZiBhbiBleGlzdGluZyAyZCBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94XG4gKiBJZiBhcmd1bWVudHMgYXJlIG5vdCBzdXBwbGllZCwgdGhlIGFhYm94IGlzIGluaXRpYWxpemVkIGFzIGVtcHR5LlxuICogQHBhcmFtIHtBQUJveDJkfSBvdXQgIEFBYm94MmQgdG8gc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gW21pbnggPSBJbmZpbml0eV0gTWluaW11bSB4LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWlueSA9IEluZmluaXR5XSBNaW5pbXVtIHktYXhpcyB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXh4ID0gLUluZmluaXR5XSBNYXhpbXVtIHgtYXhpcyB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXh5ID0gLUluZmluaXR5XSBNYXhpbXVtIHktYXhpcyB2YWx1ZVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbWlueCwgbWlueSwgbWF4eCwgbWF4eSkge1xuICBvdXRbTUlOWF0gPSB0eXBlb2YgbWlueCA9PT0gXCJudW1iZXJcIiA/IG1pbnggOiBJbmZpbml0eVxuICBvdXRbTUlOWV0gPSB0eXBlb2YgbWlueSA9PT0gXCJudW1iZXJcIiA/IG1pbnkgOiBJbmZpbml0eVxuICBvdXRbTUFYWF0gPSB0eXBlb2YgbWF4eCA9PT0gXCJudW1iZXJcIiA/IG1heHggOiAtSW5maW5pdHlcbiAgb3V0W01BWFldID0gdHlwZW9mIG1heHkgPT09IFwibnVtYmVyXCIgPyBtYXh5IDogLUluZmluaXR5XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IDJkIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2JqZWN0XG4gKiB3aXRoIG9wdGlvbmFsIGJvdW5kYXJpZXMuIElmIGJvdW5kYXJpZXMgYXJlIG5vdCBzdXBwbGllZCxcbiAqIHRoZSBhYWJveCBpcyBpbml0aWFsaXplZCBhcyBlbXB0eS5cbiAqIEBwYXJhbSAge051bWJlcn0gW21pbnggPSBJbmZpbml0eV0gTWluaW11bSB4LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gW21pbnkgPSBJbmZpbml0eV0gTWluaW11bSB5LWF4aXMgdmFsdWVcbiAqIEBwYXJhbSAge051bWJlcn0gW21heHggPSAtSW5maW5pdHldIE1heGltdW0geC1heGlzIHZhbHVlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFttYXh5ID0gLUluZmluaXR5XSBNYXhpbXVtIHktYXhpcyB2YWx1ZVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgICBOZXcgQUFCb3gyZCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShtaW54LCBtaW55LCBtYXh4LCBtYXh5KSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpXG4gIHJldHVybiBzZXQob3V0LCBtaW54LCBtaW55LCBtYXh4LCBtYXh5KVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgMmQgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCB3aXRoIGJvdW5kYXJpZXMgY29waWVkXG4gKiBmcm9tIGFuIGV4aXN0aW5nIGFhYm94LlxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGV4aXN0aW5nIGJvdW5kcyB0byBjb3B5IGJvdW5kYXJpZXMgZnJvbVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIG5ldyBBQUJveDJkIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYm94KSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpXG4gIG91dFtNSU5YXSA9IGJveFtNSU5YXVxuICBvdXRbTUlOWV0gPSBib3hbTUlOWV1cbiAgb3V0W01BWFhdID0gYm94W01BWFhdXG4gIG91dFtNQVhZXSA9IGJveFtNQVhZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBib3VuZGFyaWVzIGZyb20gb25lIGV4aXN0aW5nIGFhYm94IHRvIGFub3RoZXIuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHRvIGNvcHkgdG9cbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBib3VuZHMgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGJveCkge1xuICBvdXRbTUlOWF0gPSBib3hbTUlOWF1cbiAgb3V0W01JTlldID0gYm94W01JTlldXG4gIG91dFtNQVhYXSA9IGJveFtNQVhYXVxuICBvdXRbTUFYWV0gPSBib3hbTUFYWV1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJlLWluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IGFzIGVtcHR5LlxuICogQW4gYWFib3ggaXMgZW1wdHkgaWYgdGhlIG1pbmltdW0gdmFsdWUgaW4gZWl0aGVyIG9mXG4gKiBpdHMgZGltZW5zaW9ucyBleGNlZWRzIGl0cyByZXNwZWN0aXZlIG1heCB2YWx1ZS5cbiAqIEluIHRoaXMgY2FzZSwgdGhlIG1pbnVtdW1zIHdpbGwgYmUgc2V0IHRvICtJbmZpbml0eVxuICogYW5kIHRoZSBtYXhpbXVtcyB0byAtSW5maW5pdHlcbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZSBhcyBlbXB0eVxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRFbXB0eShvdXQpIHtcbiAgb3V0W01JTlhdID0gSW5maW5pdHlcbiAgb3V0W01JTlldID0gSW5maW5pdHlcbiAgb3V0W01BWFhdID0gLUluZmluaXR5XG4gIG91dFtNQVhZXSA9IC1JbmZpbml0eVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUmUtaW5pdGlhbGl6ZXMgYW4gZXhpc3RpbmcgYWFib3ggdG8gaW5maW5pdHksIHVsdGltYXRlbHkgZW5jb21wYXNzaW5nXG4gKiBhbGwgbnVtZXJpYyB2YWx1ZXMuXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgZXhpc3RpbmcgYm91bmRzIHRvIGluaXRpYWxpemUgdG8gaW5maW5pdHlcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0SW5maW5pdHkob3V0KSB7XG4gIG91dFtNSU5YXSA9IC1JbmZpbml0eVxuICBvdXRbTUlOWV0gPSAtSW5maW5pdHlcbiAgb3V0W01BWFhdID0gSW5maW5pdHlcbiAgb3V0W01BWFldID0gSW5maW5pdHlcbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHdpdGggaXRzIHRvcC1sZWZ0IGNvcm5lciBzZXQgdG8gYmUgdGhlIG9yaWdpbiAoWzAsIDBdKSxcbiAqIGFuIGV4dGVuZHMgb3V0d2FyZHMgaW4gZWFjaCBkaW1lbnNpb24gYnkgaXRzIHJlc3BlY3RpdmUgc2l6ZS5cbiAqICAgbWlueDogMFxuICogICBtaW55OiAwXG4gKiAgIG1heHg6IHNpemVzW3hdXG4gKiAgIG1heHk6IHNpemVzW3ldXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgICBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZVxuICogQHBhcmFtICB7VmVjMmR9IHNpemVzICAgbmV3IHdpZHRoL2hlaWdodCBvZiB0aGUgYm91bmRzXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2l6ZUZyb21PcmlnaW4ob3V0LCBzaXplcykge1xuICBpZiAoc2l6ZXNbMF0gPCAwKSB7XG4gICAgb3V0W01JTlhdID0gLXNpemVzWzBdXG4gICAgb3V0W01BWFhdID0gMFxuICB9IGVsc2Uge1xuICAgIG91dFtNSU5YXSA9IDBcbiAgICBvdXRbTUFYWF0gPSBzaXplc1swXVxuICB9XG4gIGlmIChzaXplc1sxXSA8IDApIHtcbiAgICBvdXRbTUlOWV0gPSAtc2l6ZXNbMV1cbiAgICBvdXRbTUFYWV0gPSAwXG4gIH0gZWxzZSB7XG4gICAgb3V0W01JTlldID0gMFxuICAgIG91dFtNQVhZXSA9IHNpemVzWzFdXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHdpdGggaXRzIHRvcC1sZWZ0IGNvcm5lciBzZXQgdG8gYmUgYW4gZXhpc3RpbmcgcHQgYW5kIHdpdGhcbiAqIGJvdW5kcyBleHRlbmRpbmcgb3V0d2FyZHMgaW4gZWFjaCBkaW1lbnNpb24gYnkgaXRzIHJlc3BlY3RpdmUgc2l6ZS5cbiAqICAgbWlueDogcHRbeF1cbiAqICAgbWlueTogcHRbeV1cbiAqICAgbWF4eDogcHRbeF0gKyBzaXplc1t4XVxuICogICBtYXh5OiBwdFt5XSArIHNpemVzW3ldXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgICBleGlzdGluZyBib3VuZHMgdG8gcmUtaW5pdGlhbGl6ZVxuICogQHBhcmFtICB7UG9pbnQyZH0gcHQgICAgbmV3IHBvc2l0aW9uIG9mIHRoZSB0b3AtbGVmdCBjb3JuZXIgb2YgdGhlIGJvdW5kc1xuICogQHBhcmFtICB7VmVjMmR9IHNpemVzICAgbmV3IHdpZHRoL2hlaWdodCBvZiB0aGUgYm91bmRzXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbml0U2l6ZUZyb21Mb2NhdGlvbihvdXQsIHB0LCBzaXplcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkgKz0gMSkge1xuICAgIGlmIChzaXplc1tpXSA8IDApIHtcbiAgICAgIG91dFtpXSA9IHB0W2ldIC0gc2l6ZXNbaV1cbiAgICAgIG91dFtpICsgMl0gPSBwdFtpXVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRbaV0gPSBwdFtpXVxuICAgICAgb3V0W2kgKyAyXSA9IHB0W2ldICsgc2l6ZXNbaV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGV4aXN0aW5nIGFhYm94IHdpdGggaXRzIGNlbnRlciBzZXQgdG8gYSBzcGVjaWZpYyBwdCBhbmQgd2l0aCBib3VuZHNcbiAqIGV4dGVuZGluZyBvdXR3YXJkIGluIGVhY2ggZGltZW5zaW9uIHNvIHRoYXQgdGhlIGFhYm94J3Mgd2lkdGggYW5kIGhlaWdodCBhcmUgYVxuICogc3BlY2lmaWMgc2l6ZVxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0ICAgIGV4aXN0aW5nIGJvdW5kcyB0byByZS1pbml0aWFsaXplXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBjZW50ZXIgbmV3IGNlbnRlciBvZiB0aGUgYm91bmRzXG4gKiBAcGFyYW0gIHtWZWMyZH0gc2l6ZXMgIG5ldyB3aWR0aC9oZWlnaHQgb2YgdGhlIGJvdW5kc1xuICogQHJldHVybiB7QUFCb3gyZH0gICAgICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRDZW50ZXJFeHRlbnRzKG91dCwgY2VudGVyLCBzaXplcykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkgKz0gMSkge1xuICAgIGlmIChzaXplc1tpXSA8IDApIHtcbiAgICAgIG91dFtpXSA9IGNlbnRlcltpXSArIHNpemVzW2ldXG4gICAgICBvdXRbaSArIDJdID0gY2VudGVyW2ldIC0gc2l6ZXNbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0W2ldID0gY2VudGVyW2ldIC0gc2l6ZXNbaV1cbiAgICAgIG91dFtpICsgMl0gPSBjZW50ZXJbaV0gKyBzaXplc1tpXVxuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhYWJveCBpcyBlbXB0eVxuICogQHBhcmFtICB7QUFCb3gyZH0gIGJveFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIHRydWUgaWYgYm94IGlzIGVtcHR5LCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHkoYm94KSB7XG4gIHJldHVybiAoYm94W01JTlhdID4gYm94W01BWFhdIHx8IGJveFtNSU5ZXSA+IGJveFtNQVhZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gYWFib3ggaXMgaW5maW5pdGUgaW4gZWl0aGVyIGRpbWVuc2lvblxuICogQHBhcmFtICB7QUFCb3gyZH0gIGJveCBFeGlzdGluZyBhYWJveCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUgaWYgYm94IGV4dGVuZHMgdG8gKy8tIGluaWZpbml0eSBpbiBlaXRoZXIgZGltZW5zaW9uLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW5maW5pdGUoYm94KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoYm94W01JTlhdKSB8fCAhaXNGaW5pdGUoYm94W01JTlldKSB8fCAhaXNGaW5pdGUoYm94W01BWFhdKSB8fCAhaXNGaW5pdGUoYm94W01BWFldKVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvbmUgYWFib3ggYXBwcm94aW1hdGVseSBlcXVhbHMgYW5vdGhlclxuICogQHBhcmFtICB7QUFCb3gyZH0gYVxuICogQHBhcmFtICB7QUFCb3gyZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIGlmIGEgfj0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgY29uc3QgYTAgPSBhWzBdXG4gIGNvbnN0IGExID0gYVsxXVxuICBjb25zdCBhMiA9IGFbMl1cbiAgY29uc3QgYTMgPSBhWzNdXG4gIGNvbnN0IGIwID0gYlswXVxuICBjb25zdCBiMSA9IGJbMV1cbiAgY29uc3QgYjIgPSBiWzJdXG4gIGNvbnN0IGIzID0gYlszXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04pXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgd2lkdGgvaGVpZ2h0IG9mIGFuIGV4aXN0aW5nIGFhYm94XG4gKiBAcGFyYW0gIHtWZWMyZH0gb3V0IDJkIHZlY3RvciB0byBzdG9yZSB0aGUgd2lkdGgvaGVpZ2h0IG9mIGFuIGV4aXN0aW5nIGFhYm94XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggYm91bmRzIHRvIGV4dHJhY3QgdGhlIHdpZHRoL2hlaWdodCBmcm9tXG4gKiBAcmV0dXJuIHtWZWMyZH0gICAgIHZlY3RvciByZWZlcmVuY2VkIGJ5IHRoZSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXplKG91dCwgYm94KSB7XG4gIHJldHVybiBWZWMyZC5zZXQob3V0LCBib3hbTUFYWF0gLSBib3hbTUlOWF0sIGJveFtNQVhZXSAtIGJveFtNSU5ZXSlcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBleHRlbnRzIG9mIGFuIGV4aXN0aW5nIGFhYm94LlxuICogRXh0ZW50cyBpcyB0aGUgc2l6ZSBvZiBhIGJvdW5kcyBpbiBlYWNoIGRpbWVuc2lvbiBzdGFydGluZyBhdCB0aGUgY2VudGVyXG4gKiBvZiB0aGUgYm91bmRzLiAoaS5lLiBleHRlbnRzID0gW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl0pXG4gKiBAcGFyYW0gIHtWZWMyZH0gb3V0IDJkIHZlY3RvciB0byBzdG9yZSB0aGUgZXh0ZW50cyBvZiBhbiBleGlzdGluZyBhYWJveFxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IGJvdW5kcyB0byBleHRyYWN0IHRoZSBleHRlbnRzIGZyb21cbiAqIEByZXR1cm4ge1ZlYzJkfSAgICAgdmVjdG9yIHJlZmVyZW5jZWQgYnkgdGhlIG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4dGVudHMob3V0LCBib3gpIHtcbiAgZ2V0U2l6ZShvdXQsIGJveClcbiAgcmV0dXJuIFZlYzJkLnNjYWxlKG91dCwgb3V0LCAwLjUpXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY2VudGVyIG9mIGFuIGV4aXN0aW5nIGFhYm94XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBvdXQgcG9pbnQgdG8gc3RvcmUgdGhlIGNlbnRlciBvZiBhbiBleGlzdGluZyBib3VuZHNcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBib3VuZHMgdG8gZXh0cmFjdCB0aGUgY2VudGVyIGZyb21cbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBwb2ludCByZWZlcmVuY2VkIGJ5IHRoZSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDZW50ZXIob3V0LCBib3gpIHtcbiAgZ2V0RXh0ZW50cyhvdXQsIGJveClcbiAgb3V0W01JTlhdICs9IGJveFtNSU5YXVxuICBvdXRbTUlOWV0gKz0gYm94W01JTlldXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBFeHBhbmRzIGFuIGV4aXN0aW5nIGFhYm94IGJ5IGEgc3BlY2lmaWVkIHNpemUgaW4gZWFjaCBkaW1lbnNpb24uXG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgICAgICAgIGJvdW5kcyB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIG9wZXJhdGlvbiBpblxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94ICAgICAgICBzdGFydGluZyBib3VuZHMgdG8gZXhwYW5kXG4gKiBAcGFyYW0gIHtWZWMyZH0gZXhwYW5kU2l6ZSAgIHNpemUgdG8gZXhwYW5kIGluIGVhY2ggZGltZW5zaW9uXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgICAgICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IHRoZSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmQob3V0LCBib3gsIGV4cGFuZFNpemUpIHtcbiAgb3V0W01JTlhdID0gYm94W01JTlhdIC0gZXhwYW5kU2l6ZVswXVxuICBvdXRbTUFYWF0gPSBib3hbTUFYWF0gKyBleHBhbmRTaXplWzBdXG4gIG91dFtNSU5ZXSA9IGJveFtNSU5ZXSAtIGV4cGFuZFNpemVbMV1cbiAgb3V0W01BWFldID0gYm94W01BWFldICsgZXhwYW5kU2l6ZVsxXVxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBhcmVhIG9mIGFuIGV4aXN0aW5nIGFhYm94XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3hcbiAqIEByZXR1cm4ge051bWJlcn0gICAgIGFyZWEgb2YgdGhlIGJvdW5kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlYShib3gpIHtcbiAgcmV0dXJuIChib3hbTUFYWF0gLSBib3hbTUlOWF0pICogKGJveFtNQVhZXSAtIGJveFtNSU5ZXSlcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBodWxsIG9mIHR3byBhYWJveGVzLiBUaGUgaHVsbCBpcyB0aGUgc21hbGxlc3QgYm91bmRzIHRoYXQgY29udGFpbnNcbiAqIGJvdGggb2YgdGhlIGFhYm94ZXNcbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBib3VuZHMgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBvcGVyYXRpb24gaW5cbiAqIEBwYXJhbSAge0FBQm94MmR9IGFcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodWxsKG91dCwgYSwgYikge1xuICByZXR1cm4gY3JlYXRlKE1hdGgubWluKGFbTUlOWF0sIGJbTUlOWF0pLCBNYXRoLm1pbihhW01JTlldLCBiW01JTlldKSwgTWF0aC5tYXgoYVtNQVhYXSwgYltNQVhYXSksIE1hdGgubWF4KGFbTUFYWV0sIGJbTUFYWV0pKVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGludGVyc2VjdGlvbiBvZiB0d28gZXhpc3RpbmcgYm91bmRzLlxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGJvdW5kcyB0byBzdG9yZSB0aGUgcmVzdWx0aW5nIG9wZXJhdGlvbiBpblxuICogQHBhcmFtICB7QUFCb3gyZH0gYVxuICogQHBhcmFtICB7QUFCb3gyZH0gYlxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihvdXQsIGEsIGIpIHtcbiAgbGV0IGJveFRvVXNlID0gb3V0XG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICBib3hUb1VzZSA9IGNyZWF0ZSgpXG4gIH1cblxuICBsZXQgbWluaW5kZXggPSBNSU5YXG4gIGxldCBtYXhpbmRleCA9IE1BWFhcbiAgZm9yICg7IG1pbmluZGV4IDw9IE1JTlk7IG1pbmluZGV4ICs9IDEsIG1heGluZGV4ICs9IDEpIHtcbiAgICBpZiAoYVttYXhpbmRleF0gPCBiW21pbmluZGV4XSB8fCBhW21pbmluZGV4XSA+IGJbbWF4aW5kZXhdKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGJveFRvVXNlW21pbmluZGV4XSA9IE1hdGgubWF4KGFbbWluaW5kZXhdLCBiW21pbmluZGV4XSlcbiAgICBib3hUb1VzZVttYXhpbmRleF0gPSBNYXRoLm1pbihhW21heGluZGV4XSwgYlttYXhpbmRleF0pXG4gIH1cblxuICBpZiAobWluaW5kZXggIT09IE1JTlkgKyAxKSB7XG4gICAgaW5pdEVtcHR5KGJveFRvVXNlKVxuICB9XG5cbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIGNvcHkob3V0LCBib3hUb1VzZSlcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb25lIGJvdW5kcyBvdmVybGFwcyBhbm90aGVyIGluIGFueSB3YXkgKG5vbi1pbmNsdXNpdmUpLlxuICogQHBhcmFtICB7QUFCb3gyZH0gYVxuICogQHBhcmFtICB7QUFCb3gyZH0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gICBSZXR1cm5zIHRydWUgaWYgYSBvdmVybGFwcyBiLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG92ZXJsYXBzKGEsIGIpIHtcbiAgcmV0dXJuICEoYVtNQVhYXSA8PSBiW01JTlhdIHx8IGFbTUlOWF0gPj0gYltNQVhYXSB8fCBhW01BWFldIDw9IGJbTUlOWV0gfHwgYVtNSU5ZXSA+PSBiW01BWFldKVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvbmUgYm91bmRzIGZ1bGwgY29udGFpbnMgYW5vdGhlciAoaW5jbHVzaXZlKS5cbiAqIEBwYXJhbSAge0FBQm94MmR9IGFcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgdHJ1ZSBpZiBhIGZ1bGx5IGNvbnRhaW5zIGIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWlucyhhLCBiKSB7XG4gIHJldHVybiAhKGJbTUlOWF0gPCBhW01JTlhdIHx8IGJbTUFYWF0gPiBhW01BWFhdIHx8IGJbTUlOWV0gPCBhW01JTlldIHx8IGJbTUFYWV0gPiBhW01BWFldKVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBleGlzdGluZyBib3VuZHMgY29udGFpbnMgYSBzcGVjaWZpYyBwb2ludCAoaW5jbHVzaXZlKVxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFJldHVybnMgdHJ1ZSBpZiBwdCBpcyBpbnNpZGUgb2YgYm94LCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUHQoYm94LCBwdCkge1xuICByZXR1cm4gKHB0W01JTlhdID49IGJveFtNSU5YXSAmJiBwdFtNSU5YXSA8PSBib3hbTUFYWF0gJiYgcHRbTUlOWV0gPj0gYm94W01JTlldICYmIHB0W01JTlldIDw9IGJveFtNQVhZXSlcbn1cblxuLyoqXG4gKiBFeHRlbmRzIGFuIGV4aXN0aW5nIGJvdW5kcyBzbyB0aGF0IGl0IHdvdWxkIGNvbnRhaW4gYSBzcGVjaWZpYyBwb2ludFxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IEJvdW5kcyBjb250YWluaW5nIHRoZSBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggU3RhcnRpbmcgYm91bmRzIHRvIHBvc3NpYmx5IGV4dGVuZFxuICogQHBhcmFtICB7UG9pbnQyZH0gcHQgIFBvaW50IHRvIGVuY2Fwc3VsYXRlIGluIGJveFxuICogQHJldHVybiB7QUFib3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY2Fwc3VsYXRlUHQob3V0LCBib3gsIHB0KSB7XG4gIGlmIChvdXQgIT09IGJveCkge1xuICAgIGNvcHkob3V0LCBib3gpXG4gIH1cbiAgaWYgKGlzRW1wdHkoYm94KSkge1xuICAgIG91dFtNSU5YXSA9IHB0W01JTlhdXG4gICAgb3V0W01BWFhdID0gcHRbTUlOWF1cbiAgICBvdXRbTUlOWV0gPSBwdFtNSU5ZXVxuICAgIG91dFtNQVhZXSA9IHB0W01JTlldXG4gIH0gZWxzZSB7XG4gICAgaWYgKHB0W01JTlhdIDwgb3V0W01JTlhdKSB7XG4gICAgICBvdXRbTUlOWF0gPSBwdFtNSU5YXVxuICAgIH0gZWxzZSBpZiAocHRbTUlOWF0gPiBvdXRbTUFYWF0pIHtcbiAgICAgIG91dFtNQVhYXSA9IHB0W01JTlhdXG4gICAgfVxuXG4gICAgaWYgKHB0W01JTlldIDwgb3V0W01JTlldKSB7XG4gICAgICBvdXRbTUlOWV0gPSBwdFtNSU5ZXVxuICAgIH0gZWxzZSBpZiAocHRbTUlOWV0gPiBvdXRbTUFYWV0pIHtcbiAgICAgIG91dFtNQVhZXSA9IHB0W01JTlldXG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIGFuIGV4aXN0aW5nIGJvdW5kcyBieSBhIHNwZWNpZmllZCBvZmZzZXQgaXQgZWFjaCBkaW1lbnNpb25cbiAqIEBwYXJhbSAge0FBQm94MmR9IG91dCBib3VuZHMgcmVzdWx0aW5nIGZyb20gdGhlIG9wZXJhdGlvblxuICogQHBhcmFtICB7QUFCb3gyZH0gYm94IHN0YXJ0aW5nIGJvdW5kc1xuICogQHBhcmFtICB7VmVjMmR9IHBvcyAgIHRyYW5zbGF0aW9uIGluIGVhY2ggZGltZW5zaW9uXG4gKiBAcmV0dXJuIHtBQUJveDJkfSAgICAgYm91bmRzIHJlZmVyZW5jZWQgYnkgb3V0IGFyZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYm94LCBwb3MpIHtcbiAgb3V0W01JTlhdID0gYm94W01JTlhdICsgcG9zWzBdXG4gIG91dFtNSU5ZXSA9IGJveFtNSU5ZXSArIHBvc1sxXVxuICBvdXRbTUFYWF0gPSBib3hbTUFYWF0gKyBwb3NbMF1cbiAgb3V0W01BWFldID0gYm94W01BWFldICsgcG9zWzFdXG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShvdXQsIGJveCwgbWF0LCB4Zm9ybUZ1bmMpIHtcbiAgbGV0IGJveFRvVXNlID0gb3V0XG4gIGlmIChvdXQgPT09IGJveCkge1xuICAgIGJveFRvVXNlID0gY3JlYXRlKClcbiAgfVxuICBpbml0RW1wdHkoYm94VG9Vc2UpXG5cbiAgY29uc3QgcHQxID0gVmVjMmQuc2V0KFZlYzJkLmNyZWF0ZSgpLCBib3hbTUlOWF0sIGJveFtNSU5ZXSlcbiAgY29uc3QgcHQyID0gVmVjMmQuY3JlYXRlKClcbiAgeGZvcm1GdW5jKHB0MiwgcHQxLCBtYXQpXG4gIGVuY2Fwc3VsYXRlUHQoYm94VG9Vc2UsIGJveFRvVXNlLCBwdDIpXG4gIHB0MVtNSU5YXSA9IGJveFtNQVhYXVxuICB4Zm9ybUZ1bmMocHQyLCBwdDEsIG1hdClcbiAgZW5jYXBzdWxhdGVQdChib3hUb1VzZSwgYm94VG9Vc2UsIHB0MilcbiAgcHQxW01JTlldID0gYm94W01BWFldXG4gIHhmb3JtRnVuYyhwdDIsIHB0MSwgbWF0KVxuICBlbmNhcHN1bGF0ZVB0KGJveFRvVXNlLCBib3hUb1VzZSwgcHQyKVxuICBwdDFbTUlOWF0gPSBib3hbTUlOWF1cbiAgeGZvcm1GdW5jKHB0MiwgcHQxLCBtYXQpXG4gIGVuY2Fwc3VsYXRlUHQoYm94VG9Vc2UsIGJveFRvVXNlLCBwdDIpXG4gIGlmIChvdXQgPT09IGJveCkge1xuICAgIGNvcHkob3V0LCBib3hUb1VzZSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleGlzdGluZyBib3VuZHMgYnkgYSAyeDIgbWF0cml4XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBvdXQgYm91bmRzIHRvIGNvbnRhaW4gdGhlIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSAge0FBQm94MmR9IGJveCBib3VuZHMgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0gIHtNYXQyfSBtYXQgMngyIG1hdHJpeCB0cmFuc2Zvcm1hdGlvblxuICogQHJldHVybiB7QUFCb3gyZH0gICAgIGJvdW5kcyByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDIob3V0LCBib3gsIG1hdCkge1xuICByZXR1cm4gdHJhbnNmb3JtKG91dCwgYm94LCBtYXQsIFZlYzJkLnRyYW5zZm9ybU1hdDIpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhbiBleGlzdGluZyBib3VuZHMgYnkgYSAyeDMgbWF0cml4LlxuICogQSAyeDMgbWF0cml4IGlzIGEgMngyIG1hdHJpeCB3aXRoIGEgdHJhbnNsYXRpb24gY29tcG9uZW50LlxuICogQHBhcmFtICB7QUFCb3gyZH0gb3V0IGJvdW5kcyB0byBob2xkIHRoZSBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtBQUJveDJkfSBib3ggYm91bmRzIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtICB7TWF0MmR9IG1hdCAgIDJ4MyBtYXRyaXhcbiAqIEByZXR1cm4ge0FBQm94MmR9ICAgICBib3VuZHMgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGJveCwgbWF0KSB7XG4gIHJldHVybiB0cmFuc2Zvcm0ob3V0LCBib3gsIG1hdCwgVmVjMmQudHJhbnNmb3JtTWF0MmQpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb3JlL2FhYm94MmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sqrDist = exports.dist = undefined;\nexports.set = set;\nexports.create = create;\nexports.clone = clone;\nexports.copy = copy;\nexports.initFromValues = initFromValues;\nexports.addVec2 = addVec2;\nexports.sub = sub;\nexports.transformMat2 = transformMat2;\nexports.transformMat2d = transformMat2d;\nexports.str = str;\nexports.distance = distance;\nexports.squaredDistance = squaredDistance;\nexports.lerp = lerp;\nexports.equals = equals;\nexports.exactEquals = exactEquals;\n\nvar _glMatrix = __webpack_require__(1);\n\nvar X = 0;\nvar Y = 1;\n\n/**\n * Sets the coordinates of a 2D point\n * @param {Point2d} out Point to set\n * @param {Number} [x = 0]   X coordinate\n * @param {Number} [y = 0]   Y coordinate\n * @return {Point2d}    Point referenced by out arg\n */\nfunction set(out) {\n  var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  out[X] = x;\n  out[Y] = y;\n  return out;\n}\n\n/**\n * Creates a new Point2d object\n * @param  {Number} [x = 0] X coordinate\n * @param  {Number} [y = 0] Y coordinate\n * @return {Point2d}\n */\nfunction create() {\n  var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(2);\n  return set(out, x, y);\n}\n\n/**\n * Creates a new Point2d object with coordinates initialized from an existing point.\n * @param  {Point2d} p\n * @return {Point2d}\n */\nfunction clone(p) {\n  var out = new _glMatrix.glMatrix.ARRAY_TYPE(2);\n  out[X] = p[X];\n  out[Y] = p[Y];\n  return out;\n}\n\n/**\n * Copies the coordinates of one point to another.\n * @param  {Point2d} out The point to copy to\n * @param  {Point2d} p   The point to copy from\n * @return {Point2d}     Point referenced by out arg\n */\nfunction copy(out, p) {\n  out[X] = p[X];\n  out[Y] = p[Y];\n  return out;\n}\n\n/**\n * Creates a new point from coordinates\n * @param  {Number} x X coordinate\n * @param  {Number} y Y coordinate\n * @return {Point2d}   New point\n */\nfunction initFromValues(x, y) {\n  return create(x, y);\n}\n\n/**\n * Adds a 2d offset to an existing point\n * @param {Point2d} out Point receiving the operation result\n * @param {Point2d} pt  Existing point\n * @param {Vec2d} v   Vector describing the offset\n * @return {Point2d}   Point referenced by out arg\n */\nfunction addVec2(out, pt, v) {\n  return _glMatrix.vec2.add(out, pt, v);\n}\n\n/**\n * Calculates the difference between two points\n * @param  {Vec2d} out Vector receiving operation result\n * @param  {Point2d} pt1\n * @param  {Point2d} pt2\n * @return {Vec2d}     Vector referenced by out arg\n */\nfunction sub(out, pt1, pt2) {\n  return _glMatrix.vec2.sub(out, pt1, pt2);\n}\n\n/**\n * Performs an 2x2 matrix multiplication on a point\n * @param  {Point2d} out Point receiving operation result\n * @param  {Point2d} p\n * @param  {Mat2} m 2x2 matrix\n * @return {Point2d}     Point referenced by out arg\n */\nfunction transformMat2(out, p, m) {\n  return _glMatrix.vec2.transformMat2(out, p, m);\n}\n\n/**\n * Performs a 2x3 matrix multiplication on a point.\n * A 2x3 matrix is ultimately a 2x2 matrix with a\n * translation component\n * @param  {Point2d} out Point receiving operation result\n * @param  {Point2d} p\n * @param  {Mat2d} m   2x3 matrix\n * @return {Point2d}     Point referenced by out arg\n */\nfunction transformMat2d(out, p, m) {\n  return _glMatrix.vec2.transformMat2d(out, p, m);\n}\n\n/**\n * Creates a string representation of a point\n * @param  {Point2d} p\n * @return {string}\n */\nfunction str(p) {\n  return \"point2d(\" + p[0] + \" , \" + p[1] + \")\";\n}\n\n/**\n * Computes the distance between two 2d points\n * @param  {Point2d} p1\n * @param  {Point2d} p2\n * @return {Number}\n */\nfunction distance(p1, p2) {\n  return _glMatrix.vec2.distance(p1, p2);\n}\n\nvar dist = exports.dist = distance;\n\n/**\n * Returns the squared distance between two points.\n * This is a cheaper operation than the true distance\n * calculation.\n * @param  {Point2d} p1\n * @param  {Point2d} p2\n * @return {Number}    distance^2\n */\nfunction squaredDistance(p1, p2) {\n  return _glMatrix.vec2.squaredDistance(p1, p2);\n}\n\nvar sqrDist = exports.sqrDist = squaredDistance;\n\n/**\n * Calculates the point linearly interpolated\n * between two points according to the relative operator t\n * [t == 0 = p1 & t == 1 = p2]\n * @param  {Point2d} out Point receiving result of operation\n * @param  {Point2d} p1  Start point (t = 0)\n * @param  {Point2d} p2  End point (t = 1)\n * @param  {[type]} t   Interpolate parameter [0, 1]\n * @return {Point2d}     Point referenced by out arg\n */\nfunction lerp(out, p1, p2, t) {\n  return _glMatrix.vec2.lerp(out, p1, p2, t);\n}\n\n/**\n * Returns whether two points are relatively equal\n * @param  {Point2d} a\n * @param  {Point2d} b\n * @return {Boolean}   Returns true if two point are relatively equal, false otherwise\n */\nfunction equals(a, b) {\n  return _glMatrix.vec2.equals(a, b);\n}\n\n/**\n * Returns whether two points are exactly equal.\n * @param  {Point2d} a\n * @param  {Point2d} b\n * @return {Boolean}   Returns true if the two points are exactly equal, false otherwise\n */\nfunction exactEquals(a, b) {\n  return _glMatrix.vec2.exactEquals(a, b);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL3BvaW50MmQuanM/NzNlMyJdLCJuYW1lcyI6WyJzZXQiLCJjcmVhdGUiLCJjbG9uZSIsImNvcHkiLCJpbml0RnJvbVZhbHVlcyIsImFkZFZlYzIiLCJzdWIiLCJ0cmFuc2Zvcm1NYXQyIiwidHJhbnNmb3JtTWF0MmQiLCJzdHIiLCJkaXN0YW5jZSIsInNxdWFyZWREaXN0YW5jZSIsImxlcnAiLCJlcXVhbHMiLCJleGFjdEVxdWFscyIsIlgiLCJZIiwib3V0IiwieCIsInkiLCJBUlJBWV9UWVBFIiwicCIsInB0IiwidiIsImFkZCIsInB0MSIsInB0MiIsIm0iLCJwMSIsInAyIiwiZGlzdCIsInNxckRpc3QiLCJ0IiwiYSIsImIiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7UUFjZ0JBLEcsR0FBQUEsRztRQVlBQyxNLEdBQUFBLE07UUFVQUMsSyxHQUFBQSxLO1FBYUFDLEksR0FBQUEsSTtRQVlBQyxjLEdBQUFBLGM7UUFXQUMsTyxHQUFBQSxPO1FBV0FDLEcsR0FBQUEsRztRQVdBQyxhLEdBQUFBLGE7UUFhQUMsYyxHQUFBQSxjO1FBU0FDLEcsR0FBQUEsRztRQVVBQyxRLEdBQUFBLFE7UUFjQUMsZSxHQUFBQSxlO1FBZ0JBQyxJLEdBQUFBLEk7UUFVQUMsTSxHQUFBQSxNO1FBVUFDLFcsR0FBQUEsVzs7QUE5S2hCOztBQUVBLElBQU1DLElBQUksQ0FBVjtBQUNBLElBQU1DLElBQUksQ0FBVjs7QUFFQTs7Ozs7OztBQU9PLFNBQVNoQixHQUFULENBQWFpQixHQUFiLEVBQWdDO0FBQUEsTUFBZEMsQ0FBYyx1RUFBVixDQUFVO0FBQUEsTUFBUEMsQ0FBTyx1RUFBSCxDQUFHOztBQUNyQ0YsTUFBSUYsQ0FBSixJQUFTRyxDQUFUO0FBQ0FELE1BQUlELENBQUosSUFBU0csQ0FBVDtBQUNBLFNBQU9GLEdBQVA7QUFDRDs7QUFFRDs7Ozs7O0FBTU8sU0FBU2hCLE1BQVQsR0FBOEI7QUFBQSxNQUFkaUIsQ0FBYyx1RUFBVixDQUFVO0FB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S3JCLE1BQUwsQ0FBWW9CLENBQVosRUFBZUMsQ0FBZixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1PLFNBQVNwQixXQUFULENBQXFCbUIsQ0FBckIsRUFBd0JDLENBQXhCLEVBQTJCO0FBQ2hDLFNBQU8sZUFBS3BCLFdBQUwsQ0FBaUJtQixDQUFqQixFQUFvQkMsQ0FBcEIsQ0FBUDtBQUNEIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQge2dsTWF0cml4LCB2ZWMyIGFzIFZlYzJ9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5jb25zdCBYID0gMFxuY29uc3QgWSA9IDFcblxuLyoqXG4gKiBTZXRzIHRoZSBjb29yZGluYXRlcyBvZiBhIDJEIHBvaW50XG4gKiBAcGFyYW0ge1BvaW50MmR9IG91dCBQb2ludCB0byBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSBbeCA9IDBdICAgWCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge051bWJlcn0gW3kgPSAwXSAgIFkgY29vcmRpbmF0ZVxuICogQHJldHVybiB7UG9pbnQyZH0gICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4ID0gMCwgeSA9IDApIHtcbiAgb3V0W1hdID0geFxuICBvdXRbWV0gPSB5XG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBvaW50MmQgb2JqZWN0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt4ID0gMF0gWCBjb29yZGluYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IFt5ID0gMF0gWSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludDJkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKHggPSAwLCB5ID0gMCkge1xuICBjb25zdCBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKVxuICByZXR1cm4gc2V0KG91dCwgeCwgeSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFBvaW50MmQgb2JqZWN0IHdpdGggY29vcmRpbmF0ZXMgaW5pdGlhbGl6ZWQgZnJvbSBhbiBleGlzdGluZyBwb2ludC5cbiAqIEBwYXJhbSAge1BvaW50MmR9IHBcbiAqIEByZXR1cm4ge1BvaW50MmR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShwKSB7XG4gIGNvbnN0IG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpXG4gIG91dFtYXSA9IHBbWF1cbiAgb3V0W1ldID0gcFtZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSBjb29yZGluYXRlcyBvZiBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBUaGUgcG9pbnQgdG8gY29weSB0b1xuICogQHBhcmFtICB7UG9pbnQyZH0gcCAgIFRoZSBwb2ludCB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBQb2ludCByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBwKSB7XG4gIG91dFtYXSA9IHBbWF1cbiAgb3V0W1ldID0gcFtZXVxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBwb2ludCBmcm9tIGNvb3JkaW5hdGVzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHggWCBjb29yZGluYXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHkgWSBjb29yZGluYXRlXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgIE5ldyBwb2ludFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdEZyb21WYWx1ZXMoeCwgeSkge1xuICByZXR1cm4gY3JlYXRlKHgsIHkpXG59XG5cbi8qKlxuICogQWRkcyBhIDJkIG9mZnNldCB0byBhbiBleGlzdGluZyBwb2ludFxuICogQHBhcmFtIHtQb2ludDJkfSBvdXQgUG9pbnQgcmVjZWl2aW5nIHRoZSBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge1BvaW50MmR9IHB0ICBFeGlzdGluZyBwb2ludFxuICogQHBhcmFtIHtWZWMyZH0gdiAgIFZlY3RvciBkZXNjcmliaW5nIHRoZSBvZmZzZXRcbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRWZWMyKG91dCwgcHQsIHYpIHtcbiAgcmV0dXJuIFZlYzIuYWRkKG91dCwgcHQsIHYpXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSAge1ZlYzJkfSBvdXQgVmVjdG9yIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdDFcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0MlxuICogQHJldHVybiB7VmVjMmR9ICAgICBWZWN0b3IgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdWIob3V0LCBwdDEsIHB0Mikge1xuICByZXR1cm4gVmVjMi5zdWIob3V0LCBwdDEsIHB0Milcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhbiAyeDIgbWF0cml4IG11bHRpcGxpY2F0aW9uIG9uIGEgcG9pbnRcbiAqIEBwYXJhbSAge1BvaW50MmR9IG91dCBQb2ludCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtICB7UG9pbnQyZH0gcFxuICogQHBhcmFtICB7TWF0Mn0gbSAyeDIgbWF0cml4XG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgcCwgbSkge1xuICByZXR1cm4gVmVjMi50cmFuc2Zvcm1NYXQyKG91dCwgcCwgbSlcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIDJ4MyBtYXRyaXggbXVsdGlwbGljYXRpb24gb24gYSBwb2ludC5cbiAqIEEgMngzIG1hdHJpeCBpcyB1bHRpbWF0ZWx5IGEgMngyIG1hdHJpeCB3aXRoIGFcbiAqIHRyYW5zbGF0aW9uIGNvbXBvbmVudFxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IFBvaW50IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwXG4gKiBAcGFyYW0gIHtNYXQyZH0gbSAgIDJ4MyBtYXRyaXhcbiAqIEByZXR1cm4ge1BvaW50MmR9ICAgICBQb2ludCByZWZlcmVuY2VkIGJ5IG91dCBhcmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgcCwgbSkge1xuICByZXR1cm4gVmVjMi50cmFuc2Zvcm1NYXQyZChvdXQsIHAsIG0pXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHBvaW50XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHIocCkge1xuICByZXR1cm4gYHBvaW50MmQoJHtwWzBdfSAsICR7cFsxXX0pYFxufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byAyZCBwb2ludHNcbiAqIEBwYXJhbSAge1BvaW50MmR9IHAxXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwMlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2UocDEsIHAyKSB7XG4gIHJldHVybiBWZWMyLmRpc3RhbmNlKHAxLCBwMilcbn1cblxuZXhwb3J0IGNvbnN0IGRpc3QgPSBkaXN0YW5jZVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICogVGhpcyBpcyBhIGNoZWFwZXIgb3BlcmF0aW9uIHRoYW4gdGhlIHRydWUgZGlzdGFuY2VcbiAqIGNhbGN1bGF0aW9uLlxuICogQHBhcmFtICB7UG9pbnQyZH0gcDFcbiAqIEBwYXJhbSAge1BvaW50MmR9IHAyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIGRpc3RhbmNlXjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShwMSwgcDIpIHtcbiAgcmV0dXJuIFZlYzIuc3F1YXJlZERpc3RhbmNlKHAxLCBwMilcbn1cblxuZXhwb3J0IGNvbnN0IHNxckRpc3QgPSBzcXVhcmVkRGlzdGFuY2VcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBwb2ludCBsaW5lYXJseSBpbnRlcnBvbGF0ZWRcbiAqIGJldHdlZW4gdHdvIHBvaW50cyBhY2NvcmRpbmcgdG8gdGhlIHJlbGF0aXZlIG9wZXJhdG9yIHRcbiAqIFt0ID09IDAgPSBwMSAmIHQgPT0gMSA9IHAyXVxuICogQHBhcmFtICB7UG9pbnQyZH0gb3V0IFBvaW50IHJlY2VpdmluZyByZXN1bHQgb2Ygb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwMSAgU3RhcnQgcG9pbnQgKHQgPSAwKVxuICogQHBhcmFtICB7UG9pbnQyZH0gcDIgIEVuZCBwb2ludCAodCA9IDEpXG4gKiBAcGFyYW0gIHtbdHlwZV19IHQgICBJbnRlcnBvbGF0ZSBwYXJhbWV0ZXIgWzAsIDFdXG4gKiBAcmV0dXJuIHtQb2ludDJkfSAgICAgUG9pbnQgcmVmZXJlbmNlZCBieSBvdXQgYXJnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiBWZWMyLmxlcnAob3V0LCBwMSwgcDIsIHQpXG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHR3byBwb2ludHMgYXJlIHJlbGF0aXZlbHkgZXF1YWxcbiAqIEBwYXJhbSAge1BvaW50MmR9IGFcbiAqIEBwYXJhbSAge1BvaW50MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIHR3byBwb2ludCBhcmUgcmVsYXRpdmVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gVmVjMi5lcXVhbHMoYSwgYilcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdHdvIHBvaW50cyBhcmUgZXhhY3RseSBlcXVhbC5cbiAqIEBwYXJhbSAge1BvaW50MmR9IGFcbiAqIEBwYXJhbSAge1BvaW50MmR9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcG9pbnRzIGFyZSBleGFjdGx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIFZlYzIuZXhhY3RFcXVhbHMoYSwgYilcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvcG9pbnQyZC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\n/**\n * @class Common utilities\n * @name glMatrix\n */\nvar glMatrix = {};\n\n// Configuration Constants\nglMatrix.EPSILON = 0.000001;\nglMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\nglMatrix.RANDOM = Math.random;\nglMatrix.ENABLE_SIMD = false;\n\n// Capability detection\nglMatrix.SIMD_AVAILABLE = (glMatrix.ARRAY_TYPE === Float32Array) && ('SIMD' in this);\nglMatrix.USE_SIMD = glMatrix.ENABLE_SIMD && glMatrix.SIMD_AVAILABLE;\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nglMatrix.setMatrixArrayType = function(type) {\n    glMatrix.ARRAY_TYPE = type;\n}\n\nvar degree = Math.PI / 180;\n\n/**\n* Convert Degree To Radian\n*\n* @param {Number} Angle in Degrees\n*/\nglMatrix.toRadian = function(a){\n     return a * degree;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less \n * than or equal to 1.0, and a relative tolerance is used for larger values)\n * \n * @param {Number} a The first number to test.\n * @param {Number} b The second number to test.\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nglMatrix.equals = function(a, b) {\n\treturn Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));\n}\n\nmodule.exports = glMatrix;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9jb21tb24uanM/N2NhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyBDb21tb24gdXRpbGl0aWVzXG4gKiBAbmFtZSBnbE1hdHJpeFxuICovXG52YXIgZ2xNYXRyaXggPSB7fTtcblxuLy8gQ29uZmlndXJhdGlvbiBDb25zdGFudHNcbmdsTWF0cml4LkVQU0lMT04gPSAwLjAwMDAwMTtcbmdsTWF0cml4LkFSUkFZX1RZUEUgPSAodHlwZW9mIEZsb2F0MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5nbE1hdHJpeC5SQU5ET00gPSBNYXRoLnJhbmRvbTtcbmdsTWF0cml4LkVOQUJMRV9TSU1EID0gZmFsc2U7XG5cbi8vIENhcGFiaWxpdHkgZGV0ZWN0aW9uXG5nbE1hdHJpeC5TSU1EX0FWQUlMQUJMRSA9IChnbE1hdHJpeC5BUlJBWV9UWVBFID09PSBGbG9hdDMyQXJyYXkpICYmICgnU0lNRCcgaW4gdGhpcyk7XG5nbE1hdHJpeC5VU0VfU0lNRCA9IGdsTWF0cml4LkVOQUJMRV9TSU1EICYmIGdsTWF0cml4LlNJTURfQVZBSUxBQkxFO1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgZ2xNYXRyaXguQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBBbmdsZSBpbiBEZWdyZWVzXG4qL1xuZ2xNYXRyaXgudG9SYWRpYW4gPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbi8qKlxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzcyBcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcbiAqIFxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBudW1iZXJzIGFyZSBhcHByb3hpbWF0ZWx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmdsTWF0cml4LmVxdWFscyA9IGZ1bmN0aW9uKGEsIGIpIHtcblx0cmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnbE1hdHJpeDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar EPS = 1e-5;\nvar quarter = 0.25;\nvar half = 0.5;\nvar two = 2;\n\nMath.QUATER_PI = quarter * Math.PI;\nMath.HALF_PI = half * Math.PI;\nMath.HALF_NPI = -half * Math.PI;\nMath.TWO_PI = two * Math.PI;\nMath.NPI = -Math.PI;\nMath.NQUATER_PI = quarter * Math.NPI;\nMath.NHALF_PI = half * Math.NPI;\nMath.NTWO_PI = two * Math.NPI;\nMath.INV_PI = 1 / Math.PI;\nMath.RAD_TO_DEG = 180 / Math.PI;\nMath.DEG_TO_RAD = Math.PI / 180;\n\n// this could be useful to tweak in your app, depends on your world resolution\nMath.EPS = EPS;\n\n/**\n * Clamp f to be between a min and max.\n * @param {Number} f\n * @param {Number} minv\n * @param {Number} maxv\n * @return {Number}\n */\nfunction clamp(f, minv, maxv) {\n  return f < minv ? minv : f > maxv ? maxv : f;\n}\n\n/**\n * Clamp f to be between 0 and 1.\n * @param {Number} f\n * @return {Number}\n */\nfunction clamp01(f) {\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\n/**\n * Linearly interpolate (or extrapolate) between @c f1 and @c f2 by @c t percent.\n * @param {Number} f1\n * @param {Number} f2\n * @param {Number} t\n * @return {Number}\n */\nfunction lerp(f1, f2, t) {\n  return f1 * (1 - t) + f2 * t;\n}\n\nMath.clamp = clamp;\nMath.clamp01 = clamp01;\nMath.lerp = lerp;\n\nexports.default = Math;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRoL21hdGguanM/MDU5NiJdLCJuYW1lcyI6WyJFUFMiLCJxdWFydGVyIiwiaGFsZiIsInR3byIsIk1hdGgiLCJRVUFURVJfUEkiLCJQSSIsIkhBTEZfUEkiLCJIQUxGX05QSSIsIlRXT19QSSIsIk5QSSIsIk5RVUFURVJfUEkiLCJOSEFMRl9QSSIsIk5UV09fUEkiLCJJTlZfUEkiLCJSQURfVE9fREVHIiwiREVHX1RPX1JBRCIsImNsYW1wIiwiZiIsIm1pbnYiLCJtYXh2IiwiY2xhbXAwMSIsImxlcnAiLCJmMSIsImYyIiwidCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFNQSxNQUFNLElBQVo7QUFDQSxJQUFNQyxVQUFVLElBQWhCO0FBQ0EsSUFBTUMsT0FBTyxHQUFiO0FBQ0EsSUFBTUMsTUFBTSxDQUFaOztBQUVBQyxLQUFLQyxTQUFMLEdBQWlCSixVQUFVRyxLQUFLRSxFQUFoQztBQUNBRixLQUFLRyxPQUFMLEdBQWVMLE9BQU9FLEtBQUtFLEVBQTNCO0FBQ0FGLEtBQUtJLFFBQUwsR0FBZ0IsQ0FBQ04sSUFBRCxHQUFRRSxLQUFLRSxFQUE3QjtBQUNBRixLQUFLSyxNQUFMLEdBQWNOLE1BQU1DLEtBQUtFLEVBQXpCO0FBQ0FGLEtBQUtNLEdBQUwsR0FBVyxDQUFDTixLQUFLRSxFQUFqQjtBQUNBRixLQUFLTyxVQUFMLEdBQWtCVixVQUFVRyxLQUFLTSxHQUFqQztBQUNBTixLQUFLUSxRQUFMLEdBQWdCVixPQUFPRSxLQUFLTSxHQUE1QjtBQUNBTixLQUFLUyxPQUFMLEdBQWVWLE1BQU1DLEtBQUtNLEdBQTFCO0FBQ0FOLEtBQUtVLE1BQUwsR0FBYyxJQUFJVixLQUFLRSxFQUF2QjtBQUNBRixLQUFLVyxVQUFMLEdBQWtCLE1BQU1YLEtBQUtFLEVBQTdCO0FBQ0FGLEtBQUtZLFVBQUwsR0FBa0JaLEtBQUtFLEVBQUwsR0FBVSxHQUE1Qjs7QUFFQTtBQUNBRixLQUFLSixHQUFMLEdBQVdBLEdBQVg7O0FBRUE7Ozs7Ozs7QUFPQSxTQUFTaUIsS0FBVCxDQUFlQyxDQUFmLEVBQWtCQyxJQUFsQixFQUF3QkMsSUFBeEIsRUFBOEI7QUFDNUIsU0FBT0YsSUFBSUMsSUFBSixHQUFXQSxJQUFYLEdBQW1CRCxJQUFJRSxJQUFKLEdBQVdBLElBQVgsR0FBa0JGLENBQTVDO0FBQ0Q7O0FBRUQ7Ozs7O0FBS0EsU0FBU0csT0FBVCxDQUFpQkgsQ0FBakIsRUFBb0I7QUFDbEIsU0FBT0EsSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFhQSxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVlBLENBQWhDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTSSxJQUFULENBQWNDLEVBQWQsRUFBa0JDLEVBQWxCLEVBQXNCQyxDQUF0QixFQUF5QjtBQUN2QixTQUFPRixNQUFNLElBQUlFLENBQVYsSUFBZUQsS0FBS0MsQ0FBM0I7QUFDRDs7QUFFRHJCLEtBQUthLEtBQUwsR0FBYUEsS0FBYjtBQUNBYixLQUFLaUIsT0FBTCxHQUFlQSxPQUFmO0FBQ0FqQixLQUFLa0IsSUFBTCxHQUFZQSxJQUFaOztrQkFFZWxCLEkiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVQUyA9IDFlLTVcbmNvbnN0IHF1YXJ0ZXIgPSAwLjI1XG5jb25zdCBoYWxmID0gMC41XG5jb25zdCB0d28gPSAyXG5cbk1hdGguUVVBVEVSX1BJID0gcXVhcnRlciAqIE1hdGguUElcbk1hdGguSEFMRl9QSSA9IGhhbGYgKiBNYXRoLlBJXG5NYXRoLkhBTEZfTlBJID0gLWhhbGYgKiBNYXRoLlBJXG5NYXRoLlRXT19QSSA9IHR3byAqIE1hdGguUElcbk1hdGguTlBJID0gLU1hdGguUElcbk1hdGguTlFVQVRFUl9QSSA9IHF1YXJ0ZXIgKiBNYXRoLk5QSVxuTWF0aC5OSEFMRl9QSSA9IGhhbGYgKiBNYXRoLk5QSVxuTWF0aC5OVFdPX1BJID0gdHdvICogTWF0aC5OUElcbk1hdGguSU5WX1BJID0gMSAvIE1hdGguUElcbk1hdGguUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUElcbk1hdGguREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODBcblxuLy8gdGhpcyBjb3VsZCBiZSB1c2VmdWwgdG8gdHdlYWsgaW4geW91ciBhcHAsIGRlcGVuZHMgb24geW91ciB3b3JsZCByZXNvbHV0aW9uXG5NYXRoLkVQUyA9IEVQU1xuXG4vKipcbiAqIENsYW1wIGYgdG8gYmUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4LlxuICogQHBhcmFtIHtOdW1iZXJ9IGZcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW52XG4gKiBAcGFyYW0ge051bWJlcn0gbWF4dlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcChmLCBtaW52LCBtYXh2KSB7XG4gIHJldHVybiBmIDwgbWludiA/IG1pbnYgOiAoZiA+IG1heHYgPyBtYXh2IDogZilcbn1cblxuLyoqXG4gKiBDbGFtcCBmIHRvIGJlIGJldHdlZW4gMCBhbmQgMS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNsYW1wMDEoZikge1xuICByZXR1cm4gZiA8IDAgPyAwIDogKGYgPiAxID8gMSA6IGYpXG59XG5cbi8qKlxuICogTGluZWFybHkgaW50ZXJwb2xhdGUgKG9yIGV4dHJhcG9sYXRlKSBiZXR3ZWVuIEBjIGYxIGFuZCBAYyBmMiBieSBAYyB0IHBlcmNlbnQuXG4gKiBAcGFyYW0ge051bWJlcn0gZjFcbiAqIEBwYXJhbSB7TnVtYmVyfSBmMlxuICogQHBhcmFtIHtOdW1iZXJ9IHRcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gbGVycChmMSwgZjIsIHQpIHtcbiAgcmV0dXJuIGYxICogKDEgLSB0KSArIGYyICogdFxufVxuXG5NYXRoLmNsYW1wID0gY2xhbXBcbk1hdGguY2xhbXAwMSA9IGNsYW1wMDFcbk1hdGgubGVycCA9IGxlcnBcblxuZXhwb3J0IGRlZmF1bHQgTWF0aFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbWF0aC9tYXRoLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _fillStyle = __webpack_require__(19);\n\nvar _fillStyle2 = _interopRequireDefault(_fillStyle);\n\nvar _strokeStyle = __webpack_require__(10);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nvar _transform2d = __webpack_require__(14);\n\nvar _transform2d2 = _interopRequireDefault(_transform2d);\n\nvar _aggregation2 = __webpack_require__(8);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _eventHandler = __webpack_require__(15);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} CoreShapeOptions\n * @property {number} [zIndex=0] Z index draw order of the shape. Lower numbers get drawn before larger numbers\n */\n\n/**\n * Shape geom modification event\n * @event Shape#geomChanged\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * Shape modification event\n * @event EventedShape#changed\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * @class Defines the core functionality for all shapes\n * @extends {EventHandler}\n */\nvar CoreBaseShape = function (_EventHandler) {\n  _inherits(CoreBaseShape, _EventHandler);\n\n  /**\n   * Creates new core functionality for a shape\n   * @param  {CoreShapeOptions} [opts]\n   * @return {CoreBaseShape}\n   */\n  function CoreBaseShape(opts) {\n    _classCallCheck(this, CoreBaseShape);\n\n    var _this = _possibleConstructorReturn(this, (CoreBaseShape.__proto__ || Object.getPrototypeOf(CoreBaseShape)).call(this, [\"changed:xform\", \"changed:style\", \"changed:order\", \"changed:visibility\", \"changed:geom\"]));\n\n    _this._aabox = AABox2d.create();\n    _this._zIndex = opts && opts.zIndex ? opts.zIndex : 0;\n    _this._visible = true;\n    _this._geomDirty = false;\n\n    _this._fullXform = _glMatrix.mat2d.create();\n    return _this;\n  }\n\n  /**\n   * Sets the z index (back to front draw order) of the shape\n   * @param  {number} zIndex\n   * @fires  EventedShape#changed\n   * @return {CoreBaseShape}        this\n   */\n\n\n  _createClass(CoreBaseShape, [{\n    key: \"zIndex\",\n    set: function set(zIndex) {\n      if (!Number.isInteger(zIndex)) {\n        throw new Error(\"zIndex must be an integer\");\n      }\n      if (zIndex !== this._zIndex) {\n        var prev = this._zIndex;\n        this._zIndex = zIndex;\n        this.fire(\"changed:order\", {\n          attr: \"zIndex\",\n          prevVal: prev,\n          currVal: this._zIndex\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current z index (i.e. draw/layer order) of the shape\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._zIndex;\n    }\n\n    /**\n     * Gets a reference to the current axis-aligned bounding box of the\n     * shape\n     * @return {AABox2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"aabox\",\n    get: function get() {\n      this._updateAABox();\n      return this._aabox;\n    }\n\n    /**\n     * Sets the visibility of the shape\n     * @param  {Boolean} visible If true, the shape is considered visible\n     * @fires  EventedShape#changed\n     * @return {CoreBaseShape}         this\n     * @throws {Error} If argument is not a boolean type\n     */\n\n  }, {\n    key: \"visible\",\n    set: function set(visible) {\n      if (typeof visible !== \"boolean\") {\n        throw new Error(\"visible must be a boolean\");\n      }\n\n      if (visible !== this._visible) {\n        this._visible = visible;\n        this.fire(\"changed:visibility\", {\n          attr: \"visible\",\n          prevVal: !this._visible,\n          currVal: this._visible\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets the current visibility of the shape\n     * @return {boolean}\n     */\n    ,\n    get: function get() {\n      return this._visible;\n    }\n  }]);\n\n  return CoreBaseShape;\n}(_eventHandler2.default);\n\n/**\n * @class Defines the basic functionality of all shapes. This includes\n *        mixing in from EventedTransform2d so that affine transformations\n *        can be applied to the shape. Also includes mixing in fill and stroke\n *        properties so that the shape's renderable properties can be modified.\n * @extends {CoreBaseShape}\n * @mixin {EventedTransform2d}\n * @mixin {EventedFillStyle}\n * @mixin {EventedStrokeStyle}\n */\n\n\nvar BaseShape = function (_aggregation) {\n  _inherits(BaseShape, _aggregation);\n\n  /**\n   * Creates new basic functionality (including transform, fill style, and stroke style properties)\n   * for a shape\n   * @param  {object} opts\n   * @return {BaseShape}\n   */\n  function BaseShape(opts) {\n    _classCallCheck(this, BaseShape);\n\n    var _this2 = _possibleConstructorReturn(this, (BaseShape.__proto__ || Object.getPrototypeOf(BaseShape)).call(this, opts));\n\n    _this2._stateStack = [];\n    return _this2;\n  }\n\n  /**\n   * Saves the current state of the shape so that it can be restored later.\n   * @return {BaseShape} this\n   */\n\n\n  _createClass(BaseShape, [{\n    key: \"save\",\n    value: function save() {\n      // Currently only the state of the fill/stroke style properties\n      // and the z index are saved. May want to expand this to include\n      // all modifiable properties (i.e. transform props and visibility prop)\n      var state = new _basicStyle2.default();\n      _basicStyle2.default.copyBasicStyle(this, state);\n      state.zIndex = this.zIndex;\n      this._stateStack.push(state);\n      return this;\n    }\n\n    /**\n     * Pops a saved state from the top of the saved state stack\n     * @return {BaseShape} this\n     */\n\n  }, {\n    key: \"restore\",\n    value: function restore() {\n      // Currently only restores the state of the fill/stroke style properties\n      // and the z index. May want to expand this to include\n      // all modifiable properties (i.e. transform props and visibility prop)\n      var state = this._stateStack.pop();\n      if (state) {\n        _basicStyle2.default.copyBasicStyle(state, this);\n        this.zIndex = state.zIndex;\n      }\n      return this;\n    }\n\n    /**\n     * Gets the visibility of the shape\n     * @return {boolean}\n     * @override\n     */\n\n  }, {\n    key: \"getGlobalDimensions\",\n\n\n    /**\n     * Gets the width/height of the shape after the parent transforms are applied\n     * @return {Vec2d} Width/Height of the shape after all parent transforms applied\n     */\n    value: function getGlobalDimensions() {\n      var scale = [0, 0];\n      _glMatrix.mat2d.svd(null, scale, null, this.globalXform);\n      scale[0] *= this.width;\n      scale[1] *= this.height;\n      return scale;\n    }\n\n    /**\n     * Returns true the shape contains a screen/world space point\n     * @param  {Point2d} screenPt           The point to check in screen/pixel space\n     * @param  {Poitn2d} worldPt            The point to check in world space\n     * @param  {Mat2d} worldToScreenMatrix  The transform matrix from world to screen space\n     * @param  {CanvasRenderingContext2D} ctx The 2d rendering context\n     * @return {boolean}                    True if the shape contains the point, false otherwise\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtn = false;\n      var aabox = this.aabox;\n\n      // Check if the point is contained by the shape's bounds first\n      if (this.visible && AABox2d.containsPt(aabox, worldPt)) {\n        // re-draw the shape (invisible) so that we can use canvas's\n        // isPointInPath/isPointInStroke api calls. Doing that\n        // as this should be compatible across all browsers\n        ctx.save();\n        ctx.setTransform(this._fullXform[0], this._fullXform[1], this._fullXform[2], this._fullXform[3], this._fullXform[4], this._fullXform[5]);\n        ctx.beginPath();\n        this._draw(ctx);\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineWidth = this.strokeWidth + 5;\n        ctx.dashPattern = [];\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n        if (this.isFillVisible() && ctx.isPointInPath(screenPt[0], screenPt[1]) || this.isStrokeVisible() && ctx.isPointInStroke(screenPt[0], screenPt[1])) {\n          rtn = true;\n        }\n        ctx.restore();\n      }\n      return rtn;\n    }\n\n    /**\n     * Debug function to draw the bounds of the shape\n     * @param  {CanvasRenderingContext2D} ctx                 2d rendering context\n     * @param  {Mat2d} worldToScreenMatrix Transform from world to screen space\n     * @param  {StrokeStyle} boundsStrokeStyle   The stroke style to use to render the bounds\n     */\n\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      ctx.save();\n      ctx.setTransform(worldToScreenMatrix[0], worldToScreenMatrix[1], worldToScreenMatrix[2], worldToScreenMatrix[3], worldToScreenMatrix[4], worldToScreenMatrix[5]);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      var aabox = this.aabox;\n      AABox2d.getCenter(center, aabox);\n      AABox2d.getExtents(extents, aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    /**\n     * Called when the local transform (does not include parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the shape's bounds needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_localXformUpdated\",\n    value: function _localXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Called when the global transform (includes parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the shape's bounds needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_globalXformUpdated\",\n    value: function _globalXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Renders the shape using a 2d rendering context\n     * @param  {CanvasRenderingContext2d} ctx                 2d rendering context\n     * @param  {Mat2d} worldToScreenMatrix Transform from world to screen space,\n     *                                     usually provided by a camera\n     * @param  {DrawStyleState} styleState Manages the current state of the fill/stroke style attrs\n     *                                     of the 2d rendering context. This is self-managed to minimize\n     *                                     context state switches\n     * @param  {boolean} [doFill=null]     If provided, used to manually override whether to fill the\n     *                                     shape.\n     * @param  {boolean} [doStroke=null]   If provided, used to manually override whether to stroke the\n     *                                     shape.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      var doFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var doStroke = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n      this.transformCtx(ctx, this._fullXform, worldToScreenMatrix);\n\n      ctx.beginPath();\n\n      var rtn = this._draw(ctx);\n      if (rtn || typeof rtn === \"undefined\") {\n        if (this.isFillVisible() && (doFill === null || Boolean(doFill))) {\n          styleState.setFillStyle(ctx, this);\n          ctx.fill();\n        }\n\n        if (this.isStrokeVisible() && (doStroke === null || Boolean(doStroke))) {\n          styleState.setStrokeStyle(ctx, this);\n          ctx.setTransform(1, 0, 0, 1, 0, 0);\n          ctx.stroke();\n        }\n      }\n    }\n\n    /**\n     * Copies the fill/stroke style from one BasicStyle object to this shape\n     * @param {BasicStyle} newStyle The style to copy from.\n     * @return {BaseShape} this\n     */\n\n  }, {\n    key: \"setStyle\",\n    value: function setStyle(newStyle) {\n      _basicStyle2.default.copyBasicStyle(newStyle, this);\n      return this;\n    }\n\n    /**\n     * Returns a JSON object containing the properties of this shape\n     * @return {object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var state = this;\n      if (this._stateStack && this._stateStack.length) {\n        state = this._stateStack[0];\n      }\n      return Object.assign({\n        // type: this.constructor.name,\n        // NOTE: I wanted to use the above call, which would keep the type\n        // consistent with the name of the class, but this isn't always\n        // the case, as was found out a few times when trying to add\n        // this to immerse\n        visible: this.visible,\n        zIndex: state.zIndex\n      }, _basicStyle2.default.toJSON(state), _transform2d2.default.toJSON(this));\n    }\n\n    /**\n     * Compares two shapes, usually used to sort the shapes for drawing\n     * @param  {BaseShape} shape1\n     * @param  {BaseShape} shape2\n     * @return {number}        Returns < 0 if shape1 < shape2, > 0 if shape1 > shape2, 0 if shape1 === shape2\n     */\n\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return this._visible && (this.isFillVisible() || this.isStrokeVisible());\n    }\n  }], [{\n    key: \"shapeCompare\",\n    value: function shapeCompare(shape1, shape2) {\n      var zIndex1 = shape1.zIndex;\n      var zIndex2 = shape2.zIndex;\n      if (zIndex1 < zIndex2) {\n        return -1;\n      } else if (zIndex1 > zIndex2) {\n        return 1;\n      }\n\n      var rtn = _fillStyle2.default.compareFillStyle(shape1, shape2);\n      if (!rtn) {\n        rtn = _strokeStyle2.default.compareStrokeStyle(shape1, shape2);\n      }\n\n      return rtn;\n    }\n  }]);\n\n  return BaseShape;\n}((0, _aggregation3.default)(CoreBaseShape, (0, _transform2d.createEventedTransform2dMixin)(\"changed:xform\"), (0, _fillStyle.createEventedFillStyleMixin)(\"changed:style\"), (0, _strokeStyle.createEventedStrokeStyleMixin)(\"changed:style\")));\n\nexports.default = BaseShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvYmFzZS1zaGFwZS5qcz9iYmVhIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJDb3JlQmFzZVNoYXBlIiwib3B0cyIsIl9hYWJveCIsImNyZWF0ZSIsIl96SW5kZXgiLCJ6SW5kZXgiLCJfdmlzaWJsZSIsIl9nZW9tRGlydHkiLCJfZnVsbFhmb3JtIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiRXJyb3IiLCJwcmV2IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsIl91cGRhdGVBQUJveCIsInZpc2libGUiLCJCYXNlU2hhcGUiLCJfc3RhdGVTdGFjayIsInN0YXRlIiwiY29weUJhc2ljU3R5bGUiLCJwdXNoIiwicG9wIiwic2NhbGUiLCJzdmQiLCJnbG9iYWxYZm9ybSIsIndpZHRoIiwiaGVpZ2h0Iiwic2NyZWVuUHQiLCJ3b3JsZFB0Iiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImN0eCIsInJ0biIsImFhYm94IiwiY29udGFpbnNQdCIsInNhdmUiLCJzZXRUcmFuc2Zvcm0iLCJiZWdpblBhdGgiLCJfZHJhdyIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwic3Ryb2tlV2lkdGgiLCJkYXNoUGF0dGVybiIsInN0cm9rZSIsImlzRmlsbFZpc2libGUiLCJpc1BvaW50SW5QYXRoIiwiaXNTdHJva2VWaXNpYmxlIiwiaXNQb2ludEluU3Ryb2tlIiwicmVzdG9yZSIsImJvdW5kc1N0cm9rZVN0eWxlIiwic2V0U3Ryb2tlQ3R4IiwiY2VudGVyIiwiZXh0ZW50cyIsImdldENlbnRlciIsImdldEV4dGVudHMiLCJyZWN0IiwiX2JvdW5kc091dE9mRGF0ZSIsInN0eWxlU3RhdGUiLCJkb0ZpbGwiLCJkb1N0cm9rZSIsInRyYW5zZm9ybUN0eCIsIkJvb2xlYW4iLCJzZXRGaWxsU3R5bGUiLCJmaWxsIiwic2V0U3Ryb2tlU3R5bGUiLCJuZXdTdHlsZSIsImxlbmd0aCIsIk9iamVjdCIsImFzc2lnbiIsInRvSlNPTiIsInNoYXBlMSIsInNoYXBlMiIsInpJbmRleDEiLCJ6SW5kZXgyIiwiY29tcGFyZUZpbGxTdHlsZSIsImNvbXBhcmVTdHJva2VTdHlsZSJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7OztBQUtBOzs7Ozs7Ozs7QUFTQTs7Ozs7Ozs7O0FBU0E7Ozs7SUFJTUMsYTs7O0FBQ0o7Ozs7O0FBS0EseUJBQVlDLElBQVosRUFBa0I7QUFBQTs7QUFBQSw4SEFDVixDQUFDLGVBQUQsRUFBa0IsZUFBbEIsRUFBbUMsZUFBbkMsRUFBb0Qsb0JBQXBELEVBQTBFLGNBQTFFLENBRFU7O0FBRWhCLFVBQUtDLE1BQUwsR0FBY0gsUUFBUUksTUFBUixFQUFkO0FBQ0EsVUFBS0MsT0FBTCxHQUFnQkgsUUFBUUEsS0FBS0ksTUFBZCxHQUF3QkosS0FBS0ksTUFBN0IsR0FBc0MsQ0FBckQ7QUFDQSxVQUFLQyxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsVUFBS0MsVUFBTCxHQUFrQixLQUFsQjs7QUFFQSxVQUFLQyxVQUFMLEdBQWtCLGdCQUFNTCxNQUFOLEVBQWxCO0FBUGdCO0FBUWpCOztBQUVEOzs7Ozs7Ozs7O3NCQU1XRSxNLEVBQVE7QUFDakIsVUFBSSxDQUFDSSxPQUFPQyxTQUFQLENBQWlCTCxNQUFqQixDQUFMLEVBQStCO0FBQzdCLGNBQU0sSUFBSU0sS0FBSixDQUFVLDJCQUFWLENBQU47QUFDRDtBQUNELFVBQUlOLFdBQVcsS0FBS0QsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTVEsT0FBTyxLQUFLUixPQUFsQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUMsTUFBZjtBQUNBLGFBQUtRLElBQUwsQ0FBVSxlQUFWLEVBQTJCO0FBQ3pCQyxnQkFBTSxRQURtQjtBQUV6QkMsbUJBQVNILElBRmdCO0FBR3pCSSxtQkFBUyxLQUFLWjtBQUhXLFNBQTNCO0FBS0Q7QUFDRCxhQUFPLElBQVA7QUFD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QUl6QyxNQUFNLG9CQUFVMEMsZ0JBQVYsQ0FBMkJKLE1BQTNCLEVBQW1DQyxNQUFuQyxDQUFWO0FBQ0EsVUFBSSxDQUFDdkMsR0FBTCxFQUFVO0FBQ1JBLGNBQU0sc0JBQVkyQyxrQkFBWixDQUErQkwsTUFBL0IsRUFBdUNDLE1BQXZDLENBQU47QUFDRDs7QUFFRCxhQUFPdkMsR0FBUDtBQUNEOzs7O0VBdE9vQywyQkFBWWxDLGFBQVosRUFDckMsZ0RBQThCLGVBQTlCLENBRHFDLEVBQ1csNENBQTRCLGVBQTVCLENBRFgsRUFFckMsZ0RBQThCLGVBQTlCLENBRnFDLEM7O2tCQUFsQm1CLFMiLCJmaWxlIjoiNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgRmlsbFN0eWxlLCB7Y3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGlufSBmcm9tIFwiLi4vc3R5bGUvZmlsbC1zdHlsZVwiXG5pbXBvcnQgU3Ryb2tlU3R5bGUsIHtjcmVhdGVFdmVudGVkU3Ryb2tlU3R5bGVNaXhpbn0gZnJvbSBcIi4uL3N0eWxlL3N0cm9rZS1zdHlsZVwiXG5pbXBvcnQgVHJhbnNmb3JtMmQsIHtjcmVhdGVFdmVudGVkVHJhbnNmb3JtMmRNaXhpbn0gZnJvbSBcIi4vdHJhbnNmb3JtMmRcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCBCYXNpY1N0eWxlIGZyb20gXCIuLi9zdHlsZS9iYXNpYy1zdHlsZVwiXG5pbXBvcnQgRXZlbnRIYW5kbGVyIGZyb20gXCIuLi91dGlsL2V2ZW50LWhhbmRsZXJcIlxuaW1wb3J0IHttYXQyZCBhcyBNYXQyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ29yZVNoYXBlT3B0aW9uc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt6SW5kZXg9MF0gWiBpbmRleCBkcmF3IG9yZGVyIG9mIHRoZSBzaGFwZS4gTG93ZXIgbnVtYmVycyBnZXQgZHJhd24gYmVmb3JlIGxhcmdlciBudW1iZXJzXG4gKi9cblxuLyoqXG4gKiBTaGFwZSBnZW9tIG1vZGlmaWNhdGlvbiBldmVudFxuICogQGV2ZW50IFNoYXBlI2dlb21DaGFuZ2VkXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICogQHByb3BlcnR5IHt9IGN1cnJWYWwgVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwb3N0IG1vZGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogU2hhcGUgbW9kaWZpY2F0aW9uIGV2ZW50XG4gKiBAZXZlbnQgRXZlbnRlZFNoYXBlI2NoYW5nZWRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXR0ciBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgbW9kaWZpZWRcbiAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgRGVmaW5lcyB0aGUgY29yZSBmdW5jdGlvbmFsaXR5IGZvciBhbGwgc2hhcGVzXG4gKiBAZXh0ZW5kcyB7RXZlbnRIYW5kbGVyfVxuICovXG5jbGFzcyBDb3JlQmFzZVNoYXBlIGV4dGVuZHMgRXZlbnRIYW5kbGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgbmV3IGNvcmUgZnVuY3Rpb25hbGl0eSBmb3IgYSBzaGFwZVxuICAgKiBAcGFyYW0gIHtDb3JlU2hhcGVPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7Q29yZUJhc2VTaGFwZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihbXCJjaGFuZ2VkOnhmb3JtXCIsIFwiY2hhbmdlZDpzdHlsZVwiLCBcImNoYW5nZWQ6b3JkZXJcIiwgXCJjaGFuZ2VkOnZpc2liaWxpdHlcIiwgXCJjaGFuZ2VkOmdlb21cIl0pXG4gICAgdGhpcy5fYWFib3ggPSBBQUJveDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fekluZGV4ID0gKG9wdHMgJiYgb3B0cy56SW5kZXgpID8gb3B0cy56SW5kZXggOiAwXG4gICAgdGhpcy5fdmlzaWJsZSA9IHRydWVcbiAgICB0aGlzLl9nZW9tRGlydHkgPSBmYWxzZVxuXG4gICAgdGhpcy5fZnVsbFhmb3JtID0gTWF0MmQuY3JlYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB6IGluZGV4IChiYWNrIHRvIGZyb250IGRyYXcgb3JkZXIpIG9mIHRoZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHpJbmRleFxuICAgKiBAZmlyZXMgIEV2ZW50ZWRTaGFwZSNjaGFuZ2VkXG4gICAqIEByZXR1cm4ge0NvcmVCYXNlU2hhcGV9ICAgICAgICB0aGlzXG4gICAqL1xuICBzZXQgekluZGV4KHpJbmRleCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih6SW5kZXgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ6SW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyXCIpXG4gICAgfVxuICAgIGlmICh6SW5kZXggIT09IHRoaXMuX3pJbmRleCkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3pJbmRleFxuICAgICAgdGhpcy5fekluZGV4ID0gekluZGV4XG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOm9yZGVyXCIsIHtcbiAgICAgICAgYXR0cjogXCJ6SW5kZXhcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogdGhpcy5fekluZGV4XG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgeiBpbmRleCAoaS5lLiBkcmF3L2xheWVyIG9yZGVyKSBvZiB0aGUgc2hhcGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHpJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fekluZGV4XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIHRoZVxuICAgKiBzaGFwZVxuICAgKiBAcmV0dXJuIHtBQUJveDJkfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCBhYWJveCgpIHtcbiAgICB0aGlzLl91cGRhdGVBQUJveCgpXG4gICAgcmV0dXJuIHRoaXMuX2FhYm94XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgc2hhcGVcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gdmlzaWJsZSBJZiB0cnVlLCB0aGUgc2hhcGUgaXMgY29uc2lkZXJlZCB2aXNpYmxlXG4gICAqIEBmaXJlcyAgRXZlbnRlZFNoYXBlI2NoYW5nZWRcbiAgICogQHJldHVybiB7Q29yZUJhc2VTaGFwZX0gICAgICAgICB0aGlzXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBhcmd1bWVudCBpcyBub3QgYSBib29sZWFuIHR5cGVcbiAgICovXG4gIHNldCB2aXNpYmxlKHZpc2libGUpIHtcbiAgICBpZiAodHlwZW9mIHZpc2libGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2aXNpYmxlIG11c3QgYmUgYSBib29sZWFuXCIpXG4gICAgfVxuXG4gICAgaWYgKHZpc2libGUgIT09IHRoaXMuX3Zpc2libGUpIHtcbiAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlXG4gICAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOnZpc2liaWxpdHlcIiwge1xuICAgICAgICBhdHRyOiBcInZpc2libGVcIixcbiAgICAgICAgcHJldlZhbDogIXRoaXMuX3Zpc2libGUsXG4gICAgICAgIGN1cnJWYWw6IHRoaXMuX3Zpc2libGVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZpc2liaWxpdHkgb2YgdGhlIHNoYXBlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgdmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmlzaWJsZVxuICB9XG59XG5cbi8qKlxuICogQGNsYXNzIERlZmluZXMgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdHkgb2YgYWxsIHNoYXBlcy4gVGhpcyBpbmNsdWRlc1xuICogICAgICAgIG1peGluZyBpbiBmcm9tIEV2ZW50ZWRUcmFuc2Zvcm0yZCBzbyB0aGF0IGFmZmluZSB0cmFuc2Zvcm1hdGlvbnNcbiAqICAgICAgICBjYW4gYmUgYXBwbGllZCB0byB0aGUgc2hhcGUuIEFsc28gaW5jbHVkZXMgbWl4aW5nIGluIGZpbGwgYW5kIHN0cm9rZVxuICogICAgICAgIHByb3BlcnRpZXMgc28gdGhhdCB0aGUgc2hhcGUncyByZW5kZXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIG1vZGlmaWVkLlxuICogQGV4dGVuZHMge0NvcmVCYXNlU2hhcGV9XG4gKiBAbWl4aW4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAqIEBtaXhpbiB7RXZlbnRlZEZpbGxTdHlsZX1cbiAqIEBtaXhpbiB7RXZlbnRlZFN0cm9rZVN0eWxlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCYXNlU2hhcGUgZXh0ZW5kcyBhZ2dyZWdhdGlvbihDb3JlQmFzZVNoYXBlLFxuICBjcmVhdGVFdmVudGVkVHJhbnNmb3JtMmRNaXhpbihcImNoYW5nZWQ6eGZvcm1cIiksIGNyZWF0ZUV2ZW50ZWRGaWxsU3R5bGVNaXhpbihcImNoYW5nZWQ6c3R5bGVcIiksXG4gIGNyZWF0ZUV2ZW50ZWRTdHJva2VTdHlsZU1peGluKFwiY2hhbmdlZDpzdHlsZVwiKSkge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG5ldyBiYXNpYyBmdW5jdGlvbmFsaXR5IChpbmNsdWRpbmcgdHJhbnNmb3JtLCBmaWxsIHN0eWxlLCBhbmQgc3Ryb2tlIHN0eWxlIHByb3BlcnRpZXMpXG4gICAqIGZvciBhIHNoYXBlXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0c1xuICAgKiBAcmV0dXJuIHtCYXNlU2hhcGV9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9zdGF0ZVN0YWNrID0gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgc2hhcGUgc28gdGhhdCBpdCBjYW4gYmUgcmVzdG9yZWQgbGF0ZXIuXG4gICAqIEByZXR1cm4ge0Jhc2VTaGFwZX0gdGhpc1xuICAgKi9cbiAgc2F2ZSgpIHtcbiAgICAvLyBDdXJyZW50bHkgb25seSB0aGUgc3RhdGUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlIHByb3BlcnRpZXNcbiAgICAvLyBhbmQgdGhlIHogaW5kZXggYXJlIHNhdmVkLiBNYXkgd2FudCB0byBleHBhbmQgdGhpcyB0byBpbmNsdWRlXG4gICAgLy8gYWxsIG1vZGlmaWFibGUgcHJvcGVydGllcyAoaS5lLiB0cmFuc2Zvcm0gcHJvcHMgYW5kIHZpc2liaWxpdHkgcHJvcClcbiAgICBjb25zdCBzdGF0ZSA9IG5ldyBCYXNpY1N0eWxlKClcbiAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHRoaXMsIHN0YXRlKVxuICAgIHN0YXRlLnpJbmRleCA9IHRoaXMuekluZGV4XG4gICAgdGhpcy5fc3RhdGVTdGFjay5wdXNoKHN0YXRlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogUG9wcyBhIHNhdmVkIHN0YXRlIGZyb20gdGhlIHRvcCBvZiB0aGUgc2F2ZWQgc3RhdGUgc3RhY2tcbiAgICogQHJldHVybiB7QmFzZVNoYXBlfSB0aGlzXG4gICAqL1xuICByZXN0b3JlKCkge1xuICAgIC8vIEN1cnJlbnRseSBvbmx5IHJlc3RvcmVzIHRoZSBzdGF0ZSBvZiB0aGUgZmlsbC9zdHJva2Ugc3R5bGUgcHJvcGVydGllc1xuICAgIC8vIGFuZCB0aGUgeiBpbmRleC4gTWF5IHdhbnQgdG8gZXhwYW5kIHRoaXMgdG8gaW5jbHVkZVxuICAgIC8vIGFsbCBtb2RpZmlhYmxlIHByb3BlcnRpZXMgKGkuZS4gdHJhbnNmb3JtIHByb3BzIGFuZCB2aXNpYmlsaXR5IHByb3ApXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZVN0YWNrLnBvcCgpXG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHN0YXRlLCB0aGlzKVxuICAgICAgdGhpcy56SW5kZXggPSBzdGF0ZS56SW5kZXhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBzaGFwZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl92aXNpYmxlICYmICh0aGlzLmlzRmlsbFZpc2libGUoKSB8fCB0aGlzLmlzU3Ryb2tlVmlzaWJsZSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgc2hhcGUgYWZ0ZXIgdGhlIHBhcmVudCB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkXG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9IZWlnaHQgb2YgdGhlIHNoYXBlIGFmdGVyIGFsbCBwYXJlbnQgdHJhbnNmb3JtcyBhcHBsaWVkXG4gICAqL1xuICBnZXRHbG9iYWxEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHNjYWxlID0gWzAsIDBdXG4gICAgTWF0MmQuc3ZkKG51bGwsIHNjYWxlLCBudWxsLCB0aGlzLmdsb2JhbFhmb3JtKVxuICAgIHNjYWxlWzBdICo9IHRoaXMud2lkdGhcbiAgICBzY2FsZVsxXSAqPSB0aGlzLmhlaWdodFxuICAgIHJldHVybiBzY2FsZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSB0aGUgc2hhcGUgY29udGFpbnMgYSBzY3JlZW4vd29ybGQgc3BhY2UgcG9pbnRcbiAgICogQHBhcmFtICB7UG9pbnQyZH0gc2NyZWVuUHQgICAgICAgICAgIFRoZSBwb2ludCB0byBjaGVjayBpbiBzY3JlZW4vcGl4ZWwgc3BhY2VcbiAgICogQHBhcmFtICB7UG9pdG4yZH0gd29ybGRQdCAgICAgICAgICAgIFRoZSBwb2ludCB0byBjaGVjayBpbiB3b3JsZCBzcGFjZVxuICAgKiBAcGFyYW0gIHtNYXQyZH0gd29ybGRUb1NjcmVlbk1hdHJpeCAgVGhlIHRyYW5zZm9ybSBtYXRyaXggZnJvbSB3b3JsZCB0byBzY3JlZW4gc3BhY2VcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggVGhlIDJkIHJlbmRlcmluZyBjb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICBUcnVlIGlmIHRoZSBzaGFwZSBjb250YWlucyB0aGUgcG9pbnQsIGZhbHNlIG90aGVyd2lzZVxuICAgKi9cbiAgY29udGFpbnNQb2ludChzY3JlZW5QdCwgd29ybGRQdCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgY3R4KSB7XG4gICAgLy8gU2hvdWxkIHdlIHVwZGF0ZSBoZXJlLCBvciBpcyBpdCBzYWZlIHRvXG4gICAgLy8gc2F5IHRoYXQgdGhpcyBpcyBzdGF0ZWZ1bCwgbWVhbmluZyBhIHJlbmRlclxuICAgIC8vIHNob3VsZCBoYXZlIGJlZW4gcGVyZm9ybWVkIGJlZm9yZWhhbmQgd2hpY2hcbiAgICAvLyB3b3VsZCd2ZSB1cGRhdGVkIGl0cyBzdGF0ZVxuICAgIGxldCBydG4gPSBmYWxzZVxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHBvaW50IGlzIGNvbnRhaW5lZCBieSB0aGUgc2hhcGUncyBib3VuZHMgZmlyc3RcbiAgICBpZiAodGhpcy52aXNpYmxlICYmIEFBQm94MmQuY29udGFpbnNQdChhYWJveCwgd29ybGRQdCkpIHtcbiAgICAgIC8vIHJlLWRyYXcgdGhlIHNoYXBlIChpbnZpc2libGUpIHNvIHRoYXQgd2UgY2FuIHVzZSBjYW52YXMnc1xuICAgICAgLy8gaXNQb2ludEluUGF0aC9pc1BvaW50SW5TdHJva2UgYXBpIGNhbGxzLiBEb2luZyB0aGF0XG4gICAgICAvLyBhcyB0aGlzIHNob3VsZCBiZSBjb21wYXRpYmxlIGFjcm9zcyBhbGwgYnJvd3NlcnNcbiAgICAgIGN0eC5zYXZlKClcbiAgICAgIGN0eC5zZXRUcmFuc2Zvcm0odGhpcy5fZnVsbFhmb3JtWzBdLCB0aGlzLl9mdWxsWGZvcm1bMV0sIHRoaXMuX2Z1bGxYZm9ybVsyXSwgdGhpcy5fZnVsbFhmb3JtWzNdLCB0aGlzLl9mdWxsWGZvcm1bNF0sIHRoaXMuX2Z1bGxYZm9ybVs1XSlcbiAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgdGhpcy5fZHJhdyhjdHgpXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBcInJnYmEoMCwwLDAsMClcIlxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGggKyA1XG4gICAgICBjdHguZGFzaFBhdHRlcm4gPSBbXVxuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgICAgY3R4LnN0cm9rZSgpXG4gICAgICBpZiAoKHRoaXMuaXNGaWxsVmlzaWJsZSgpICYmIGN0eC5pc1BvaW50SW5QYXRoKHNjcmVlblB0WzBdLCBzY3JlZW5QdFsxXSkpIHx8XG4gICAgICAgICh0aGlzLmlzU3Ryb2tlVmlzaWJsZSgpICYmIGN0eC5pc1BvaW50SW5TdHJva2Uoc2NyZWVuUHRbMF0sIHNjcmVlblB0WzFdKSkpIHtcbiAgICAgICAgcnRuID0gdHJ1ZVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cbiAgICByZXR1cm4gcnRuXG4gIH1cblxuICAvKipcbiAgICogRGVidWcgZnVuY3Rpb24gdG8gZHJhdyB0aGUgYm91bmRzIG9mIHRoZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAgICAgICAgICAgICAgICAgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7TWF0MmR9IHdvcmxkVG9TY3JlZW5NYXRyaXggVHJhbnNmb3JtIGZyb20gd29ybGQgdG8gc2NyZWVuIHNwYWNlXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBib3VuZHNTdHJva2VTdHlsZSAgIFRoZSBzdHJva2Ugc3R5bGUgdG8gdXNlIHRvIHJlbmRlciB0aGUgYm91bmRzXG4gICAqL1xuICByZW5kZXJCb3VuZHMoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBib3VuZHNTdHJva2VTdHlsZSkge1xuICAgIGN0eC5zYXZlKClcbiAgICBjdHguc2V0VHJhbnNmb3JtKHdvcmxkVG9TY3JlZW5NYXRyaXhbMF0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbMV0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbMl0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbM10sIHdvcmxkVG9TY3JlZW5NYXRyaXhbNF0sIHdvcmxkVG9TY3JlZW5NYXRyaXhbNV0pXG4gICAgYm91bmRzU3Ryb2tlU3R5bGUuc2V0U3Ryb2tlQ3R4KGN0eClcbiAgICBjb25zdCBjZW50ZXIgPSBbMCwgMF1cbiAgICBjb25zdCBleHRlbnRzID0gWzAsIDBdXG4gICAgY29uc3QgYWFib3ggPSB0aGlzLmFhYm94XG4gICAgQUFCb3gyZC5nZXRDZW50ZXIoY2VudGVyLCBhYWJveClcbiAgICBBQUJveDJkLmdldEV4dGVudHMoZXh0ZW50cywgYWFib3gpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LnJlY3QoY2VudGVyWzBdIC0gZXh0ZW50c1swXSwgY2VudGVyWzFdIC0gZXh0ZW50c1sxXSwgZXh0ZW50c1swXSAqIDIsIGV4dGVudHNbMV0gKiAyKVxuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjdHguc3Ryb2tlKClcbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybSAoZG9lcyBub3QgaW5jbHVkZSBwYXJlbnQgdHJhbnNmb3Jtcykgb2YgdGhlIFRyYW5zZm9ybTJkXG4gICAqIG1peGluIGlzIG1vZGlmaWVkLiBVc2VkIHRvIGJlIG5vdGlmaWVkIGludGVybmFsbHkgdGhhdCB0aGUgc2hhcGUncyBib3VuZHMgbmVlZHMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2NhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGdsb2JhbCB0cmFuc2Zvcm0gKGluY2x1ZGVzIHBhcmVudCB0cmFuc2Zvcm1zKSBvZiB0aGUgVHJhbnNmb3JtMmRcbiAgICogbWl4aW4gaXMgbW9kaWZpZWQuIFVzZWQgdG8gYmUgbm90aWZpZWQgaW50ZXJuYWxseSB0aGF0IHRoZSBzaGFwZSdzIGJvdW5kcyBuZWVkcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dsb2JhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgc2hhcGUgdXNpbmcgYSAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAgICAgICAgICAgICAgICAgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7TWF0MmR9IHdvcmxkVG9TY3JlZW5NYXRyaXggVHJhbnNmb3JtIGZyb20gd29ybGQgdG8gc2NyZWVuIHNwYWNlLFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c3VhbGx5IHByb3ZpZGVkIGJ5IGEgY2FtZXJhXG4gICAqIEBwYXJhbSAge0RyYXdTdHlsZVN0YXRlfSBzdHlsZVN0YXRlIE1hbmFnZXMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlIGF0dHJzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoZSAyZCByZW5kZXJpbmcgY29udGV4dC4gVGhpcyBpcyBzZWxmLW1hbmFnZWQgdG8gbWluaW1pemVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCBzdGF0ZSBzd2l0Y2hlc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbZG9GaWxsPW51bGxdICAgICBJZiBwcm92aWRlZCwgdXNlZCB0byBtYW51YWxseSBvdmVycmlkZSB3aGV0aGVyIHRvIGZpbGwgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSBbZG9TdHJva2U9bnVsbF0gICBJZiBwcm92aWRlZCwgdXNlZCB0byBtYW51YWxseSBvdmVycmlkZSB3aGV0aGVyIHRvIHN0cm9rZSB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuXG4gICAqL1xuICByZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBzdHlsZVN0YXRlLCBkb0ZpbGwgPSBudWxsLCBkb1N0cm9rZSA9IG51bGwpIHtcbiAgICB0aGlzLnRyYW5zZm9ybUN0eChjdHgsIHRoaXMuX2Z1bGxYZm9ybSwgd29ybGRUb1NjcmVlbk1hdHJpeClcblxuICAgIGN0eC5iZWdpblBhdGgoKVxuXG4gICAgY29uc3QgcnRuID0gdGhpcy5fZHJhdyhjdHgpXG4gICAgaWYgKHJ0biB8fCB0eXBlb2YgcnRuID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAodGhpcy5pc0ZpbGxWaXNpYmxlKCkgJiYgKGRvRmlsbCA9PT0gbnVsbCB8fCBCb29sZWFuKGRvRmlsbCkpKSB7XG4gICAgICAgIHN0eWxlU3RhdGUuc2V0RmlsbFN0eWxlKGN0eCwgdGhpcylcbiAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc1N0cm9rZVZpc2libGUoKSAmJiAoZG9TdHJva2UgPT09IG51bGwgfHwgQm9vbGVhbihkb1N0cm9rZSkpKSB7XG4gICAgICAgIHN0eWxlU3RhdGUuc2V0U3Ryb2tlU3R5bGUoY3R4LCB0aGlzKVxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgICAgIGN0eC5zdHJva2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIGZpbGwvc3Ryb2tlIHN0eWxlIGZyb20gb25lIEJhc2ljU3R5bGUgb2JqZWN0IHRvIHRoaXMgc2hhcGVcbiAgICogQHBhcmFtIHtCYXNpY1N0eWxlfSBuZXdTdHlsZSBUaGUgc3R5bGUgdG8gY29weSBmcm9tLlxuICAgKiBAcmV0dXJuIHtCYXNlU2hhcGV9IHRoaXNcbiAgICovXG4gIHNldFN0eWxlKG5ld1N0eWxlKSB7XG4gICAgQmFzaWNTdHlsZS5jb3B5QmFzaWNTdHlsZShuZXdTdHlsZSwgdGhpcylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBKU09OIG9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgc2hhcGVcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIGxldCBzdGF0ZSA9IHRoaXNcbiAgICBpZiAodGhpcy5fc3RhdGVTdGFjayAmJiB0aGlzLl9zdGF0ZVN0YWNrLmxlbmd0aCkge1xuICAgICAgc3RhdGUgPSB0aGlzLl9zdGF0ZVN0YWNrWzBdXG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIC8vIHR5cGU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgIC8vIE5PVEU6IEkgd2FudGVkIHRvIHVzZSB0aGUgYWJvdmUgY2FsbCwgd2hpY2ggd291bGQga2VlcCB0aGUgdHlwZVxuICAgICAgLy8gY29uc2lzdGVudCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBjbGFzcywgYnV0IHRoaXMgaXNuJ3QgYWx3YXlzXG4gICAgICAvLyB0aGUgY2FzZSwgYXMgd2FzIGZvdW5kIG91dCBhIGZldyB0aW1lcyB3aGVuIHRyeWluZyB0byBhZGRcbiAgICAgIC8vIHRoaXMgdG8gaW1tZXJzZVxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlLFxuICAgICAgekluZGV4OiBzdGF0ZS56SW5kZXhcbiAgICB9LCBCYXNpY1N0eWxlLnRvSlNPTihzdGF0ZSksIFRyYW5zZm9ybTJkLnRvSlNPTih0aGlzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlcyB0d28gc2hhcGVzLCB1c3VhbGx5IHVzZWQgdG8gc29ydCB0aGUgc2hhcGVzIGZvciBkcmF3aW5nXG4gICAqIEBwYXJhbSAge0Jhc2VTaGFwZX0gc2hhcGUxXG4gICAqIEBwYXJhbSAge0Jhc2VTaGFwZX0gc2hhcGUyXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgIFJldHVybnMgPCAwIGlmIHNoYXBlMSA8IHNoYXBlMiwgPiAwIGlmIHNoYXBlMSA+IHNoYXBlMiwgMCBpZiBzaGFwZTEgPT09IHNoYXBlMlxuICAgKi9cbiAgc3RhdGljIHNoYXBlQ29tcGFyZShzaGFwZTEsIHNoYXBlMikge1xuICAgIGNvbnN0IHpJbmRleDEgPSBzaGFwZTEuekluZGV4XG4gICAgY29uc3QgekluZGV4MiA9IHNoYXBlMi56SW5kZXhcbiAgICBpZiAoekluZGV4MSA8IHpJbmRleDIpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH0gZWxzZSBpZiAoekluZGV4MSA+IHpJbmRleDIpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGV0IHJ0biA9IEZpbGxTdHlsZS5jb21wYXJlRmlsbFN0eWxlKHNoYXBlMSwgc2hhcGUyKVxuICAgIGlmICghcnRuKSB7XG4gICAgICBydG4gPSBTdHJva2VTdHlsZS5jb21wYXJlU3Ryb2tlU3R5bGUoc2hhcGUxLCBzaGFwZTIpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9iYXNlLXNoYXBlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _glMatrix = __webpack_require__(1);\n\n/**\n * Singular value decomposition\n * See: http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation\n */\n\n/**\n * Calculates the singular value decomposition to extract the\n * scale, rotation, and translation from a 2x3 matrix.\n * Any matrix built by affine transformations can be decomposed\n * into a rotation*scale*rotation*translation\n * See: http://math.stackexchange.com/questions/861674/decompose-a-2d-arbitrary-transform-into-only-scaling-and-rotation\n * @param  {Vec2d} outTranslate Vector to hold the translation components\n * @param  {Vec2d} outScale     Vector to hold the x,y scale components\n * @param  {Vec2d} outRotate    Vector to hold the rotation components\n * @param  {Mat2d} mat          Matrix to decompose\n */\n_glMatrix.mat2d.svd = function (outTranslate, outScale, outRotate, mat) {\n  if (outTranslate) {\n    outTranslate[0] = mat[4];\n    outTranslate[1] = mat[5];\n  }\n  if (outScale || outRotate) {\n    var E = (mat[0] + mat[3]) / 2.0;\n    var F = (mat[0] - mat[3]) / 2.0;\n    var G = (mat[1] + mat[2]) / 2.0;\n    var H = (mat[1] - mat[2]) / 2.0;\n    if (outScale) {\n      var Q = Math.sqrt(E * E + H * H);\n      var R = Math.sqrt(F * F + G * G);\n      outScale[0] = Q + R;\n      outScale[1] = Q - R;\n    }\n    if (outRotate) {\n      var a1 = Math.atan2(G, F);\n      var a2 = Math.atan2(H, E);\n      outRotate[0] = (a2 - a1) / 2.0;\n      outRotate[1] = (a2 + a1) / 2.0;\n    }\n  }\n};\n\nexports.default = _glMatrix.mat2d;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL21hdDJkLmpzPzY0YTUiXSwibmFtZXMiOlsic3ZkIiwib3V0VHJhbnNsYXRlIiwib3V0U2NhbGUiLCJvdXRSb3RhdGUiLCJtYXQiLCJFIiwiRiIsIkciLCJIIiwiUSIsIk1hdGgiLCJzcXJ0IiwiUiIsImExIiwiYXRhbjIiLCJhMiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztBQUVBOztBQUVBOzs7OztBQUtDOzs7Ozs7Ozs7OztBQVdELGdCQUFNQSxHQUFOLEdBQVksVUFBQ0MsWUFBRCxFQUFlQyxRQUFmLEVBQXlCQyxTQUF6QixFQUFvQ0MsR0FBcEMsRUFBNEM7QUFDdEQsTUFBSUgsWUFBSixFQUFrQjtBQUNoQkEsaUJBQWEsQ0FBYixJQUFrQkcsSUFBSSxDQUFKLENBQWxCO0FBQ0FILGlCQUFhLENBQWIsSUFBa0JHLElBQUksQ0FBSixDQUFsQjtBQUNEO0FBQ0QsTUFBSUYsWUFBWUMsU0FBaEIsRUFBMkI7QUFDekIsUUFBTUUsSUFBSSxDQUFDRCxJQUFJLENBQUosSUFBU0EsSUFBSSxDQUFKLENBQVYsSUFBb0IsR0FBOUI7QUFDQSxRQUFNRSxJQUFJLENBQUNGLElBQUksQ0FBSixJQUFTQSxJQUFJLENBQUosQ0FBVixJQUFvQixHQUE5QjtBQUNBLFFBQU1HLElBQUksQ0FBQ0gsSUFBSSxDQUFKLElBQVNBLElBQUksQ0FBSixDQUFWLElBQW9CLEdBQTlCO0FBQ0EsUUFBTUksSUFBSSxDQUFDSixJQUFJLENBQUosSUFBU0EsSUFBSSxDQUFKLENBQVYsSUFBb0IsR0FBOUI7QUFDQSxRQUFJRixRQUFKLEVBQWM7QUFDWixVQUFNTyxJQUFJQyxLQUFLQyxJQUFMLENBQVVOLElBQUlBLENBQUosR0FBUUcsSUFBSUEsQ0FBdEIsQ0FBVjtBQUNBLFVBQU1JLElBQUlGLEtBQUtDLElBQUwsQ0FBVUwsSUFBSUEsQ0FBSixHQUFRQyxJQUFJQSxDQUF0QixDQUFWO0FBQ0FMLGVBQVMsQ0FBVCxJQUFjTyxJQUFJRyxDQUFsQjtBQUNBVixlQUFTLENBQVQsSUFBY08sSUFBSUcsQ0FBbEI7QUFDRDtBQUNELFFBQUlULFNBQUosRUFBZTtBQUNiLFVBQU1VLEtBQUtILEtBQUtJLEtBQUwsQ0FBV1AsQ0FBWCxFQUFjRCxDQUFkLENBQVg7QUFDQSxVQUFNUyxLQUFLTCxLQUFLSSxLQUFMLENBQVdOLENBQVgsRUFBY0gsQ0FBZCxDQUFYO0FBQ0FGLGdCQUFVLENBQVYsSUFBZSxDQUFDWSxLQUFLRixFQUFOLElBQVksR0FBM0I7QUFDQVYsZ0JBQVUsQ0FBVixJQUFlLENBQUNZLEtBQUtGLEVBQU4sSUFBWSxHQUEzQjtBQUNEO0FBQ0Y7QUFDRixDQXZCRCIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IHttYXQyZCBhcyBNYXQyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5cbi8qKlxuICogU2luZ3VsYXIgdmFsdWUgZGVjb21wb3NpdGlvblxuICogU2VlOiBodHRwOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvODYxNjc0L2RlY29tcG9zZS1hLTJkLWFyYml0cmFyeS10cmFuc2Zvcm0taW50by1vbmx5LXNjYWxpbmctYW5kLXJvdGF0aW9uXG4gKi9cblxuIC8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gdG8gZXh0cmFjdCB0aGVcbiAgKiBzY2FsZSwgcm90YXRpb24sIGFuZCB0cmFuc2xhdGlvbiBmcm9tIGEgMngzIG1hdHJpeC5cbiAgKiBBbnkgbWF0cml4IGJ1aWx0IGJ5IGFmZmluZSB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGRlY29tcG9zZWRcbiAgKiBpbnRvIGEgcm90YXRpb24qc2NhbGUqcm90YXRpb24qdHJhbnNsYXRpb25cbiAgKiBTZWU6IGh0dHA6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy84NjE2NzQvZGVjb21wb3NlLWEtMmQtYXJiaXRyYXJ5LXRyYW5zZm9ybS1pbnRvLW9ubHktc2NhbGluZy1hbmQtcm90YXRpb25cbiAgKiBAcGFyYW0gIHtWZWMyZH0gb3V0VHJhbnNsYXRlIFZlY3RvciB0byBob2xkIHRoZSB0cmFuc2xhdGlvbiBjb21wb25lbnRzXG4gICogQHBhcmFtICB7VmVjMmR9IG91dFNjYWxlICAgICBWZWN0b3IgdG8gaG9sZCB0aGUgeCx5IHNjYWxlIGNvbXBvbmVudHNcbiAgKiBAcGFyYW0gIHtWZWMyZH0gb3V0Um90YXRlICAgIFZlY3RvciB0byBob2xkIHRoZSByb3RhdGlvbiBjb21wb25lbnRzXG4gICogQHBhcmFtICB7TWF0MmR9IG1hdCAgICAgICAgICBNYXRyaXggdG8gZGVjb21wb3NlXG4gICovXG5NYXQyZC5zdmQgPSAob3V0VHJhbnNsYXRlLCBvdXRTY2FsZSwgb3V0Um90YXRlLCBtYXQpID0+IHtcbiAgaWYgKG91dFRyYW5zbGF0ZSkge1xuICAgIG91dFRyYW5zbGF0ZVswXSA9IG1hdFs0XVxuICAgIG91dFRyYW5zbGF0ZVsxXSA9IG1hdFs1XVxuICB9XG4gIGlmIChvdXRTY2FsZSB8fCBvdXRSb3RhdGUpIHtcbiAgICBjb25zdCBFID0gKG1hdFswXSArIG1hdFszXSkgLyAyLjBcbiAgICBjb25zdCBGID0gKG1hdFswXSAtIG1hdFszXSkgLyAyLjBcbiAgICBjb25zdCBHID0gKG1hdFsxXSArIG1hdFsyXSkgLyAyLjBcbiAgICBjb25zdCBIID0gKG1hdFsxXSAtIG1hdFsyXSkgLyAyLjBcbiAgICBpZiAob3V0U2NhbGUpIHtcbiAgICAgIGNvbnN0IFEgPSBNYXRoLnNxcnQoRSAqIEUgKyBIICogSClcbiAgICAgIGNvbnN0IFIgPSBNYXRoLnNxcnQoRiAqIEYgKyBHICogRylcbiAgICAgIG91dFNjYWxlWzBdID0gUSArIFJcbiAgICAgIG91dFNjYWxlWzFdID0gUSAtIFJcbiAgICB9XG4gICAgaWYgKG91dFJvdGF0ZSkge1xuICAgICAgY29uc3QgYTEgPSBNYXRoLmF0YW4yKEcsIEYpXG4gICAgICBjb25zdCBhMiA9IE1hdGguYXRhbjIoSCwgRSlcbiAgICAgIG91dFJvdGF0ZVswXSA9IChhMiAtIGExKSAvIDIuMFxuICAgICAgb3V0Um90YXRlWzFdID0gKGEyICsgYTEpIC8gMi4wXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1hdDJkXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb3JlL21hdDJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 8 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/*\n **  Aggregation -- Aggregation of Base Class and Mixin Classes\n **  Copyright (c) 2015 Ralf S. Engelschall <rse@engelschall.com>\n **\n **  Permission is hereby granted, free of charge, to any person obtaining\n **  a copy of this software and associated documentation files (the\n **  \"Software\"), to deal in the Software without restriction, including\n **  without limitation the rights to use, copy, modify, merge, publish,\n **  distribute, sublicense, and/or sell copies of the Software, and to\n **  permit persons to whom the Software is furnished to do so, subject to\n **  the following conditions:\n **\n **  The above copyright notice and this permission notice shall be included\n **  in all copies or substantial portions of the Software.\n **\n **  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n **  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n **  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n **  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n **  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n **  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n **  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/*  ==== ECMAScript 6 variant ====  */\n\n/**\n * Creates a new class constructor function using an optional base class\n * and an optional list of mixins. If mixins need initializing, then\n * they should contain an 'initializer' member function\n * @param  {function}    base   base class construct function, if null, a bare-bones\n *                              base class is used by default\n * @param  {...[function]} mixins mixin classes\n * @return {function}           new class constructor function\n */\nvar aggregation = function aggregation(base) {\n  for (var _len = arguments.length, mixins = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    mixins[_key - 1] = arguments[_key];\n  }\n\n  /*  create aggregation class  */\n  var aggregate = base ? function (_base) {\n    _inherits(__Aggregate, _base);\n\n    function __Aggregate() {\n      var _ref;\n\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _classCallCheck(this, __Aggregate);\n\n      /*  call mixin's initializer  */\n      var _this = _possibleConstructorReturn(this, (_ref = __Aggregate.__proto__ || Object.getPrototypeOf(__Aggregate)).call.apply(_ref, [this].concat(args)));\n      /*  call base class constructor  */\n\n\n      mixins.forEach(function (mixin) {\n        var _mixin$prototype$init;\n\n        if (typeof mixin.prototype.initializer === \"function\") (_mixin$prototype$init = mixin.prototype.initializer).call.apply(_mixin$prototype$init, [_this].concat(args));\n      });\n      return _this;\n    }\n\n    return __Aggregate;\n  }(base) : function () {};\n\n  /*  copy properties  */\n  var copyProps = function copyProps(target, source) {\n    Object.getOwnPropertyNames(source).concat(Object.getOwnPropertySymbols(source)).forEach(function (prop) {\n      if (prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/)) return;\n      if (base && prop.match(/^(?:initializer)$/)) return;\n      Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));\n    });\n  };\n\n  /*  copy all properties of all mixins into aggregation class  */\n  mixins.forEach(function (mixin) {\n    copyProps(aggregate.prototype, mixin.prototype);\n    copyProps(aggregate, mixin);\n  });\n\n  return aggregate;\n};\n\nexports.default = aggregation;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2FnZ3JlZ2F0aW9uLmpzP2I4ODAiXSwibmFtZXMiOlsiYWdncmVnYXRpb24iLCJiYXNlIiwibWl4aW5zIiwiYWdncmVnYXRlIiwiYXJncyIsImZvckVhY2giLCJtaXhpbiIsInByb3RvdHlwZSIsImluaXRpYWxpemVyIiwiY2FsbCIsImNvcHlQcm9wcyIsInRhcmdldCIsInNvdXJjZSIsIk9iamVjdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJwcm9wIiwibWF0Y2giLCJkZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7QUFFQTs7Ozs7Ozs7O0FBU0EsSUFBSUEsY0FBYyxTQUFkQSxXQUFjLENBQUNDLElBQUQsRUFBcUI7QUFBQSxvQ0FBWEMsTUFBVztBQUFYQSxVQUFXO0FBQUE7O0FBRXJDO0FBQ0EsTUFBSUMsWUFBYUY7QUFBQTs7QUFDZiwyQkFBcUI7QUFBQTs7QUFBQSx5Q0FBTkcsSUFBTTtBQUFOQSxZQUFNO0FBQUE7O0FBQUE7O0FBSW5CO0FBSm1CLHVKQUVWQSxJQUZVO0FBQ25COzs7QUFJQUYsYUFBT0csT0FBUCxDQUFlLFVBQUNDLEtBQUQsRUFBVztBQUFBOztBQUN4QixZQUFJLE9BQU9BLE1BQU1DLFNBQU4sQ0FBZ0JDLFdBQXZCLEtBQXVDLFVBQTNDLEVBQ0UsK0JBQU1ELFNBQU4sQ0FBZ0JDLFdBQWhCLEVBQTRCQyxJQUE1Qiw2Q0FBMENMLElBQTFDO0FBQ0gsT0FIRDtBQUxtQjtBQVNwQjs7QUFWYztBQUFBLElBQWlDSCxJQUFqQyxJQVdiLFlBQVcsQ0FBRSxDQVhqQjs7QUFhQTtBQUNBLE1BQUlTLFlBQVksU0FBWkEsU0FBWSxDQUFDQyxNQUFELEVBQVNDLE1BQVQsRUFBb0I7QUFDbENDLFdBQU9DLG1CQUFQLENBQTJCRixNQUEzQixFQUNHRyxNQURILENBQ1VGLE9BQU9HLHFCQUFQLENBQTZCSixNQUE3QixDQURWLEVBRUdQLE9BRkgsQ0FFVyxVQUFDWSxJQUFELEVBQVU7QUFDakIsVUFBSUEsS0FBS0MsS0FBTCxDQUFXLG1GQUFYLENBQUosRUFDRTtBQUNGLFVBQUlqQixRQUFRZ0IsS0FBS0MsS0FBTCxDQUFXLG1CQUFYLENBQVosRUFDRTtBQUNGTCxhQUFPTSxjQUFQLENBQXNCUixNQUF0QixFQUE4Qk0sSUFBOUIsRUFBb0NKLE9BQU9PLHdCQUFQLENBQWdDUixNQUFoQyxFQUF3Q0ssSUFBeEMsQ0FBcEM7QUFDRCxLQVJIO0FBU0QsR0FWRDs7QUFZQTtBQUNBZixTQUFPRyxPQUFQLENBQWUsVUFBQ0MsS0FBRCxFQUFXO0FBQ3hCSSxjQUFVUCxVQUFVSSxTQUFwQixFQUErQkQsTUFBTUMsU0FBckM7QUFDQUcsY0FBVVAsU0FBVixFQUFxQkcsS0FBckI7QUFDRCxHQUhEOztBQUtBLFNBQU9ILFNBQVA7QUFDRCxDQXBDRDs7a0JBc0NlSCxXIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICoqICBBZ2dyZWdhdGlvbiAtLSBBZ2dyZWdhdGlvbiBvZiBCYXNlIENsYXNzIGFuZCBNaXhpbiBDbGFzc2VzXG4gKiogIENvcHlyaWdodCAoYykgMjAxNSBSYWxmIFMuIEVuZ2Vsc2NoYWxsIDxyc2VAZW5nZWxzY2hhbGwuY29tPlxuICoqXG4gKiogIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuICoqICBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqKiAgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gKiogIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbiAqKiAgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvXG4gKiogIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICoqICB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKipcbiAqKiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbiAqKiAgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKipcbiAqKiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqKiAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiogIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAqKiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbiAqKiAgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCxcbiAqKiAgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAqKiAgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogID09PT0gRUNNQVNjcmlwdCA2IHZhcmlhbnQgPT09PSAgKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHVzaW5nIGFuIG9wdGlvbmFsIGJhc2UgY2xhc3NcbiAqIGFuZCBhbiBvcHRpb25hbCBsaXN0IG9mIG1peGlucy4gSWYgbWl4aW5zIG5lZWQgaW5pdGlhbGl6aW5nLCB0aGVuXG4gKiB0aGV5IHNob3VsZCBjb250YWluIGFuICdpbml0aWFsaXplcicgbWVtYmVyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgYmFzZSAgIGJhc2UgY2xhc3MgY29uc3RydWN0IGZ1bmN0aW9uLCBpZiBudWxsLCBhIGJhcmUtYm9uZXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFzZSBjbGFzcyBpcyB1c2VkIGJ5IGRlZmF1bHRcbiAqIEBwYXJhbSAgey4uLltmdW5jdGlvbl19IG1peGlucyBtaXhpbiBjbGFzc2VzXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gICAgICAgICAgIG5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICovXG52YXIgYWdncmVnYXRpb24gPSAoYmFzZSwgLi4ubWl4aW5zKSA9PiB7XG5cbiAgLyogIGNyZWF0ZSBhZ2dyZWdhdGlvbiBjbGFzcyAgKi9cbiAgbGV0IGFnZ3JlZ2F0ZSA9IChiYXNlID8gY2xhc3MgX19BZ2dyZWdhdGUgZXh0ZW5kcyBiYXNlIHtcbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAvKiAgY2FsbCBiYXNlIGNsYXNzIGNvbnN0cnVjdG9yICAqL1xuICAgICAgc3VwZXIoLi4uYXJncylcblxuICAgICAgLyogIGNhbGwgbWl4aW4ncyBpbml0aWFsaXplciAgKi9cbiAgICAgIG1peGlucy5mb3JFYWNoKChtaXhpbikgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIG1peGluLnByb3RvdHlwZS5pbml0aWFsaXplciA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIG1peGluLnByb3RvdHlwZS5pbml0aWFsaXplci5jYWxsKHRoaXMsIC4uLmFyZ3MpXG4gICAgICB9KVxuICAgIH1cbiAgfSA6IGZ1bmN0aW9uKCkge30pO1xuXG4gIC8qICBjb3B5IHByb3BlcnRpZXMgICovXG4gIGxldCBjb3B5UHJvcHMgPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzb3VyY2UpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKSlcbiAgICAgIC5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wLm1hdGNoKC9eKD86Y29uc3RydWN0b3J8cHJvdG90eXBlfGFyZ3VtZW50c3xjYWxsZXJ8bmFtZXxiaW5kfGNhbGx8YXBwbHl8dG9TdHJpbmd8bGVuZ3RoKSQvKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgaWYgKGJhc2UgJiYgcHJvcC5tYXRjaCgvXig/OmluaXRpYWxpemVyKSQvKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3ApKVxuICAgICAgfSlcbiAgfVxuXG4gIC8qICBjb3B5IGFsbCBwcm9wZXJ0aWVzIG9mIGFsbCBtaXhpbnMgaW50byBhZ2dyZWdhdGlvbiBjbGFzcyAgKi9cbiAgbWl4aW5zLmZvckVhY2goKG1peGluKSA9PiB7XG4gICAgY29weVByb3BzKGFnZ3JlZ2F0ZS5wcm90b3R5cGUsIG1peGluLnByb3RvdHlwZSlcbiAgICBjb3B5UHJvcHMoYWdncmVnYXRlLCBtaXhpbilcbiAgfSlcblxuICByZXR1cm4gYWdncmVnYXRlXG59XG5cbmV4cG9ydCBkZWZhdWx0IGFnZ3JlZ2F0aW9uXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlsL2FnZ3JlZ2F0aW9uLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aggregation2 = __webpack_require__(8);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _fillStyle = __webpack_require__(19);\n\nvar _fillStyle2 = _interopRequireDefault(_fillStyle);\n\nvar _strokeStyle = __webpack_require__(10);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @class  Basic shape style for a 2d rendering context\n * @extends {FillStyle}\n * @extends {StrokeStyle}\n */\nvar BasicStyle = function (_aggregation) {\n  _inherits(BasicStyle, _aggregation);\n\n  /**\n   * Creates a new Basic Style\n   * @param  {...{}} [args] Initializer options for base classes/mixins\n   * @return {BasicStyle}\n   */\n  function BasicStyle() {\n    var _ref;\n\n    _classCallCheck(this, BasicStyle);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _possibleConstructorReturn(this, (_ref = BasicStyle.__proto__ || Object.getPrototypeOf(BasicStyle)).call.apply(_ref, [this].concat(args)));\n  }\n\n  /**\n   * Copies the properties from one BasicStyle to another\n   * @param  {BasicStyle} srcBasicStyle The style to copy from\n   * @param  {BasicStyle} dstBasicStyle The style to copy to\n   */\n\n\n  _createClass(BasicStyle, null, [{\n    key: \"copyBasicStyle\",\n    value: function copyBasicStyle(srcBasicStyle, dstBasicStyle) {\n      _fillStyle2.default.copyFillStyle(srcBasicStyle, dstBasicStyle);\n      _strokeStyle2.default.copyStrokeStyle(srcBasicStyle, dstBasicStyle);\n    }\n\n    /**\n     * Converts a BasicStyle instance to a JSON object\n     * @param  {BasicStyle} basicStyleObj\n     * @return {{fillColor   : string,\n     *           strokeColor : string,\n     *           strokeWidth : number,\n     *           lineJoin    : string,\n     *           lineCap     : string,\n     *           dashPattern : number[],\n     *           dashOffset  : number\n     *          }}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(basicStyleObj) {\n      return Object.assign(_fillStyle2.default.toJSON(basicStyleObj), _strokeStyle2.default.toJSON(basicStyleObj));\n    }\n  }]);\n\n  return BasicStyle;\n}((0, _aggregation3.default)(function BaseBasicStyle() {\n  _classCallCheck(this, BaseBasicStyle);\n}, _fillStyle2.default, _strokeStyle2.default));\n\nexports.default = BasicStyle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9iYXNpYy1zdHlsZS5qcz9kNTU5Il0sIm5hbWVzIjpbIkJhc2ljU3R5bGUiLCJhcmdzIiwic3JjQmFzaWNTdHlsZSIsImRzdEJhc2ljU3R5bGUiLCJjb3B5RmlsbFN0eWxlIiwiY29weVN0cm9rZVN0eWxlIiwiYmFzaWNTdHlsZU9iaiIsIk9iamVjdCIsImFzc2lnbiIsInRvSlNPTiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQTs7Ozs7SUFLcUJBLFU7OztBQUNuQjs7Ozs7QUFLQSx3QkFBcUI7QUFBQTs7QUFBQTs7QUFBQSxzQ0FBTkMsSUFBTTtBQUFOQSxVQUFNO0FBQUE7O0FBQUEsOElBQ1ZBLElBRFU7QUFFcEI7O0FBRUQ7Ozs7Ozs7OzttQ0FLc0JDLGEsRUFBZUMsYSxFQUFlO0FBQ2xELDBCQUFVQyxhQUFWLENBQXdCRixhQUF4QixFQUF1Q0MsYUFBdkM7QUFDQSw0QkFBWUUsZUFBWixDQUE0QkgsYUFBNUIsRUFBMkNDLGFBQTNDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7OzsyQkFZY0csYSxFQUFlO0FBQzNCLGFBQU9DLE9BQU9DLE1BQVAsQ0FBYyxvQkFBVUMsTUFBVixDQUFpQkgsYUFBakIsQ0FBZCxFQUErQyxzQkFBWUcsTUFBWixDQUFtQkgsYUFBbkIsQ0FBL0MsQ0FBUDtBQUNEOzs7O0VBbENxQztBQUFBO0FBQUEsOEM7O2tCQUFuQk4sVSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCBGaWxsU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2ZpbGwtc3R5bGVcIlxuaW1wb3J0IFN0cm9rZVN0eWxlIGZyb20gXCIuLi9zdHlsZS9zdHJva2Utc3R5bGVcIlxuXG4vKipcbiAqIEBjbGFzcyAgQmFzaWMgc2hhcGUgc3R5bGUgZm9yIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAqIEBleHRlbmRzIHtGaWxsU3R5bGV9XG4gKiBAZXh0ZW5kcyB7U3Ryb2tlU3R5bGV9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhc2ljU3R5bGUgZXh0ZW5kcyBhZ2dyZWdhdGlvbihjbGFzcyBCYXNlQmFzaWNTdHlsZSB7fSwgRmlsbFN0eWxlLCBTdHJva2VTdHlsZSkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBCYXNpYyBTdHlsZVxuICAgKiBAcGFyYW0gIHsuLi57fX0gW2FyZ3NdIEluaXRpYWxpemVyIG9wdGlvbnMgZm9yIGJhc2UgY2xhc3Nlcy9taXhpbnNcbiAgICogQHJldHVybiB7QmFzaWNTdHlsZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKVxuICB9XG5cbiAgLyoqXG4gICAqIENvcGllcyB0aGUgcHJvcGVydGllcyBmcm9tIG9uZSBCYXNpY1N0eWxlIHRvIGFub3RoZXJcbiAgICogQHBhcmFtICB7QmFzaWNTdHlsZX0gc3JjQmFzaWNTdHlsZSBUaGUgc3R5bGUgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSAge0Jhc2ljU3R5bGV9IGRzdEJhc2ljU3R5bGUgVGhlIHN0eWxlIHRvIGNvcHkgdG9cbiAgICovXG4gIHN0YXRpYyBjb3B5QmFzaWNTdHlsZShzcmNCYXNpY1N0eWxlLCBkc3RCYXNpY1N0eWxlKSB7XG4gICAgRmlsbFN0eWxlLmNvcHlGaWxsU3R5bGUoc3JjQmFzaWNTdHlsZSwgZHN0QmFzaWNTdHlsZSlcbiAgICBTdHJva2VTdHlsZS5jb3B5U3Ryb2tlU3R5bGUoc3JjQmFzaWNTdHlsZSwgZHN0QmFzaWNTdHlsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIEJhc2ljU3R5bGUgaW5zdGFuY2UgdG8gYSBKU09OIG9iamVjdFxuICAgKiBAcGFyYW0gIHtCYXNpY1N0eWxlfSBiYXNpY1N0eWxlT2JqXG4gICAqIEByZXR1cm4ge3tmaWxsQ29sb3IgICA6IHN0cmluZyxcbiAgICogICAgICAgICAgIHN0cm9rZUNvbG9yIDogc3RyaW5nLFxuICAgKiAgICAgICAgICAgc3Ryb2tlV2lkdGggOiBudW1iZXIsXG4gICAqICAgICAgICAgICBsaW5lSm9pbiAgICA6IHN0cmluZyxcbiAgICogICAgICAgICAgIGxpbmVDYXAgICAgIDogc3RyaW5nLFxuICAgKiAgICAgICAgICAgZGFzaFBhdHRlcm4gOiBudW1iZXJbXSxcbiAgICogICAgICAgICAgIGRhc2hPZmZzZXQgIDogbnVtYmVyXG4gICAqICAgICAgICAgIH19XG4gICAqL1xuICBzdGF0aWMgdG9KU09OKGJhc2ljU3R5bGVPYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihGaWxsU3R5bGUudG9KU09OKGJhc2ljU3R5bGVPYmopLCBTdHJva2VTdHlsZS50b0pTT04oYmFzaWNTdHlsZU9iaikpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3N0eWxlL2Jhc2ljLXN0eWxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedStrokeStyleMixin = createEventedStrokeStyleMixin;\n\nvar _colorRgba = __webpack_require__(18);\n\nvar _colorRgba2 = _interopRequireDefault(_colorRgba);\n\nvar _aggregation = __webpack_require__(8);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {object} StrokeStyleOptions\n * @property {string} [strokeColor = \"black\"]\n * @property {number} [strokeWidth = 0]\n * @property {string} [lineJoin = \"miter\"]\n * @property {string} [lineCap = \"butt\"]\n * @property {number[]} [dashPattern = []]\n * @property {number} [dashOffset = 0]\n */\n\n/**\n * validates a possible stroke width value\n * @param  {number} strokeWidth\n * @throws If validation fails\n * @private\n */\nfunction validateStrokeWidth(strokeWidth) {\n  if (typeof strokeWidth !== \"number\") {\n    throw new Error(\"Stroke width must be a number\");\n  }\n}\n\n/**\n * Enum for line join values\n * @enum {number}\n */\nvar JoinEnum = {\n  MITER: 0,\n  BEVEL: 1,\n  ROUND: 2\n};\n\n/**\n * line join values as strings, the enum values match the index in this string\n * @type {string[]}\n */\nvar lineJoinOpts = [\"miter\", \"bevel\", \"round\"];\n\n/**\n * validates a line join value\n * @param  {string} lineJoin Should be one of [\"miter\", \"bevel\", \"round\"]\n * @throws If validation fails\n * @return {JoinEnum}\n * @private\n */\nfunction validateLineJoin(lineJoin) {\n  var idx = -1;\n  if (typeof lineJoin !== \"string\" || (idx = lineJoinOpts.indexOf(lineJoin.toLowerCase())) < 0) {\n    throw new Error(\"Line join must be a string and must be one of [\" + lineJoinOpts.join(\", \") + \"]\");\n  }\n  return idx;\n}\n\n/**\n * Enum for line cap values\n * @enum {number}\n */\nvar CapEnum = {\n  BUTT: 0,\n  SQUARE: 1,\n  ROUND: 2\n};\n\n/**\n * line cap values as strings, the CapEnum values match the index in this string\n * @type {string[]}\n */\nvar lineCapOpts = [\"butt\", \"square\", \"round\"];\n\n/**\n * validates a line cap value\n * @param  {string} lineCap Should be one of \"butt\", \"square\", \"round\"\n * @throws If validation fails\n * @return {CapEnum}\n * @private\n */\nfunction validateLineCap(lineCap) {\n  var idx = -1;\n  if (typeof lineCap !== \"string\" || (idx = lineCapOpts.indexOf(lineCap.toLowerCase())) < 0) {\n    throw new Error(\"Line cap must be a string and must be one of [\" + lineCapOpts.join(\", \") + \"]\");\n  }\n  return idx;\n}\n\n/**\n * validates a dash pattern value\n * @param  {number[]} dashPattern\n * @throws If validation fails\n * @private\n */\nfunction validateDashPattern(dashPattern) {\n  if (!dashPattern || !Array.isArray(dashPattern) || dashPattern.length % 2 !== 0) {\n    throw new Error(\"The dash pattern must be an array with an even number of numbers (or an empty array)\");\n  }\n}\n\n/**\n * validates a dash offset value\n * @param  {number} dashOffset\n * @throws If validation fails\n * @private\n */\nfunction validateDashOffset(dashOffset) {\n  if (typeof dashOffset !== \"number\") {\n    throw new Error(\"The dash offset must be a number\");\n  }\n}\n\n/**\n * Manages the stroke style of a 2d rendering context. Can be used as a mixin or base class\n * @class\n * @mixin\n */\n\nvar StrokeStyle = function () {\n  function StrokeStyle(opts) {\n    _classCallCheck(this, StrokeStyle);\n\n    this.initializer(opts);\n  }\n\n  /**\n   * initializes the stroke style object from an options object\n   * @param  {StrokeStyleOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(StrokeStyle, [{\n    key: \"_initStrokeStyleFromOptions\",\n    value: function _initStrokeStyleFromOptions(opts) {\n      if (opts) {\n        if (typeof opts.strokeColor !== \"undefined\") {\n          this.strokeColor = opts.strokeColor;\n        }\n        if (typeof opts.strokeOpacity !== \"undefined\") {\n          this.strokeOpacity = opts.strokeOpacity;\n        }\n        if (typeof opts.strokeWidth !== \"undefined\") {\n          this.strokeWidth = opts.strokeWidth;\n        }\n        if (typeof opts.lineMiter !== \"undefined\") {\n          this.lineJoin = opts.lineMiter;\n        }\n        if (typeof opts.lineCap !== \"undefined\") {\n          this.lineCap = opts.lineCap;\n        }\n        if (typeof opts.dashPattern !== \"undefined\") {\n          this.dashPattern = opts.dashPattern;\n        }\n        if (typeof opts.dashOffset !== \"undefined\") {\n          this.dashOffset = opts.dashOffset;\n        }\n      }\n    }\n\n    /**\n     * Initializer method to initialize a stroke style. Used for both initializing\n     * via base-class and mixin hierarchy.\n     * @param  {StrokeStyleOptions} [opts]\n     * @protected\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._strokeColor = new _colorRgba2.default(\"black\");\n      this._strokeWidth = 0;\n      this._lineJoin = JoinEnum.MITER;\n      this._lineCap = CapEnum.BUTT;\n      this._dashPattern = [];\n      this._dashOffset = 0;\n      this._initStrokeStyleFromOptions(opts);\n    }\n\n    /**\n     * Sets the stroke color\n     * @param  {string} strokeColor Color as a string, \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"black\")\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"isStrokeVisible\",\n\n\n    /**\n     * Returns true if the stroke style is visible, i.e. it is not fully transparent\n     * and has a width > 0\n     * @return {Boolean}\n     */\n    value: function isStrokeVisible() {\n      return this._strokeColor.opacity > 0 && this._strokeWidth > 0;\n    }\n\n    /**\n     * Returns true if stroke is partially transparent, i.e. opacity < 1\n     * @return {Boolean} [description]\n     */\n\n  }, {\n    key: \"isTransparent\",\n    value: function isTransparent() {\n      return this._strokeColor.isTransparent();\n    }\n\n    /**\n     * Sets the stroke style state of a 2d rendering context\n     * @param {CanvasRenderingContext2D} ctx\n     */\n\n  }, {\n    key: \"setStrokeCtx\",\n    value: function setStrokeCtx(ctx) {\n      ctx.strokeStyle = this.strokeColor;\n      ctx.lineWidth = this._strokeWidth;\n      ctx.lineJoin = this._lineJoin;\n      ctx.lineCap = this._lineCap;\n      ctx.setLineDash(this._dashPattern);\n      ctx.lineDashOffset = this._dashOffset;\n    }\n\n    /**\n     * Copies the properties of one stroke style to another\n     * @param  {StrokeStyle} srcStyle StrokeStyle object to copy from\n     * @param  {StrokeStyle} dstStyle StrokeStyle object to copy to\n     */\n\n  }, {\n    key: \"strokeColor\",\n    set: function set(strokeColor) {\n      this._strokeColor.value = strokeColor;\n      return this;\n    }\n\n    /**\n     * Gets the stroke color of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.value;\n    }\n\n    /**\n     * Sets the opacity of the stroke style\n     * @param  {number} opacity [0,1]\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"strokeOpacity\",\n    set: function set(opacity) {\n      this._strokeColor.opacity = opacity;\n    }\n\n    /**\n     * Gets the current opacity of the stroke style [0,1]\n     * @return {number} Opacity in the range [0,1]\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.opacity;\n    }\n\n    /**\n     * Sets the stroke color of the style defined as a 32-bit int\n     * @param  {number} packedStrokeColor Color value as a 32-bit int (i.e. 0xFFFFFFFF)\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"packedStrokeColor\",\n    set: function set(packedStrokeColor) {\n      this._strokeColor.packedValue = packedStrokeColor;\n    }\n\n    /**\n     * Gets the current value of the color of the stroke style as a 32-bit int\n     * @return {number} i.e. 0xFFFFFFFF\n     */\n    ,\n    get: function get() {\n      return this._strokeColor.packedValue;\n    }\n\n    /**\n     * Sets the stroke width\n     * @param  {number} strokeWidth\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"strokeWidth\",\n    set: function set(strokeWidth) {\n      validateStrokeWidth(strokeWidth);\n      this._strokeWidth = strokeWidth;\n      return this;\n    }\n\n    /**\n     * Gets the current stroke width\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._strokeWidth;\n    }\n\n    /**\n     * Sets how lines should be joined\n     * @param  {string} lineJoin One of \"miter\", \"round\", or \"bevel\"\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"lineJoin\",\n    set: function set(lineJoin) {\n      var enumVal = validateLineJoin(lineJoin);\n      this._lineJoin = enumVal;\n      return this;\n    }\n\n    /**\n     * Gets the current line join\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return lineJoinOpts[this._lineJoin];\n    }\n\n    /**\n     * Sets how lines should be capped\n     * @param  {string} lineCap One of \"butt\", \"square\", or \"round\"\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"lineCap\",\n    set: function set(lineCap) {\n      var enumVal = validateLineCap(lineCap);\n      this._lineCap = enumVal;\n      return this;\n    }\n\n    /**\n     * Gets the current line cap of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return lineCapOpts[this._lineJoin];\n    }\n\n    /**\n     * Sets the dash pattern of the style\n     * @param  {number[]} dashPattern A list of numbers that specifies distances to alternately\n     *                                draw a line and a gap (in screen units)\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"dashPattern\",\n    set: function set(dashPattern) {\n      validateDashPattern(dashPattern);\n      this._dashPattern = dashPattern.slice();\n      return this;\n    }\n\n    /**\n     * Gets the current dash pattern of the style\n     * @return {number[]}\n     */\n    ,\n    get: function get() {\n      return this._dashPattern.slice();\n    }\n\n    /**\n     * Sets the dash offset of the style\n     * @param  {number} dashOffset\n     * @return {StrokeStyle}\n     */\n\n  }, {\n    key: \"dashOffset\",\n    set: function set(dashOffset) {\n      validateDashOffset(dashOffset);\n      this._dashOffset = dashOffset;\n      return this;\n    }\n\n    /**\n     * Gets the current dash offset\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._dashOffset;\n    }\n  }], [{\n    key: \"copyStrokeStyle\",\n    value: function copyStrokeStyle(srcStyle, dstStyle) {\n      if (typeof srcStyle.packedStrokeColor !== \"undefined\") {\n        dstStyle.packedStrokeColor = srcStyle.packedStrokeColor;\n      } else {\n        if (typeof srcStyle.strokeColor !== \"undefined\") {\n          dstStyle.strokeColor = srcStyle.strokeColor;\n        }\n        if (typeof srcStyle.strokeOpacity !== \"undefined\") {\n          dstStyle.strokeOpacity = srcStyle.strokeOpacity;\n        }\n      }\n      if (typeof srcStyle.strokeWidth !== \"undefined\") {\n        dstStyle.strokeWidth = srcStyle.strokeWidth;\n      }\n      if (typeof srcStyle.lineJoin !== \"undefined\") {\n        dstStyle.lineJoin = srcStyle.lineJoin;\n      }\n      if (typeof srcStyle.lineCap !== \"undefined\") {\n        dstStyle.lineCap = srcStyle.lineCap;\n      }\n      if (typeof srcStyle.dashPattern !== \"undefined\") {\n        dstStyle.dashPattern = srcStyle.dashPattern;\n      }\n      if (typeof srcStyle.dashOffset !== \"undefined\") {\n        dstStyle.dashOffset = srcStyle.dashOffset;\n      }\n    }\n\n    /**\n     * Comparison operator between two StrokeStyle objects. This is primarily\n     * used for sorting to minimize context switching of a 2d renderer\n     * @param  {StrokeStyle} strokeStyleA\n     * @param  {StrokeStyle} strokeStyleB\n     * @return {number}            Returns < 0 if strokeStyleA < strokeStyleB, > 0 if strokeStyleA > strokeStyleB, or 0 if they are equal.\n     */\n\n  }, {\n    key: \"compareStrokeStyle\",\n    value: function compareStrokeStyle(strokeStyleA, strokeStyleB) {\n      var valA = strokeStyleA.isStrokeVisible();\n      var valB = strokeStyleB.isStrokeVisible();\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA.packedStrokeColor;\n      valB = strokeStyleB.packedStrokeColor;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA.strokeWidth;\n      valB = strokeStyleB.strokeWidth;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._lineJoin;\n      valB = strokeStyleB._lineJoin;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._lineCap;\n      valB = strokeStyleB._lineCap;\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      valA = strokeStyleA._dashPattern;\n      valB = strokeStyleB._dashPattern;\n      if (valA.length === valB.length && valA.length > 0) {\n        for (var i = 0; i < valA.length; i += 1) {\n          if (valA[i] !== valB[i]) {\n            return valA[i] - valB[i];\n          }\n        }\n        return strokeStyleA.dashOffset - strokeStyleB.dashOffset;\n      }\n      return valA.length - valB.length;\n    }\n\n    /**\n     * Returns a json object of a StrokeStyle object\n     * @param  {StrokeStyle} strokeStyleObj\n     * @return {{strokeColor: string,\n     *           strokeWidth: number,\n     *           lineJoin: string,\n     *           lineCap: string,\n     *           dashPattern: number[],\n     *           dashOffset: number\n     *          }}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(strokeStyleObj) {\n      return {\n        strokeColor: strokeStyleObj.strokeColor,\n        strokeWidth: strokeStyleObj.strokeWidth,\n        lineJoin: strokeStyleObj.lineJoin,\n        lineCap: strokeStyleObj.lineCap,\n        dashPattern: strokeStyleObj.dashPattern,\n        dashOffset: strokeStyleObj.dashOffset\n      };\n    }\n  }]);\n\n  return StrokeStyle;\n}();\n\n/**\n * Creates a new stroke style class that fires events whenever the style\n * is modified.\n * @param  {string} eventName Event type to fire when stroke style is modified\n * @return {function}         New class constructor function\n */\n\n\nexports.default = StrokeStyle;\nfunction createEventedStrokeStyleMixin(eventName) {\n  /**\n   * Evented stroke color class to handle color modification events\n   * @type {ColorRGBA}\n   */\n  var StrokeColorClass = (0, _colorRgba.createEventedColorRGBAClass)(eventName, \"strokeColor\");\n\n  /**\n   * Stroke style modification event\n   * @event EventedStrokeStyle#changed\n   * @type {object}\n   * @property {string} attr Name of the attribute modified\n   * @property {} prevVal Previous value of the attribute prior to modification\n   * @property {} currVal Value of the attribute post modification\n   */\n\n  /**\n   * @mixin New evented stroke style mixin. Will fire events whenever\n   *        the stroke is modified\n   */\n  return (0, _aggregation2.default)(null, StrokeStyle, function () {\n    function EventedStrokeStyle() {\n      _classCallCheck(this, EventedStrokeStyle);\n    }\n\n    _createClass(EventedStrokeStyle, [{\n      key: \"initializer\",\n\n      /**\n       * Initializer method to initialize an evented stroke style.\n       * @param  {StrokeStyleOptions} [opts]\n       * @protected\n       */\n      value: function initializer(opts) {\n        this._strokeColor = new StrokeColorClass(\"black\", this);\n        this._strokeWidth = 0;\n        this._lineJoin = JoinEnum.MITER;\n        this._lineCap = CapEnum.BUTT;\n        this._dashPattern = [];\n        this._dashOffset = 0;\n        this._initStrokeStyleFromOptions(opts);\n      }\n\n      /**\n       * Sets the stroke width\n       * @param  {number}\n       * @fires  EventedStrokeStyle#changed\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"strokeWidth\",\n      set: function set(strokeWidth) {\n        validateStrokeWidth(strokeWidth);\n        if (strokeWidth !== this._strokeWidth) {\n          var prev = this._strokeWidth;\n          this._strokeWidth = strokeWidth;\n          this.fire(eventName, {\n            attr: \"strokeWidth\",\n            prevVal: prev,\n            curral: this._strokeWidth\n          });\n        }\n\n        return this;\n      }\n\n      /**\n       * Gets the current stroke width\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._strokeWidth;\n      }\n\n      /**\n       * Sets the line join\n       * @param  {string} lineJoin\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"lineJoin\",\n      set: function set(lineJoin) {\n        var enumVal = validateLineJoin(lineJoin);\n\n        if (enumVal !== this._lineJoin) {\n          var prev = this._lineJoin;\n          this._lineJoin = enumVal;\n          this.fire(eventName, {\n            attr: \"lineJoin\",\n            prevVal: prev,\n            curral: this._lineJoin\n          });\n        }\n\n        return this;\n      }\n\n      /**\n       * Gets the current line join\n       * @return {string}\n       */\n      ,\n      get: function get() {\n        return lineJoinOpts[this._lineJoin];\n      }\n\n      /**\n       * Sets the line cap\n       * @param  {string} lineCap\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"lineCap\",\n      set: function set(lineCap) {\n        var enumVal = validateLineCap(lineCap);\n        if (enumVal !== this._lineCap) {\n          var prev = this._lineCap;\n          this._lineCap = enumVal;\n          this.fire(eventName, {\n            attr: \"lineCap\",\n            prevVal: prev,\n            curral: this._lineCap\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the line cap\n       * @return {string}\n       */\n      ,\n      get: function get() {\n        return lineCapOpts[this._lineCap];\n      }\n\n      /**\n       * Sets the dash pattern\n       * @param  {number[]} dashPattern\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"dashPattern\",\n      set: function set(dashPattern) {\n        validateDashPattern(dashPattern);\n        var diff = false;\n        if (dashPattern.length === this._dashPattern.length) {\n          for (var i = 0; i < dashPattern.length; i += 1) {\n            if (dashPattern[i] !== this._dashPattern[i]) {\n              diff = true;\n              break;\n            }\n          }\n        } else {\n          diff = true;\n        }\n\n        if (diff) {\n          var prev = this._dashPattern;\n          this._dashPattern = dashPattern.slice();\n          this.fire(eventName, {\n            attr: \"dashPattern\",\n            prevVal: prev,\n            curral: this._dashPattern.slice()\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current dash pattern\n       * @return {number[]}\n       */\n      ,\n      get: function get() {\n        return this._dashPattern.slice();\n      }\n\n      /**\n       * Sets the current dash offset\n       * @param  {number} dashOffset\n       * @fires {EventedStrokeStyle#changed}\n       * @return {EventedStrokeStyle}\n       */\n\n    }, {\n      key: \"dashOffset\",\n      set: function set(dashOffset) {\n        validateDashOffset(dashOffset);\n\n        if (dashOffset !== this._dashOffset) {\n          var prev = this._dashOffset;\n          this._dashOffset = dashOffset;\n\n          if (this._dashPattern.length) {\n            // only fire if dashing is activated\n            this.fire(eventName, {\n              attr: \"dashOffset\",\n              prevVal: prev,\n              curral: this._dashOffset\n            });\n          }\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current dash offset\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._dashOffset;\n      }\n    }]);\n\n    return EventedStrokeStyle;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9zdHJva2Utc3R5bGUuanM/MzNkZiJdLCJuYW1lcyI6WyJjcmVhdGVFdmVudGVkU3Ryb2tlU3R5bGVNaXhpbiIsInZhbGlkYXRlU3Ryb2tlV2lkdGgiLCJzdHJva2VXaWR0aCIsIkVycm9yIiwiSm9pbkVudW0iLCJNSVRFUiIsIkJFVkVMIiwiUk9VTkQiLCJsaW5lSm9pbk9wdHMiLCJ2YWxpZGF0ZUxpbmVKb2luIiwibGluZUpvaW4iLCJpZHgiLCJpbmRleE9mIiwidG9Mb3dlckNhc2UiLCJqb2luIiwiQ2FwRW51bSIsIkJVVFQiLCJTUVVBUkUiLCJsaW5lQ2FwT3B0cyIsInZhbGlkYXRlTGluZUNhcCIsImxpbmVDYXAiLCJ2YWxpZGF0ZURhc2hQYXR0ZXJuIiwiZGFzaFBhdHRlcm4iLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ2YWxpZGF0ZURhc2hPZmZzZXQiLCJkYXNoT2Zmc2V0IiwiU3Ryb2tlU3R5bGUiLCJvcHRzIiwiaW5pdGlhbGl6ZXIiLCJzdHJva2VDb2xvciIsInN0cm9rZU9wYWNpdHkiLCJsaW5lTWl0ZXIiLCJfc3Ryb2tlQ29sb3IiLCJfc3Ryb2tlV2lkdGgiLCJfbGluZUpvaW4iLCJfbGluZUNhcCIsIl9kYXNoUGF0dGVybiIsIl9kYXNoT2Zmc2V0IiwiX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zIiwib3BhY2l0eSIsImlzVHJhbnNwYXJlbnQiLCJjdHgiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJ2YWx1ZSIsInBhY2tlZFN0cm9rZUNvbG9yIiwicGFja2VkVmFsdWUiLCJlbnVtVmFsIiwic2xpY2UiLCJzcmNTdHlsZSIsImRzdFN0eWxlIiwic3Ryb2tlU3R5bGVBIiwic3Ryb2tlU3R5bGVCIiwidmFsQSIsImlzU3Ryb2tlVmlzaWJsZSIsInZhbEIiLCJpIiwic3Ryb2tlU3R5bGVPYmoiLCJldmVudE5hbWUiLCJTdHJva2VDb2xv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T087QUFDTEEsaUJBQU8sSUFBUDtBQUNEOztBQUVELFlBQUlBLElBQUosRUFBVTtBQUNSLGNBQU1MLE9BQU8sS0FBSzFCLFlBQWxCO0FBQ0EsZUFBS0EsWUFBTCxHQUFvQmhCLFlBQVk4QixLQUFaLEVBQXBCO0FBQ0EsZUFBS2EsSUFBTCxDQUFVSCxTQUFWLEVBQXFCO0FBQ25CSSxrQkFBTSxhQURhO0FBRW5CQyxxQkFBU0gsSUFGVTtBQUduQkksb0JBQVEsS0FBSzlCLFlBQUwsQ0FBa0JjLEtBQWxCO0FBSFcsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBdklLO0FBQUEsMEJBMklhO0FBQ2hCLGVBQU8sS0FBS2QsWUFBTCxDQUFrQmMsS0FBbEIsRUFBUDtBQUNEOztBQUVEOzs7Ozs7O0FBL0lLO0FBQUE7QUFBQSx3QkFxSlV6QixVQXJKVixFQXFKc0I7QUFDekJELDJCQUFtQkMsVUFBbkI7O0FBRUEsWUFBSUEsZUFBZSxLQUFLWSxXQUF4QixFQUFxQztBQUNuQyxjQUFNeUIsT0FBTyxLQUFLekIsV0FBbEI7QUFDQSxlQUFLQSxXQUFMLEdBQW1CWixVQUFuQjs7QUFFQSxjQUFJLEtBQUtXLFlBQUwsQ0FBa0JiLE1BQXRCLEVBQThCO0FBQzVCO0FBQ0EsaUJBQUt3QyxJQUFMLENBQVVILFNBQVYsRUFBcUI7QUFDbkJJLG9CQUFNLFlBRGE7QUFFbkJDLHVCQUFTSCxJQUZVO0FBR25CSSxzQkFBUSxLQUFLN0I7QUFITSxhQUFyQjtBQUtEO0FBQ0Y7QUFDRCxlQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXhLSztBQUFBLDBCQTRLWTtBQUNmLGVBQU8sS0FBS0EsV0FBWjtBQUNEO0FBOUtJOztBQUFBO0FBQUEsTUFBUDtBQWdMRCIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCBDb2xvclJHQkEsIHtjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3N9IGZyb20gXCIuL2NvbG9yLXJnYmFcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdHJva2VTdHlsZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3Ryb2tlQ29sb3IgPSBcImJsYWNrXCJdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0cm9rZVdpZHRoID0gMF1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGluZUpvaW4gPSBcIm1pdGVyXCJdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xpbmVDYXAgPSBcImJ1dHRcIl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyW119IFtkYXNoUGF0dGVybiA9IFtdXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtkYXNoT2Zmc2V0ID0gMF1cbiAqL1xuXG4vKipcbiAqIHZhbGlkYXRlcyBhIHBvc3NpYmxlIHN0cm9rZSB3aWR0aCB2YWx1ZVxuICogQHBhcmFtICB7bnVtYmVyfSBzdHJva2VXaWR0aFxuICogQHRocm93cyBJZiB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSB7XG4gIGlmICh0eXBlb2Ygc3Ryb2tlV2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJva2Ugd2lkdGggbXVzdCBiZSBhIG51bWJlclwiKVxuICB9XG59XG5cbi8qKlxuICogRW51bSBmb3IgbGluZSBqb2luIHZhbHVlc1xuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgSm9pbkVudW0gPSB7XG4gIE1JVEVSOiAwLFxuICBCRVZFTDogMSxcbiAgUk9VTkQ6IDJcbn1cblxuLyoqXG4gKiBsaW5lIGpvaW4gdmFsdWVzIGFzIHN0cmluZ3MsIHRoZSBlbnVtIHZhbHVlcyBtYXRjaCB0aGUgaW5kZXggaW4gdGhpcyBzdHJpbmdcbiAqIEB0eXBlIHtzdHJpbmdbXX1cbiAqL1xuY29uc3QgbGluZUpvaW5PcHRzID0gW1wibWl0ZXJcIiwgXCJiZXZlbFwiLCBcInJvdW5kXCJdXG5cbi8qKlxuICogdmFsaWRhdGVzIGEgbGluZSBqb2luIHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVKb2luIFNob3VsZCBiZSBvbmUgb2YgW1wibWl0ZXJcIiwgXCJiZXZlbFwiLCBcInJvdW5kXCJdXG4gKiBAdGhyb3dzIElmIHZhbGlkYXRpb24gZmFpbHNcbiAqIEByZXR1cm4ge0pvaW5FbnVtfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVMaW5lSm9pbihsaW5lSm9pbikge1xuICBsZXQgaWR4ID0gLTFcbiAgaWYgKHR5cGVvZiBsaW5lSm9pbiAhPT0gXCJzdHJpbmdcIiB8fCAoaWR4ID0gbGluZUpvaW5PcHRzLmluZGV4T2YobGluZUpvaW4udG9Mb3dlckNhc2UoKSkpIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgTGluZSBqb2luIG11c3QgYmUgYSBzdHJpbmcgYW5kIG11c3QgYmUgb25lIG9mIFske2xpbmVKb2luT3B0cy5qb2luKFwiLCBcIil9XWApXG4gIH1cbiAgcmV0dXJuIGlkeFxufVxuXG4vKipcbiAqIEVudW0gZm9yIGxpbmUgY2FwIHZhbHVlc1xuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ2FwRW51bSA9IHtcbiAgQlVUVDogMCxcbiAgU1FVQVJFOiAxLFxuICBST1VORDogMlxufVxuXG4vKipcbiAqIGxpbmUgY2FwIHZhbHVlcyBhcyBzdHJpbmdzLCB0aGUgQ2FwRW51bSB2YWx1ZXMgbWF0Y2ggdGhlIGluZGV4IGluIHRoaXMgc3RyaW5nXG4gKiBAdHlwZSB7c3RyaW5nW119XG4gKi9cbmNvbnN0IGxpbmVDYXBPcHRzID0gW1wiYnV0dFwiLCBcInNxdWFyZVwiLCBcInJvdW5kXCJdXG5cbi8qKlxuICogdmFsaWRhdGVzIGEgbGluZSBjYXAgdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30gbGluZUNhcCBTaG91bGQgYmUgb25lIG9mIFwiYnV0dFwiLCBcInNxdWFyZVwiLCBcInJvdW5kXCJcbiAqIEB0aHJvd3MgSWYgdmFsaWRhdGlvbiBmYWlsc1xuICogQHJldHVybiB7Q2FwRW51bX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlTGluZUNhcChsaW5lQ2FwKSB7XG4gIGxldCBpZHggPSAtMVxuICBpZiAodHlwZW9mIGxpbmVDYXAgIT09IFwic3RyaW5nXCIgfHwgKGlkeCA9IGxpbmVDYXBPcHRzLmluZGV4T2YobGluZUNhcC50b0xvd2VyQ2FzZSgpKSkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBMaW5lIGNhcCBtdXN0IGJlIGEgc3RyaW5nIGFuZCBtdXN0IGJlIG9uZSBvZiBbJHtsaW5lQ2FwT3B0cy5qb2luKFwiLCBcIil9XWApXG4gIH1cbiAgcmV0dXJuIGlkeFxufVxuXG4vKipcbiAqIHZhbGlkYXRlcyBhIGRhc2ggcGF0dGVybiB2YWx1ZVxuICogQHBhcmFtICB7bnVtYmVyW119IGRhc2hQYXR0ZXJuXG4gKiBAdGhyb3dzIElmIHZhbGlkYXRpb24gZmFpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pIHtcbiAgaWYgKCFkYXNoUGF0dGVybiB8fCAhQXJyYXkuaXNBcnJheShkYXNoUGF0dGVybikgfHwgZGFzaFBhdHRlcm4ubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBkYXNoIHBhdHRlcm4gbXVzdCBiZSBhbiBhcnJheSB3aXRoIGFuIGV2ZW4gbnVtYmVyIG9mIG51bWJlcnMgKG9yIGFuIGVtcHR5IGFycmF5KVwiKVxuICB9XG59XG5cbi8qKlxuICogdmFsaWRhdGVzIGEgZGFzaCBvZmZzZXQgdmFsdWVcbiAqIEBwYXJhbSAge251bWJlcn0gZGFzaE9mZnNldFxuICogQHRocm93cyBJZiB2YWxpZGF0aW9uIGZhaWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZURhc2hPZmZzZXQoZGFzaE9mZnNldCkge1xuICBpZiAodHlwZW9mIGRhc2hPZmZzZXQgIT09IFwibnVtYmVyXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGFzaCBvZmZzZXQgbXVzdCBiZSBhIG51bWJlclwiKVxuICB9XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgc3Ryb2tlIHN0eWxlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHQuIENhbiBiZSB1c2VkIGFzIGEgbWl4aW4gb3IgYmFzZSBjbGFzc1xuICogQGNsYXNzXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3Ryb2tlU3R5bGUge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIGluaXRpYWxpemVzIHRoZSBzdHJva2Ugc3R5bGUgb2JqZWN0IGZyb20gYW4gb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7U3Ryb2tlU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0U3Ryb2tlU3R5bGVGcm9tT3B0aW9ucyhvcHRzKSB7XG4gICAgaWYgKG9wdHMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5zdHJva2VDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0cy5zdHJva2VDb2xvclxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzLnN0cm9rZU9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gb3B0cy5zdHJva2VPcGFjaXR5XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMuc3Ryb2tlV2lkdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5zdHJva2VXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGhcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5saW5lTWl0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5saW5lSm9pbiA9IG9wdHMubGluZU1pdGVyXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMubGluZUNhcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmxpbmVDYXAgPSBvcHRzLmxpbmVDYXBcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cy5kYXNoUGF0dGVybiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmRhc2hQYXR0ZXJuID0gb3B0cy5kYXNoUGF0dGVyblxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvcHRzLmRhc2hPZmZzZXQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5kYXNoT2Zmc2V0ID0gb3B0cy5kYXNoT2Zmc2V0XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIG1ldGhvZCB0byBpbml0aWFsaXplIGEgc3Ryb2tlIHN0eWxlLiBVc2VkIGZvciBib3RoIGluaXRpYWxpemluZ1xuICAgKiB2aWEgYmFzZS1jbGFzcyBhbmQgbWl4aW4gaGllcmFyY2h5LlxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZU9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSBuZXcgQ29sb3JSR0JBKFwiYmxhY2tcIilcbiAgICB0aGlzLl9zdHJva2VXaWR0aCA9IDBcbiAgICB0aGlzLl9saW5lSm9pbiA9IEpvaW5FbnVtLk1JVEVSXG4gICAgdGhpcy5fbGluZUNhcCA9IENhcEVudW0uQlVUVFxuICAgIHRoaXMuX2Rhc2hQYXR0ZXJuID0gW11cbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gMFxuICAgIHRoaXMuX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zKG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3Ryb2tlIGNvbG9yXG4gICAqIEBwYXJhbSAge3N0cmluZ30gc3Ryb2tlQ29sb3IgQ29sb3IgYXMgYSBzdHJpbmcsIFwicmdiKClcIiwgXCJyZ2JhKClcIiwgXCIjLi4uLi4uXCIsIG9yIGEgY29sb3Iga2V5d29yZCAoaS5lLiBcImJsYWNrXCIpXG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IHN0cm9rZUNvbG9yKHN0cm9rZUNvbG9yKSB7XG4gICAgdGhpcy5fc3Ryb2tlQ29sb3IudmFsdWUgPSBzdHJva2VDb2xvclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBzdHlsZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgc3Ryb2tlQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZUNvbG9yLnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlIHN0eWxlXG4gICAqIEBwYXJhbSAge251bWJlcn0gb3BhY2l0eSBbMCwxXVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBzdHJva2VPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9zdHJva2VDb2xvci5vcGFjaXR5ID0gb3BhY2l0eVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3BhY2l0eSBvZiB0aGUgc3Ryb2tlIHN0eWxlIFswLDFdXG4gICAqIEByZXR1cm4ge251bWJlcn0gT3BhY2l0eSBpbiB0aGUgcmFuZ2UgWzAsMV1cbiAgICovXG4gIGdldCBzdHJva2VPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5vcGFjaXR5XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3Ryb2tlIGNvbG9yIG9mIHRoZSBzdHlsZSBkZWZpbmVkIGFzIGEgMzItYml0IGludFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZFN0cm9rZUNvbG9yIENvbG9yIHZhbHVlIGFzIGEgMzItYml0IGludCAoaS5lLiAweEZGRkZGRkZGKVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBwYWNrZWRTdHJva2VDb2xvcihwYWNrZWRTdHJva2VDb2xvcikge1xuICAgIHRoaXMuX3N0cm9rZUNvbG9yLnBhY2tlZFZhbHVlID0gcGFja2VkU3Ryb2tlQ29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb2xvciBvZiB0aGUgc3Ryb2tlIHN0eWxlIGFzIGEgMzItYml0IGludFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGkuZS4gMHhGRkZGRkZGRlxuICAgKi9cbiAgZ2V0IHBhY2tlZFN0cm9rZUNvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5wYWNrZWRWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0cm9rZSB3aWR0aFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0cm9rZVdpZHRoXG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IHN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSB7XG4gICAgdmFsaWRhdGVTdHJva2VXaWR0aChzdHJva2VXaWR0aClcbiAgICB0aGlzLl9zdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0cm9rZSB3aWR0aFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc3Ryb2tlV2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cm9rZVdpZHRoXG4gIH1cblxuICAvKipcbiAgICogU2V0cyBob3cgbGluZXMgc2hvdWxkIGJlIGpvaW5lZFxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVKb2luIE9uZSBvZiBcIm1pdGVyXCIsIFwicm91bmRcIiwgb3IgXCJiZXZlbFwiXG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XG4gICAgY29uc3QgZW51bVZhbCA9IHZhbGlkYXRlTGluZUpvaW4obGluZUpvaW4pXG4gICAgdGhpcy5fbGluZUpvaW4gPSBlbnVtVmFsXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGxpbmUgam9pblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXQgbGluZUpvaW4oKSB7XG4gICAgcmV0dXJuIGxpbmVKb2luT3B0c1t0aGlzLl9saW5lSm9pbl1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGhvdyBsaW5lcyBzaG91bGQgYmUgY2FwcGVkXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbGluZUNhcCBPbmUgb2YgXCJidXR0XCIsIFwic3F1YXJlXCIsIG9yIFwicm91bmRcIlxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBsaW5lQ2FwKGxpbmVDYXApIHtcbiAgICBjb25zdCBlbnVtVmFsID0gdmFsaWRhdGVMaW5lQ2FwKGxpbmVDYXApXG4gICAgdGhpcy5fbGluZUNhcCA9IGVudW1WYWxcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgbGluZSBjYXAgb2YgdGhlIHN0eWxlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldCBsaW5lQ2FwKCkge1xuICAgIHJldHVybiBsaW5lQ2FwT3B0c1t0aGlzLl9saW5lSm9pbl1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkYXNoIHBhdHRlcm4gb2YgdGhlIHN0eWxlXG4gICAqIEBwYXJhbSAge251bWJlcltdfSBkYXNoUGF0dGVybiBBIGxpc3Qgb2YgbnVtYmVycyB0aGF0IHNwZWNpZmllcyBkaXN0YW5jZXMgdG8gYWx0ZXJuYXRlbHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXcgYSBsaW5lIGFuZCBhIGdhcCAoaW4gc2NyZWVuIHVuaXRzKVxuICAgKiBAcmV0dXJuIHtTdHJva2VTdHlsZX1cbiAgICovXG4gIHNldCBkYXNoUGF0dGVybihkYXNoUGF0dGVybikge1xuICAgIHZhbGlkYXRlRGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pXG4gICAgdGhpcy5fZGFzaFBhdHRlcm4gPSBkYXNoUGF0dGVybi5zbGljZSgpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGRhc2ggcGF0dGVybiBvZiB0aGUgc3R5bGVcbiAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAqL1xuICBnZXQgZGFzaFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Rhc2hQYXR0ZXJuLnNsaWNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBkYXNoIG9mZnNldCBvZiB0aGUgc3R5bGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkYXNoT2Zmc2V0XG4gICAqIEByZXR1cm4ge1N0cm9rZVN0eWxlfVxuICAgKi9cbiAgc2V0IGRhc2hPZmZzZXQoZGFzaE9mZnNldCkge1xuICAgIHZhbGlkYXRlRGFzaE9mZnNldChkYXNoT2Zmc2V0KVxuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGRhc2ggb2Zmc2V0XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBkYXNoT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXNoT2Zmc2V0XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdHJva2Ugc3R5bGUgaXMgdmlzaWJsZSwgaS5lLiBpdCBpcyBub3QgZnVsbHkgdHJhbnNwYXJlbnRcbiAgICogYW5kIGhhcyBhIHdpZHRoID4gMFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNTdHJva2VWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5vcGFjaXR5ID4gMCAmJiB0aGlzLl9zdHJva2VXaWR0aCA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgc3Ryb2tlIGlzIHBhcnRpYWxseSB0cmFuc3BhcmVudCwgaS5lLiBvcGFjaXR5IDwgMVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBpc1RyYW5zcGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvci5pc1RyYW5zcGFyZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHJva2Ugc3R5bGUgc3RhdGUgb2YgYSAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICBzZXRTdHJva2VDdHgoY3R4KSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5zdHJva2VDb2xvclxuICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLl9zdHJva2VXaWR0aFxuICAgIGN0eC5saW5lSm9pbiA9IHRoaXMuX2xpbmVKb2luXG4gICAgY3R4LmxpbmVDYXAgPSB0aGlzLl9saW5lQ2FwXG4gICAgY3R4LnNldExpbmVEYXNoKHRoaXMuX2Rhc2hQYXR0ZXJuKVxuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHByb3BlcnRpZXMgb2Ygb25lIHN0cm9rZSBzdHlsZSB0byBhbm90aGVyXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBzcmNTdHlsZSBTdHJva2VTdHlsZSBvYmplY3QgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBkc3RTdHlsZSBTdHJva2VTdHlsZSBvYmplY3QgdG8gY29weSB0b1xuICAgKi9cbiAgc3RhdGljIGNvcHlTdHJva2VTdHlsZShzcmNTdHlsZSwgZHN0U3R5bGUpIHtcbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnBhY2tlZFN0cm9rZUNvbG9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkc3RTdHlsZS5wYWNrZWRTdHJva2VDb2xvciA9IHNyY1N0eWxlLnBhY2tlZFN0cm9rZUNvbG9yXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuc3Ryb2tlQ29sb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZHN0U3R5bGUuc3Ryb2tlQ29sb3IgPSBzcmNTdHlsZS5zdHJva2VDb2xvclxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5zdHJva2VPcGFjaXR5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRzdFN0eWxlLnN0cm9rZU9wYWNpdHkgPSBzcmNTdHlsZS5zdHJva2VPcGFjaXR5XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuc3Ryb2tlV2lkdGggIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLnN0cm9rZVdpZHRoID0gc3JjU3R5bGUuc3Ryb2tlV2lkdGhcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5saW5lSm9pbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZHN0U3R5bGUubGluZUpvaW4gPSBzcmNTdHlsZS5saW5lSm9pblxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLmxpbmVDYXAgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLmxpbmVDYXAgPSBzcmNTdHlsZS5saW5lQ2FwXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuZGFzaFBhdHRlcm4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGRzdFN0eWxlLmRhc2hQYXR0ZXJuID0gc3JjU3R5bGUuZGFzaFBhdHRlcm5cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5kYXNoT2Zmc2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkc3RTdHlsZS5kYXNoT2Zmc2V0ID0gc3JjU3R5bGUuZGFzaE9mZnNldFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJpc29uIG9wZXJhdG9yIGJldHdlZW4gdHdvIFN0cm9rZVN0eWxlIG9iamVjdHMuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIHVzZWQgZm9yIHNvcnRpbmcgdG8gbWluaW1pemUgY29udGV4dCBzd2l0Y2hpbmcgb2YgYSAyZCByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gc3Ryb2tlU3R5bGVBXG4gICAqIEBwYXJhbSAge1N0cm9rZVN0eWxlfSBzdHJva2VTdHlsZUJcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgIFJldHVybnMgPCAwIGlmIHN0cm9rZVN0eWxlQSA8IHN0cm9rZVN0eWxlQiwgPiAwIGlmIHN0cm9rZVN0eWxlQSA+IHN0cm9rZVN0eWxlQiwgb3IgMCBpZiB0aGV5IGFyZSBlcXVhbC5cbiAgICovXG4gIHN0YXRpYyBjb21wYXJlU3Ryb2tlU3R5bGUoc3Ryb2tlU3R5bGVBLCBzdHJva2VTdHlsZUIpIHtcbiAgICBsZXQgdmFsQSA9IHN0cm9rZVN0eWxlQS5pc1N0cm9rZVZpc2libGUoKVxuICAgIGxldCB2YWxCID0gc3Ryb2tlU3R5bGVCLmlzU3Ryb2tlVmlzaWJsZSgpXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICB2YWxBID0gc3Ryb2tlU3R5bGVBLnBhY2tlZFN0cm9rZUNvbG9yXG4gICAgdmFsQiA9IHN0cm9rZVN0eWxlQi5wYWNrZWRTdHJva2VDb2xvclxuICAgIGlmICh2YWxBICE9PSB2YWxCKSB7XG4gICAgICByZXR1cm4gdmFsQSAtIHZhbEJcbiAgICB9XG4gICAgdmFsQSA9IHN0cm9rZVN0eWxlQS5zdHJva2VXaWR0aFxuICAgIHZhbEIgPSBzdHJva2VTdHlsZUIuc3Ryb2tlV2lkdGhcbiAgICBpZiAodmFsQSAhPT0gdmFsQikge1xuICAgICAgcmV0dXJuIHZhbEEgLSB2YWxCXG4gICAgfVxuICAgIHZhbEEgPSBzdHJva2VTdHlsZUEuX2xpbmVKb2luXG4gICAgdmFsQiA9IHN0cm9rZVN0eWxlQi5fbGluZUpvaW5cbiAgICBpZiAodmFsQSAhPT0gdmFsQikge1xuICAgICAgcmV0dXJuIHZhbEEgLSB2YWxCXG4gICAgfVxuICAgIHZhbEEgPSBzdHJva2VTdHlsZUEuX2xpbmVDYXBcbiAgICB2YWxCID0gc3Ryb2tlU3R5bGVCLl9saW5lQ2FwXG4gICAgaWYgKHZhbEEgIT09IHZhbEIpIHtcbiAgICAgIHJldHVybiB2YWxBIC0gdmFsQlxuICAgIH1cbiAgICB2YWxBID0gc3Ryb2tlU3R5bGVBLl9kYXNoUGF0dGVyblxuICAgIHZhbEIgPSBzdHJva2VTdHlsZUIuX2Rhc2hQYXR0ZXJuXG4gICAgaWYgKHZhbEEubGVuZ3RoID09PSB2YWxCLmxlbmd0aCAmJiB2YWxBLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsQS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAodmFsQVtpXSAhPT0gdmFsQltpXSkge1xuICAgICAgICAgIHJldHVybiB2YWxBW2ldIC0gdmFsQltpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc3Ryb2tlU3R5bGVBLmRhc2hPZmZzZXQgLSBzdHJva2VTdHlsZUIuZGFzaE9mZnNldFxuICAgIH1cbiAgICByZXR1cm4gdmFsQS5sZW5ndGggLSB2YWxCLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBqc29uIG9iamVjdCBvZiBhIFN0cm9rZVN0eWxlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZX0gc3Ryb2tlU3R5bGVPYmpcbiAgICogQHJldHVybiB7e3N0cm9rZUNvbG9yOiBzdHJpbmcsXG4gICAqICAgICAgICAgICBzdHJva2VXaWR0aDogbnVtYmVyLFxuICAgKiAgICAgICAgICAgbGluZUpvaW46IHN0cmluZyxcbiAgICogICAgICAgICAgIGxpbmVDYXA6IHN0cmluZyxcbiAgICogICAgICAgICAgIGRhc2hQYXR0ZXJuOiBudW1iZXJbXSxcbiAgICogICAgICAgICAgIGRhc2hPZmZzZXQ6IG51bWJlclxuICAgKiAgICAgICAgICB9fVxuICAgKi9cbiAgc3RhdGljIHRvSlNPTihzdHJva2VTdHlsZU9iaikge1xuICAgIHJldHVybiB7XG4gICAgICBzdHJva2VDb2xvcjogc3Ryb2tlU3R5bGVPYmouc3Ryb2tlQ29sb3IsXG4gICAgICBzdHJva2VXaWR0aDogc3Ryb2tlU3R5bGVPYmouc3Ryb2tlV2lkdGgsXG4gICAgICBsaW5lSm9pbjogc3Ryb2tlU3R5bGVPYmoubGluZUpvaW4sXG4gICAgICBsaW5lQ2FwOiBzdHJva2VTdHlsZU9iai5saW5lQ2FwLFxuICAgICAgZGFzaFBhdHRlcm46IHN0cm9rZVN0eWxlT2JqLmRhc2hQYXR0ZXJuLFxuICAgICAgZGFzaE9mZnNldDogc3Ryb2tlU3R5bGVPYmouZGFzaE9mZnNldFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc3Ryb2tlIHN0eWxlIGNsYXNzIHRoYXQgZmlyZXMgZXZlbnRzIHdoZW5ldmVyIHRoZSBzdHlsZVxuICogaXMgbW9kaWZpZWQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZSBFdmVudCB0eXBlIHRvIGZpcmUgd2hlbiBzdHJva2Ugc3R5bGUgaXMgbW9kaWZpZWRcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgIE5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZFN0cm9rZVN0eWxlTWl4aW4oZXZlbnROYW1lKSB7XG4gIC8qKlxuICAgKiBFdmVudGVkIHN0cm9rZSBjb2xvciBjbGFzcyB0byBoYW5kbGUgY29sb3IgbW9kaWZpY2F0aW9uIGV2ZW50c1xuICAgKiBAdHlwZSB7Q29sb3JSR0JBfVxuICAgKi9cbiAgY29uc3QgU3Ryb2tlQ29sb3JDbGFzcyA9IGNyZWF0ZUV2ZW50ZWRDb2xvclJHQkFDbGFzcyhldmVudE5hbWUsIFwic3Ryb2tlQ29sb3JcIilcblxuICAvKipcbiAgICogU3Ryb2tlIHN0eWxlIG1vZGlmaWNhdGlvbiBldmVudFxuICAgKiBAZXZlbnQgRXZlbnRlZFN0cm9rZVN0eWxlI2NoYW5nZWRcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIG1vZGlmaWVkXG4gICAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gICAqIEBwcm9wZXJ0eSB7fSBjdXJyVmFsIFZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcG9zdCBtb2RpZmljYXRpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIEBtaXhpbiBOZXcgZXZlbnRlZCBzdHJva2Ugc3R5bGUgbWl4aW4uIFdpbGwgZmlyZSBldmVudHMgd2hlbmV2ZXJcbiAgICogICAgICAgIHRoZSBzdHJva2UgaXMgbW9kaWZpZWRcbiAgICovXG4gIHJldHVybiBhZ2dyZWdhdGlvbihudWxsLCBTdHJva2VTdHlsZSwgY2xhc3MgRXZlbnRlZFN0cm9rZVN0eWxlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplciBtZXRob2QgdG8gaW5pdGlhbGl6ZSBhbiBldmVudGVkIHN0cm9rZSBzdHlsZS5cbiAgICAgKiBAcGFyYW0gIHtTdHJva2VTdHlsZU9wdGlvbnN9IFtvcHRzXVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgICB0aGlzLl9zdHJva2VDb2xvciA9IG5ldyBTdHJva2VDb2xvckNsYXNzKFwiYmxhY2tcIiwgdGhpcylcbiAgICAgIHRoaXMuX3N0cm9rZVdpZHRoID0gMFxuICAgICAgdGhpcy5fbGluZUpvaW4gPSBKb2luRW51bS5NSVRFUlxuICAgICAgdGhpcy5fbGluZUNhcCA9IENhcEVudW0uQlVUVFxuICAgICAgdGhpcy5fZGFzaFBhdHRlcm4gPSBbXVxuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDBcbiAgICAgIHRoaXMuX2luaXRTdHJva2VTdHlsZUZyb21PcHRpb25zKG9wdHMpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtICB7bnVtYmVyfVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZFN0cm9rZVN0eWxlI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IHN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKSB7XG4gICAgICB2YWxpZGF0ZVN0cm9rZVdpZHRoKHN0cm9rZVdpZHRoKVxuICAgICAgaWYgKHN0cm9rZVdpZHRoICE9PSB0aGlzLl9zdHJva2VXaWR0aCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fc3Ryb2tlV2lkdGhcbiAgICAgICAgdGhpcy5fc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aFxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJzdHJva2VXaWR0aFwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9zdHJva2VXaWR0aFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc3Ryb2tlIHdpZHRoXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdHJva2VXaWR0aCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJva2VXaWR0aFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxpbmUgam9pblxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGluZUpvaW5cbiAgICAgKiBAZmlyZXMge0V2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkfVxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRTdHJva2VTdHlsZX1cbiAgICAgKi9cbiAgICBzZXQgbGluZUpvaW4obGluZUpvaW4pIHtcbiAgICAgIGNvbnN0IGVudW1WYWwgPSB2YWxpZGF0ZUxpbmVKb2luKGxpbmVKb2luKVxuXG4gICAgICBpZiAoZW51bVZhbCAhPT0gdGhpcy5fbGluZUpvaW4pIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2xpbmVKb2luXG4gICAgICAgIHRoaXMuX2xpbmVKb2luID0gZW51bVZhbFxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJsaW5lSm9pblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9saW5lSm9pblxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGluZSBqb2luXG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBsaW5lSm9pbigpIHtcbiAgICAgIHJldHVybiBsaW5lSm9pbk9wdHNbdGhpcy5fbGluZUpvaW5dXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbGluZSBjYXBcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxpbmVDYXBcbiAgICAgKiBAZmlyZXMge0V2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkfVxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRTdHJva2VTdHlsZX1cbiAgICAgKi9cbiAgICBzZXQgbGluZUNhcChsaW5lQ2FwKSB7XG4gICAgICBjb25zdCBlbnVtVmFsID0gdmFsaWRhdGVMaW5lQ2FwKGxpbmVDYXApXG4gICAgICBpZiAoZW51bVZhbCAhPT0gdGhpcy5fbGluZUNhcCkge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fbGluZUNhcFxuICAgICAgICB0aGlzLl9saW5lQ2FwID0gZW51bVZhbFxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJsaW5lQ2FwXCIsXG4gICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICBjdXJyYWw6IHRoaXMuX2xpbmVDYXBcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbGluZSBjYXBcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGxpbmVDYXAoKSB7XG4gICAgICByZXR1cm4gbGluZUNhcE9wdHNbdGhpcy5fbGluZUNhcF1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkYXNoIHBhdHRlcm5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJbXX0gZGFzaFBhdHRlcm5cbiAgICAgKiBAZmlyZXMge0V2ZW50ZWRTdHJva2VTdHlsZSNjaGFuZ2VkfVxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRTdHJva2VTdHlsZX1cbiAgICAgKi9cbiAgICBzZXQgZGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pIHtcbiAgICAgIHZhbGlkYXRlRGFzaFBhdHRlcm4oZGFzaFBhdHRlcm4pXG4gICAgICBsZXQgZGlmZiA9IGZhbHNlXG4gICAgICBpZiAoZGFzaFBhdHRlcm4ubGVuZ3RoID09PSB0aGlzLl9kYXNoUGF0dGVybi5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXNoUGF0dGVybi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChkYXNoUGF0dGVybltpXSAhPT0gdGhpcy5fZGFzaFBhdHRlcm5baV0pIHtcbiAgICAgICAgICAgIGRpZmYgPSB0cnVlXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZiA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2Rhc2hQYXR0ZXJuXG4gICAgICAgIHRoaXMuX2Rhc2hQYXR0ZXJuID0gZGFzaFBhdHRlcm4uc2xpY2UoKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJkYXNoUGF0dGVyblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9kYXNoUGF0dGVybi5zbGljZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgZGFzaCBwYXR0ZXJuXG4gICAgICogQHJldHVybiB7bnVtYmVyW119XG4gICAgICovXG4gICAgZ2V0IGRhc2hQYXR0ZXJuKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rhc2hQYXR0ZXJuLnNsaWNlKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGRhc2ggb2Zmc2V0XG4gICAgICogQHBhcmFtICB7bnVtYmVyfSBkYXNoT2Zmc2V0XG4gICAgICogQGZpcmVzIHtFdmVudGVkU3Ryb2tlU3R5bGUjY2hhbmdlZH1cbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkU3Ryb2tlU3R5bGV9XG4gICAgICovXG4gICAgc2V0IGRhc2hPZmZzZXQoZGFzaE9mZnNldCkge1xuICAgICAgdmFsaWRhdGVEYXNoT2Zmc2V0KGRhc2hPZmZzZXQpXG5cbiAgICAgIGlmIChkYXNoT2Zmc2V0ICE9PSB0aGlzLl9kYXNoT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9kYXNoT2Zmc2V0XG4gICAgICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0XG5cbiAgICAgICAgaWYgKHRoaXMuX2Rhc2hQYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIG9ubHkgZmlyZSBpZiBkYXNoaW5nIGlzIGFjdGl2YXRlZFxuICAgICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICAgIGF0dHI6IFwiZGFzaE9mZnNldFwiLFxuICAgICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICAgIGN1cnJhbDogdGhpcy5fZGFzaE9mZnNldFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBkYXNoIG9mZnNldFxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZGFzaE9mZnNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kYXNoT2Zmc2V0XG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3R5bGUvc3Ryb2tlLXN0eWxlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _glMatrix = __webpack_require__(1);\n\n/**\n * Returns the Z coordinate of a 2D crossproduct\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    z coord of the 2D crossproduct\n */\n_glMatrix.vec2.cross2d = function (v1, v2) {\n  return v1[0] * v2[1] - v1[1] * v2[0];\n};\n\n/**\n * Calculates the angle between two vectors when directionality\n * is unnecessary (only returns an angle between 0 and PI, inclusive)\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    The angle between two vectors in radians [0, PI]\n */\n_glMatrix.vec2.angleFast = function (v1, v2) {\n  return Math.acos(_glMatrix.vec2.dot(v1, v2));\n};\n\n/**\n * Returns the true angle between two vectors\n * @param  {Vec2d} v1\n * @param  {Vec2d} v2\n * @return {Number}    The angle between two vectors in radians [-PI, PI]\n */\n_glMatrix.vec2.angle = function (v1, v2) {\n  var c = _glMatrix.vec2.dot(v1, v2);\n  var s = _glMatrix.vec2.cross2d(v1, v2);\n  var angle = Math.atan2(s, c);\n  return angle;\n};\n\n/**\n * Returns the angle of a vector from the positive X direction\n * in a cartesian coordinate system\n * @param  {Vec2d} v1\n * @return {Number}    The angle in radians [-PI, PI]\n */\n_glMatrix.vec2.anglePosX = function (v) {\n  var angle = Math.atan2(v[1], v[0]);\n  if (angle < 0) {\n    angle *= -1;\n  }\n  return angle;\n};\n\nexports.default = _glMatrix.vec2;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jb3JlL3ZlYzJkLmpzPzhkZDMiXSwibmFtZXMiOlsiY3Jvc3MyZCIsInYxIiwidjIiLCJhbmdsZUZhc3QiLCJNYXRoIiwiYWNvcyIsImRvdCIsImFuZ2xlIiwiYyIsInMiLCJhdGFuMiIsImFuZ2xlUG9zWCIsInYiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQTs7QUFFQTs7Ozs7O0FBTUEsZUFBTUEsT0FBTixHQUFnQixVQUFDQyxFQUFELEVBQUtDLEVBQUwsRUFBWTtBQUMxQixTQUFPRCxHQUFHLENBQUgsSUFBUUMsR0FBRyxDQUFILENBQVIsR0FBZ0JELEdBQUcsQ0FBSCxJQUFRQyxHQUFHLENBQUgsQ0FBL0I7QUFDRCxDQUZEOztBQUlBOzs7Ozs7O0FBT0EsZUFBTUMsU0FBTixHQUFrQixVQUFDRixFQUFELEVBQUtDLEVBQUw7QUFBQSxTQUFZRSxLQUFLQyxJQUFMLENBQVUsZUFBTUMsR0FBTixDQUFVTCxFQUFWLEVBQWNDLEVBQWQsQ0FBVixDQUFaO0FBQUEsQ0FBbEI7O0FBRUE7Ozs7OztBQU1BLGVBQU1LLEtBQU4sR0FBYyxVQUFDTixFQUFELEVBQUtDLEVBQUwsRUFBWTtBQUN4QixNQUFNTSxJQUFJLGVBQU1GLEdBQU4sQ0FBVUwsRUFBVixFQUFjQyxFQUFkLENBQVY7QUFDQSxNQUFNTyxJQUFJLGVBQU1ULE9BQU4sQ0FBY0MsRUFBZCxFQUFrQkMsRUFBbEIsQ0FBVjtBQUNBLE1BQUlLLFFBQVFILEtBQUtNLEtBQUwsQ0FBV0QsQ0FBWCxFQUFjRCxDQUFkLENBQVo7QUFDQSxTQUFPRCxLQUFQO0FBQ0QsQ0FMRDs7QUFPQTs7Ozs7O0FBTUEsZUFBTUksU0FBTixHQUFrQixhQUFLO0FBQ3JCLE1BQUlKLFFBQVFILEtBQUtNLEtBQUwsQ0FBV0UsRUFBRSxDQUFGLENBQVgsRUFBaUJBLEVBQUUsQ0FBRixDQUFqQixDQUFaO0FBQ0EsTUFBSUwsUUFBUSxDQUFaLEVBQWU7QUFDYkEsYUFBUyxDQUFDLENBQVY7QUFDRDtBQUNELFNBQU9BLEtBQVA7QUFDRCxDQU5EIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IHt2ZWMyIGFzIFZlYzJkfSBmcm9tIFwiZ2wtbWF0cml4XCJcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBaIGNvb3JkaW5hdGUgb2YgYSAyRCBjcm9zc3Byb2R1Y3RcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MVxuICogQHBhcmFtICB7VmVjMmR9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIHogY29vcmQgb2YgdGhlIDJEIGNyb3NzcHJvZHVjdFxuICovXG5WZWMyZC5jcm9zczJkID0gKHYxLCB2MikgPT4ge1xuICByZXR1cm4gdjFbMF0gKiB2MlsxXSAtIHYxWzFdICogdjJbMF1cbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIHdoZW4gZGlyZWN0aW9uYWxpdHlcbiAqIGlzIHVubmVjZXNzYXJ5IChvbmx5IHJldHVybnMgYW4gYW5nbGUgYmV0d2VlbiAwIGFuZCBQSSwgaW5jbHVzaXZlKVxuICogQHBhcmFtICB7VmVjMmR9IHYxXG4gKiBAcGFyYW0gIHtWZWMyZH0gdjJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgVGhlIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnMgaW4gcmFkaWFucyBbMCwgUEldXG4gKi9cblZlYzJkLmFuZ2xlRmFzdCA9ICh2MSwgdjIpID0+IE1hdGguYWNvcyhWZWMyZC5kb3QodjEsIHYyKSlcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0cnVlIGFuZ2xlIGJldHdlZW4gdHdvIHZlY3RvcnNcbiAqIEBwYXJhbSAge1ZlYzJkfSB2MVxuICogQHBhcmFtICB7VmVjMmR9IHYyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzIGluIHJhZGlhbnMgWy1QSSwgUEldXG4gKi9cblZlYzJkLmFuZ2xlID0gKHYxLCB2MikgPT4ge1xuICBjb25zdCBjID0gVmVjMmQuZG90KHYxLCB2MilcbiAgY29uc3QgcyA9IFZlYzJkLmNyb3NzMmQodjEsIHYyKVxuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHMsIGMpXG4gIHJldHVybiBhbmdsZVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIGEgdmVjdG9yIGZyb20gdGhlIHBvc2l0aXZlIFggZGlyZWN0aW9uXG4gKiBpbiBhIGNhcnRlc2lhbiBjb29yZGluYXRlIHN5c3RlbVxuICogQHBhcmFtICB7VmVjMmR9IHYxXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgIFRoZSBhbmdsZSBpbiByYWRpYW5zIFstUEksIFBJXVxuICovXG5WZWMyZC5hbmdsZVBvc1ggPSB2ID0+IHtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih2WzFdLCB2WzBdKVxuICBpZiAoYW5nbGUgPCAwKSB7XG4gICAgYW5nbGUgKj0gLTFcbiAgfVxuICByZXR1cm4gYW5nbGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVjMmRcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NvcmUvdmVjMmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports) {

	eval("// Copyright 2001 softSurfer, 2012 Dan Sunday\n// This code may be freely used and modified for any purpose\n// providing that this copyright notice is included with it.\n// SoftSurfer makes no warranty for this code, and cannot be held\n// liable for any real or imagined damage resulting from its use.\n// Users of this code must verify correctness for their application.\n\n// from http://geomalgorithms.com/a12-_hull-3.html\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simpleHull_2D = simpleHull_2D;\nvar X = 0;\nvar Y = 1;\n\n/**\n * Test if a point is Left|On|Right of an infinite line.\n * @param  {Point2d}  P0 [description]\n * @param  {Point2d}  P1 [description]\n * @param  {Point2d}  P2 [description]\n * @return {Boolean}  Returns > 0 if P2 is left of the line thru P0 & P1,\n *                    Returns < 0 if P2 is to the right\n *                    Returns 0 if P2 is on the line\n */\nfunction isLeft(P0, P1, P2) {\n  return (P1[X] - P0[X]) * (P2[Y] - P0[Y]) - (P2[X] - P0[X]) * (P1[Y] - P0[Y]);\n}\n\n/**\n * Melkman's 2D simple polyline O(n) convex hull algorithm\n * @param  {Point2d[]} verts [description]\n * @return {number[]}       [description]\n */\nfunction simpleHull_2D(verts) {\n  // initialize a deque D[] from bottom to top so that the\n  // 1st three vertices of P[] are a ccw triangle\n  var H = [];\n  var n = verts.length;\n\n  if (n < 3) {\n    for (var i = 0; i < n; i += 1) {\n      H[i] = i;\n    }\n    return H;\n  }\n\n  var D = new Array(2 * n + 1);\n  D.fill(-1);\n  var bot = n - 2;\n  var top = bot + 3; // initial bottom and top deque indices\n\n  D[bot] = D[top] = 2; // 3rd vertex is at both bot and top\n  if (isLeft(verts[0], verts[1], verts[2]) > 0) {\n    D[bot + 1] = 0;\n    D[bot + 2] = 1; // ccw vertices are: 2,0,1,2\n  } else {\n    D[bot + 1] = 1;\n    D[bot + 2] = 0; // ccw vertices are: 2,1,0,2\n  }\n\n  // compute the hull on the deque D[]\n  for (var _i = 3; _i < n; _i += 1) {\n    // process the rest of vertices\n    // test if next vertex is outside the deque hull\n    if (isLeft(verts[D[bot]], verts[D[bot + 1]], verts[_i]) <= 0 || isLeft(verts[D[top - 1]], verts[D[top]], verts[_i]) <= 0) {\n\n      // incrementally add an exterior vertex to the deque hull\n      // get the rightmost tangent at the deque bot\n      while (D[bot] >= 0 && D[bot + 1] >= 0 && isLeft(verts[D[bot]], verts[D[bot + 1]], verts[_i]) <= 0) {\n        bot += 1; // remove bot of deque\n      }\n      bot -= 1;\n      D[bot] = _i; // insert verts[i] at bot of deque\n\n      // get the leftmost tangent at the deque top\n      while (D[top] >= 0 && D[top + 1] >= 0 && isLeft(verts[D[top - 1]], verts[D[top]], verts[_i]) <= 0) {\n        top -= 1; // pop top of deque\n      }\n      top += 1;\n      D[top] = _i; // push verts[i] onto top of deque\n    }\n  }\n\n  // transcribe deque D[] to the output hull array H[]\n  var h = 0;\n  for (h = 0; h <= top - bot - 1; h += 1) {\n    H[h] = D[bot + h];\n  }\n\n  if (D[bot + h] !== H[0]) {\n    H[h] = D[bot + h];\n  }\n\n  return H;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tYXRoL2NvbnZleC1odWxsLmpzPzBkYTkiXSwibmFtZXMiOlsic2ltcGxlSHVsbF8yRCIsIlgiLCJZIiwiaXNMZWZ0IiwiUDAiLCJQMSIsIlAyIiwidmVydHMiLCJIIiwibiIsImxlbmd0aCIsImkiLCJEIiwiQXJyYXkiLCJmaWxsIiwiYm90IiwidG9wIiwiaCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7OztRQXdCZ0JBLGEsR0FBQUEsYTtBQXRCaEIsSUFBTUMsSUFBSSxDQUFWO0FBQ0EsSUFBTUMsSUFBSSxDQUFWOztBQUdBOzs7Ozs7Ozs7QUFTQSxTQUFTQyxNQUFULENBQWdCQyxFQUFoQixFQUFvQkMsRUFBcEIsRUFBd0JDLEVBQXhCLEVBQTRCO0FBQzFCLFNBQU8sQ0FBQ0QsR0FBR0osQ0FBSCxJQUFRRyxHQUFHSCxDQUFILENBQVQsS0FBbUJLLEdBQUdKLENBQUgsSUFBUUUsR0FBR0YsQ0FBSCxDQUEzQixJQUFvQyxDQUFDSSxHQUFHTCxDQUFILElBQVFHLEdBQUdILENBQUgsQ0FBVCxLQUFtQkksR0FBR0gsQ0FBSCxJQUFRRSxHQUFHRixDQUFILENBQTNCLENBQTNDO0FBQ0Q7O0FBRUQ7Ozs7O0FBS08sU0FBU0YsYUFBVCxDQUF1Qk8sS0FBdkIsRUFBOEI7QUFDbkM7QUFDQTtBQUNBLE1BQU1DLElBQUksRUFBVjtBQUNBLE1BQU1DLElBQUlGLE1BQU1HLE1BQWhCOztBQUVBLE1BQUlELElBQUksQ0FBUixFQUFXO0FBQ1QsU0FBSyxJQUFJRSxJQUFJLENBQWIsRUFBZ0JBLElBQUlGLENBQXBCLEVBQXVCRSxLQUFLLENBQTVCLEVBQStCO0FBQzdCSCxRQUFFRyxDQUFGLElBQU9BLENBQVA7QUFDRDtBQUNELFdBQU9ILENBQVA7QUFDRDs7QUFFRCxNQUFNSSxJQUFJLElBQUlDLEtBQUosQ0FBVSxJQUFJSixDQUFKLEdBQVEsQ0FBbEIsQ0FBVjtBQUNBRyxJQUFFRSxJQUFGLENBQU8sQ0FBQyxDQUFSO0FBQ0EsTUFBSUMsTUFBTU4sSUFBSSxDQUFkO0FBQ0EsTUFBSU8sTUFBTUQsTUFBTSxDQUFoQixDQWhCbUMsQ0FnQmpCOztBQUVsQkgsSUFBRUcsR0FBRixJQUFTSCxFQUFFSSxHQUFGLElBQVMsQ0FBbEIsQ0FsQm1DLENBa0JmO0FBQ3BCLE1BQUliLE9BQU9JLE1BQU0sQ0FBTixDQUFQLEVBQWlCQSxNQUFNLENBQU4sQ0FBakIsRUFBMkJBLE1BQU0sQ0FBTixDQUEzQixJQUF1QyxDQUEzQyxFQUE4QztBQUM1Q0ssTUFBRUcsTUFBTSxDQUFSLElBQWEsQ0FBYjtBQUNBSCxNQUFFRyxNQUFNLENBQVIsSUFBYSxDQUFiLENBRjRDLENBRTdCO0FBQ2hCLEdBSEQsTUFHTztBQUNMSCxNQUFFRyxNQUFNLENBQVIsSUFBYSxDQUFiO0FBQ0FILE1BQUVHLE1BQU0sQ0FBUixJQUFhLENBQWIsQ0FGSyxDQUVVO0FBQ2hCOztBQUVEO0FBQ0EsT0FBSyxJQUFJSixLQUFJLENBQWIsRUFBZ0JBLEtBQUlGLENBQXBCLEVBQXVCRSxNQUFLLENBQTVCLEVBQStCO0FBQUU7QUFDL0I7QUFDQSxRQUFLUixPQUFPSSxNQUFNSyxFQUFFRyxHQUFGLENBQU4sQ0FBUCxFQUFzQlIsTUFBTUssRUFBRUcsTUFBTSxDQUFSLENBQU4sQ0FBdEIsRUFBeUNSLE1BQU1JLEVBQU4sQ0FBekMsS0FBc0QsQ0FBdkQsSUFDRFIsT0FBT0ksTUFBTUssRUFBRUksTUFBTSxDQUFSLENBQU4sQ0FBUCxFQUEwQlQsTUFBTUssRUFBRUksR0FBRixDQUFOLENBQTFCLEVBQXlDVCxNQUFNSSxFQUFOLENBQXpDLEtBQXNELENBRHpELEVBQzZEOztBQUUzRDtBQUNBO0FBQ0EsYUFBT0MsRUFBRUcsR0FBRixLQUFVLENBQVYsSUFBZUgsRUFBRUcsTUFBTSxDQUFSLEtBQWMsQ0FBN0IsSUFBa0NaLE9BQU9JLE1BQU1LLEVBQUVHLEdBQUYsQ0FBTixDQUFQLEVBQXNCUixNQUFNSyxFQUFFRyxNQUFNLENBQVIsQ0FBTixDQUF0QixFQUF5Q1IsTUFBTUksRUFBTixDQUF6QyxLQUFzRCxDQUEvRixFQUFrRztBQUNoR0ksZUFBTyxDQUFQLENBRGdHLENBQ3ZGO0FBQ1Y7QUFDREEsYUFBTyxDQUFQO0FBQ0FILFFBQUVHLEdBQUYsSUFBU0osRUFBVCxDQVIyRCxDQVFoRDs7QUFFWDtBQUNBLGFBQU9DLEVBQUVJLEdBQUYsS0FBVSxDQUFWLElBQWVKLEVBQUVJLE1BQU0sQ0FBUixLQUFjLENBQTdCLElBQWtDYixPQUFPSSxNQUFNSyxFQUFFSSxNQUFNLENBQVIsQ0FBTixDQUFQLEVBQTBCVCxNQUFNSyxFQUFFSSxHQUFGLENBQU4sQ0FBMUIsRUFBeUNULE1BQU1JLEVBQU4sQ0FBekMsS0FBc0QsQ0FBL0YsRUFBa0c7QUFDaEdLLGVBQU8sQ0FBUCxDQURnRyxDQUN2RjtBQUNWO0FBQ0RBLGFBQU8sQ0FBUDtBQUNBSixRQUFFSSxHQUFGLElBQVNMLEVBQVQsQ0FmMkQsQ0FlaEQ7QUFDWjtBQUNGOztBQUVEO0FBQ0EsTUFBSU0sSUFBSSxDQUFSO0FBQ0EsT0FBS0EsSUFBSSxDQUFULEVBQVlBLEtBQU1ELE1BQU1ELEdBQU4sR0FBWSxDQUE5QixFQUFrQ0UsS0FBSyxDQUF2QyxFQUEwQztBQUN4Q1QsTUFBRVMsQ0FBRixJQUFPTCxFQUFFRyxNQUFNRSxDQUFSLENBQVA7QUFDRDs7QUFFRCxNQUFJTCxFQUFFRyxNQUFNRSxDQUFSLE1BQWVULEVBQUUsQ0FBRixDQUFuQixFQUF5QjtBQUN2QkEsTUFBRVMsQ0FBRixJQUFPTCxFQUFFRyxNQUFNRSxDQUFSLENBQVA7QUFDRDs7QUFFRCxTQUFPVCxDQUFQO0FBQ0QiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgMjAwMSBzb2Z0U3VyZmVyLCAyMDEyIERhbiBTdW5kYXlcbi8vIFRoaXMgY29kZSBtYXkgYmUgZnJlZWx5IHVzZWQgYW5kIG1vZGlmaWVkIGZvciBhbnkgcHVycG9zZVxuLy8gcHJvdmlkaW5nIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGluY2x1ZGVkIHdpdGggaXQuXG4vLyBTb2Z0U3VyZmVyIG1ha2VzIG5vIHdhcnJhbnR5IGZvciB0aGlzIGNvZGUsIGFuZCBjYW5ub3QgYmUgaGVsZFxuLy8gbGlhYmxlIGZvciBhbnkgcmVhbCBvciBpbWFnaW5lZCBkYW1hZ2UgcmVzdWx0aW5nIGZyb20gaXRzIHVzZS5cbi8vIFVzZXJzIG9mIHRoaXMgY29kZSBtdXN0IHZlcmlmeSBjb3JyZWN0bmVzcyBmb3IgdGhlaXIgYXBwbGljYXRpb24uXG5cbi8vIGZyb20gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMTItX2h1bGwtMy5odG1sXG5cblwidXNlIHN0cmljdFwiXG5cbmNvbnN0IFggPSAwXG5jb25zdCBZID0gMVxuXG5cbi8qKlxuICogVGVzdCBpZiBhIHBvaW50IGlzIExlZnR8T258UmlnaHQgb2YgYW4gaW5maW5pdGUgbGluZS5cbiAqIEBwYXJhbSAge1BvaW50MmR9ICBQMCBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtQb2ludDJkfSAgUDEgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7UG9pbnQyZH0gIFAyIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICBSZXR1cm5zID4gMCBpZiBQMiBpcyBsZWZ0IG9mIHRoZSBsaW5lIHRocnUgUDAgJiBQMSxcbiAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIDwgMCBpZiBQMiBpcyB0byB0aGUgcmlnaHRcbiAqICAgICAgICAgICAgICAgICAgICBSZXR1cm5zIDAgaWYgUDIgaXMgb24gdGhlIGxpbmVcbiAqL1xuZnVuY3Rpb24gaXNMZWZ0KFAwLCBQMSwgUDIpIHtcbiAgcmV0dXJuIChQMVtYXSAtIFAwW1hdKSAqIChQMltZXSAtIFAwW1ldKSAtIChQMltYXSAtIFAwW1hdKSAqIChQMVtZXSAtIFAwW1ldKVxufVxuXG4vKipcbiAqIE1lbGttYW4ncyAyRCBzaW1wbGUgcG9seWxpbmUgTyhuKSBjb252ZXggaHVsbCBhbGdvcml0aG1cbiAqIEBwYXJhbSAge1BvaW50MmRbXX0gdmVydHMgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7bnVtYmVyW119ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZUh1bGxfMkQodmVydHMpIHtcbiAgLy8gaW5pdGlhbGl6ZSBhIGRlcXVlIERbXSBmcm9tIGJvdHRvbSB0byB0b3Agc28gdGhhdCB0aGVcbiAgLy8gMXN0IHRocmVlIHZlcnRpY2VzIG9mIFBbXSBhcmUgYSBjY3cgdHJpYW5nbGVcbiAgY29uc3QgSCA9IFtdXG4gIGNvbnN0IG4gPSB2ZXJ0cy5sZW5ndGhcblxuICBpZiAobiA8IDMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkgKz0gMSkge1xuICAgICAgSFtpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIEhcbiAgfVxuXG4gIGNvbnN0IEQgPSBuZXcgQXJyYXkoMiAqIG4gKyAxKVxuICBELmZpbGwoLTEpXG4gIGxldCBib3QgPSBuIC0gMlxuICBsZXQgdG9wID0gYm90ICsgMyAvLyBpbml0aWFsIGJvdHRvbSBhbmQgdG9wIGRlcXVlIGluZGljZXNcblxuICBEW2JvdF0gPSBEW3RvcF0gPSAyIC8vIDNyZCB2ZXJ0ZXggaXMgYXQgYm90aCBib3QgYW5kIHRvcFxuICBpZiAoaXNMZWZ0KHZlcnRzWzBdLCB2ZXJ0c1sxXSwgdmVydHNbMl0pID4gMCkge1xuICAgIERbYm90ICsgMV0gPSAwXG4gICAgRFtib3QgKyAyXSA9IDEgLy8gY2N3IHZlcnRpY2VzIGFyZTogMiwwLDEsMlxuICB9IGVsc2Uge1xuICAgIERbYm90ICsgMV0gPSAxXG4gICAgRFtib3QgKyAyXSA9IDAgLy8gY2N3IHZlcnRpY2VzIGFyZTogMiwxLDAsMlxuICB9XG5cbiAgLy8gY29tcHV0ZSB0aGUgaHVsbCBvbiB0aGUgZGVxdWUgRFtdXG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbjsgaSArPSAxKSB7IC8vIHByb2Nlc3MgdGhlIHJlc3Qgb2YgdmVydGljZXNcbiAgICAvLyB0ZXN0IGlmIG5leHQgdmVydGV4IGlzIG91dHNpZGUgdGhlIGRlcXVlIGh1bGxcbiAgICBpZiAoKGlzTGVmdCh2ZXJ0c1tEW2JvdF1dLCB2ZXJ0c1tEW2JvdCArIDFdXSwgdmVydHNbaV0pIDw9IDApIHx8XG4gICAgICAoaXNMZWZ0KHZlcnRzW0RbdG9wIC0gMV1dLCB2ZXJ0c1tEW3RvcF1dLCB2ZXJ0c1tpXSkgPD0gMCkpIHtcblxuICAgICAgLy8gaW5jcmVtZW50YWxseSBhZGQgYW4gZXh0ZXJpb3IgdmVydGV4IHRvIHRoZSBkZXF1ZSBodWxsXG4gICAgICAvLyBnZXQgdGhlIHJpZ2h0bW9zdCB0YW5nZW50IGF0IHRoZSBkZXF1ZSBib3RcbiAgICAgIHdoaWxlIChEW2JvdF0gPj0gMCAmJiBEW2JvdCArIDFdID49IDAgJiYgaXNMZWZ0KHZlcnRzW0RbYm90XV0sIHZlcnRzW0RbYm90ICsgMV1dLCB2ZXJ0c1tpXSkgPD0gMCkge1xuICAgICAgICBib3QgKz0gMSAvLyByZW1vdmUgYm90IG9mIGRlcXVlXG4gICAgICB9XG4gICAgICBib3QgLT0gMVxuICAgICAgRFtib3RdID0gaSAvLyBpbnNlcnQgdmVydHNbaV0gYXQgYm90IG9mIGRlcXVlXG5cbiAgICAgIC8vIGdldCB0aGUgbGVmdG1vc3QgdGFuZ2VudCBhdCB0aGUgZGVxdWUgdG9wXG4gICAgICB3aGlsZSAoRFt0b3BdID49IDAgJiYgRFt0b3AgKyAxXSA+PSAwICYmIGlzTGVmdCh2ZXJ0c1tEW3RvcCAtIDFdXSwgdmVydHNbRFt0b3BdXSwgdmVydHNbaV0pIDw9IDApIHtcbiAgICAgICAgdG9wIC09IDEgLy8gcG9wIHRvcCBvZiBkZXF1ZVxuICAgICAgfVxuICAgICAgdG9wICs9IDFcbiAgICAgIERbdG9wXSA9IGkgLy8gcHVzaCB2ZXJ0c1tpXSBvbnRvIHRvcCBvZiBkZXF1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIHRyYW5zY3JpYmUgZGVxdWUgRFtdIHRvIHRoZSBvdXRwdXQgaHVsbCBhcnJheSBIW11cbiAgbGV0IGggPSAwXG4gIGZvciAoaCA9IDA7IGggPD0gKHRvcCAtIGJvdCAtIDEpOyBoICs9IDEpIHtcbiAgICBIW2hdID0gRFtib3QgKyBoXVxuICB9XG5cbiAgaWYgKERbYm90ICsgaF0gIT09IEhbMF0pIHtcbiAgICBIW2hdID0gRFtib3QgKyBoXVxuICB9XG5cbiAgcmV0dXJuIEhcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL21hdGgvY29udmV4LWh1bGwuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _convexHull = __webpack_require__(12);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar identityMatrix = _glMatrix.mat2d.create();\n\n/**\n * Expands an axis-aligned bounding box to encapsulate a 2d vertex\n * defined in an array of vertices, and updates a struct used to\n * store the indices of the vertices that define the final bounds\n * of the vertices\n * @param  {AABox2d} box          Bounds to expand\n * @param  {Point2d} pt           2d vertex to encapsulate\n * @param  {number} ptIdx         Index of the vertex in its list of vertices\n * @param  {number[]} extentIndices Struct to store the indices of the bounding vertices\n * @private\n */\nfunction aaboxEncapsulatePt(box, pt, ptIdx, extentIndices) {\n  if (AABox2d.isEmpty(box)) {\n    box[0] = pt[0];\n    box[2] = pt[0];\n    extentIndices[0] = extentIndices[2] = ptIdx;\n    box[1] = pt[1];\n    box[3] = pt[1];\n    extentIndices[1] = extentIndices[3] = ptIdx;\n  } else {\n    if (pt[0] < box[0]) {\n      box[0] = pt[0];\n      extentIndices[0] = ptIdx;\n    } else if (pt[0] > box[2]) {\n      box[2] = pt[0];\n      extentIndices[2] = ptIdx;\n    }\n\n    if (pt[1] < box[1]) {\n      box[1] = pt[1];\n      extentIndices[1] = ptIdx;\n    } else if (pt[1] > box[3]) {\n      box[3] = pt[1];\n      extentIndices[3] = ptIdx;\n    }\n  }\n}\n\n/**\n * Function called sequentially to calculate the centroid of a polygon\n * @param  {Point2d} centroidPt Current centroid point\n * @param  {Point2d} pt1        Point describing one end of an edge of a polygon\n * @param  {Point2d} pt2        Point describing other end of an edge of a polygon\n * @private\n */\nfunction buildCentroid(centroidPt, pt1, pt2) {\n  var a = pt1[0] * pt2[1] - pt2[0] * pt1[1];\n  centroidPt[0] += (pt1[0] + pt2[0]) * a;\n  centroidPt[1] += (pt1[1] + pt2[1]) * a;\n  return a;\n}\n\n/**\n * Utility function used to check whether an argument is an array\n * of an arraybuffer\n * @param  {}  obj\n * @return {Boolean}     Returns true if object is array-like\n */\nfunction isArray(obj) {\n  return Array.isArray(obj) || ArrayBuffer && ArrayBuffer.isView(obj);\n}\n\n/**\n * @typedef {object} PolyLineOptions\n * @property {number[]|Point2d[]} [verts=[]] Initial vertices of the polyline\n */\n\n/**\n * @class Class defining a poly line\n * @extends {BaseShape}\n */\n\nvar PolyLine = function (_BaseShape) {\n  _inherits(PolyLine, _BaseShape);\n\n  /**\n   * Creates a new poly line shape\n   * @param  {PolyLineOptions} [opts] [description]\n   * @return {PolyLine}\n   */\n  function PolyLine(opts) {\n    _classCallCheck(this, PolyLine);\n\n    var verts = opts.verts || [];\n\n    var _this = _possibleConstructorReturn(this, (PolyLine.__proto__ || Object.getPrototypeOf(PolyLine)).call(this, opts));\n\n    if (!isArray(verts) || verts.length === 0 || isArray(verts[0]) && verts.length < 1 || !isArray(verts[0]) && (verts.length < 2 || verts.length % 2 !== 0)) {\n      throw new Error(\"PolyLine shapes must be initialized with an array of 2d points and contain at least 1 points\");\n    }\n\n    // going to build the aabox and store the indices for each vertex\n    // that defines the bounds\n    _this._extentIndices = [-1, -1, -1, -1];\n    _this._localaabox = AABox2d.create();\n    _this._verts = [];\n    _this._centroid = [0, 0];\n    AABox2d.initEmpty(_this._aabox);\n    var signedArea = 0;\n    var i = 0;\n    if (isArray(verts[0])) {\n      for (i = 0; i < verts.length - 1; i += 1) {\n        _this._verts.push(Point2d.clone(verts[i]));\n        aaboxEncapsulatePt(_this._aabox, verts[i], i, _this._extentIndices);\n        signedArea += buildCentroid(_this._centroid, verts[i], verts[i + 1]);\n      }\n      _this._verts.push(Point2d.clone(verts[i]));\n      aaboxEncapsulatePt(_this._aabox, verts[i], i, _this._extentIndices);\n      signedArea += buildCentroid(_this._centroid, verts[i], verts[0]);\n    } else {\n      _this._verts.push(Point2d.create(verts[0], verts[1]));\n      aaboxEncapsulatePt(_this._aabox, _this._verts[0], 0, _this._extentIndices);\n      var idx = 1;\n      for (i = 2; i < verts.length - 2; i += 2, idx += 1) {\n        _this._verts.push(Point2d.create(verts[i], verts[i + 1]));\n        aaboxEncapsulatePt(_this._aabox, _this._verts[idx], idx, _this._extentIndices);\n        signedArea += buildCentroid(_this._centroid, _this._verts[idx - 1], _this._verts[idx]);\n      }\n      _this._verts.push(Point2d.create(verts[i], verts[i + 1]));\n      aaboxEncapsulatePt(_this._aabox, _this._verts[idx], idx, _this._extentIndices);\n      signedArea += buildCentroid(_this._centroid, _this._verts[idx], _this._verts[0]);\n    }\n    signedArea *= 0.5;\n    _this._centroid[0] /= 6.0 * signedArea;\n    _this._centroid[1] /= 6.0 * signedArea;\n\n    // extract the center of the aabox. We are going to use this as the\n    // shape's pivot, so all rotation/scale transformations will be sourced\n    // at this location\n    var pivot = Point2d.create();\n    AABox2d.getCenter(pivot, _this._aabox);\n    _this.pivot = pivot;\n\n    // now build the convex hull of the vertices.\n    // When rebuilding the axis aligned box (a transform is applied for example),\n    // there's no need to traverse all the points. All we need to do is traverse\n    // the points that define the convex hull to rebuild the bounds\n    if (_this._verts.length < 3) {\n      _this._convexHull = _this._verts.map(function (val, idx) {\n        return idx;\n      });\n    } else {\n      _this._convexHull = (0, _convexHull.simpleHull_2D)(_this._verts);\n    }\n    return _this;\n  }\n\n  /**\n   * Get the untransformed width/height of the polyline. This is essentially\n   * the width/height of the poly's bounds\n   * @return {Vec2d} Width/height of the bounds of the polyline\n   */\n\n\n  _createClass(PolyLine, [{\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return [this.width, this.height];\n    }\n\n    /**\n     * Get the untransformed width of the polyline. This is the width of the\n     * axis-aligned bounds of the poly\n     * @return {number} Width of the poly in world-space units\n     */\n\n  }, {\n    key: \"_collapseVerts\",\n\n\n    /**\n     * Utility function that collapses all the verts, meaning the verts\n     * are flattened to their position with local-space transforms applied\n     * and then the local transforms are cleared. This is done whenever\n     * the vertices of the polygon are modified as it can be a little tricky\n     * to re-adjust the pivot/transforms of the vert when new verts are added,\n     * deleted, etc.\n     * @return {boolean} Returns true if the points were indeed flattened\n     *                   The points wouldn't be flattened if there are no\n     *                   transforms to apply, for example\n     * @private\n     */\n    value: function _collapseVerts() {\n      var _this2 = this;\n\n      Point2d.set(this._pivot, 0, 0);\n\n      // TODO(croot): what if this poly is\n      // parented to another transform?\n\n      var xform = this.localXform;\n      if (_glMatrix.mat2d.equals(xform, identityMatrix)) {\n        // if there are no transforms to apply,\n        // do nothing - fast out\n        return false;\n      }\n\n      AABox2d.initEmpty(this._aabox);\n\n      // flatten all the points to their current world-space position\n      // with transforms applied\n      for (var i = 0; i < this._verts.length; i += 1) {\n        Point2d.transformMat2d(this._verts[i], this._verts[i], xform);\n      }\n\n      // now recalcute the convex hull of all the transformed points\n      if (this._verts.length < 3) {\n        this._convexHull = this._verts.map(function (val, idx) {\n          return idx;\n        });\n      } else {\n        this._convexHull = (0, _convexHull.simpleHull_2D)(this._verts);\n      }\n      // use the convex hull points to rebuild the bounds\n      this._convexHull.forEach(function (idx) {\n        aaboxEncapsulatePt(_this2._aabox, _this2._verts[idx], idx, _this2._extentIndices);\n      });\n\n      // reset the local transforms\n      this.setTransformations(0, 0, 1, 1, 0);\n\n      return true;\n    }\n\n    /**\n     * Translates a specific vertex of the polygon by an offset\n     * @param  {number} vertIndex Index of the vertex to translate\n     * @param  {Vec2d} t         Translation offset, in world-space units\n     * @return {PolyLine}           this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If vertIndex is invalid.\n     */\n\n  }, {\n    key: \"translateVert\",\n    value: function translateVert(vertIndex, t) {\n      if (vertIndex >= this._verts.length) {\n        throw new Error(\"Cannot translate vertex at index \" + vertIndex + \". There are only \" + this._verts.length + \" vertices in the polygon.\");\n      }\n\n      if (t[0] || t[1]) {\n        var prev = Point2d.clone(this._verts[vertIndex]);\n        var newPt = Point2d.clone(this._verts[vertIndex]);\n        Point2d.addVec2(newPt, newPt, t);\n\n        // TODO(croot): this could be made smarter by determining whether\n        // this point affects the convex hull or not by checking it's relationship\n        // with its neighbors\n        this._collapseVerts();\n        this._resetAABox = true;\n        this._geomDirty = true;\n        Point2d.copy(newPt);\n        this.fire(\"changed:geom\", {\n          attr: \"verts[\" + vertIndex + \"]\",\n          prevVal: prev,\n          currVal: newPt\n        });\n      }\n      return this;\n    }\n  }, {\n    key: \"setVertPosition\",\n    value: function setVertPosition(vertIndex, pos) {\n      if (vertIndex >= this._verts.length) {\n        throw new Error(\"Cannot translate vertex at index \" + vertIndex + \". There are only \" + this._verts.length + \" vertices in the polygon.\");\n      }\n\n      if (!Point2d.equals(pos, this._verts[vertIndex])) {\n        var prev = Point2d.clone(this._verts[vertIndex]);\n        this._collapseVerts();\n        Point2d.copy(this._verts[vertIndex], pos);\n\n        // TODO(croot): this could be made smarter by determining whether\n        // this point affects the convex hull or not by checking it's relationship\n        // with its neighbors\n        this._resetAABox = true;\n        this._geomDirty = true;\n        this.fire(\"changed:geom\", {\n          attr: \"verts[\" + vertIndex + \"]\",\n          prevVal: prev,\n          currVal: pos\n        });\n      }\n    }\n  }, {\n    key: \"insertVert\",\n    value: function insertVert(vertIndex, pos) {\n      var idx = _math2.default.min(_math2.default.max(vertIndex, 0), this._verts.length);\n      this._collapseVerts();\n      if (vertIndex >= this._verts.length) {\n        this._verts.push(Point2d.clone(pos));\n        idx = this._verts.length - 1;\n      } else {\n        this._verts.splice(vertIndex, 0, Point2d.clone(pos));\n      }\n      this._resetAABox = true;\n      this._geomDirty = true;\n\n      this.fire(\"changed:geom:addvert\", {\n        attr: \"verts[\" + idx + \"]\",\n        currVal: pos\n      });\n\n      return idx;\n    }\n  }, {\n    key: \"appendVert\",\n    value: function appendVert(pos) {\n      return this.insertVert(this._verts.length, pos);\n    }\n  }, {\n    key: \"removeVert\",\n    value: function removeVert(vertIndex) {\n      if (vertIndex >= this._verts.length || vertIndex < 0) {\n        throw new Error(\"Cannot remove vertex \" + vertIndex + \". Invalid index. There are only \" + this._verts.length + \" vertices in the shape.\");\n      }\n\n      var pos = this._verts[vertIndex];\n      this._verts.splice(vertIndex, 1);\n      this._collapseVerts();\n      this._resetAABox = true;\n      this._geomDirty = true;\n\n      this.fire(\"changed:geom:removevert\", {\n        attr: \"verts[\" + vertIndex + \"]\",\n        currVal: pos\n      });\n\n      return vertIndex;\n    }\n  }, {\n    key: \"_rebuildAABox\",\n    value: function _rebuildAABox() {\n      var _this3 = this;\n\n      AABox2d.initEmpty(this._aabox);\n      if (this._verts.length < 3) {\n        this._convexHull = this._verts.map(function (val, idx) {\n          return idx;\n        });\n      } else {\n        this._convexHull = (0, _convexHull.simpleHull_2D)(this._verts);\n      }\n      this._convexHull.forEach(function (idx) {\n        aaboxEncapsulatePt(_this3._aabox, _this3._verts[idx], idx, _this3._extentIndices);\n      });\n\n      var pivot = Point2d.create(0, 0);\n      AABox2d.getCenter(pivot, this._aabox);\n      this.pivot = pivot;\n    }\n  }, {\n    key: \"_updateAABox\",\n    value: function _updateAABox() {\n      var _this4 = this;\n\n      if (this._resetAABox) {\n        this._rebuildAABox();\n        this._resetAABox = false;\n      }\n\n      if (this._boundsOutOfDate || this._geomDirty) {\n        AABox2d.initEmpty(this._aabox);\n        var tmppt = [0, 0];\n        var xform = this.globalXform;\n        this._convexHull.forEach(function (idx) {\n          AABox2d.encapsulatePt(_this4._aabox, _this4._aabox, Point2d.transformMat2d(tmppt, _this4._verts[idx], xform));\n        });\n        this._boundsOutOfDate = false;\n\n        if (this._geomDirty) {\n          var pivot = Point2d.create();\n          pivot[0] = this._verts[this._extentIndices[0]][0] + 0.5 * (this._verts[this._extentIndices[2]][0] - this._verts[this._extentIndices[0]][0]);\n          pivot[1] = this._verts[this._extentIndices[1]][1] + 0.5 * (this._verts[this._extentIndices[3]][1] - this._verts[this._extentIndices[1]][1]);\n          this.pivot = pivot;\n          this._geomDirty = false;\n        }\n      }\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      var rtn = false;\n      if (this._verts.length >= 2) {\n        ctx.moveTo(this._verts[0][0], this._verts[0][1]);\n        for (var i = 1; i < this._verts.length; i += 1) {\n          ctx.lineTo(this._verts[i][0], this._verts[i][1]);\n        }\n        rtn = true;\n      }\n      return rtn;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"PolyLine\", // NOTE: this much match the name of the class\n        verts: this.vertsRef.map(function (vert) {\n          return [vert[0], vert[1]];\n        })\n      }, _get(PolyLine.prototype.__proto__ || Object.getPrototypeOf(PolyLine.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      this._updateAABox();\n      if (!this._verts.length || this._extentIndices[0] < 0 || this._extentIndices[2] < 0) {\n        return 0;\n      }\n\n      return this._verts[this._extentIndices[2]][0] - this._verts[this._extentIndices[0]][0];\n    }\n\n    /**\n     * Gets the untransformed height of the polyline. This is the height of the axis-aligned\n     * bounds of the poly\n     * @return {number} Height of the poly in world-space units\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      this._updateAABox();\n      if (!this._verts.length || this._extentIndices[0] < 0 || this._extentIndices[2] < 0) {\n        return 0;\n      }\n\n      return this._verts[this._extentIndices[3]][1] - this._verts[this._extentIndices[1]][1];\n    }\n\n    /**\n     * Gets a reference to the vertex array of the polyline\n     * @return {Point2d[]}\n     * @readOnly\n     */\n\n  }, {\n    key: \"vertsRef\",\n    get: function get() {\n      return this._verts;\n    }\n\n    /**\n     * Gets the number of vertices in the polyline\n     * @return {number}\n     */\n\n  }, {\n    key: \"numVerts\",\n    get: function get() {\n      return this._verts.length;\n    }\n  }]);\n\n  return PolyLine;\n}(_baseShape2.default);\n\nexports.default = PolyLine;\n\n\nPolyLine.aaboxEncapsulatePt = aaboxEncapsulatePt;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9seS1saW5lLmpzPzE4ZDQiXSwibmFtZXMiOlsiQUFCb3gyZCIsIlBvaW50MmQiLCJpZGVudGl0eU1hdHJpeCIsImNyZWF0ZSIsImFhYm94RW5jYXBzdWxhdGVQdCIsImJveCIsInB0IiwicHRJZHgiLCJleHRlbnRJbmRpY2VzIiwiaXNFbXB0eSIsImJ1aWxkQ2VudHJvaWQiLCJjZW50cm9pZFB0IiwicHQxIiwicHQyIiwiYSIsImlzQXJyYXkiLCJvYmoiLCJBcnJheSIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiUG9seUxpbmUiLCJvcHRzIiwidmVydHMiLCJsZW5ndGgiLCJFcnJvciIsIl9leHRlbnRJbmRpY2VzIiwiX2xvY2FsYWFib3giLCJfdmVydHMiLCJfY2VudHJvaWQiLCJpbml0RW1wdHkiLCJfYWFib3giLCJzaWduZWRBcmVhIiwiaSIsInB1c2giLCJjbG9uZSIsImlkeCIsInBpdm90IiwiZ2V0Q2VudGVyIiwiX2NvbnZleEh1bGwiLCJtYXAiLCJ2YWwiLCJ3aWR0aCIsImhlaWdodCIsInNldCIsIl9waXZvdCIsInhmb3JtIiwibG9jYWxYZm9ybSIsImVxdWFscyIsInRyYW5zZm9ybU1hdDJkIiwiZm9yRWFjaCIsInNldFRyYW5zZm9ybWF0aW9ucyIsInZlcnRJbmRleCIsInQiLCJwcmV2IiwibmV3UHQiLCJhZGRWZWMyIiwiX2NvbGxhcHNlVmVydHMiLCJfcmVzZXRBQUJveCIsIl9nZW9tRGlydHkiLCJjb3B5IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsInBvcyIsIm1pbiIsIm1heCIsInNwbGljZSIsImluc2VydFZlcnQiLCJfcmVidWlsZEFBQm94IiwiX2JvdW5kc091dE9mRGF0ZSIsInRtcHB0IiwiZ2xvYmFsWGZvcm0iLCJlbmNhcHN1bGF0ZVB0IiwiY3R4IiwicnRuIiwibW92ZVRvIiwibGluZVRvIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsInZlcnRzUmVmIiwidmVydCIs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QUw7QUFDQSxVQUFJLENBQUMsS0FBS3hELE1BQUwsQ0FBWUosTUFBYixJQUF1QixLQUFLRSxjQUFMLENBQW9CLENBQXBCLElBQXlCLENBQWhELElBQXFELEtBQUtBLGNBQUwsQ0FBb0IsQ0FBcEIsSUFBeUIsQ0FBbEYsRUFBcUY7QUFDbkYsZUFBTyxDQUFQO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLRSxNQUFMLENBQVksS0FBS0YsY0FBTCxDQUFvQixDQUFwQixDQUFaLEVBQW9DLENBQXBDLElBQXlDLEtBQUtFLE1BQUwsQ0FBWSxLQUFLRixjQUFMLENBQW9CLENBQXBCLENBQVosRUFBb0MsQ0FBcEMsQ0FBaEQ7QUFDRDs7QUFFRDs7Ozs7Ozs7d0JBS2E7QUFDWCxXQUFLMEQsWUFBTDtBQUNBLFVBQUksQ0FBQyxLQUFLeEQsTUFBTCxDQUFZSixNQUFiLElBQXVCLEtBQUtFLGNBQUwsQ0FBb0IsQ0FBcEIsSUFBeUIsQ0FBaEQsSUFBcUQsS0FBS0EsY0FBTCxDQUFvQixDQUFwQixJQUF5QixDQUFsRixFQUFxRjtBQUNuRixlQUFPLENBQVA7QUFDRDs7QUFFRCxhQUFPLEtBQUtFLE1BQUwsQ0FBWSxLQUFLRixjQUFMLENBQW9CLENBQXBCLENBQVosRUFBb0MsQ0FBcEMsSUFBeUMsS0FBS0UsTUFBTCxDQUFZLEtBQUtGLGNBQUwsQ0FBb0IsQ0FBcEIsQ0FBWixFQUFvQyxDQUFwQyxDQUFoRDtBQUNEOztBQUVEOzs7Ozs7Ozt3QkFLZTtBQUNiLGFBQU8sS0FBS0UsTUFBWjtBQUNEOztBQUVEOzs7Ozs7O3dCQUllO0FBQ2IsYUFBTyxLQUFLQSxNQUFMLENBQVlKLE1BQW5CO0FBQ0Q7Ozs7OztrQkEzSGtCSCxROzs7QUF1VnJCQSxTQUFTaEIsa0JBQVQsR0FBOEJBLGtCQUE5QiIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcbmltcG9ydCB7bWF0MmQgYXMgTWF0MmR9IGZyb20gXCJnbC1tYXRyaXhcIlxuaW1wb3J0IE1hdGggZnJvbSBcIi4uL21hdGgvbWF0aFwiXG5pbXBvcnQge3NpbXBsZUh1bGxfMkR9IGZyb20gXCIuLi9tYXRoL2NvbnZleC1odWxsXCJcblxuY29uc3QgaWRlbnRpdHlNYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuXG4vKipcbiAqIEV4cGFuZHMgYW4gYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveCB0byBlbmNhcHN1bGF0ZSBhIDJkIHZlcnRleFxuICogZGVmaW5lZCBpbiBhbiBhcnJheSBvZiB2ZXJ0aWNlcywgYW5kIHVwZGF0ZXMgYSBzdHJ1Y3QgdXNlZCB0b1xuICogc3RvcmUgdGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzIHRoYXQgZGVmaW5lIHRoZSBmaW5hbCBib3VuZHNcbiAqIG9mIHRoZSB2ZXJ0aWNlc1xuICogQHBhcmFtICB7QUFCb3gyZH0gYm94ICAgICAgICAgIEJvdW5kcyB0byBleHBhbmRcbiAqIEBwYXJhbSAge1BvaW50MmR9IHB0ICAgICAgICAgICAyZCB2ZXJ0ZXggdG8gZW5jYXBzdWxhdGVcbiAqIEBwYXJhbSAge251bWJlcn0gcHRJZHggICAgICAgICBJbmRleCBvZiB0aGUgdmVydGV4IGluIGl0cyBsaXN0IG9mIHZlcnRpY2VzXG4gKiBAcGFyYW0gIHtudW1iZXJbXX0gZXh0ZW50SW5kaWNlcyBTdHJ1Y3QgdG8gc3RvcmUgdGhlIGluZGljZXMgb2YgdGhlIGJvdW5kaW5nIHZlcnRpY2VzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYWJveEVuY2Fwc3VsYXRlUHQoYm94LCBwdCwgcHRJZHgsIGV4dGVudEluZGljZXMpIHtcbiAgaWYgKEFBQm94MmQuaXNFbXB0eShib3gpKSB7XG4gICAgYm94WzBdID0gcHRbMF1cbiAgICBib3hbMl0gPSBwdFswXVxuICAgIGV4dGVudEluZGljZXNbMF0gPSBleHRlbnRJbmRpY2VzWzJdID0gcHRJZHhcbiAgICBib3hbMV0gPSBwdFsxXVxuICAgIGJveFszXSA9IHB0WzFdXG4gICAgZXh0ZW50SW5kaWNlc1sxXSA9IGV4dGVudEluZGljZXNbM10gPSBwdElkeFxuICB9IGVsc2Uge1xuICAgIGlmIChwdFswXSA8IGJveFswXSkge1xuICAgICAgYm94WzBdID0gcHRbMF1cbiAgICAgIGV4dGVudEluZGljZXNbMF0gPSBwdElkeFxuICAgIH0gZWxzZSBpZiAocHRbMF0gPiBib3hbMl0pIHtcbiAgICAgIGJveFsyXSA9IHB0WzBdXG4gICAgICBleHRlbnRJbmRpY2VzWzJdID0gcHRJZHhcbiAgICB9XG5cbiAgICBpZiAocHRbMV0gPCBib3hbMV0pIHtcbiAgICAgIGJveFsxXSA9IHB0WzFdXG4gICAgICBleHRlbnRJbmRpY2VzWzFdID0gcHRJZHhcbiAgICB9IGVsc2UgaWYgKHB0WzFdID4gYm94WzNdKSB7XG4gICAgICBib3hbM10gPSBwdFsxXVxuICAgICAgZXh0ZW50SW5kaWNlc1szXSA9IHB0SWR4XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY2FsbGVkIHNlcXVlbnRpYWxseSB0byBjYWxjdWxhdGUgdGhlIGNlbnRyb2lkIG9mIGEgcG9seWdvblxuICogQHBhcmFtICB7UG9pbnQyZH0gY2VudHJvaWRQdCBDdXJyZW50IGNlbnRyb2lkIHBvaW50XG4gKiBAcGFyYW0gIHtQb2ludDJkfSBwdDEgICAgICAgIFBvaW50IGRlc2NyaWJpbmcgb25lIGVuZCBvZiBhbiBlZGdlIG9mIGEgcG9seWdvblxuICogQHBhcmFtICB7UG9pbnQyZH0gcHQyICAgICAgICBQb2ludCBkZXNjcmliaW5nIG90aGVyIGVuZCBvZiBhbiBlZGdlIG9mIGEgcG9seWdvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRDZW50cm9pZChjZW50cm9pZFB0LCBwdDEsIHB0Mikge1xuICBjb25zdCBhID0gcHQxWzBdICogcHQyWzFdIC0gcHQyWzBdICogcHQxWzFdXG4gIGNlbnRyb2lkUHRbMF0gKz0gKHB0MVswXSArIHB0MlswXSkgKiBhXG4gIGNlbnRyb2lkUHRbMV0gKz0gKHB0MVsxXSArIHB0MlsxXSkgKiBhXG4gIHJldHVybiBhXG59XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgYW4gYXJndW1lbnQgaXMgYW4gYXJyYXlcbiAqIG9mIGFuIGFycmF5YnVmZmVyXG4gKiBAcGFyYW0gIHt9ICBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSB8fCAoQXJyYXlCdWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikpXG59XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUG9seUxpbmVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcltdfFBvaW50MmRbXX0gW3ZlcnRzPVtdXSBJbml0aWFsIHZlcnRpY2VzIG9mIHRoZSBwb2x5bGluZVxuICovXG5cbi8qKlxuICogQGNsYXNzIENsYXNzIGRlZmluaW5nIGEgcG9seSBsaW5lXG4gKiBAZXh0ZW5kcyB7QmFzZVNoYXBlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb2x5TGluZSBleHRlbmRzIEJhc2VTaGFwZSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgcG9seSBsaW5lIHNoYXBlXG4gICAqIEBwYXJhbSAge1BvbHlMaW5lT3B0aW9uc30gW29wdHNdIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7UG9seUxpbmV9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgY29uc3QgdmVydHMgPSBvcHRzLnZlcnRzIHx8IFtdXG4gICAgc3VwZXIob3B0cylcbiAgICBpZiAoIWlzQXJyYXkodmVydHMpIHx8XG4gICAgICB2ZXJ0cy5sZW5ndGggPT09IDAgfHwgKGlzQXJyYXkodmVydHNbMF0pICYmIHZlcnRzLmxlbmd0aCA8IDEpIHx8XG4gICAgICAoIWlzQXJyYXkodmVydHNbMF0pICYmICh2ZXJ0cy5sZW5ndGggPCAyIHx8IHZlcnRzLmxlbmd0aCAlIDIgIT09IDApKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9seUxpbmUgc2hhcGVzIG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBhcnJheSBvZiAyZCBwb2ludHMgYW5kIGNvbnRhaW4gYXQgbGVhc3QgMSBwb2ludHNcIilcbiAgICB9XG5cbiAgICAvLyBnb2luZyB0byBidWlsZCB0aGUgYWFib3ggYW5kIHN0b3JlIHRoZSBpbmRpY2VzIGZvciBlYWNoIHZlcnRleFxuICAgIC8vIHRoYXQgZGVmaW5lcyB0aGUgYm91bmRzXG4gICAgdGhpcy5fZXh0ZW50SW5kaWNlcyA9IFstMSwgLTEsIC0xLCAtMV1cbiAgICB0aGlzLl9sb2NhbGFhYm94ID0gQUFCb3gyZC5jcmVhdGUoKVxuICAgIHRoaXMuX3ZlcnRzID0gW11cbiAgICB0aGlzLl9jZW50cm9pZCA9IFswLCAwXVxuICAgIEFBQm94MmQuaW5pdEVtcHR5KHRoaXMuX2FhYm94KVxuICAgIGxldCBzaWduZWRBcmVhID0gMFxuICAgIGxldCBpID0gMFxuICAgIGlmIChpc0FycmF5KHZlcnRzWzBdKSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHZlcnRzLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB0aGlzLl92ZXJ0cy5wdXNoKFBvaW50MmQuY2xvbmUodmVydHNbaV0pKVxuICAgICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHZlcnRzW2ldLCBpLCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgICAgICBzaWduZWRBcmVhICs9IGJ1aWxkQ2VudHJvaWQodGhpcy5fY2VudHJvaWQsIHZlcnRzW2ldLCB2ZXJ0c1tpICsgMV0pXG4gICAgICB9XG4gICAgICB0aGlzLl92ZXJ0cy5wdXNoKFBvaW50MmQuY2xvbmUodmVydHNbaV0pKVxuICAgICAgYWFib3hFbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB2ZXJ0c1tpXSwgaSwgdGhpcy5fZXh0ZW50SW5kaWNlcylcbiAgICAgIHNpZ25lZEFyZWEgKz0gYnVpbGRDZW50cm9pZCh0aGlzLl9jZW50cm9pZCwgdmVydHNbaV0sIHZlcnRzWzBdKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92ZXJ0cy5wdXNoKFBvaW50MmQuY3JlYXRlKHZlcnRzWzBdLCB2ZXJ0c1sxXSkpXG4gICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHRoaXMuX3ZlcnRzWzBdLCAwLCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgICAgbGV0IGlkeCA9IDFcbiAgICAgIGZvciAoaSA9IDI7IGkgPCB2ZXJ0cy5sZW5ndGggLSAyOyBpICs9IDIsIGlkeCArPSAxKSB7XG4gICAgICAgIHRoaXMuX3ZlcnRzLnB1c2goUG9pbnQyZC5jcmVhdGUodmVydHNbaV0sIHZlcnRzW2kgKyAxXSkpXG4gICAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdGhpcy5fdmVydHNbaWR4XSwgaWR4LCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgICAgICBzaWduZWRBcmVhICs9IGJ1aWxkQ2VudHJvaWQodGhpcy5fY2VudHJvaWQsIHRoaXMuX3ZlcnRzW2lkeCAtIDFdLCB0aGlzLl92ZXJ0c1tpZHhdKVxuICAgICAgfVxuICAgICAgdGhpcy5fdmVydHMucHVzaChQb2ludDJkLmNyZWF0ZSh2ZXJ0c1tpXSwgdmVydHNbaSArIDFdKSlcbiAgICAgIGFhYm94RW5jYXBzdWxhdGVQdCh0aGlzLl9hYWJveCwgdGhpcy5fdmVydHNbaWR4XSwgaWR4LCB0aGlzLl9leHRlbnRJbmRpY2VzKVxuICAgICAgc2lnbmVkQXJlYSArPSBidWlsZENlbnRyb2lkKHRoaXMuX2NlbnRyb2lkLCB0aGlzLl92ZXJ0c1tpZHhdLCB0aGlzLl92ZXJ0c1swXSlcbiAgICB9XG4gICAgc2lnbmVkQXJlYSAqPSAwLjVcbiAgICB0aGlzLl9jZW50cm9pZFswXSAvPSA2LjAgKiBzaWduZWRBcmVhXG4gICAgdGhpcy5fY2VudHJvaWRbMV0gLz0gNi4wICogc2lnbmVkQXJlYVxuXG4gICAgLy8gZXh0cmFjdCB0aGUgY2VudGVyIG9mIHRoZSBhYWJveC4gV2UgYXJlIGdvaW5nIHRvIHVzZSB0aGlzIGFzIHRoZVxuICAgIC8vIHNoYXBlJ3MgcGl2b3QsIHNvIGFsbCByb3RhdGlvbi9zY2FsZSB0cmFuc2Zvcm1hdGlvbnMgd2lsbCBiZSBzb3VyY2VkXG4gICAgLy8gYXQgdGhpcyBsb2NhdGlvblxuICAgIGNvbnN0IHBpdm90ID0gUG9pbnQyZC5jcmVhdGUoKVxuICAgIEFBQm94MmQuZ2V0Q2VudGVyKHBpdm90LCB0aGlzLl9hYWJveClcbiAgICB0aGlzLnBpdm90ID0gcGl2b3RcblxuICAgIC8vIG5vdyBidWlsZCB0aGUgY29udmV4IGh1bGwgb2YgdGhlIHZlcnRpY2VzLlxuICAgIC8vIFdoZW4gcmVidWlsZGluZyB0aGUgYXhpcyBhbGlnbmVkIGJveCAoYSB0cmFuc2Zvcm0gaXMgYXBwbGllZCBmb3IgZXhhbXBsZSksXG4gICAgLy8gdGhlcmUncyBubyBuZWVkIHRvIHRyYXZlcnNlIGFsbCB0aGUgcG9pbnRzLiBBbGwgd2UgbmVlZCB0byBkbyBpcyB0cmF2ZXJzZVxuICAgIC8vIHRoZSBwb2ludHMgdGhhdCBkZWZpbmUgdGhlIGNvbnZleCBodWxsIHRvIHJlYnVpbGQgdGhlIGJvdW5kc1xuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gdGhpcy5fdmVydHMubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgICByZXR1cm4gaWR4XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gc2ltcGxlSHVsbF8yRCh0aGlzLl92ZXJ0cylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1bnRyYW5zZm9ybWVkIHdpZHRoL2hlaWdodCBvZiB0aGUgcG9seWxpbmUuIFRoaXMgaXMgZXNzZW50aWFsbHlcbiAgICogdGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgcG9seSdzIGJvdW5kc1xuICAgKiBAcmV0dXJuIHtWZWMyZH0gV2lkdGgvaGVpZ2h0IG9mIHRoZSBib3VuZHMgb2YgdGhlIHBvbHlsaW5lXG4gICAqL1xuICBnZXREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiBbdGhpcy53aWR0aCwgdGhpcy5oZWlnaHRdXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSBwb2x5bGluZS4gVGhpcyBpcyB0aGUgd2lkdGggb2YgdGhlXG4gICAqIGF4aXMtYWxpZ25lZCBib3VuZHMgb2YgdGhlIHBvbHlcbiAgICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCBvZiB0aGUgcG9seSBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHRoaXMuX3VwZGF0ZUFBQm94KClcbiAgICBpZiAoIXRoaXMuX3ZlcnRzLmxlbmd0aCB8fCB0aGlzLl9leHRlbnRJbmRpY2VzWzBdIDwgMCB8fCB0aGlzLl9leHRlbnRJbmRpY2VzWzJdIDwgMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmVydHNbdGhpcy5fZXh0ZW50SW5kaWNlc1syXV1bMF0gLSB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzBdXVswXVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVudHJhbnNmb3JtZWQgaGVpZ2h0IG9mIHRoZSBwb2x5bGluZS4gVGhpcyBpcyB0aGUgaGVpZ2h0IG9mIHRoZSBheGlzLWFsaWduZWRcbiAgICogYm91bmRzIG9mIHRoZSBwb2x5XG4gICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IG9mIHRoZSBwb2x5IGluIHdvcmxkLXNwYWNlIHVuaXRzXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHRoaXMuX3VwZGF0ZUFBQm94KClcbiAgICBpZiAoIXRoaXMuX3ZlcnRzLmxlbmd0aCB8fCB0aGlzLl9leHRlbnRJbmRpY2VzWzBdIDwgMCB8fCB0aGlzLl9leHRlbnRJbmRpY2VzWzJdIDwgMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fdmVydHNbdGhpcy5fZXh0ZW50SW5kaWNlc1szXV1bMV0gLSB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzFdXVsxXVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSByZWZlcmVuY2UgdG8gdGhlIHZlcnRleCBhcnJheSBvZiB0aGUgcG9seWxpbmVcbiAgICogQHJldHVybiB7UG9pbnQyZFtdfVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCB2ZXJ0c1JlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVydHNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gdGhlIHBvbHlsaW5lXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBudW1WZXJ0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmVydHMubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGNvbGxhcHNlcyBhbGwgdGhlIHZlcnRzLCBtZWFuaW5nIHRoZSB2ZXJ0c1xuICAgKiBhcmUgZmxhdHRlbmVkIHRvIHRoZWlyIHBvc2l0aW9uIHdpdGggbG9jYWwtc3BhY2UgdHJhbnNmb3JtcyBhcHBsaWVkXG4gICAqIGFuZCB0aGVuIHRoZSBsb2NhbCB0cmFuc2Zvcm1zIGFyZSBjbGVhcmVkLiBUaGlzIGlzIGRvbmUgd2hlbmV2ZXJcbiAgICogdGhlIHZlcnRpY2VzIG9mIHRoZSBwb2x5Z29uIGFyZSBtb2RpZmllZCBhcyBpdCBjYW4gYmUgYSBsaXR0bGUgdHJpY2t5XG4gICAqIHRvIHJlLWFkanVzdCB0aGUgcGl2b3QvdHJhbnNmb3JtcyBvZiB0aGUgdmVydCB3aGVuIG5ldyB2ZXJ0cyBhcmUgYWRkZWQsXG4gICAqIGRlbGV0ZWQsIGV0Yy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludHMgd2VyZSBpbmRlZWQgZmxhdHRlbmVkXG4gICAqICAgICAgICAgICAgICAgICAgIFRoZSBwb2ludHMgd291bGRuJ3QgYmUgZmxhdHRlbmVkIGlmIHRoZXJlIGFyZSBub1xuICAgKiAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1zIHRvIGFwcGx5LCBmb3IgZXhhbXBsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbGxhcHNlVmVydHMoKSB7XG4gICAgUG9pbnQyZC5zZXQodGhpcy5fcGl2b3QsIDAsIDApXG5cbiAgICAvLyBUT0RPKGNyb290KTogd2hhdCBpZiB0aGlzIHBvbHkgaXNcbiAgICAvLyBwYXJlbnRlZCB0byBhbm90aGVyIHRyYW5zZm9ybT9cblxuICAgIGNvbnN0IHhmb3JtID0gdGhpcy5sb2NhbFhmb3JtXG4gICAgaWYgKE1hdDJkLmVxdWFscyh4Zm9ybSwgaWRlbnRpdHlNYXRyaXgpKSB7XG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdHJhbnNmb3JtcyB0byBhcHBseSxcbiAgICAgIC8vIGRvIG5vdGhpbmcgLSBmYXN0IG91dFxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgQUFCb3gyZC5pbml0RW1wdHkodGhpcy5fYWFib3gpXG5cbiAgICAvLyBmbGF0dGVuIGFsbCB0aGUgcG9pbnRzIHRvIHRoZWlyIGN1cnJlbnQgd29ybGQtc3BhY2UgcG9zaXRpb25cbiAgICAvLyB3aXRoIHRyYW5zZm9ybXMgYXBwbGllZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdmVydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodGhpcy5fdmVydHNbaV0sIHRoaXMuX3ZlcnRzW2ldLCB4Zm9ybSlcbiAgICB9XG5cbiAgICAvLyBub3cgcmVjYWxjdXRlIHRoZSBjb252ZXggaHVsbCBvZiBhbGwgdGhlIHRyYW5zZm9ybWVkIHBvaW50c1xuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gdGhpcy5fdmVydHMubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgICByZXR1cm4gaWR4XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb252ZXhIdWxsID0gc2ltcGxlSHVsbF8yRCh0aGlzLl92ZXJ0cylcbiAgICB9XG4gICAgLy8gdXNlIHRoZSBjb252ZXggaHVsbCBwb2ludHMgdG8gcmVidWlsZCB0aGUgYm91bmRzXG4gICAgdGhpcy5fY29udmV4SHVsbC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICBhYWJveEVuY2Fwc3VsYXRlUHQodGhpcy5fYWFib3gsIHRoaXMuX3ZlcnRzW2lkeF0sIGlkeCwgdGhpcy5fZXh0ZW50SW5kaWNlcylcbiAgICB9KVxuXG4gICAgLy8gcmVzZXQgdGhlIGxvY2FsIHRyYW5zZm9ybXNcbiAgICB0aGlzLnNldFRyYW5zZm9ybWF0aW9ucygwLCAwLCAxLCAxLCAwKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGVzIGEgc3BlY2lmaWMgdmVydGV4IG9mIHRoZSBwb2x5Z29uIGJ5IGFuIG9mZnNldFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZlcnRJbmRleCBJbmRleCBvZiB0aGUgdmVydGV4IHRvIHRyYW5zbGF0ZVxuICAgKiBAcGFyYW0gIHtWZWMyZH0gdCAgICAgICAgIFRyYW5zbGF0aW9uIG9mZnNldCwgaW4gd29ybGQtc3BhY2UgdW5pdHNcbiAgICogQHJldHVybiB7UG9seUxpbmV9ICAgICAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB2ZXJ0SW5kZXggaXMgaW52YWxpZC5cbiAgICovXG4gIHRyYW5zbGF0ZVZlcnQodmVydEluZGV4LCB0KSB7XG4gICAgaWYgKHZlcnRJbmRleCA+PSB0aGlzLl92ZXJ0cy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHRyYW5zbGF0ZSB2ZXJ0ZXggYXQgaW5kZXggJHt2ZXJ0SW5kZXh9LiBUaGVyZSBhcmUgb25seSAke3RoaXMuX3ZlcnRzLmxlbmd0aH0gdmVydGljZXMgaW4gdGhlIHBvbHlnb24uYClcbiAgICB9XG5cbiAgICBpZiAodFswXSB8fCB0WzFdKSB7XG4gICAgICBjb25zdCBwcmV2ID0gUG9pbnQyZC5jbG9uZSh0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXhdKVxuICAgICAgY29uc3QgbmV3UHQgPSBQb2ludDJkLmNsb25lKHRoaXMuX3ZlcnRzW3ZlcnRJbmRleF0pXG4gICAgICBQb2ludDJkLmFkZFZlYzIobmV3UHQsIG5ld1B0LCB0KVxuXG4gICAgICAvLyBUT0RPKGNyb290KTogdGhpcyBjb3VsZCBiZSBtYWRlIHNtYXJ0ZXIgYnkgZGV0ZXJtaW5pbmcgd2hldGhlclxuICAgICAgLy8gdGhpcyBwb2ludCBhZmZlY3RzIHRoZSBjb252ZXggaHVsbCBvciBub3QgYnkgY2hlY2tpbmcgaXQncyByZWxhdGlvbnNoaXBcbiAgICAgIC8vIHdpdGggaXRzIG5laWdoYm9yc1xuICAgICAgdGhpcy5fY29sbGFwc2VWZXJ0cygpXG4gICAgICB0aGlzLl9yZXNldEFBQm94ID0gdHJ1ZVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdHJ1ZVxuICAgICAgUG9pbnQyZC5jb3B5KG5ld1B0KVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tXCIsIHtcbiAgICAgICAgYXR0cjogYHZlcnRzWyR7dmVydEluZGV4fV1gLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiBuZXdQdFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldFZlcnRQb3NpdGlvbih2ZXJ0SW5kZXgsIHBvcykge1xuICAgIGlmICh2ZXJ0SW5kZXggPj0gdGhpcy5fdmVydHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCB0cmFuc2xhdGUgdmVydGV4IGF0IGluZGV4ICR7dmVydEluZGV4fS4gVGhlcmUgYXJlIG9ubHkgJHt0aGlzLl92ZXJ0cy5sZW5ndGh9IHZlcnRpY2VzIGluIHRoZSBwb2x5Z29uLmApXG4gICAgfVxuXG4gICAgaWYgKCFQb2ludDJkLmVxdWFscyhwb3MsIHRoaXMuX3ZlcnRzW3ZlcnRJbmRleF0pKSB7XG4gICAgICBjb25zdCBwcmV2ID0gUG9pbnQyZC5jbG9uZSh0aGlzLl92ZXJ0c1t2ZXJ0SW5kZXhdKVxuICAgICAgdGhpcy5fY29sbGFwc2VWZXJ0cygpXG4gICAgICBQb2ludDJkLmNvcHkodGhpcy5fdmVydHNbdmVydEluZGV4XSwgcG9zKVxuXG4gICAgICAvLyBUT0RPKGNyb290KTogdGhpcyBjb3VsZCBiZSBtYWRlIHNtYXJ0ZXIgYnkgZGV0ZXJtaW5pbmcgd2hldGhlclxuICAgICAgLy8gdGhpcyBwb2ludCBhZmZlY3RzIHRoZSBjb252ZXggaHVsbCBvciBub3QgYnkgY2hlY2tpbmcgaXQncyByZWxhdGlvbnNoaXBcbiAgICAgIC8vIHdpdGggaXRzIG5laWdoYm9yc1xuICAgICAgdGhpcy5fcmVzZXRBQUJveCA9IHRydWVcbiAgICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWVcbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IGB2ZXJ0c1ske3ZlcnRJbmRleH1dYCxcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogcG9zXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGluc2VydFZlcnQodmVydEluZGV4LCBwb3MpIHtcbiAgICBsZXQgaWR4ID0gTWF0aC5taW4oTWF0aC5tYXgodmVydEluZGV4LCAwKSwgdGhpcy5fdmVydHMubGVuZ3RoKVxuICAgIHRoaXMuX2NvbGxhcHNlVmVydHMoKVxuICAgIGlmICh2ZXJ0SW5kZXggPj0gdGhpcy5fdmVydHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl92ZXJ0cy5wdXNoKFBvaW50MmQuY2xvbmUocG9zKSlcbiAgICAgIGlkeCA9IHRoaXMuX3ZlcnRzLmxlbmd0aCAtIDFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmVydHMuc3BsaWNlKHZlcnRJbmRleCwgMCwgUG9pbnQyZC5jbG9uZShwb3MpKVxuICAgIH1cbiAgICB0aGlzLl9yZXNldEFBQm94ID0gdHJ1ZVxuICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWVcblxuICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbTphZGR2ZXJ0XCIsIHtcbiAgICAgIGF0dHI6IGB2ZXJ0c1ske2lkeH1dYCxcbiAgICAgIGN1cnJWYWw6IHBvc1xuICAgIH0pXG5cbiAgICByZXR1cm4gaWR4XG4gIH1cblxuICBhcHBlbmRWZXJ0KHBvcykge1xuICAgIHJldHVybiB0aGlzLmluc2VydFZlcnQodGhpcy5fdmVydHMubGVuZ3RoLCBwb3MpXG4gIH1cblxuICByZW1vdmVWZXJ0KHZlcnRJbmRleCkge1xuICAgIGlmICh2ZXJ0SW5kZXggPj0gdGhpcy5fdmVydHMubGVuZ3RoIHx8IHZlcnRJbmRleCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbW92ZSB2ZXJ0ZXggJHt2ZXJ0SW5kZXh9LiBJbnZhbGlkIGluZGV4LiBUaGVyZSBhcmUgb25seSAke3RoaXMuX3ZlcnRzLmxlbmd0aH0gdmVydGljZXMgaW4gdGhlIHNoYXBlLmApXG4gICAgfVxuXG4gICAgY29uc3QgcG9zID0gdGhpcy5fdmVydHNbdmVydEluZGV4XVxuICAgIHRoaXMuX3ZlcnRzLnNwbGljZSh2ZXJ0SW5kZXgsIDEpXG4gICAgdGhpcy5fY29sbGFwc2VWZXJ0cygpXG4gICAgdGhpcy5fcmVzZXRBQUJveCA9IHRydWVcbiAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlXG5cbiAgICB0aGlzLmZpcmUoXCJjaGFuZ2VkOmdlb206cmVtb3ZldmVydFwiLCB7XG4gICAgICBhdHRyOiBgdmVydHNbJHt2ZXJ0SW5kZXh9XWAsXG4gICAgICBjdXJyVmFsOiBwb3NcbiAgICB9KVxuXG4gICAgcmV0dXJuIHZlcnRJbmRleFxuICB9XG5cbiAgX3JlYnVpbGRBQUJveCgpIHtcbiAgICBBQUJveDJkLmluaXRFbXB0eSh0aGlzLl9hYWJveClcbiAgICBpZiAodGhpcy5fdmVydHMubGVuZ3RoIDwgMykge1xuICAgICAgdGhpcy5fY29udmV4SHVsbCA9IHRoaXMuX3ZlcnRzLm1hcCgodmFsLCBpZHgpID0+IHtcbiAgICAgICAgcmV0dXJuIGlkeFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY29udmV4SHVsbCA9IHNpbXBsZUh1bGxfMkQodGhpcy5fdmVydHMpXG4gICAgfVxuICAgIHRoaXMuX2NvbnZleEh1bGwuZm9yRWFjaChpZHggPT4ge1xuICAgICAgYWFib3hFbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB0aGlzLl92ZXJ0c1tpZHhdLCBpZHgsIHRoaXMuX2V4dGVudEluZGljZXMpXG4gICAgfSlcblxuICAgIGNvbnN0IHBpdm90ID0gUG9pbnQyZC5jcmVhdGUoMCwgMClcbiAgICBBQUJveDJkLmdldENlbnRlcihwaXZvdCwgdGhpcy5fYWFib3gpXG4gICAgdGhpcy5waXZvdCA9IHBpdm90XG4gIH1cblxuICBfdXBkYXRlQUFCb3goKSB7XG4gICAgaWYgKHRoaXMuX3Jlc2V0QUFCb3gpIHtcbiAgICAgIHRoaXMuX3JlYnVpbGRBQUJveCgpXG4gICAgICB0aGlzLl9yZXNldEFBQm94ID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm91bmRzT3V0T2ZEYXRlIHx8IHRoaXMuX2dlb21EaXJ0eSkge1xuICAgICAgQUFCb3gyZC5pbml0RW1wdHkodGhpcy5fYWFib3gpXG4gICAgICBjb25zdCB0bXBwdCA9IFswLCAwXVxuICAgICAgY29uc3QgeGZvcm0gPSB0aGlzLmdsb2JhbFhmb3JtXG4gICAgICB0aGlzLl9jb252ZXhIdWxsLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgQUFCb3gyZC5lbmNhcHN1bGF0ZVB0KHRoaXMuX2FhYm94LCB0aGlzLl9hYWJveCwgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0bXBwdCwgdGhpcy5fdmVydHNbaWR4XSwgeGZvcm0pKVxuICAgICAgfSlcbiAgICAgIHRoaXMuX2JvdW5kc091dE9mRGF0ZSA9IGZhbHNlXG5cbiAgICAgIGlmICh0aGlzLl9nZW9tRGlydHkpIHtcbiAgICAgICAgY29uc3QgcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgpXG4gICAgICAgIHBpdm90WzBdID0gdGhpcy5fdmVydHNbdGhpcy5fZXh0ZW50SW5kaWNlc1swXV1bMF0gKyAwLjUgKiAodGhpcy5fdmVydHNbdGhpcy5fZXh0ZW50SW5kaWNlc1syXV1bMF0gLSB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzBdXVswXSlcbiAgICAgICAgcGl2b3RbMV0gPSB0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzFdXVsxXSArIDAuNSAqICh0aGlzLl92ZXJ0c1t0aGlzLl9leHRlbnRJbmRpY2VzWzNdXVsxXSAtIHRoaXMuX3ZlcnRzW3RoaXMuX2V4dGVudEluZGljZXNbMV1dWzFdKVxuICAgICAgICB0aGlzLnBpdm90ID0gcGl2b3RcbiAgICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZHJhdyhjdHgpIHtcbiAgICBsZXQgcnRuID0gZmFsc2VcbiAgICBpZiAodGhpcy5fdmVydHMubGVuZ3RoID49IDIpIHtcbiAgICAgIGN0eC5tb3ZlVG8odGhpcy5fdmVydHNbMF1bMF0sIHRoaXMuX3ZlcnRzWzBdWzFdKVxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLl92ZXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjdHgubGluZVRvKHRoaXMuX3ZlcnRzW2ldWzBdLCB0aGlzLl92ZXJ0c1tpXVsxXSlcbiAgICAgIH1cbiAgICAgIHJ0biA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IFwiUG9seUxpbmVcIiwgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgdmVydHM6IHRoaXMudmVydHNSZWYubWFwKHZlcnQgPT4ge1xuICAgICAgICByZXR1cm4gW3ZlcnRbMF0sIHZlcnRbMV1dXG4gICAgICB9KVxuICAgIH0sIHN1cGVyLnRvSlNPTigpKVxuICB9XG5cbn1cblxuUG9seUxpbmUuYWFib3hFbmNhcHN1bGF0ZVB0ID0gYWFib3hFbmNhcHN1bGF0ZVB0XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zaGFwZXMvcG9seS1saW5lLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.buildXformMatrix = buildXformMatrix;\nexports.createEventedTransform2dMixin = createEventedTransform2dMixin;\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _aggregation = __webpack_require__(8);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Builds a 2D transformation matrix (2x3 matrix) from a rotation (in degrees),\n * an x,y scale, a translation, and a pivot (an offset from the origin to\n * apply the transformation around)\n * @param  {Mat2d} mat   Matrix to store the result of the operation\n * @param  {number} rdeg  rotation, in degrees\n * @param  {Vec2d} s     Scale vector, in x & y\n * @param  {Vec2d} t     Translation vector, in x & y\n * @param  {Vec2d} pivot Offset from origin to apply the transformation\n * @return {Mat2d}       Matrix referenced by the mat argument\n */\nfunction buildXformMatrix(mat, rdeg, s, t, pivot) {\n  _glMatrix.mat2d.identity(mat);\n  _glMatrix.mat2d.translate(mat, mat, [t[0] + pivot[0], t[1] + pivot[1]]);\n  _glMatrix.mat2d.rotate(mat, mat, _math2.default.DEG_TO_RAD * rdeg);\n  _glMatrix.mat2d.scale(mat, mat, s);\n  _glMatrix.mat2d.translate(mat, mat, [-pivot[0], -pivot[1]]);\n  return mat;\n}\n\n/**\n * Utility function to dirty all the descendants of a transform node.\n * This is called when a transform node has been modified in some way\n * that it's children need to be notified about.\n * @param  {Transform2d[]} children\n */\nfunction dirtyChildren(children) {\n  children.forEach(function (child) {\n    child._xformDirty = true;\n    dirtyChildren(child._children);\n  });\n}\n\n/**\n * @typedef {object} Transform2dOptions\n * @property {Point2d} [position = [0,0]] Position in world space coords\n * @property {Vec2d} [scale = [1,1]] Scale in world space coords\n * @property {number} [rotation = 0] Rotation in degrees\n * @property {Vec2d} [pivot = [0, 0]] Offset from origin to apply the setTransformations\n */\n\n/**\n * @class Class to manage basic 2d affine transformations\n * @mixin Can also be used as a mixin\n */\n\nvar Transform2d = function () {\n  /**\n   * Creates a new Transform2d\n   * @param  {Transform2dOptions} [opts]\n   * @return {Transform2d}\n   */\n  function Transform2d(opts) {\n    _classCallCheck(this, Transform2d);\n\n    this.initializer(opts);\n  }\n\n  /**\n   * Initializes a transform 2d object from options\n   * @param  {Transform2dOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(Transform2d, [{\n    key: \"_initTransformFromOptions\",\n    value: function _initTransformFromOptions(opts) {\n      if (!opts) {\n        return;\n      }\n\n      if (typeof opts.position !== \"undefined\") {\n        this.setPosition(opts.position);\n      }\n\n      if (typeof opts.scale !== \"undefined\") {\n        this.setScale(opts.scale);\n      }\n\n      if (typeof opts.rotation !== \"undefined\") {\n        this.setRotation(opts.rotation);\n      }\n\n      if (typeof opts.pivot !== \"undefined\") {\n        this.pivot = opts.pivot;\n      }\n    }\n\n    /**\n     * Initializes a transform 2d object from options,\n     * called from either constructor (if used as base class)\n     * or base mixin class (if used as a mixin)\n     * @param  {Transform2dOptions} [opts]\n     * @protected\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._localXform = _glMatrix.mat2d.create();\n      this._lxformDirty = false;\n\n      this._pivot = Point2d.create(0, 0);\n\n      this._pos = Point2d.create(0, 0);\n      this._scale = _glMatrix.vec2.fromValues(1, 1);\n      this._rotDeg = 0;\n\n      this._globalXform = _glMatrix.mat2d.create();\n      this._xformDirty = false;\n      this._parent = null;\n      this._children = new Set();\n\n      this._initTransformFromOptions(opts);\n    }\n\n    /**\n     * Adds a child to this transform node\n     * @param {Transform2d} childXform\n     */\n\n  }, {\n    key: \"addChildXform\",\n    value: function addChildXform(childXform) {\n      if (!this._children.has(childXform)) {\n        this._children.add(childXform);\n        if (childXform._parent) {\n          childXform._parent.removeChild(childXform);\n        }\n        childXform._parent = this;\n        childXform._xformDirty = true;\n        dirtyChildren(childXform._children);\n      }\n    }\n\n    /**\n     * Removes a child from this transform node\n     * @param  {Transform2d} childXform\n     */\n\n  }, {\n    key: \"removeChildXform\",\n    value: function removeChildXform(childXform) {\n      this._children.delete(childXform);\n    }\n\n    /**\n     * Unparents this node from its parent, if it has one\n     */\n\n  }, {\n    key: \"unparentXform\",\n    value: function unparentXform() {\n      if (this._parent) {\n        this._parent.removeChild(this);\n        this._parent = null;\n        _glMatrix.mat2d.copy(this._globalXform, this.localXform);\n      }\n    }\n\n    /**\n     * Sets the pivot of the transform\n     * @param  {Vec2d} pivot Offset vector from the origin to apply the transformations\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"getPosition\",\n\n\n    /**\n     * Gets the current unparented position of the transform\n     * @return {Point2d} This is the position of the node as if it were unparented\n     */\n    value: function getPosition() {\n      return _glMatrix.vec2.clone(this._pos);\n    }\n\n    /**\n     * Gets the reference to the unparented position of the transform, avoiding\n     * a copy\n     * @return {Point2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"getPositionRef\",\n    value: function getPositionRef() {\n      return this._pos;\n    }\n\n    /**\n     * Gets the current world position of the transform, this is its position\n     * after all parent transformations have been applied\n     * @return {Point2d}\n     */\n\n  }, {\n    key: \"getWorldPosition\",\n    value: function getWorldPosition() {\n      var xform = this.globalXform;\n      return Point2d.create(xform[4], xform[5]);\n    }\n\n    /**\n     * Sets the unparented world position of the transform\n     * @param {Point2d} pos\n     */\n\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(pos) {\n      Point2d.copy(this._pos, pos);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n    }\n\n    /**\n     * Translates the unparented world position of the transform by an offset\n     * @param  {Vec2d} translation\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(translation) {\n      if (translation[0] || translation[1]) {\n        Point2d.addVec2(this._pos, this._pos, translation);\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current unparented x,y scale of the transform\n     * @return {Vec2d}\n     */\n\n  }, {\n    key: \"getScale\",\n    value: function getScale() {\n      return _glMatrix.vec2.clone(this._scale);\n    }\n\n    /**\n     * Gets the current unparented x/y scale reference of the transform\n     * avoiding a copy\n     * @return {Vec2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"getScaleRef\",\n    value: function getScaleRef() {\n      return this._scale;\n    }\n\n    /**\n     * Sets the unparented scale of the transform\n     * @param {Vec2d} scale\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"setScale\",\n    value: function setScale(scale) {\n      _glMatrix.vec2.copy(this._scale, scale);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Scales the current unparented scale by a 2d multiplier\n     * @param  {Vec2d} scaleMult\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(scaleMult) {\n      if (scaleMult[0] !== 1 || scaleMult[1] !== 1) {\n        _glMatrix.vec2.multiply(this._scale, this._scale, scaleMult);\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current unparented rotation in degrees of the transform\n     * @return {number}\n     */\n\n  }, {\n    key: \"getRotation\",\n    value: function getRotation() {\n      return this._rotDeg;\n    }\n\n    /**\n     * Sets the unparented rotation of the transform\n     * @param {number} deg Rotation in degrees\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"setRotation\",\n    value: function setRotation(deg) {\n      this._rotDeg = deg;\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Adds an additional rotation in degrees to the current rotation\n     * of the transform\n     * @param  {number} deg Rotation offset in degrees\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(deg) {\n      if (deg) {\n        this._rotDeg += deg;\n        this._lxformDirty = true;\n        dirtyChildren(this._children);\n      }\n      return this;\n    }\n\n    /**\n     * Utility function to dirty all the descendants of this node\n     * @private\n     */\n\n  }, {\n    key: \"_dirtyChildren\",\n    value: function _dirtyChildren() {\n      dirtyChildren(this._children);\n    }\n\n    /**\n     * Updates the local affine matrix if marked as dirty\n     * If derived/mixin classes have a _localXformUpdates method\n     * defined, that will be called here when the local transform\n     * is updated.\n     * @private\n     */\n\n  }, {\n    key: \"_updatelocalxform\",\n    value: function _updatelocalxform() {\n      if (this._lxformDirty) {\n        buildXformMatrix(this._localXform, this._rotDeg, this._scale, this._pos, this._pivot);\n        if (this._localXformUpdated) {\n          this._localXformUpdated();\n        }\n        this._lxformDirty = false;\n      }\n    }\n\n    /**\n     * Updates the global 2x3 matrix of the transform if marked dirty\n     * If derived/mixin classes have a _globalXformUpdates method\n     * defined, that will be called here when the global transform\n     * is updated.\n     * @private\n     */\n\n  }, {\n    key: \"_updateglobalxform\",\n    value: function _updateglobalxform() {\n      if (this._lxformDirty || this._xformDirty) {\n        this._updatelocalxform();\n        if (this._parent) {\n          _glMatrix.mat2d.multiply(this._globalXform, this._parent.globalXform, this._localXform);\n        } else {\n          _glMatrix.mat2d.copy(this._globalXform, this._localXform);\n        }\n        if (this._globalXformUpdated) {\n          this._globalXformUpdated();\n        }\n        this._xformDirty = false;\n      }\n    }\n\n    /**\n     * Gets the current local transformation matrix of the node.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"transformCtx\",\n\n\n    /**\n     * Sets the transform state of a 2d rendering context\n     * @param  {CanvasRenderingContext2D} ctx\n     * @param  {Mat2d} currMatrix          The current matrix used to store the result of the\n     *                                     model-view-projection-screen matrix multiplication for this node\n     * @param  {Mat2d} worldToScreenMatrix The current world-to-screen tranform\n     */\n    value: function transformCtx(ctx, currMatrix, worldToScreenMatrix) {\n      _glMatrix.mat2d.multiply(currMatrix, worldToScreenMatrix, this.globalXform);\n\n      ctx.setTransform(currMatrix[0], currMatrix[1], currMatrix[2], currMatrix[3], currMatrix[4], currMatrix[5]);\n    }\n\n    /**\n     * Converts a Transform2d instance to a JSON object\n     * @param  {Transform2d} xformObj\n     * @return {{position: Point2d, scale: Vec2d, rotation: number, pivot: Vec2d}}\n     */\n\n  }, {\n    key: \"pivot\",\n    set: function set(pivot) {\n      Point2d.copy(this._pivot, pivot);\n      this._lxformDirty = true;\n      dirtyChildren(this._children);\n      return this;\n    }\n\n    /**\n     * Gets the current pivot of the transform\n     * @return {Vec2d}\n     */\n    ,\n    get: function get() {\n      return Point2d.clone(this._pivot);\n    }\n\n    /**\n     * Gets the current pivot reference of the transform.\n     * @return {[type]} [description]\n     * @readOnly\n     */\n\n  }, {\n    key: \"pivotRef\",\n    get: function get() {\n      return this._pivot;\n    }\n\n    /**\n     * Gets the parent transform node, if one is attached\n     * @return {Transform2d}\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this._parent;\n    }\n  }, {\n    key: \"localXform\",\n    get: function get() {\n      this._updatelocalxform();\n      return this._localXform;\n    }\n\n    /**\n     * Gets the current global transformation matrix of the node. This is essentially\n     * its local transform multiplied against all the local transforms of its parents.\n     * This is ultimately used to convert a point from object space to world space, and\n     * inversely, from world space to object space.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"globalXform\",\n    get: function get() {\n      this._updateglobalxform();\n      return this._globalXform;\n    }\n  }], [{\n    key: \"toJSON\",\n    value: function toJSON(xformObj) {\n      // TODO(croot): How do we deal with parenting here?\n      // To properly deal with this, we may need to supply an\n      // identifier for every created object... This may likely\n      // need to be a name string supplied by the user\n      var pos = xformObj.getPositionRef();\n      var scale = xformObj.getScaleRef();\n      var pivot = xformObj.pivotRef;\n      return {\n        position: [pos[0], pos[1]],\n        scale: [scale[0], scale[1]],\n        rotation: xformObj.getRotation(),\n        pivot: [pivot[0], pivot[1]]\n      };\n    }\n  }]);\n\n  return Transform2d;\n}();\n\n/**\n * Creates a new Transform2d mixin class that is intended to be mixed in with\n * a class that inherits from the EventHandler class\n * @param  {string} eventName Type name of the event fired when the transform is modified\n * @return {function}           Mixin\n */\n\n\nexports.default = Transform2d;\nfunction createEventedTransform2dMixin(eventName) {\n  /**\n   * Transform2d modification event\n   * @event EventedTransform2d#changed\n   * @type {object}\n   * @property {string} attr Name of the attribute modified\n   * @property {} prevVal Previous value of the attribute prior to modification\n   * @property {} currVal Value of the attribute post modification\n   */\n\n  /**\n   * @mixin Transform2d mixin with event firing when modified\n   */\n  return (0, _aggregation2.default)(null, Transform2d, function () {\n    function EventedTransform2d() {\n      _classCallCheck(this, EventedTransform2d);\n    }\n\n    _createClass(EventedTransform2d, [{\n      key: \"setPosition\",\n\n\n      /**\n       * Sets the unparented position of the transform.\n       * @param {Point2d} pos\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n      value: function setPosition(pos) {\n        if (!Point2d.equals(pos, this._pos)) {\n          var prev = [this._pos[0], this._pos[1]];\n          Point2d.copy(this._pos, pos);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"position\",\n            prevVal: prev,\n            currVal: pos\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Translates the unparented position of a transform by an offset.\n       * @param  {Vec2d} translation\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"translate\",\n      value: function translate(translation) {\n        if (translation[0] || translation[1]) {\n          var prev = [this._pos[0], this._pos[1]];\n          Point2d.addVec2(this._pos, this._pos, translation);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"position\",\n            prevVal: prev,\n            currVal: [this._pos[0], this._pos[1]]\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Sets the unparented 2d scale of the transform\n       * @param {Vec2d} scale\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setScale\",\n      value: function setScale(scale) {\n        if (!_glMatrix.vec2.equals(scale, this._scale)) {\n          var prev = [this._scale[0], this._scale[1]];\n          _glMatrix.vec2.copy(this._scale, scale);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"size\",\n            prevVal: prev,\n            currVal: scale\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Multiplies the current unparented scale of the transform by a 2d scalar\n       * @param  {Vec2d} scaleMult\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"scale\",\n      value: function scale(scaleMult) {\n        if (scaleMult[0] !== 1 || scaleMult[1] !== 1) {\n          var prev = [this._scale[0], this._scale[1]];\n          _glMatrix.vec2.multiply(this._scale, this._scale, scaleMult);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"size\",\n            prevVal: prev,\n            currVal: [this._scale[0], this._scale[1]]\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Sets the unparented rotation of the transform in degrees\n       * @param {number} deg Rotation angle in degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setRotation\",\n      value: function setRotation(deg) {\n        var degToUse = deg % 360;\n        if (degToUse !== this._rotDeg) {\n          var prev = this._rotDeg;\n          this._rotDeg = degToUse;\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"orientation\",\n            prevVal: prev,\n            curral: this._rotDeg\n          });\n        }\n      }\n\n      /**\n       * Adds a rotation angle in degrees to the current unparented\n       * rotation of the transform.\n       * @param  {number} deg Additional rotation angle in degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"rotate\",\n      value: function rotate(deg) {\n        if (deg) {\n          var prev = this._rotDeg;\n          this._rotDeg += deg;\n          this._rotDeg %= 360;\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"orientation\",\n            prevVal: prev,\n            curral: this._rotDeg\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Utility function to reset all the unparented transform parameters\n       * @param {number} tx  Translation in x in world units\n       * @param {number} ty  Translation in y in world units\n       * @param {number} sx  Scale in x in world units\n       * @param {number} sy  Scale in y in world units\n       * @param {number} deg Rotation angle degrees\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n\n    }, {\n      key: \"setTransformations\",\n      value: function setTransformations(tx, ty, sx, sy, deg) {\n        var attrs = [];\n        var prevVals = [];\n        var currVals = [];\n        if (typeof tx !== \"undefined\" && typeof ty !== \"undefined\" && (!_glMatrix.glMatrix.equals(tx, this._pos[0]) || !_glMatrix.glMatrix.equals(ty, this._pos[1]))) {\n          var prev = Point2d.clone(this._pos);\n          this._pos[0] = tx;\n          this._pos[1] = ty;\n          attrs.push(\"position\");\n          prevVals.push(prev);\n          currVals.push(Point2d.clone(this._pos));\n        }\n\n        if (typeof sx !== \"undefined\" && typeof sy !== \"undefined\" && (!_glMatrix.glMatrix.equals(sx, this._scale[0]) || !_glMatrix.glMatrix.equals(sy, this._scale[1]))) {\n          var _prev = _glMatrix.vec2.clone(this._scale);\n          _glMatrix.vec2.set(this._scale, sx, sy);\n          attrs.push(\"size\");\n          prevVals.push(_prev);\n          currVals.push(_glMatrix.vec2.clone(this._scale));\n        }\n\n        if (typeof deg !== \"undefined\") {\n          var degToUse = deg % 360;\n          if (!_glMatrix.glMatrix.equals(degToUse, this._rotDeg)) {\n            var _prev2 = this._rotDeg;\n            this._rotDeg = degToUse;\n            attrs.push(\"orientation\");\n            prevVals.push(_prev2);\n            currVals.push(this._rotDeg);\n          }\n        }\n\n        if (attrs.length) {\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attrs: attrs,\n            prevVals: prevVals,\n            currVals: currVals\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"pivot\",\n\n      /**\n       * Sets the unparented pivot of the transform. The pivot is\n       * the offset from the transform's primary position where the\n       * transformation is applied.\n       * @param {Vec2d} pivot\n       * @fires  EventedTransform2d#changed\n       * @return {EventedTransform2d}\n       */\n      set: function set(pivot) {\n        if (!Point2d.equals(pivot, this._pivot)) {\n          var prev = [this._pivot[0], this._pivot[1]];\n          Point2d.copy(this._pivot, pivot);\n          this._lxformDirty = true;\n          dirtyChildren(this._children);\n          this.fire(eventName, {\n            attr: \"pivot\",\n            prevVal: prev,\n            currVal: pivot\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets a copy of the unparented pivot of the transform\n       * @return {Vec2d}\n       */\n      ,\n      get: function get() {\n        return Point2d.clone(this._pivot);\n      }\n    }]);\n\n    return EventedTransform2d;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvdHJhbnNmb3JtMmQuanM/ZDAwMiJdLCJuYW1lcyI6WyJidWlsZFhmb3JtTWF0cml4IiwiY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4iLCJQb2ludDJkIiwibWF0IiwicmRlZyIsInMiLCJ0IiwicGl2b3QiLCJpZGVudGl0eSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsIkRFR19UT19SQUQiLCJzY2FsZSIsImRpcnR5Q2hpbGRyZW4iLCJjaGlsZHJlbiIsImZvckVhY2giLCJjaGlsZCIsIl94Zm9ybURpcnR5IiwiX2NoaWxkcmVuIiwiVHJhbnNmb3JtMmQiLCJvcHRzIiwiaW5pdGlhbGl6ZXIiLCJwb3NpdGlvbiIsInNldFBvc2l0aW9uIiwic2V0U2NhbGUiLCJyb3RhdGlvbiIsInNldFJvdGF0aW9uIiwiX2xvY2FsWGZvcm0iLCJjcmVhdGUiLCJfbHhmb3JtRGlydHkiLCJfcGl2b3QiLCJfcG9zIiwiX3NjYWxlIiwiZnJvbVZhbHVlcyIsIl9yb3REZWciLCJfZ2xvYmFsWGZvcm0iLCJfcGFyZW50IiwiU2V0IiwiX2luaXRUcmFuc2Zvcm1Gcm9tT3B0aW9ucyIsImNoaWxkWGZvcm0iLCJoYXMiLCJhZGQiLCJyZW1vdmVDaGlsZCIsImRlbGV0ZSIsImNvcHkiLCJsb2NhbFhmb3JtIiwiY2xvbmUiLCJ4Zm9ybSIsImdsb2JhbFhmb3JtIiwicG9zIiwidHJhbnNsYXRpb24iLCJhZGRWZWMyIiwic2NhbGVNdWx0IiwibXVsdGlwbHkiLCJkZWciLCJfbG9jYWxYZm9ybVVwZGF0ZWQiLCJfdXBkYXRlbG9jYWx4Zm9ybSIsIl9nbG9iYWxYZm9ybVVwZGF0ZWQiLCJjdHgiLCJjdXJyTWF0cml4Iiwid29ybGRUb1NjcmVlbk1hdHJpeCIsInNldFRyYW5zZm9ybSIsIl91cGRhdGVnbG9iYWx4Zm9ybSIsInhmb3JtT2JqIiwiZ2V0UG9zaXRpb25SZWYiLCJnZXRTY2FsZVJlZiIsInBpdm90UmVmIiwiZ2V0Um90YXRpb24iLCJldmVudE5hbWUiLCJlcXVhbHMiLCJwcmV2IiwiZmlyZSIsImF0dHIiLCJwcmV2VmFsIiwiY3VyclZhbCIsImRlZ1RvVXNlIiwiY3VycmFsIiwidHgiLCJ0eSIsInN4Iiwic3kiLCJhdHRycyIsInByZXZWYWxzIiwiY3VyclZhbHMiLCJwdXNoIiwic2V0IiwibGVuZ3RoIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7UUFrQmdCQSxnQixHQUFBQSxnQjtRQTZaQUMsNkIsR0FBQUEsNkI7O0FBN2FoQjs7SUFBWUMsTzs7QUFDWjs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7O0FBV08sU0FBU0YsZ0JBQVQsQ0FBMEJHLEdBQTFCLEVBQStCQyxJQUEvQixFQUFxQ0MsQ0FBckMsRUFBd0NDLENBQXhDLEVBQTJDQyxLQUEzQyxFQUFrRDtBQUN2RCxrQkFBTUMsUUFBTixDQUFlTCxHQUFmO0FBQ0Esa0JBQU1NLFNBQU4sQ0FBZ0JOLEdBQWhCLEVBQXFCQSxHQUFyQixFQUEwQixDQUFDRyxFQUFFLENBQUYsSUFBT0MsTUFBTSxDQUFOLENBQVIsRUFBa0JELEVBQUUsQ0FBRixJQUFPQyxNQUFNLENBQU4sQ0FBekIsQ0FBMUI7QUFDQSxrQkFBTUcsTUFBTixDQUFhUCxHQUFiLEVBQWtCQSxHQUFsQixFQUF1QixlQUFLUSxVQUFMLEdBQWtCUCxJQUF6QztBQUNBLGtCQUFNUSxLQUFOLENBQVlULEdBQVosRUFBaUJBLEdBQWpCLEVBQXNCRSxDQUF0QjtBQUNBLGtCQUFNSSxTQUFOLENBQWdCTixHQUFoQixFQUFxQkEsR0FBckIsRUFBMEIsQ0FBQyxDQUFDSSxNQUFNLENBQU4sQ0FBRixFQUFZLENBQUNBLE1BQU0sQ0FBTixDQUFiLENBQTFCO0FBQ0EsU0FBT0osR0FBUDtBQUNEOztBQUVEOzs7Ozs7QUFNQSxTQUFTVSxhQUFULENBQXVCQyxRQUF2QixFQUFpQztBQUMvQkEsV0FBU0MsT0FBVCxDQUFpQixpQkFBUztBQUN4QkMsVUFBTUMsV0FBTixHQUFvQixJQUFwQjtBQUNBSixrQkFBY0csTUFBTUUs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Q25CYSx3QkFEbUI7QUFFbkJDLDhCQUZtQjtBQUduQkM7QUFIbUIsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEO0FBcE5JO0FBQUE7O0FBQ0w7Ozs7Ozs7O0FBREssd0JBU0s1RSxLQVRMLEVBU1k7QUFDZixZQUFJLENBQUNMLFFBQVFtRSxNQUFSLENBQWU5RCxLQUFmLEVBQXNCLEtBQUt1QixNQUEzQixDQUFMLEVBQXlDO0FBQ3ZDLGNBQU13QyxPQUFPLENBQUMsS0FBS3hDLE1BQUwsQ0FBWSxDQUFaLENBQUQsRUFBaUIsS0FBS0EsTUFBTCxDQUFZLENBQVosQ0FBakIsQ0FBYjtBQUNBNUIsa0JBQVEwQyxJQUFSLENBQWEsS0FBS2QsTUFBbEIsRUFBMEJ2QixLQUExQjtBQUNBLGVBQUtzQixZQUFMLEdBQW9CLElBQXBCO0FBQ0FoQix3QkFBYyxLQUFLSyxTQUFuQjtBQUNBLGVBQUtxRCxJQUFMLENBQVVILFNBQVYsRUFBcUI7QUFDbkJJLGtCQUFNLE9BRGE7QUFFbkJDLHFCQUFTSCxJQUZVO0FBR25CSSxxQkFBU25FO0FBSFUsV0FBckI7QUFLRDtBQUNELGVBQU8sSUFBUDtBQUNEOztBQUVEOzs7O0FBeEJLO0FBQUEsMEJBNEJPO0FBQ1YsZUFBT0wsUUFBUTRDLEtBQVIsQ0FBYyxLQUFLaEIsTUFBbkIsQ0FBUDtBQUNEO0FBOUJJOztBQUFBO0FBQUEsTUFBUDtBQXNORCIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIFBvaW50MmQgZnJvbSBcIi4uL2NvcmUvcG9pbnQyZFwiXG5pbXBvcnQge2dsTWF0cml4IGFzIEdMTWF0cml4LCBtYXQyZCBhcyBNYXQyZCwgdmVjMiBhcyBWZWMyZH0gZnJvbSBcImdsLW1hdHJpeFwiXG5pbXBvcnQgYWdncmVnYXRpb24gZnJvbSBcIi4uL3V0aWwvYWdncmVnYXRpb25cIlxuaW1wb3J0IE1hdGggZnJvbSBcIi4uL21hdGgvbWF0aFwiXG5cbi8qKlxuICogQnVpbGRzIGEgMkQgdHJhbnNmb3JtYXRpb24gbWF0cml4ICgyeDMgbWF0cml4KSBmcm9tIGEgcm90YXRpb24gKGluIGRlZ3JlZXMpLFxuICogYW4geCx5IHNjYWxlLCBhIHRyYW5zbGF0aW9uLCBhbmQgYSBwaXZvdCAoYW4gb2Zmc2V0IGZyb20gdGhlIG9yaWdpbiB0b1xuICogYXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uIGFyb3VuZClcbiAqIEBwYXJhbSAge01hdDJkfSBtYXQgICBNYXRyaXggdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgb3BlcmF0aW9uXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHJkZWcgIHJvdGF0aW9uLCBpbiBkZWdyZWVzXG4gKiBAcGFyYW0gIHtWZWMyZH0gcyAgICAgU2NhbGUgdmVjdG9yLCBpbiB4ICYgeVxuICogQHBhcmFtICB7VmVjMmR9IHQgICAgIFRyYW5zbGF0aW9uIHZlY3RvciwgaW4geCAmIHlcbiAqIEBwYXJhbSAge1ZlYzJkfSBwaXZvdCBPZmZzZXQgZnJvbSBvcmlnaW4gdG8gYXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uXG4gKiBAcmV0dXJuIHtNYXQyZH0gICAgICAgTWF0cml4IHJlZmVyZW5jZWQgYnkgdGhlIG1hdCBhcmd1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRYZm9ybU1hdHJpeChtYXQsIHJkZWcsIHMsIHQsIHBpdm90KSB7XG4gIE1hdDJkLmlkZW50aXR5KG1hdClcbiAgTWF0MmQudHJhbnNsYXRlKG1hdCwgbWF0LCBbdFswXSArIHBpdm90WzBdLCB0WzFdICsgcGl2b3RbMV1dKVxuICBNYXQyZC5yb3RhdGUobWF0LCBtYXQsIE1hdGguREVHX1RPX1JBRCAqIHJkZWcpXG4gIE1hdDJkLnNjYWxlKG1hdCwgbWF0LCBzKVxuICBNYXQyZC50cmFuc2xhdGUobWF0LCBtYXQsIFstcGl2b3RbMF0sIC1waXZvdFsxXV0pXG4gIHJldHVybiBtYXRcbn1cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIGRpcnR5IGFsbCB0aGUgZGVzY2VuZGFudHMgb2YgYSB0cmFuc2Zvcm0gbm9kZS5cbiAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB0cmFuc2Zvcm0gbm9kZSBoYXMgYmVlbiBtb2RpZmllZCBpbiBzb21lIHdheVxuICogdGhhdCBpdCdzIGNoaWxkcmVuIG5lZWQgdG8gYmUgbm90aWZpZWQgYWJvdXQuXG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm0yZFtdfSBjaGlsZHJlblxuICovXG5mdW5jdGlvbiBkaXJ0eUNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGNoaWxkLl94Zm9ybURpcnR5ID0gdHJ1ZVxuICAgIGRpcnR5Q2hpbGRyZW4oY2hpbGQuX2NoaWxkcmVuKVxuICB9KVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zZm9ybTJkT3B0aW9uc1xuICogQHByb3BlcnR5IHtQb2ludDJkfSBbcG9zaXRpb24gPSBbMCwwXV0gUG9zaXRpb24gaW4gd29ybGQgc3BhY2UgY29vcmRzXG4gKiBAcHJvcGVydHkge1ZlYzJkfSBbc2NhbGUgPSBbMSwxXV0gU2NhbGUgaW4gd29ybGQgc3BhY2UgY29vcmRzXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JvdGF0aW9uID0gMF0gUm90YXRpb24gaW4gZGVncmVlc1xuICogQHByb3BlcnR5IHtWZWMyZH0gW3Bpdm90ID0gWzAsIDBdXSBPZmZzZXQgZnJvbSBvcmlnaW4gdG8gYXBwbHkgdGhlIHNldFRyYW5zZm9ybWF0aW9uc1xuICovXG5cbi8qKlxuICogQGNsYXNzIENsYXNzIHRvIG1hbmFnZSBiYXNpYyAyZCBhZmZpbmUgdHJhbnNmb3JtYXRpb25zXG4gKiBAbWl4aW4gQ2FuIGFsc28gYmUgdXNlZCBhcyBhIG1peGluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRyYW5zZm9ybTJkIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVHJhbnNmb3JtMmRcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmRPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihvcHRzKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgdHJhbnNmb3JtIDJkIG9iamVjdCBmcm9tIG9wdGlvbnNcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmRPcHRpb25zfSBbb3B0c11cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pbml0VHJhbnNmb3JtRnJvbU9wdGlvbnMob3B0cykge1xuICAgIGlmICghb3B0cykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBvc2l0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFBvc2l0aW9uKG9wdHMucG9zaXRpb24pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnNjYWxlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFNjYWxlKG9wdHMuc2NhbGUpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnJvdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnNldFJvdGF0aW9uKG9wdHMucm90YXRpb24pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBpdm90ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLnBpdm90ID0gb3B0cy5waXZvdFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIHRyYW5zZm9ybSAyZCBvYmplY3QgZnJvbSBvcHRpb25zLFxuICAgKiBjYWxsZWQgZnJvbSBlaXRoZXIgY29uc3RydWN0b3IgKGlmIHVzZWQgYXMgYmFzZSBjbGFzcylcbiAgICogb3IgYmFzZSBtaXhpbiBjbGFzcyAoaWYgdXNlZCBhcyBhIG1peGluKVxuICAgKiBAcGFyYW0gIHtUcmFuc2Zvcm0yZE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgdGhpcy5fbG9jYWxYZm9ybSA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fbHhmb3JtRGlydHkgPSBmYWxzZVxuXG4gICAgdGhpcy5fcGl2b3QgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuXG4gICAgdGhpcy5fcG9zID0gUG9pbnQyZC5jcmVhdGUoMCwgMClcbiAgICB0aGlzLl9zY2FsZSA9IFZlYzJkLmZyb21WYWx1ZXMoMSwgMSlcbiAgICB0aGlzLl9yb3REZWcgPSAwXG5cbiAgICB0aGlzLl9nbG9iYWxYZm9ybSA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5feGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IFNldCgpXG5cbiAgICB0aGlzLl9pbml0VHJhbnNmb3JtRnJvbU9wdGlvbnMob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhpcyB0cmFuc2Zvcm0gbm9kZVxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybTJkfSBjaGlsZFhmb3JtXG4gICAqL1xuICBhZGRDaGlsZFhmb3JtKGNoaWxkWGZvcm0pIHtcbiAgICBpZiAoIXRoaXMuX2NoaWxkcmVuLmhhcyhjaGlsZFhmb3JtKSkge1xuICAgICAgdGhpcy5fY2hpbGRyZW4uYWRkKGNoaWxkWGZvcm0pXG4gICAgICBpZiAoY2hpbGRYZm9ybS5fcGFyZW50KSB7XG4gICAgICAgIGNoaWxkWGZvcm0uX3BhcmVudC5yZW1vdmVDaGlsZChjaGlsZFhmb3JtKVxuICAgICAgfVxuICAgICAgY2hpbGRYZm9ybS5fcGFyZW50ID0gdGhpc1xuICAgICAgY2hpbGRYZm9ybS5feGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgIGRpcnR5Q2hpbGRyZW4oY2hpbGRYZm9ybS5fY2hpbGRyZW4pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoaXMgdHJhbnNmb3JtIG5vZGVcbiAgICogQHBhcmFtICB7VHJhbnNmb3JtMmR9IGNoaWxkWGZvcm1cbiAgICovXG4gIHJlbW92ZUNoaWxkWGZvcm0oY2hpbGRYZm9ybSkge1xuICAgIHRoaXMuX2NoaWxkcmVuLmRlbGV0ZShjaGlsZFhmb3JtKVxuICB9XG5cbiAgLyoqXG4gICAqIFVucGFyZW50cyB0aGlzIG5vZGUgZnJvbSBpdHMgcGFyZW50LCBpZiBpdCBoYXMgb25lXG4gICAqL1xuICB1bnBhcmVudFhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKVxuICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbFxuICAgICAgTWF0MmQuY29weSh0aGlzLl9nbG9iYWxYZm9ybSwgdGhpcy5sb2NhbFhmb3JtKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwaXZvdCBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEBwYXJhbSAge1ZlYzJkfSBwaXZvdCBPZmZzZXQgdmVjdG9yIGZyb20gdGhlIG9yaWdpbiB0byBhcHBseSB0aGUgdHJhbnNmb3JtYXRpb25zXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgc2V0IHBpdm90KHBpdm90KSB7XG4gICAgUG9pbnQyZC5jb3B5KHRoaXMuX3Bpdm90LCBwaXZvdClcbiAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBwaXZvdCBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge1ZlYzJkfVxuICAgKi9cbiAgZ2V0IHBpdm90KCkge1xuICAgIHJldHVybiBQb2ludDJkLmNsb25lKHRoaXMuX3Bpdm90KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcGl2b3QgcmVmZXJlbmNlIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGdldCBwaXZvdFJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGl2b3RcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBwYXJlbnQgdHJhbnNmb3JtIG5vZGUsIGlmIG9uZSBpcyBhdHRhY2hlZFxuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm0yZH1cbiAgICovXG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCBwb3NpdGlvbiBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge1BvaW50MmR9IFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBub2RlIGFzIGlmIGl0IHdlcmUgdW5wYXJlbnRlZFxuICAgKi9cbiAgZ2V0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIFZlYzJkLmNsb25lKHRoaXMuX3BvcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZWZlcmVuY2UgdG8gdGhlIHVucGFyZW50ZWQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSwgYXZvaWRpbmdcbiAgICogYSBjb3B5XG4gICAqIEByZXR1cm4ge1BvaW50MmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0UG9zaXRpb25SZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Bvc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSwgdGhpcyBpcyBpdHMgcG9zaXRpb25cbiAgICogYWZ0ZXIgYWxsIHBhcmVudCB0cmFuc2Zvcm1hdGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICogQHJldHVybiB7UG9pbnQyZH1cbiAgICovXG4gIGdldFdvcmxkUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeGZvcm0gPSB0aGlzLmdsb2JhbFhmb3JtXG4gICAgcmV0dXJuIFBvaW50MmQuY3JlYXRlKHhmb3JtWzRdLCB4Zm9ybVs1XSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtQb2ludDJkfSBwb3NcbiAgICovXG4gIHNldFBvc2l0aW9uKHBvcykge1xuICAgIFBvaW50MmQuY29weSh0aGlzLl9wb3MsIHBvcylcbiAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zbGF0ZXMgdGhlIHVucGFyZW50ZWQgd29ybGQgcG9zaXRpb24gb2YgdGhlIHRyYW5zZm9ybSBieSBhbiBvZmZzZXRcbiAgICogQHBhcmFtICB7VmVjMmR9IHRyYW5zbGF0aW9uXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgdHJhbnNsYXRlKHRyYW5zbGF0aW9uKSB7XG4gICAgaWYgKHRyYW5zbGF0aW9uWzBdIHx8IHRyYW5zbGF0aW9uWzFdKSB7XG4gICAgICBQb2ludDJkLmFkZFZlYzIodGhpcy5fcG9zLCB0aGlzLl9wb3MsIHRyYW5zbGF0aW9uKVxuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCB4LHkgc2NhbGUgb2YgdGhlIHRyYW5zZm9ybVxuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICovXG4gIGdldFNjYWxlKCkge1xuICAgIHJldHVybiBWZWMyZC5jbG9uZSh0aGlzLl9zY2FsZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVucGFyZW50ZWQgeC95IHNjYWxlIHJlZmVyZW5jZSBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIGF2b2lkaW5nIGEgY29weVxuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBnZXRTY2FsZVJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGVcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtWZWMyZH0gc2NhbGVcbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICBzZXRTY2FsZShzY2FsZSkge1xuICAgIFZlYzJkLmNvcHkodGhpcy5fc2NhbGUsIHNjYWxlKVxuICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBTY2FsZXMgdGhlIGN1cnJlbnQgdW5wYXJlbnRlZCBzY2FsZSBieSBhIDJkIG11bHRpcGxpZXJcbiAgICogQHBhcmFtICB7VmVjMmR9IHNjYWxlTXVsdFxuICAgKiBAcmV0dXJuIHtUcmFuc2Zvcm0yZH1cbiAgICovXG4gIHNjYWxlKHNjYWxlTXVsdCkge1xuICAgIGlmIChzY2FsZU11bHRbMF0gIT09IDEgfHwgc2NhbGVNdWx0WzFdICE9PSAxKSB7XG4gICAgICBWZWMyZC5tdWx0aXBseSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHNjYWxlTXVsdClcbiAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVucGFyZW50ZWQgcm90YXRpb24gaW4gZGVncmVlcyBvZiB0aGUgdHJhbnNmb3JtXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJvdGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yb3REZWdcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHJvdGF0aW9uIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyBSb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAqIEByZXR1cm4ge1RyYW5zZm9ybTJkfVxuICAgKi9cbiAgc2V0Um90YXRpb24oZGVnKSB7XG4gICAgdGhpcy5fcm90RGVnID0gZGVnXG4gICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gYWRkaXRpb25hbCByb3RhdGlvbiBpbiBkZWdyZWVzIHRvIHRoZSBjdXJyZW50IHJvdGF0aW9uXG4gICAqIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICogQHBhcmFtICB7bnVtYmVyfSBkZWcgUm90YXRpb24gb2Zmc2V0IGluIGRlZ3JlZXNcbiAgICogQHJldHVybiB7VHJhbnNmb3JtMmR9XG4gICAqL1xuICByb3RhdGUoZGVnKSB7XG4gICAgaWYgKGRlZykge1xuICAgICAgdGhpcy5fcm90RGVnICs9IGRlZ1xuICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZGlydHkgYWxsIHRoZSBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kaXJ0eUNoaWxkcmVuKCkge1xuICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgbG9jYWwgYWZmaW5lIG1hdHJpeCBpZiBtYXJrZWQgYXMgZGlydHlcbiAgICogSWYgZGVyaXZlZC9taXhpbiBjbGFzc2VzIGhhdmUgYSBfbG9jYWxYZm9ybVVwZGF0ZXMgbWV0aG9kXG4gICAqIGRlZmluZWQsIHRoYXQgd2lsbCBiZSBjYWxsZWQgaGVyZSB3aGVuIHRoZSBsb2NhbCB0cmFuc2Zvcm1cbiAgICogaXMgdXBkYXRlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGVsb2NhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSkge1xuICAgICAgYnVpbGRYZm9ybU1hdHJpeCh0aGlzLl9sb2NhbFhmb3JtLCB0aGlzLl9yb3REZWcsIHRoaXMuX3NjYWxlLCB0aGlzLl9wb3MsIHRoaXMuX3Bpdm90KVxuICAgICAgaWYgKHRoaXMuX2xvY2FsWGZvcm1VcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsWGZvcm1VcGRhdGVkKClcbiAgICAgIH1cbiAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgZ2xvYmFsIDJ4MyBtYXRyaXggb2YgdGhlIHRyYW5zZm9ybSBpZiBtYXJrZWQgZGlydHlcbiAgICogSWYgZGVyaXZlZC9taXhpbiBjbGFzc2VzIGhhdmUgYSBfZ2xvYmFsWGZvcm1VcGRhdGVzIG1ldGhvZFxuICAgKiBkZWZpbmVkLCB0aGF0IHdpbGwgYmUgY2FsbGVkIGhlcmUgd2hlbiB0aGUgZ2xvYmFsIHRyYW5zZm9ybVxuICAgKiBpcyB1cGRhdGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZWdsb2JhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCB0aGlzLl94Zm9ybURpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVsb2NhbHhmb3JtKClcbiAgICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgTWF0MmQubXVsdGlwbHkodGhpcy5fZ2xvYmFsWGZvcm0sIHRoaXMuX3BhcmVudC5nbG9iYWxYZm9ybSwgdGhpcy5fbG9jYWxYZm9ybSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1hdDJkLmNvcHkodGhpcy5fZ2xvYmFsWGZvcm0sIHRoaXMuX2xvY2FsWGZvcm0pXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fZ2xvYmFsWGZvcm1VcGRhdGVkKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbFhmb3JtVXBkYXRlZCgpXG4gICAgICB9XG4gICAgICB0aGlzLl94Zm9ybURpcnR5ID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBsb2NhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IGxvY2FsWGZvcm0oKSB7XG4gICAgdGhpcy5fdXBkYXRlbG9jYWx4Zm9ybSgpXG4gICAgcmV0dXJuIHRoaXMuX2xvY2FsWGZvcm1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIG5vZGUuIFRoaXMgaXMgZXNzZW50aWFsbHlcbiAgICogaXRzIGxvY2FsIHRyYW5zZm9ybSBtdWx0aXBsaWVkIGFnYWluc3QgYWxsIHRoZSBsb2NhbCB0cmFuc2Zvcm1zIG9mIGl0cyBwYXJlbnRzLlxuICAgKiBUaGlzIGlzIHVsdGltYXRlbHkgdXNlZCB0byBjb252ZXJ0IGEgcG9pbnQgZnJvbSBvYmplY3Qgc3BhY2UgdG8gd29ybGQgc3BhY2UsIGFuZFxuICAgKiBpbnZlcnNlbHksIGZyb20gd29ybGQgc3BhY2UgdG8gb2JqZWN0IHNwYWNlLlxuICAgKiBAcmV0dXJuIHtNYXQyZH1cbiAgICovXG4gIGdldCBnbG9iYWxYZm9ybSgpIHtcbiAgICB0aGlzLl91cGRhdGVnbG9iYWx4Zm9ybSgpXG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbFhmb3JtXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIHN0YXRlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHBhcmFtICB7TWF0MmR9IGN1cnJNYXRyaXggICAgICAgICAgVGhlIGN1cnJlbnQgbWF0cml4IHVzZWQgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWwtdmlldy1wcm9qZWN0aW9uLXNjcmVlbiBtYXRyaXggbXVsdGlwbGljYXRpb24gZm9yIHRoaXMgbm9kZVxuICAgKiBAcGFyYW0gIHtNYXQyZH0gd29ybGRUb1NjcmVlbk1hdHJpeCBUaGUgY3VycmVudCB3b3JsZC10by1zY3JlZW4gdHJhbmZvcm1cbiAgICovXG4gIHRyYW5zZm9ybUN0eChjdHgsIGN1cnJNYXRyaXgsIHdvcmxkVG9TY3JlZW5NYXRyaXgpIHtcbiAgICBNYXQyZC5tdWx0aXBseShjdXJyTWF0cml4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLmdsb2JhbFhmb3JtKVxuXG4gICAgY3R4LnNldFRyYW5zZm9ybShjdXJyTWF0cml4WzBdLFxuICAgICAgY3Vyck1hdHJpeFsxXSxcbiAgICAgIGN1cnJNYXRyaXhbMl0sXG4gICAgICBjdXJyTWF0cml4WzNdLFxuICAgICAgY3Vyck1hdHJpeFs0XSxcbiAgICAgIGN1cnJNYXRyaXhbNV0pXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBUcmFuc2Zvcm0yZCBpbnN0YW5jZSB0byBhIEpTT04gb2JqZWN0XG4gICAqIEBwYXJhbSAge1RyYW5zZm9ybTJkfSB4Zm9ybU9ialxuICAgKiBAcmV0dXJuIHt7cG9zaXRpb246IFBvaW50MmQsIHNjYWxlOiBWZWMyZCwgcm90YXRpb246IG51bWJlciwgcGl2b3Q6IFZlYzJkfX1cbiAgICovXG4gIHN0YXRpYyB0b0pTT04oeGZvcm1PYmopIHtcbiAgICAvLyBUT0RPKGNyb290KTogSG93IGRvIHdlIGRlYWwgd2l0aCBwYXJlbnRpbmcgaGVyZT9cbiAgICAvLyBUbyBwcm9wZXJseSBkZWFsIHdpdGggdGhpcywgd2UgbWF5IG5lZWQgdG8gc3VwcGx5IGFuXG4gICAgLy8gaWRlbnRpZmllciBmb3IgZXZlcnkgY3JlYXRlZCBvYmplY3QuLi4gVGhpcyBtYXkgbGlrZWx5XG4gICAgLy8gbmVlZCB0byBiZSBhIG5hbWUgc3RyaW5nIHN1cHBsaWVkIGJ5IHRoZSB1c2VyXG4gICAgY29uc3QgcG9zID0geGZvcm1PYmouZ2V0UG9zaXRpb25SZWYoKVxuICAgIGNvbnN0IHNjYWxlID0geGZvcm1PYmouZ2V0U2NhbGVSZWYoKVxuICAgIGNvbnN0IHBpdm90ID0geGZvcm1PYmoucGl2b3RSZWZcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IFtwb3NbMF0sIHBvc1sxXV0sXG4gICAgICBzY2FsZTogW3NjYWxlWzBdLCBzY2FsZVsxXV0sXG4gICAgICByb3RhdGlvbjogeGZvcm1PYmouZ2V0Um90YXRpb24oKSxcbiAgICAgIHBpdm90OiBbcGl2b3RbMF0sIHBpdm90WzFdXVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVHJhbnNmb3JtMmQgbWl4aW4gY2xhc3MgdGhhdCBpcyBpbnRlbmRlZCB0byBiZSBtaXhlZCBpbiB3aXRoXG4gKiBhIGNsYXNzIHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgRXZlbnRIYW5kbGVyIGNsYXNzXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGV2ZW50TmFtZSBUeXBlIG5hbWUgb2YgdGhlIGV2ZW50IGZpcmVkIHdoZW4gdGhlIHRyYW5zZm9ybSBpcyBtb2RpZmllZFxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgICBNaXhpblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW4oZXZlbnROYW1lKSB7XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0yZCBtb2RpZmljYXRpb24gZXZlbnRcbiAgICogQGV2ZW50IEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBtb2RpZmllZFxuICAgKiBAcHJvcGVydHkge30gcHJldlZhbCBQcmV2aW91cyB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlIHByaW9yIHRvIG1vZGlmaWNhdGlvblxuICAgKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAbWl4aW4gVHJhbnNmb3JtMmQgbWl4aW4gd2l0aCBldmVudCBmaXJpbmcgd2hlbiBtb2RpZmllZFxuICAgKi9cbiAgcmV0dXJuIGFnZ3JlZ2F0aW9uKG51bGwsIFRyYW5zZm9ybTJkLCBjbGFzcyBFdmVudGVkVHJhbnNmb3JtMmQge1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVucGFyZW50ZWQgcGl2b3Qgb2YgdGhlIHRyYW5zZm9ybS4gVGhlIHBpdm90IGlzXG4gICAgICogdGhlIG9mZnNldCBmcm9tIHRoZSB0cmFuc2Zvcm0ncyBwcmltYXJ5IHBvc2l0aW9uIHdoZXJlIHRoZVxuICAgICAqIHRyYW5zZm9ybWF0aW9uIGlzIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtWZWMyZH0gcGl2b3RcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHNldCBwaXZvdChwaXZvdCkge1xuICAgICAgaWYgKCFQb2ludDJkLmVxdWFscyhwaXZvdCwgdGhpcy5fcGl2b3QpKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fcGl2b3RbMF0sIHRoaXMuX3Bpdm90WzFdXVxuICAgICAgICBQb2ludDJkLmNvcHkodGhpcy5fcGl2b3QsIHBpdm90KVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwicGl2b3RcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IHBpdm90XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBjb3B5IG9mIHRoZSB1bnBhcmVudGVkIHBpdm90IG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICAgKi9cbiAgICBnZXQgcGl2b3QoKSB7XG4gICAgICByZXR1cm4gUG9pbnQyZC5jbG9uZSh0aGlzLl9waXZvdClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIHBvc2l0aW9uIG9mIHRoZSB0cmFuc2Zvcm0uXG4gICAgICogQHBhcmFtIHtQb2ludDJkfSBwb3NcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHNldFBvc2l0aW9uKHBvcykge1xuICAgICAgaWYgKCFQb2ludDJkLmVxdWFscyhwb3MsIHRoaXMuX3BvcykpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IFt0aGlzLl9wb3NbMF0sIHRoaXMuX3Bvc1sxXV1cbiAgICAgICAgUG9pbnQyZC5jb3B5KHRoaXMuX3BvcywgcG9zKVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwicG9zaXRpb25cIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IHBvc1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSB1bnBhcmVudGVkIHBvc2l0aW9uIG9mIGEgdHJhbnNmb3JtIGJ5IGFuIG9mZnNldC5cbiAgICAgKiBAcGFyYW0gIHtWZWMyZH0gdHJhbnNsYXRpb25cbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh0cmFuc2xhdGlvbikge1xuICAgICAgaWYgKHRyYW5zbGF0aW9uWzBdIHx8IHRyYW5zbGF0aW9uWzFdKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fcG9zWzBdLCB0aGlzLl9wb3NbMV1dXG4gICAgICAgIFBvaW50MmQuYWRkVmVjMih0aGlzLl9wb3MsIHRoaXMuX3BvcywgdHJhbnNsYXRpb24pXG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJwb3NpdGlvblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VyclZhbDogW3RoaXMuX3Bvc1swXSwgdGhpcy5fcG9zWzFdXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB1bnBhcmVudGVkIDJkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge1ZlYzJkfSBzY2FsZVxuICAgICAqIEBmaXJlcyAgRXZlbnRlZFRyYW5zZm9ybTJkI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gICAgICovXG4gICAgc2V0U2NhbGUoc2NhbGUpIHtcbiAgICAgIGlmICghVmVjMmQuZXF1YWxzKHNjYWxlLCB0aGlzLl9zY2FsZSkpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IFt0aGlzLl9zY2FsZVswXSwgdGhpcy5fc2NhbGVbMV1dXG4gICAgICAgIFZlYzJkLmNvcHkodGhpcy5fc2NhbGUsIHNjYWxlKVxuICAgICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IHRydWVcbiAgICAgICAgZGlydHlDaGlsZHJlbih0aGlzLl9jaGlsZHJlbilcbiAgICAgICAgdGhpcy5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwic2l6ZVwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VyclZhbDogc2NhbGVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCB1bnBhcmVudGVkIHNjYWxlIG9mIHRoZSB0cmFuc2Zvcm0gYnkgYSAyZCBzY2FsYXJcbiAgICAgKiBAcGFyYW0gIHtWZWMyZH0gc2NhbGVNdWx0XG4gICAgICogQGZpcmVzICBFdmVudGVkVHJhbnNmb3JtMmQjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAgICAgKi9cbiAgICBzY2FsZShzY2FsZU11bHQpIHtcbiAgICAgIGlmIChzY2FsZU11bHRbMF0gIT09IDEgfHwgc2NhbGVNdWx0WzFdICE9PSAxKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBbdGhpcy5fc2NhbGVbMF0sIHRoaXMuX3NjYWxlWzFdXVxuICAgICAgICBWZWMyZC5tdWx0aXBseSh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUsIHNjYWxlTXVsdClcbiAgICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICBhdHRyOiBcInNpemVcIixcbiAgICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICAgIGN1cnJWYWw6IFt0aGlzLl9zY2FsZVswXSwgdGhpcy5fc2NhbGVbMV1dXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHVucGFyZW50ZWQgcm90YXRpb24gb2YgdGhlIHRyYW5zZm9ybSBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlZyBSb3RhdGlvbiBhbmdsZSBpbiBkZWdyZWVzXG4gICAgICogQGZpcmVzICBFdmVudGVkVHJhbnNmb3JtMmQjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0V2ZW50ZWRUcmFuc2Zvcm0yZH1cbiAgICAgKi9cbiAgICBzZXRSb3RhdGlvbihkZWcpIHtcbiAgICAgIGNvbnN0IGRlZ1RvVXNlID0gZGVnICUgMzYwXG4gICAgICBpZiAoZGVnVG9Vc2UgIT09IHRoaXMuX3JvdERlZykge1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5fcm90RGVnXG4gICAgICAgIHRoaXMuX3JvdERlZyA9IGRlZ1RvVXNlXG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cjogXCJvcmllbnRhdGlvblwiLFxuICAgICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgICAgY3VycmFsOiB0aGlzLl9yb3REZWdcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcm90YXRpb24gYW5nbGUgaW4gZGVncmVlcyB0byB0aGUgY3VycmVudCB1bnBhcmVudGVkXG4gICAgICogcm90YXRpb24gb2YgdGhlIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGRlZyBBZGRpdGlvbmFsIHJvdGF0aW9uIGFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRUcmFuc2Zvcm0yZCNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7RXZlbnRlZFRyYW5zZm9ybTJkfVxuICAgICAqL1xuICAgIHJvdGF0ZShkZWcpIHtcbiAgICAgIGlmIChkZWcpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3JvdERlZ1xuICAgICAgICB0aGlzLl9yb3REZWcgKz0gZGVnXG4gICAgICAgIHRoaXMuX3JvdERlZyAlPSAzNjBcbiAgICAgICAgdGhpcy5fbHhmb3JtRGlydHkgPSB0cnVlXG4gICAgICAgIGRpcnR5Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pXG4gICAgICAgIHRoaXMuZmlyZShldmVudE5hbWUsIHtcbiAgICAgICAgICBhdHRyOiBcIm9yaWVudGF0aW9uXCIsXG4gICAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgICBjdXJyYWw6IHRoaXMuX3JvdERlZ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVdGlsaXR5IGZ1bmN0aW9uIHRvIHJlc2V0IGFsbCB0aGUgdW5wYXJlbnRlZCB0cmFuc2Zvcm0gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAgVHJhbnNsYXRpb24gaW4geCBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAgVHJhbnNsYXRpb24gaW4geSBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeCAgU2NhbGUgaW4geCBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzeSAgU2NhbGUgaW4geSBpbiB3b3JsZCB1bml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWcgUm90YXRpb24gYW5nbGUgZGVncmVlc1xuICAgICAqIEBmaXJlcyAgRXZlbnRlZFRyYW5zZm9ybTJkI2NoYW5nZWRcbiAgICAgKiBAcmV0dXJuIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtYXRpb25zKHR4LCB0eSwgc3gsIHN5LCBkZWcpIHtcbiAgICAgIGNvbnN0IGF0dHJzID0gW11cbiAgICAgIGNvbnN0IHByZXZWYWxzID0gW11cbiAgICAgIGNvbnN0IGN1cnJWYWxzID0gW11cbiAgICAgIGlmICh0eXBlb2YgdHggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHR5ICE9PSBcInVuZGVmaW5lZFwiICYmICghR0xNYXRyaXguZXF1YWxzKHR4LCB0aGlzLl9wb3NbMF0pIHx8ICFHTE1hdHJpeC5lcXVhbHModHksIHRoaXMuX3Bvc1sxXSkpKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBQb2ludDJkLmNsb25lKHRoaXMuX3BvcylcbiAgICAgICAgdGhpcy5fcG9zWzBdID0gdHhcbiAgICAgICAgdGhpcy5fcG9zWzFdID0gdHlcbiAgICAgICAgYXR0cnMucHVzaChcInBvc2l0aW9uXCIpXG4gICAgICAgIHByZXZWYWxzLnB1c2gocHJldilcbiAgICAgICAgY3VyclZhbHMucHVzaChQb2ludDJkLmNsb25lKHRoaXMuX3BvcykpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc3ggIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHN5ICE9PSBcInVuZGVmaW5lZFwiICYmICghR0xNYXRyaXguZXF1YWxzKHN4LCB0aGlzLl9zY2FsZVswXSkgfHwgIUdMTWF0cml4LmVxdWFscyhzeSwgdGhpcy5fc2NhbGVbMV0pKSkge1xuICAgICAgICBjb25zdCBwcmV2ID0gVmVjMmQuY2xvbmUodGhpcy5fc2NhbGUpXG4gICAgICAgIFZlYzJkLnNldCh0aGlzLl9zY2FsZSwgc3gsIHN5KVxuICAgICAgICBhdHRycy5wdXNoKFwic2l6ZVwiKVxuICAgICAgICBwcmV2VmFscy5wdXNoKHByZXYpXG4gICAgICAgIGN1cnJWYWxzLnB1c2goVmVjMmQuY2xvbmUodGhpcy5fc2NhbGUpKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRlZyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBkZWdUb1VzZSA9IGRlZyAlIDM2MFxuICAgICAgICBpZiAoIUdMTWF0cml4LmVxdWFscyhkZWdUb1VzZSwgdGhpcy5fcm90RGVnKSkge1xuICAgICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLl9yb3REZWdcbiAgICAgICAgICB0aGlzLl9yb3REZWcgPSBkZWdUb1VzZVxuICAgICAgICAgIGF0dHJzLnB1c2goXCJvcmllbnRhdGlvblwiKVxuICAgICAgICAgIHByZXZWYWxzLnB1c2gocHJldilcbiAgICAgICAgICBjdXJyVmFscy5wdXNoKHRoaXMuX3JvdERlZylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYXR0cnMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2x4Zm9ybURpcnR5ID0gdHJ1ZVxuICAgICAgICBkaXJ0eUNoaWxkcmVuKHRoaXMuX2NoaWxkcmVuKVxuICAgICAgICB0aGlzLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgYXR0cnMsXG4gICAgICAgICAgcHJldlZhbHMsXG4gICAgICAgICAgY3VyclZhbHNcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9KVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3RyYW5zZm9ybTJkLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n  @typedef EventObject\n  @type {object}\n  @property {string} type - the type of the event\n  @property {string} target - the target object that fired the event\n /\n\n/**\n * This callback is displayed as a global member.\n * @callback EventCallback\n * @param {EventObject} Event object describing the event being fired\n */\n\n/**\n * Recursively fires hierarchical events from an handler's registered\n * event types. For example, if an event is registered as \"changed:color\",\n * both a \"changed:color\" and \"changed\" event is fired, so listeners who\n * only generically care if something changed on an object can be notified.\n * @param  {Map} currMap  map datastructure holding all hierarchical events and callbacks\n * @param  {string[]} subtypes the \":\" separated list of the event\n * @param  {number} currIdx  the current index of subtypes being processed\n * @param  {Object} fireData the event object to fire\n * @return {number}          total number of listeners called\n * @private\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction recursiveFire(currMap, subtypes, currIdx, fireData) {\n  var _this = this;\n\n  if (currIdx >= subtypes.length) {\n    return 0;\n  }\n\n  var cnt = 0;\n  var data = null;\n  data = currMap.get(subtypes[currIdx]);\n  if (data) {\n    cnt = recursiveFire(data[0], subtypes, currIdx + 1, fireData);\n    data[1].forEach(function (listener) {\n      return listener.call(_this, fireData);\n    });\n    cnt += data[1].length;\n  }\n  return cnt;\n}\n\n/**\n * Recursively deletes specific listeners from a handlers event\n * data structure. For instance, if the same callback is used for both\n * a \"changed\" and a \"changed:color\" event, and that callback is deleted\n * from the \"changed\" event, it is also deleted from the \"changed:color\" event\n * @param  {Object} currNode  Current node of the map data structure being processed\n * @param  {function[]} listeners Array of listeners to delete\n * @private\n */\nfunction recursiveDelete(currNode, listeners) {\n  var index = -1;\n  var subnodes = currNode[0];\n  var nodelisteners = currNode[1];\n  if (nodelisteners.length) {\n    listeners.forEach(function (listener) {\n      if ((index = nodelisteners.indexOf(listener)) >= 0) {\n        nodelisteners.splice(index, 1);\n      }\n    });\n  }\n  subnodes.forEach(function (node) {\n    recursiveDelete(node, listeners);\n  });\n}\n\n/**\n * Validates that an input is a string or an array of strings, and if the former\n * returns a 1-element string array\n * @param  {string|string[]} intype\n * @return {string[]}\n * @private\n */\nfunction arrayify(intype) {\n  var arrayToUse = intype;\n  if (typeof intype === \"string\") {\n    arrayToUse = [intype];\n  } else if (!Array.isArray(intype)) {\n    throw new Error(\"Input must be an array of strings\");\n  }\n  return arrayToUse;\n}\n\n/** Class for managing events and listeners. Can be used as a base class or a mixin (using @see {@link aggregation}) */\n\nvar EventHandler = function () {\n\n  /**\n   * Create a new event handler\n   * @param  {string|string[]} eventsToRegister initial events to register\n   */\n  function EventHandler(eventsToRegister) {\n    _classCallCheck(this, EventHandler);\n\n    this.initializer(eventsToRegister);\n  }\n\n  /**\n   * Initializes an event handler object\n   * @param  {string|string[]} eventsToRegister events to initialize event handler with\n   * @see  {@link aggregation}\n   */\n\n\n  _createClass(EventHandler, [{\n    key: \"initializer\",\n    value: function initializer(eventsToRegister) {\n      this._listeners = new Map();\n      this.registerEvents(eventsToRegister);\n    }\n\n    /**\n     * Registers new events for the event handler\n     * @param  {string|string[]} events new event(s) to register\n     */\n\n  }, {\n    key: \"registerEvents\",\n    value: function registerEvents(events) {\n      var _this2 = this;\n\n      if (!events) {\n        return;\n      }\n\n      var eventsToUse = arrayify(events);\n      if (typeof events === \"string\") {\n        eventsToUse = [events];\n      } else if (!Array.isArray(events)) {\n        throw new Error(\"Events must be an array of strings\");\n      }\n\n      eventsToUse.forEach(function (event) {\n        var subevents = event.split(\":\");\n        var currMap = _this2._listeners;\n        for (var i = 0; i < subevents.length; i += 1) {\n          var data = currMap.get(subevents[i]);\n          if (!data) {\n            data = [new Map(), []];\n            currMap.set(subevents[i], data);\n          }\n          currMap = data[0];\n        }\n      });\n    }\n\n    /**\n     * Adds a new listener to a specific event or list of different events\n     * @param  {string|string[]} types    event(s) this listener is listening to\n     * @param  {EventCallback} listener function to be called when events destribed by types is fired\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(types, listener) {\n      var _this3 = this;\n\n      var typesToUse = arrayify(types);\n      typesToUse.forEach(function (type) {\n        var subtypes = type.split(\":\");\n        var currMap = _this3._listeners;\n        var data = null;\n        subtypes.forEach(function (subtype) {\n          data = currMap.get(subtype);\n          if (!data) {\n            var keys = [];\n            currMap.forEach(function (val, key) {\n              return keys.push(key);\n            });\n            throw new Error(type + \" is not a valid event type. The registered event types at this level are [\" + keys + \"]\");\n          }\n          currMap = data[0];\n        });\n        if (data[1].indexOf(listener) < 0) {\n          data[1].push(listener);\n        }\n      });\n\n      return this;\n    }\n\n    /**\n     * Removes a listener from specific events\n     * @param  {string|string[]} types    event(s) the listener is being removed from\n     * @param  {EventCallback} listener callback function to be cleared from the specified event types\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(types, listener) {\n      var _this4 = this;\n\n      var typesToUse = arrayify(types);\n      var listeners = listener;\n      if (!Array.isArray(listeners)) {\n        listeners = [listener];\n      }\n      typesToUse.forEach(function (type) {\n        var subtypes = type.split(\":\");\n        var currMap = _this4._listeners;\n        var data = null;\n        var i = 0;\n        for (i = 0; i < subtypes.length; i += 1) {\n          data = currMap.get(subtypes[i]);\n          if (!data) {\n            break;\n          }\n          currMap = data[0];\n        }\n        if (data) {\n          recursiveDelete(data, listeners);\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Sets up a lister callback to only be called once\n     * @param  {string|string[]} types    event(s) the listener is listening to\n     * @param  {EventCallback} listener callback function to be called with event(s) are fired\n     * @return {EventHandler}          this\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(types, listener) {\n      var _this5 = this;\n\n      var wrapper = function wrapper(data) {\n        _this5.off(types, wrapper);\n        listener.call(_this5, data);\n      };\n      this.on(types, wrapper);\n      return this;\n    }\n\n    /**\n     * Fires a specific event and calls any listeners of that event type.\n     * @param  {string} type Event type to fire\n     * @param  {Object} data Additional data to fire with the event\n     * @return {EventHandler}      this\n     */\n\n  }, {\n    key: \"fire\",\n    value: function fire(type, data) {\n      var subtypes = type.split(\":\");\n\n      var fireData = {\n        type: type,\n        target: this\n      };\n\n      Object.assign(fireData, data);\n\n      var numFires = recursiveFire(this._listeners, subtypes, 0, fireData);\n\n      // To ensure that no error events are dropped, print them to the\n      // console if they have no listeners.\n      // if (!numFires && endsWith(type, \"error\")) {\n      //   console.error((data && data.error) || data || \"Empty error event\")\n      // }\n\n      if (this._eventParent) {\n        fireData = {};\n        Object.getOwnPropertyNames(data).forEach(function (key) {\n          fireData[key] = data[key];\n        });\n        this._eventParent.fire(type, fireData);\n      }\n\n      return this;\n    }\n\n    /**\n     * Returns whether or not this event hander fires a specific event type\n     * @param  {string} type Event type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"listens\",\n    value: function listens(type) {\n      var subtypes = type.split(\":\");\n      var currMap = this._listeners;\n      var data = null;\n      for (var i = 0; i < subtypes.length; i += 1) {\n        data = currMap.get(subtypes[i]);\n        if (!data) {\n          break;\n        }\n        currMap = data[0];\n      }\n      return data || this._eventParent && this._eventParent.listens(type);\n    }\n\n    /**\n     * Sets a parent event handler\n     * @param {EventHandler} parent\n     * @param {object} data\n     */\n\n  }, {\n    key: \"setEventedParent\",\n    value: function setEventedParent(parent, data) {\n      this._eventParent = parent;\n      this._eventParentData = data;\n\n      return this;\n    }\n  }]);\n\n  return EventHandler;\n}();\n\nexports.default = EventHandler;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2V2ZW50LWhhbmRsZXIuanM/MWM0OSJdLCJuYW1lcyI6WyJyZWN1cnNpdmVGaXJlIiwiY3Vyck1hcCIsInN1YnR5cGVzIiwiY3VycklkeCIsImZpcmVEYXRhIiwibGVuZ3RoIiwiY250IiwiZGF0YSIsImdldCIsImZvckVhY2giLCJsaXN0ZW5lciIsImNhbGwiLCJyZWN1cnNpdmVEZWxldGUiLCJjdXJyTm9kZSIsImxpc3RlbmVycyIsImluZGV4Iiwic3Vibm9kZXMiLCJub2RlbGlzdGVuZXJzIiwiaW5kZXhPZiIsInNwbGljZSIsIm5vZGUiLCJhcnJheWlmeSIsImludHlwZSIsImFycmF5VG9Vc2UiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsIkV2ZW50SGFuZGxlciIsImV2ZW50c1RvUmVnaXN0ZXIiLCJpbml0aWFsaXplciIsIl9saXN0ZW5lcnMiLCJNYXAiLCJyZWdpc3RlckV2ZW50cyIsImV2ZW50cyIsImV2ZW50c1RvVXNlIiwic3ViZXZlbnRzIiwiZXZlbnQiLCJzcGxpdCIsImkiLCJzZXQiLCJ0eXBlcyIsInR5cGVzVG9Vc2UiLCJ0eXBlIiwic3VidHlwZSIsImtleXMiLCJ2YWwiLCJrZXkiLCJwdXNoIiwid3JhcHBlciIsIm9mZiIsIm9uIiwidGFyZ2V0IiwiT2JqZWN0IiwiYXNzaWduIiwibnVtRmlyZXMiLCJfZXZlbnRQYXJlbnQiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZmlyZSIsImxpc3RlbnMiLCJwYXJlbnQiLCJfZXZlbnRQYXJlbnREYXRhIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFZQSxTQUFTQSxhQUFULENBQXVCQyxPQUF2QixFQUFnQ0MsUUFBaEMsRUFBMENDLE9BQTFDLEVBQW1EQyxRQUFuRCxFQUE2RDtBQUFBOztBQUMzRCxNQUFJRCxXQUFXRCxTQUFTRyxNQUF4QixFQUFnQztBQUM5QixXQUFPLENBQVA7QUFDRDs7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d0JyRCxJQUF4Qjs7QUFFQSxhQUFPLElBQVA7QUFDRDs7Ozs7O2tCQTdMa0JvQixZIiwiZmlsZSI6IjE1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuLyoqXG4gIEB0eXBlZGVmIEV2ZW50T2JqZWN0XG4gIEB0eXBlIHtvYmplY3R9XG4gIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIC0gdGhlIHR5cGUgb2YgdGhlIGV2ZW50XG4gIEBwcm9wZXJ0eSB7c3RyaW5nfSB0YXJnZXQgLSB0aGUgdGFyZ2V0IG9iamVjdCB0aGF0IGZpcmVkIHRoZSBldmVudFxuIC9cblxuLyoqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGRpc3BsYXllZCBhcyBhIGdsb2JhbCBtZW1iZXIuXG4gKiBAY2FsbGJhY2sgRXZlbnRDYWxsYmFja1xuICogQHBhcmFtIHtFdmVudE9iamVjdH0gRXZlbnQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGV2ZW50IGJlaW5nIGZpcmVkXG4gKi9cblxuLyoqXG4gKiBSZWN1cnNpdmVseSBmaXJlcyBoaWVyYXJjaGljYWwgZXZlbnRzIGZyb20gYW4gaGFuZGxlcidzIHJlZ2lzdGVyZWRcbiAqIGV2ZW50IHR5cGVzLiBGb3IgZXhhbXBsZSwgaWYgYW4gZXZlbnQgaXMgcmVnaXN0ZXJlZCBhcyBcImNoYW5nZWQ6Y29sb3JcIixcbiAqIGJvdGggYSBcImNoYW5nZWQ6Y29sb3JcIiBhbmQgXCJjaGFuZ2VkXCIgZXZlbnQgaXMgZmlyZWQsIHNvIGxpc3RlbmVycyB3aG9cbiAqIG9ubHkgZ2VuZXJpY2FsbHkgY2FyZSBpZiBzb21ldGhpbmcgY2hhbmdlZCBvbiBhbiBvYmplY3QgY2FuIGJlIG5vdGlmaWVkLlxuICogQHBhcmFtICB7TWFwfSBjdXJyTWFwICBtYXAgZGF0YXN0cnVjdHVyZSBob2xkaW5nIGFsbCBoaWVyYXJjaGljYWwgZXZlbnRzIGFuZCBjYWxsYmFja3NcbiAqIEBwYXJhbSAge3N0cmluZ1tdfSBzdWJ0eXBlcyB0aGUgXCI6XCIgc2VwYXJhdGVkIGxpc3Qgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGN1cnJJZHggIHRoZSBjdXJyZW50IGluZGV4IG9mIHN1YnR5cGVzIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtICB7T2JqZWN0fSBmaXJlRGF0YSB0aGUgZXZlbnQgb2JqZWN0IHRvIGZpcmVcbiAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgdG90YWwgbnVtYmVyIG9mIGxpc3RlbmVycyBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY3Vyc2l2ZUZpcmUoY3Vyck1hcCwgc3VidHlwZXMsIGN1cnJJZHgsIGZpcmVEYXRhKSB7XG4gIGlmIChjdXJySWR4ID49IHN1YnR5cGVzLmxlbmd0aCkge1xuICAgIHJldHVybiAwXG4gIH1cblxuICBsZXQgY250ID0gMFxuICBsZXQgZGF0YSA9IG51bGxcbiAgZGF0YSA9IGN1cnJNYXAuZ2V0KHN1YnR5cGVzW2N1cnJJZHhdKVxuICBpZiAoZGF0YSkge1xuICAgIGNudCA9IHJlY3Vyc2l2ZUZpcmUoZGF0YVswXSwgc3VidHlwZXMsIGN1cnJJZHggKyAxLCBmaXJlRGF0YSlcbiAgICBkYXRhWzFdLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIuY2FsbCh0aGlzLCBmaXJlRGF0YSkpXG4gICAgY250ICs9IGRhdGFbMV0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGNudFxufVxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGRlbGV0ZXMgc3BlY2lmaWMgbGlzdGVuZXJzIGZyb20gYSBoYW5kbGVycyBldmVudFxuICogZGF0YSBzdHJ1Y3R1cmUuIEZvciBpbnN0YW5jZSwgaWYgdGhlIHNhbWUgY2FsbGJhY2sgaXMgdXNlZCBmb3IgYm90aFxuICogYSBcImNoYW5nZWRcIiBhbmQgYSBcImNoYW5nZWQ6Y29sb3JcIiBldmVudCwgYW5kIHRoYXQgY2FsbGJhY2sgaXMgZGVsZXRlZFxuICogZnJvbSB0aGUgXCJjaGFuZ2VkXCIgZXZlbnQsIGl0IGlzIGFsc28gZGVsZXRlZCBmcm9tIHRoZSBcImNoYW5nZWQ6Y29sb3JcIiBldmVudFxuICogQHBhcmFtICB7T2JqZWN0fSBjdXJyTm9kZSAgQ3VycmVudCBub2RlIG9mIHRoZSBtYXAgZGF0YSBzdHJ1Y3R1cmUgYmVpbmcgcHJvY2Vzc2VkXG4gKiBAcGFyYW0gIHtmdW5jdGlvbltdfSBsaXN0ZW5lcnMgQXJyYXkgb2YgbGlzdGVuZXJzIHRvIGRlbGV0ZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjdXJzaXZlRGVsZXRlKGN1cnJOb2RlLCBsaXN0ZW5lcnMpIHtcbiAgbGV0IGluZGV4ID0gLTFcbiAgY29uc3Qgc3Vibm9kZXMgPSBjdXJyTm9kZVswXVxuICBjb25zdCBub2RlbGlzdGVuZXJzID0gY3Vyck5vZGVbMV1cbiAgaWYgKG5vZGVsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4ge1xuICAgICAgaWYgKChpbmRleCA9IG5vZGVsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcikpID49IDApIHtcbiAgICAgICAgbm9kZWxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICBzdWJub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgcmVjdXJzaXZlRGVsZXRlKG5vZGUsIGxpc3RlbmVycylcbiAgfSlcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhhdCBhbiBpbnB1dCBpcyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLCBhbmQgaWYgdGhlIGZvcm1lclxuICogcmV0dXJucyBhIDEtZWxlbWVudCBzdHJpbmcgYXJyYXlcbiAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gaW50eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmdbXX1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFycmF5aWZ5KGludHlwZSkge1xuICBsZXQgYXJyYXlUb1VzZSA9IGludHlwZVxuICBpZiAodHlwZW9mIGludHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGFycmF5VG9Vc2UgPSBbaW50eXBlXVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGludHlwZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ3NcIilcbiAgfVxuICByZXR1cm4gYXJyYXlUb1VzZVxufVxuXG4vKiogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cyBhbmQgbGlzdGVuZXJzLiBDYW4gYmUgdXNlZCBhcyBhIGJhc2UgY2xhc3Mgb3IgYSBtaXhpbiAodXNpbmcgQHNlZSB7QGxpbmsgYWdncmVnYXRpb259KSAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXZlbnRIYW5kbGVyIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSBldmVudHNUb1JlZ2lzdGVyIGluaXRpYWwgZXZlbnRzIHRvIHJlZ2lzdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihldmVudHNUb1JlZ2lzdGVyKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihldmVudHNUb1JlZ2lzdGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGFuIGV2ZW50IGhhbmRsZXIgb2JqZWN0XG4gICAqIEBwYXJhbSAge3N0cmluZ3xzdHJpbmdbXX0gZXZlbnRzVG9SZWdpc3RlciBldmVudHMgdG8gaW5pdGlhbGl6ZSBldmVudCBoYW5kbGVyIHdpdGhcbiAgICogQHNlZSAge0BsaW5rIGFnZ3JlZ2F0aW9ufVxuICAgKi9cbiAgaW5pdGlhbGl6ZXIoZXZlbnRzVG9SZWdpc3Rlcikge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IG5ldyBNYXAoKVxuICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoZXZlbnRzVG9SZWdpc3RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgbmV3IGV2ZW50cyBmb3IgdGhlIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSBldmVudHMgbmV3IGV2ZW50KHMpIHRvIHJlZ2lzdGVyXG4gICAqL1xuICByZWdpc3RlckV2ZW50cyhldmVudHMpIHtcbiAgICBpZiAoIWV2ZW50cykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGV2ZW50c1RvVXNlID0gYXJyYXlpZnkoZXZlbnRzKVxuICAgIGlmICh0eXBlb2YgZXZlbnRzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBldmVudHNUb1VzZSA9IFtldmVudHNdXG4gICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdmVudHMgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdzXCIpXG4gICAgfVxuXG4gICAgZXZlbnRzVG9Vc2UuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICBjb25zdCBzdWJldmVudHMgPSBldmVudC5zcGxpdChcIjpcIilcbiAgICAgIGxldCBjdXJyTWFwID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YmV2ZW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgZGF0YSA9IGN1cnJNYXAuZ2V0KHN1YmV2ZW50c1tpXSlcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IFtuZXcgTWFwKCksIFtdXVxuICAgICAgICAgIGN1cnJNYXAuc2V0KHN1YmV2ZW50c1tpXSwgZGF0YSlcbiAgICAgICAgfVxuICAgICAgICBjdXJyTWFwID0gZGF0YVswXVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBsaXN0ZW5lciB0byBhIHNwZWNpZmljIGV2ZW50IG9yIGxpc3Qgb2YgZGlmZmVyZW50IGV2ZW50c1xuICAgKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IHR5cGVzICAgIGV2ZW50KHMpIHRoaXMgbGlzdGVuZXIgaXMgbGlzdGVuaW5nIHRvXG4gICAqIEBwYXJhbSAge0V2ZW50Q2FsbGJhY2t9IGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGV2ZW50cyBkZXN0cmliZWQgYnkgdHlwZXMgaXMgZmlyZWRcbiAgICogQHJldHVybiB7RXZlbnRIYW5kbGVyfSAgICAgICAgICB0aGlzXG4gICAqL1xuICBvbih0eXBlcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCB0eXBlc1RvVXNlID0gYXJyYXlpZnkodHlwZXMpXG4gICAgdHlwZXNUb1VzZS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgICAgY29uc3Qgc3VidHlwZXMgPSB0eXBlLnNwbGl0KFwiOlwiKVxuICAgICAgbGV0IGN1cnJNYXAgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAgIGxldCBkYXRhID0gbnVsbFxuICAgICAgc3VidHlwZXMuZm9yRWFjaChzdWJ0eXBlID0+IHtcbiAgICAgICAgZGF0YSA9IGN1cnJNYXAuZ2V0KHN1YnR5cGUpXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGNvbnN0IGtleXMgPSBbXVxuICAgICAgICAgIGN1cnJNYXAuZm9yRWFjaCgodmFsLCBrZXkpID0+IGtleXMucHVzaChrZXkpKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0eXBlfSBpcyBub3QgYSB2YWxpZCBldmVudCB0eXBlLiBUaGUgcmVnaXN0ZXJlZCBldmVudCB0eXBlcyBhdCB0aGlzIGxldmVsIGFyZSBbJHtrZXlzfV1gKVxuICAgICAgICB9XG4gICAgICAgIGN1cnJNYXAgPSBkYXRhWzBdXG4gICAgICB9KVxuICAgICAgaWYgKGRhdGFbMV0uaW5kZXhPZihsaXN0ZW5lcikgPCAwKSB7XG4gICAgICAgIGRhdGFbMV0ucHVzaChsaXN0ZW5lcilcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgbGlzdGVuZXIgZnJvbSBzcGVjaWZpYyBldmVudHNcbiAgICogQHBhcmFtICB7c3RyaW5nfHN0cmluZ1tdfSB0eXBlcyAgICBldmVudChzKSB0aGUgbGlzdGVuZXIgaXMgYmVpbmcgcmVtb3ZlZCBmcm9tXG4gICAqIEBwYXJhbSAge0V2ZW50Q2FsbGJhY2t9IGxpc3RlbmVyIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNsZWFyZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGVzXG4gICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlcn0gICAgICAgICAgdGhpc1xuICAgKi9cbiAgb2ZmKHR5cGVzLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IHR5cGVzVG9Vc2UgPSBhcnJheWlmeSh0eXBlcylcbiAgICBsZXQgbGlzdGVuZXJzID0gbGlzdGVuZXJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdGVuZXJzKSkge1xuICAgICAgbGlzdGVuZXJzID0gW2xpc3RlbmVyXVxuICAgIH1cbiAgICB0eXBlc1RvVXNlLmZvckVhY2godHlwZSA9PiB7XG4gICAgICBjb25zdCBzdWJ0eXBlcyA9IHR5cGUuc3BsaXQoXCI6XCIpXG4gICAgICBsZXQgY3Vyck1hcCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgICAgbGV0IGRhdGEgPSBudWxsXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzdWJ0eXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRhID0gY3Vyck1hcC5nZXQoc3VidHlwZXNbaV0pXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY3Vyck1hcCA9IGRhdGFbMF1cbiAgICAgIH1cbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIHJlY3Vyc2l2ZURlbGV0ZShkYXRhLCBsaXN0ZW5lcnMpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdXAgYSBsaXN0ZXIgY2FsbGJhY2sgdG8gb25seSBiZSBjYWxsZWQgb25jZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd8c3RyaW5nW119IHR5cGVzICAgIGV2ZW50KHMpIHRoZSBsaXN0ZW5lciBpcyBsaXN0ZW5pbmcgdG9cbiAgICogQHBhcmFtICB7RXZlbnRDYWxsYmFja30gbGlzdGVuZXIgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdpdGggZXZlbnQocykgYXJlIGZpcmVkXG4gICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlcn0gICAgICAgICAgdGhpc1xuICAgKi9cbiAgb25jZSh0eXBlcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gKGRhdGEpID0+IHtcbiAgICAgIHRoaXMub2ZmKHR5cGVzLCB3cmFwcGVyKVxuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBkYXRhKVxuICAgIH1cbiAgICB0aGlzLm9uKHR5cGVzLCB3cmFwcGVyKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgYSBzcGVjaWZpYyBldmVudCBhbmQgY2FsbHMgYW55IGxpc3RlbmVycyBvZiB0aGF0IGV2ZW50IHR5cGUuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSBFdmVudCB0eXBlIHRvIGZpcmVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIEFkZGl0aW9uYWwgZGF0YSB0byBmaXJlIHdpdGggdGhlIGV2ZW50XG4gICAqIEByZXR1cm4ge0V2ZW50SGFuZGxlcn0gICAgICB0aGlzXG4gICAqL1xuICBmaXJlKHR5cGUsIGRhdGEpIHtcbiAgICBjb25zdCBzdWJ0eXBlcyA9IHR5cGUuc3BsaXQoXCI6XCIpXG5cbiAgICBsZXQgZmlyZURhdGEgPSB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdGFyZ2V0OiB0aGlzXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbihmaXJlRGF0YSwgZGF0YSlcblxuICAgIGxldCBudW1GaXJlcyA9IHJlY3Vyc2l2ZUZpcmUodGhpcy5fbGlzdGVuZXJzLCBzdWJ0eXBlcywgMCwgZmlyZURhdGEpXG5cbiAgICAvLyBUbyBlbnN1cmUgdGhhdCBubyBlcnJvciBldmVudHMgYXJlIGRyb3BwZWQsIHByaW50IHRoZW0gdG8gdGhlXG4gICAgLy8gY29uc29sZSBpZiB0aGV5IGhhdmUgbm8gbGlzdGVuZXJzLlxuICAgIC8vIGlmICghbnVtRmlyZXMgJiYgZW5kc1dpdGgodHlwZSwgXCJlcnJvclwiKSkge1xuICAgIC8vICAgY29uc29sZS5lcnJvcigoZGF0YSAmJiBkYXRhLmVycm9yKSB8fCBkYXRhIHx8IFwiRW1wdHkgZXJyb3IgZXZlbnRcIilcbiAgICAvLyB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRQYXJlbnQpIHtcbiAgICAgIGZpcmVEYXRhID0ge31cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGRhdGEpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgZmlyZURhdGFba2V5XSA9IGRhdGFba2V5XVxuICAgICAgfSlcbiAgICAgIHRoaXMuX2V2ZW50UGFyZW50LmZpcmUodHlwZSwgZmlyZURhdGEpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgZXZlbnQgaGFuZGVyIGZpcmVzIGEgc3BlY2lmaWMgZXZlbnQgdHlwZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgRXZlbnQgdHlwZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgbGlzdGVucyh0eXBlKSB7XG4gICAgY29uc3Qgc3VidHlwZXMgPSB0eXBlLnNwbGl0KFwiOlwiKVxuICAgIGxldCBjdXJyTWFwID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgbGV0IGRhdGEgPSBudWxsXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJ0eXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgZGF0YSA9IGN1cnJNYXAuZ2V0KHN1YnR5cGVzW2ldKVxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjdXJyTWFwID0gZGF0YVswXVxuICAgIH1cbiAgICByZXR1cm4gZGF0YSB8fCAodGhpcy5fZXZlbnRQYXJlbnQgJiYgdGhpcy5fZXZlbnRQYXJlbnQubGlzdGVucyh0eXBlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgcGFyZW50IGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIHtFdmVudEhhbmRsZXJ9IHBhcmVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gZGF0YVxuICAgKi9cbiAgc2V0RXZlbnRlZFBhcmVudChwYXJlbnQsIGRhdGEpIHtcbiAgICB0aGlzLl9ldmVudFBhcmVudCA9IHBhcmVudFxuICAgIHRoaXMuX2V2ZW50UGFyZW50RGF0YSA9IGRhdGFcblxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3V0aWwvZXZlbnQtaGFuZGxlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EventConstants = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _canvasUtils = __webpack_require__(30);\n\nvar CanvasUtils = _interopRequireWildcard(_canvasUtils);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _utils = __webpack_require__(31);\n\nvar _camera2d = __webpack_require__(32);\n\nvar _camera2d2 = _interopRequireDefault(_camera2d);\n\nvar _eventHandler = __webpack_require__(15);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _ResizeSensor = __webpack_require__(33);\n\nvar _ResizeSensor2 = _interopRequireDefault(_ResizeSensor);\n\nvar _strokeStyle = __webpack_require__(10);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar mouseevents = [\"mousedown\", \"mouseup\", \"mousemove\", \"click\", \"dblclick\", \"mouseover\", \"mouseout\"];\nvar marginProps = [\"top\", \"bottom\", \"left\", \"right\"];\n\nvar EventConstants = exports.EventConstants = {\n  MOUSEDOWN: \"mousedown\",\n  MOUSEUP: \"mouseup\",\n  MOUSEMOVE: \"mousemove\",\n  CLICK: \"click\",\n  DBLCLICK: \"dblclick\",\n  MOUSEOVER: \"mouseover\",\n  MOUSEOUT: \"mouseout\",\n  SHAPE_ADD: \"shape:add\",\n  SHAPE_DELETE: \"shape:delete\"\n};\n\nvar DrawStyleState = function (_BasicStyle) {\n  _inherits(DrawStyleState, _BasicStyle);\n\n  function DrawStyleState() {\n    var _ref;\n\n    _classCallCheck(this, DrawStyleState);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _this = _possibleConstructorReturn(this, (_ref = DrawStyleState.__proto__ || Object.getPrototypeOf(DrawStyleState)).call.apply(_ref, [this].concat(args)));\n\n    _this._defaults = {\n      packedFillColor: _this.packedFillColor,\n      packedStrokeColor: _this.packedStrokeColor,\n      strokeWidth: _this.strokeWidth,\n      lineJoin: _this.lineJoin,\n      lineCap: _this.lineCap,\n      dashPattern: _this.dashPattern,\n      dashOffset: _this.dashOffset\n    };\n    return _this;\n  }\n\n  _createClass(DrawStyleState, [{\n    key: \"setFillStyle\",\n    value: function setFillStyle(ctx, fillStyle) {\n      if (fillStyle.packedFillColor !== this.packedFillColor) {\n        this.packedFillColor = fillStyle.packedFillColor;\n        ctx.fillStyle = this.fillColor;\n      }\n    }\n  }, {\n    key: \"setStrokeStyle\",\n    value: function setStrokeStyle(ctx, strokeStyle) {\n      if (strokeStyle.packedStrokeColor !== this.packedStrokeColor) {\n        this.packedStrokeColor = strokeStyle.packedStrokeColor;\n        ctx.strokeStyle = this.strokeColor;\n      }\n      if (strokeStyle.strokeWidth !== this._strokeWidth) {\n        this.strokeWidth = strokeStyle.strokeWidth;\n        ctx.lineWidth = this._strokeWidth;\n      }\n      if (strokeStyle.lineJoin !== this._lineJoin) {\n        this.lineJoin = strokeStyle.lineJoin;\n        ctx.lineJoin = this._lineJoin;\n      }\n      if (strokeStyle.lineCap !== this._lineCap) {\n        this.lineCap = strokeStyle.lineCap;\n        ctx.lineCap = this._lineCap;\n      }\n\n      var dashPattern = strokeStyle._dashPattern;\n      var diff = false;\n      if (dashPattern.length === this._dashPattern.length) {\n        for (var i = 0; i < dashPattern.length; i += 1) {\n          if (dashPattern[i] !== this._dashPattern[i]) {\n            diff = true;\n            break;\n          }\n        }\n      } else {\n        diff = true;\n      }\n\n      if (diff) {\n        this.dashPattern = dashPattern;\n        ctx.setLineDash(this._dashPattern);\n      }\n\n      if (strokeStyle.dashOffset !== this._dashOffset) {\n        this.dashOffset = strokeStyle.dashOffset;\n        ctx.lineDashOffset = this._dashOffset;\n      }\n    }\n  }, {\n    key: \"applyDefaults\",\n    value: function applyDefaults(ctx) {\n      var _this2 = this;\n\n      Object.getOwnPropertyNames(this._defaults).forEach(function (prop) {\n        _this2[prop] = _this2._defaults[prop];\n      });\n      this.setFillCtx(ctx);\n      this.setStrokeCtx(ctx);\n    }\n  }]);\n\n  return DrawStyleState;\n}(_basicStyle2.default);\n\nvar boundsStrokeStyle = new _strokeStyle2.default({\n  strokeColor: \"darkgray\",\n  strokeWidth: 2\n});\n\nfunction addClass(element, className) {\n  if (element && (\" \" + element.className + \" \").indexOf(\" \" + className + \" \") < 0) {\n    element.className += (element.className ? \" \" : \"\") + className;\n  }\n}\n\nfunction createCanvas(parent) {\n  var canvasContainer = document.createElement(\"div\");\n  addClass(canvasContainer, \"mapd-draw-canvas-container\");\n\n  var canvas = document.createElement(\"canvas\");\n  var canvasContext = canvas.getContext(\"2d\");\n  var ratio = CanvasUtils.makeCanvasAutoHighDPI(canvasContext);\n  // const ratio = 1\n\n  // add class?\n  addClass(canvas, \"mapd-draw-canvas\");\n  canvas.style.position = \"absolute\";\n  canvas.style.pointerEvents = \"none\";\n\n  canvasContainer.appendChild(canvas);\n\n  // canvas.setAttribute(\"width\", ratio * parent.offsetX)\n  // canvas.setAttribute(\"height\", ratio * parent.offsetY)\n  // parent.insertBefore(canvas, parent.firstChild)\n  parent.appendChild(canvasContainer);\n\n  return {\n    canvasContainer: canvasContainer,\n    canvas: canvas,\n    canvasContext: canvasContext,\n    ratio: ratio\n  };\n}\n\nfunction addShapesToMap(newShapes, existingObjectsMap, currIds, reorderCb, redrawCb) {\n  newShapes.forEach(function (shape) {\n    existingObjectsMap.set(shape, {\n      shapeObj: shape,\n      shapeId: currIds.shapeId,\n      shapeIdx: -1\n    });\n    shape.on([\"changed:order\", \"changed:visibility\", \"changed:style\"], reorderCb);\n    shape.on([\"changed:geom\", \"changed:visibility\", \"changed:xform\"], redrawCb);\n    currIds.shapeId += 1;\n  });\n}\n\nfunction deleteShapesFromMap(shapes, existingObjectsMap, reorderCb, redrawCb) {\n  var idxs = [];\n  shapes.forEach(function (shape) {\n    var shapeInfo = existingObjectsMap.get(shape);\n    if (shapeInfo) {\n      idxs.push(shapeInfo.shapeIdx);\n    }\n    existingObjectsMap.delete(shape);\n    shape.off([\"changed\"], [reorderCb, redrawCb]);\n  });\n  return idxs;\n}\n\nvar DrawEngine = function (_EventHander) {\n  _inherits(DrawEngine, _EventHander);\n\n  function DrawEngine(parent, opts) {\n    _classCallCheck(this, DrawEngine);\n\n    var _this3 = _possibleConstructorReturn(this, (DrawEngine.__proto__ || Object.getPrototypeOf(DrawEngine)).call(this));\n\n    _this3._init(parent, opts);\n    return _this3;\n  }\n\n  _createClass(DrawEngine, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this4 = this;\n\n      this._destroyCanvas();\n\n      if (this._objects) {\n        this._objects.forEach(function (shapeInfo, shape) {\n          shape.off(\"changed\", [_this4._reorderCb, _this4._redrawCb]);\n        });\n        this._objects.clear();\n        this._sortedObjs = [];\n        this._reorderedObjIdxs.clear();\n      }\n    }\n  }, {\n    key: \"_resize\",\n    value: function _resize(opts) {\n      var width = 0;\n      if (this._parent.offsetWidth) {\n        width = Math.max(width, this._parent.offsetWidth - this._margins.left - this._margins.right);\n      }\n\n      var height = 0;\n      if (this._parent.offsetHeight) {\n        height = Math.max(height, this._parent.offsetHeight - this._margins.top - this._margins.bottom);\n      }\n\n      this._drawCanvas.width = width * this._pixelRatio;\n      this._drawCanvas.height = height * this._pixelRatio;\n\n      this._drawCanvas.style.left = this._margins.left + \"px\";\n      this._drawCanvas.style.top = this._margins.top + \"px\";\n      this._drawCanvas.style.width = width + \"px\";\n      this._drawCanvas.style.height = height + \"px\";\n\n      if (this._camera) {\n        // const currViewport = this._camera.viewport\n        // const currSpace = this._camera.projectionBounds\n        // const viewportExtents = [0, 0]\n        // AABox2d.getExtents(viewportExtents, currViewport)\n        // const spaceCenter = [0, 0]\n        // const spaceExtents = [0, 0]\n        // AABox2d.getCenter(spaceCenter, currSpace)\n        // AABox2d.getExtents(spaceExtents, currSpace)\n        // const ratio = spaceExtents\n        // Vec2d.div(ratio, spaceExtents, viewportExtents)\n        // AABox2d.set(currViewport, 0, 0, width, height)\n        // AABox2d.getExtents(viewportExtents, currViewport)\n        // Vec2d.multiply(spaceExtents, ratio, viewportExtents)\n        // AABox2d.initCenterExtents(currSpace, spaceCenter, spaceExtents)\n        // this._camera.viewport = currViewport\n        // this._camera.projectionBounds = currSpace\n        //   // this._camera.viewport = [0, 0, width, height]\n        //   // this._camera.projectionBounds = [0, 0, width, height]\n      } else {\n        var projDims = opts && opts.projectionDimensions ? opts.projectionDimensions : [width, height];\n        this._camera = new _camera2d2.default([0, 0, width, height], projDims, opts.flipY ? Boolean(opts.flipY) : false);\n        this._camera.setPosition(opts && opts.cameraPosition ? opts.cameraPosition : [width / 2.0, height / 2.0]);\n        this._camera.on(\"changed\", this._rerenderCb);\n      }\n      // this._camera = new Camera2d([0, 0, this.width, this.height], [0, 0, this.width, this.height])\n      // this._camera.on(\"changed\", this._rerenderCb)\n\n      this._rerenderCb();\n    }\n  }, {\n    key: \"_mousedownCB\",\n    value: function _mousedownCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mousedown\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseupCB\",\n    value: function _mouseupCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseup\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mousemoveCB\",\n    value: function _mousemoveCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mousemove\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_clickCB\",\n    value: function _clickCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"click\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_dblclickCB\",\n    value: function _dblclickCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"dblclick\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseoverCB\",\n    value: function _mouseoverCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseover\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_mouseoutCB\",\n    value: function _mouseoutCB(event) {\n      if (event.target !== this._parent) {\n        return;\n      }\n\n      this.fire(\"mouseout\", {\n        originalEvent: event\n      });\n    }\n  }, {\n    key: \"_enableEvents\",\n    value: function _enableEvents() {\n      this.registerEvents(mouseevents);\n      var callbacks = mouseevents.map(function (event) {\n        return \"_\" + event + \"CB\";\n      });\n      // bindAll(callbacks, this)\n      for (var i = 0; i < mouseevents.length; i += 1) {\n        document.addEventListener(mouseevents[i], this[callbacks[i]], true);\n      }\n    }\n  }, {\n    key: \"_disableEvents\",\n    value: function _disableEvents() {\n      var callbacks = mouseevents.map(function (event) {\n        return \"_\" + event + \"CB\";\n      });\n      for (var i = 0; i < mouseevents.length; i += 1) {\n        document.removeEventListener(mouseevents[i], this[callbacks[i]], true);\n      }\n    }\n  }, {\n    key: \"_initCanvas\",\n    value: function _initCanvas(parent, opts) {\n      var _this5 = this;\n\n      var forceEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this._margins = opts && opts.margins ? Object.assign({}, opts.margins) : {};\n      marginProps.forEach(function (prop) {\n        if (typeof _this5._margins[prop] !== \"number\") {\n          _this5._margins[prop] = 0;\n        }\n      });\n\n      var _createCanvas = createCanvas(parent),\n          canvasContainer = _createCanvas.canvasContainer,\n          canvas = _createCanvas.canvas,\n          canvasContext = _createCanvas.canvasContext,\n          ratio = _createCanvas.ratio;\n\n      this._container = canvasContainer;\n      this._drawCanvas = canvas;\n      this._drawCtx = canvasContext;\n      this._pixelRatio = ratio;\n      this._parent = parent;\n\n      (0, _utils.bindAll)([\"_resize\"], this);\n      this._resize(opts);\n      this._resizeSensor = new _ResizeSensor2.default(parent, this._resize);\n\n      if (forceEvents || forceEvents === null && opts && opts.enableEvents) {\n        this._enableEvents();\n      }\n    }\n  }, {\n    key: \"_destroyCanvas\",\n    value: function _destroyCanvas() {\n      if (this._drawCanvas) {\n        this._disableEvents();\n      }\n\n      if (this._parent) {\n        this._parent.removeChild(this._drawCanvas);\n\n        if (this._resizeSensor) {\n          this._resizeSensor.detach(this._parent, this._resize);\n        }\n      }\n\n      this._drawCanvas = null;\n      this._drawCtx = null;\n      this._parent = null;\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(parent, opts) {\n      var forceEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      this.registerEvents([EventConstants.SHAPE_ADD, EventConstants.SHAPE_DELETE]);\n\n      (0, _utils.bindAll)([\"_reorderCb\", \"_rerenderCb\"], this);\n      (0, _utils.bindAll)([\"_mousedownCB\", \"_mouseupCB\", \"_mousemoveCB\", \"_clickCB\", \"_dblclickCB\", \"_mouseoverCB\", \"_mouseoutCB\"], this);\n\n      this._renderFrameCb = this.renderAll.bind(this);\n      this._renderRequestId = 0;\n      this._ids = {\n        shapeId: 1\n      };\n\n      this._objects = new Map();\n      this._sortedObjs = [];\n      this._reorderedObjIdxs = new Set();\n\n      this._initCanvas(parent, opts, forceEvents);\n\n      this._styleState = new DrawStyleState({\n        fillColor: \"red\"\n      });\n    }\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this._parent;\n    }\n  }, {\n    key: \"getCanvasContainer\",\n    value: function getCanvasContainer() {\n      return this._container;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this._drawCanvas;\n    }\n  }, {\n    key: \"project\",\n    value: function project(out, screenPt) {\n      var screenToWorldMatrix = this._camera.screenToWorldMatrix;\n      return Point2d.transformMat2d(out, screenPt, screenToWorldMatrix);\n    }\n  }, {\n    key: \"unproject\",\n    value: function unproject(out, worldPt) {\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      return Point2d.transformMat2d(out, worldPt, worldToScreenMatrix);\n    }\n  }, {\n    key: \"hasShape\",\n    value: function hasShape(shape) {\n      return this._objects.has(shape);\n    }\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      addShapesToMap(shapes, this._objects, this._ids, this._reorderCb, this._rerenderCb);\n\n      // fire add event\n      this.fire(\"shape:add\", {\n        shape: shapes\n      });\n\n      var proxyEvent = {\n        target: shapes\n      };\n      this._reorderCb(proxyEvent);\n\n      return this;\n    }\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      var idxs = deleteShapesFromMap(shapes, this._objects, this._reorderCb, this._rerenderCb);\n      var index = -1;\n      for (var i = 0; i < shapes.length; i += 1) {\n        if ((index = this._sortedObjs.indexOf(shapes[i])) >= 0) {\n          this._sortedObjs.splice(index, 1);\n        }\n        this._reorderedObjIdxs.add(idxs[i]);\n      }\n      this._rerenderCb();\n\n      this.fire(\"shape:delete\", {\n        shape: shapes\n      });\n\n      return this;\n    }\n  }, {\n    key: \"deleteAllShapes\",\n    value: function deleteAllShapes() {\n      this.deleteShape(this.sortedShapes.slice());\n      return this;\n    }\n  }, {\n    key: \"moveShapeToTop\",\n    value: function moveShapeToTop(shape) {\n      if (this._objects.has(shape)) {\n        var shapes = this.sortedShapes;\n        var zindex = shapes[shapes.length - 1].zIndex;\n        shape.zIndex = zindex + 1;\n      }\n    }\n  }, {\n    key: \"moveShapeToBack\",\n    value: function moveShapeToBack(shape) {\n      if (this._objects.has(shape)) {\n        var shapes = this.sortedShapes;\n        var zindex = shapes[0].zIndex;\n        shape.zIndex = zindex;\n      }\n    }\n  }, {\n    key: \"getShapesAsJSON\",\n    value: function getShapesAsJSON() {\n      var shapes = this.sortedShapes;\n      return shapes.map(function (shape) {\n        return shape.toJSON();\n      });\n    }\n  }, {\n    key: \"_rerenderCb\",\n    value: function _rerenderCb(event) {\n      if (this._renderRequestId) {\n        window.cancelAnimationFrame(this._renderRequestId);\n      }\n      this._renderRequestId = window.requestAnimationFrame(this._renderFrameCb);\n    }\n  }, {\n    key: \"_reorderCb\",\n    value: function _reorderCb(event) {\n      var _this6 = this;\n\n      var changedShapes = event.target;\n      if (!Array.isArray(changedShapes)) {\n        changedShapes = [event.target];\n      }\n      changedShapes.forEach(function (changedShape) {\n        console.assert(changedShape, \"A changed event doesn't have an object\");\n        var shapeInfo = _this6._objects.get(changedShape);\n        console.assert(shapeInfo, \"A changed event target isn't in the list of shapes \" + changedShape);\n        if (shapeInfo.shapeIdx < 0) {\n          shapeInfo.shapeIdx = _this6._sortedObjs.push(changedShape) - 1;\n        }\n        _this6._reorderedObjIdxs.add(shapeInfo.shapeIdx);\n      });\n      this._rerenderCb();\n    }\n  }, {\n    key: \"_renderShapes\",\n    value: function _renderShapes(ctx, drawShapes, camera) {\n      var _this7 = this;\n\n      var worldToScreenMat = camera.worldToScreenMatrix;\n      drawShapes.forEach(function (shape) {\n        if (shape.visible) {\n          shape.render(ctx, worldToScreenMat, _this7._styleState);\n        }\n      });\n    }\n  }, {\n    key: \"renderAll\",\n    value: function renderAll() {\n      var ctx = this._drawCtx;\n      // ctx.clearRect(0, 0, this.width, this.height)\n      ctx.clearRect(0, 0, this._drawCanvas.offsetWidth, this._drawCanvas.offsetHeight);\n\n      if (!this._objects.size) {\n        return;\n      }\n\n      ctx.save();\n      var drawShapes = this.sortedShapes;\n      this._styleState.applyDefaults(ctx);\n      this._renderShapes(ctx, drawShapes, this._camera);\n      ctx.restore();\n    }\n  }, {\n    key: \"sortedShapes\",\n    get: function get() {\n      if (this._reorderedObjIdxs.size) {\n        console.assert(this._sortedObjs.length === this._objects.size, \"Size mismatch when rendering objets. Something got out of sync - sorted objs length: \" + this._sortedObjs.length + \", objects length: \" + this._objects.size);\n\n        // if (this._reorderedObjIdxs.length / this._sortedObjs.length > 0.7) {\n        //   // might as well just resort the whole thing over\n        //   this._sortedObjs.sort(shapeInfoCompare)\n        // } else {\n        // }\n\n        this._sortedObjs.sort(_baseShape2.default.shapeCompare);\n        this._reorderedObjIdxs.clear();\n      }\n      return this._sortedObjs;\n    }\n  }, {\n    key: \"margins\",\n    get: function get() {\n      var _this8 = this;\n\n      var rtn = {};\n      marginProps.forEach(function (prop) {\n        rtn[prop] = _this8._margins[prop];\n      });\n      return rtn;\n    },\n    set: function set(margins) {\n      var _this9 = this;\n\n      var resize = false;\n      marginProps.forEach(function (prop) {\n        if (typeof margins[prop] === \"number\" && margins[prop] !== _this9._margins[prop]) {\n          _this9._margins[prop] = margins.prop;\n          resize = true;\n        }\n      });\n\n      this._resize();\n    }\n  }, {\n    key: \"viewport\",\n    get: function get() {\n      return this._camera.viewport;\n    },\n    set: function set(viewport) {\n      this._camera.viewport = viewport;\n    }\n  }, {\n    key: \"projectionDimensions\",\n    get: function get() {\n      return this._camera.projectionDimensions;\n    },\n    set: function set(projectionDimensions) {\n      this._camera.projectionDimensions = projectionDimensions;\n      return this;\n    }\n  }, {\n    key: \"cameraPosition\",\n    get: function get() {\n      return this._camera.getPosition();\n    },\n    set: function set(pos) {\n      this._camera.setPosition(pos);\n      return this;\n    }\n  }]);\n\n  return DrawEngine;\n}(_eventHandler2.default);\n\nexports.default = DrawEngine;\n\n\nDrawEngine.EventConstants = EventConstants;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvZHJhdy1lbmdpbmUuanM/ZmYwMiJdLCJuYW1lcyI6WyJDYW52YXNVdGlscyIsIlBvaW50MmQiLCJtb3VzZWV2ZW50cyIsIm1hcmdpblByb3BzIiwiRXZlbnRDb25zdGFudHMiLCJNT1VTRURPV04iLCJNT1VTRVVQIiwiTU9VU0VNT1ZFIiwiQ0xJQ0siLCJEQkxDTElDSyIsIk1PVVNFT1ZFUiIsIk1PVVNFT1VUIiwiU0hBUEVfQUREIiwiU0hBUEVfREVMRVRFIiwiRHJhd1N0eWxlU3RhdGUiLCJhcmdzIiwiX2RlZmF1bHRzIiwicGFja2VkRmlsbENvbG9yIiwicGFja2VkU3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImxpbmVKb2luIiwibGluZUNhcCIsImRhc2hQYXR0ZXJuIiwiZGFzaE9mZnNldCIsImN0eCIsImZpbGxTdHlsZSIsImZpbGxDb2xvciIsInN0cm9rZVN0eWxlIiwic3Ryb2tlQ29sb3IiLCJfc3Ryb2tlV2lkdGgiLCJsaW5lV2lkdGgiLCJfbGluZUpvaW4iLCJfbGluZUNhcCIsIl9kYXNoUGF0dGVybiIsImRpZmYiLCJsZW5ndGgiLCJpIiwic2V0TGluZURhc2giLCJfZGFzaE9mZnNldCIsImxpbmVEYXNoT2Zmc2V0IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZvckVhY2giLCJwcm9wIiwic2V0RmlsbEN0eCIsInNldFN0cm9rZUN0eCIsImJvdW5kc1N0cm9rZVN0eWxlIiwiYWRkQ2xhc3MiLCJlbGVtZW50IiwiY2xhc3NOYW1lIiwiaW5kZXhPZiIsImNyZWF0ZUNhbnZhcyIsInBhcmVudCIsImNhbnZhc0NvbnRhaW5lciIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNhbnZhcyIsImNhbnZhc0NvbnRleHQiLCJnZXRDb250ZXh0IiwicmF0aW8iLCJtYWtlQ2FudmFzQXV0b0hpZ2hEUEkiLCJzdHlsZSIsInBvc2l0aW9uIiwicG9pbnRlckV2ZW50cyIsImFwcGVuZENoaWxkIiwiYWRkU2hhcGVzVG9NYXAiLCJuZXdTaGFwZXMiLCJleGlzdGluZ09iamVjdHNNYXAiLCJjdXJySWRzIiwicmVvcmRlckNiIiwicmVkcmF3Q2IiLCJzZXQiLCJzaGFwZSIsInNoYXBlT2JqIiwic2hhcGVJZCIsInNoYXBlSWR4Iiwib24iLCJkZWxldGVTaGFwZXNGcm9tTWFwIiwic2hhcGVzIiwiaWR4cyIsInNoYXBlSW5mbyIsImdldCIsInB1c2giLCJkZWxldGUiLCJvZmYiLCJEcmF3RW5naW5lIiwib3B0cyIsIl9pbml0IiwiX2Rlc3Ryb3lDYW52YXMiLCJfb2JqZWN0cyIsIl9yZW9yZGVyQ2IiLCJfcmVkcmF3Q2IiLCJjbGVhciIsIl9zb3J0ZWRPYmpzIiwiX3Jlb3JkZXJlZE9iaklkeHMiLCJ3aWR0aCIsIl9wYXJlbnQiLCJvZmZzZXRXaWR0aCIsIk1hdGgiLCJtYXgiLCJfbWFyZ2lucyIsImxlZnQiLCJyaWdodCIsImhlaWdodCIsIm9mZnNldEhlaWdodCIsInRvcCIsImJvdHRvbSIsIl9kcmF3Q2FudmFzIiwiX3BpeGVsUmF0aW8iLCJfY2FtZXJhIiwicHJvakRpbXMiLCJwcm9qZWN0aW9uRGltZW5zaW9ucyIsImZsaXBZIiwiQm9vbGVhbiIsInNldFBvc2l0aW9uIiwiY2FtZXJhUG9zaXRpb24iLCJfcmVyZW5kZXJDYiIsImV2ZW50IiwidGFyZ2V0IiwiZmlyZSIsIm9yaWdpbmFsRXZlbnQiLCJyZWdpc3RlckV2ZW50cyIsImNhbGxiYWNrcyIsIm1hcCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZm9yY2VFdmVudHMiLCJtYXJnaW5zIiwiYXNzaWduIiwiX2NvbnRhaW5lciIsIl9kcmF3Q3R4IiwiX3Jlc2l6ZSIsIl9yZXNpemVTZW5zb3IiLCJlbmFibGVFdmVudHMiLCJfZW5hYmxlRXZlbnRzIiwiX2Rpc2FibGVFdmVudHMiLCJyZW1vdmVDaGlsZCIsImRldGFjaCIsIl9yZW5kZXJGcmFtZUNiIiwicmVuZGVyQWxsIiwiYmluZCIsIl9yZW5kZXJSZXF1ZXN0SWQiLCJfaWRzIiwiTWFwIiwiU2V0IiwiX2luaXRDYW52YXMiLCJfc3R5bGVTdGF0ZSIsIm91dCIsInNjcmVlblB0Iiwic2NyZWVuVG9Xb3JsZE1hdHJpeCIsInRyYW5zZm9ybU1hdDJkIiwid29ybGRQdCIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJoYXMiLCJBcnJheSIsImlzQXJyYXkiLCJwcm94eUV2ZW50IiwiaW5kZXgiLCJzcGxpY2UiLCJhZGQiLCJkZWxldGVTaGFwZSIsInNvcnRlZFNoYXBlcyIsInNsaWNlIiwiemluZGV4IiwiekluZGV4IiwidG9KU09OIiwid2luZG93IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJjaGFuZ2VkU2hhcGVzIiwiY29uc29sZSIsImFzc2VydCIsImNoYW5nZWRTaGFwZSIsImRyYXdTaGFwZXMiLCJjYW1lcmEiLCJ3b3JsZFRvU2NyZWVuTWF0IiwidmlzaWJsZSIsInJlbmRlciIsImNsZWFyUmVjdCIsInNpemUiLCJzYXZlIiwiYXBwbHlEZWZhdWx0cyIsIl9yZW5kZXJTaGFwZXMiLCJyZXN0b3JlIiwic29ydCIsInNoYXBlQ29tcGFyZSIsInJ0biIsInJlc2l6ZSIsInZpZXdwb3J0IiwiZ2V0UG9zaXRpb24iLCJwb3MiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7QUFFQTs7SUFBWUEsVzs7QUFDWjs7SUFBWUMsTzs7QUFDWjs7OztBQUNBOzs7O0FBQ0E7O0FBR0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUMsY0FBYyxDQUFDLFdBQUQsRUFBYyxTQUFkLEVBQXlCLFdBQXpCLEVBQXNDLE9BQXRDLEVBQStDLFVBQS9DLEVBQTJELFdBQTNELEVBQXdFLFVBQXhFLENBQXBCO0FBQ0EsSUFBTUMsY0FBYyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLE1BQWxCLEVBQTBCLE9BQTFCLENBQXBCOztBQUVPLElBQU1DLDBDQUFpQjtBQUM1QkMsYUFBVyxXQURpQjtBQUU1QkMsV0FB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RVczRCxPLEVBQVM7QUFBQTs7QUFDbkIsVUFBSTRELFNBQVMsS0FBYjtBQUNBeEwsa0JBQVl1QyxPQUFaLENBQW9CLGdCQUFRO0FBQzFCLFlBQUksT0FBT3FGLFFBQVFwRixJQUFSLENBQVAsS0FBeUIsUUFBekIsSUFBcUNvRixRQUFRcEYsSUFBUixNQUFrQixPQUFLeUQsUUFBTCxDQUFjekQsSUFBZCxDQUEzRCxFQUFnRjtBQUM5RSxpQkFBS3lELFFBQUwsQ0FBY3pELElBQWQsSUFBc0JvRixRQUFRcEYsSUFBOUI7QUFDQWdKLG1CQUFTLElBQVQ7QUFDRDtBQUNGLE9BTEQ7O0FBT0EsV0FBS3hELE9BQUw7QUFDRDs7O3dCQUVjO0FBQ2IsYUFBTyxLQUFLdEIsT0FBTCxDQUFhK0UsUUFBcEI7QUFDRCxLO3NCQUVZQSxRLEVBQVU7QUFDckIsV0FBSy9FLE9BQUwsQ0FBYStFLFFBQWIsR0FBd0JBLFFBQXhCO0FBQ0Q7Ozt3QkFFMEI7QUFDekIsYUFBTyxLQUFLL0UsT0FBTCxDQUFhRSxvQkFBcEI7QUFDRCxLO3NCQUV3QkEsb0IsRUFBc0I7QUFDN0MsV0FBS0YsT0FBTCxDQUFhRSxvQkFBYixHQUFvQ0Esb0JBQXBDO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7Ozt3QkFFb0I7QUFDbkIsYUFBTyxLQUFLRixPQUFMLENBQWFnRixXQUFiLEVBQVA7QUFDRCxLO3NCQUVrQkMsRyxFQUFLO0FBQ3RCLFdBQUtqRixPQUFMLENBQWFLLFdBQWIsQ0FBeUI0RSxHQUF6QjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7Ozs7a0JBL1NrQnpHLFU7OztBQXlickJBLFdBQVdqRixjQUFYLEdBQTRCQSxjQUE1QiIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIENhbnZhc1V0aWxzIGZyb20gXCIuLi91dGlsL2NhbnZhcy11dGlsc1wiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi4vc2hhcGVzL2Jhc2Utc2hhcGVcIlxuaW1wb3J0IEJhc2ljU3R5bGUgZnJvbSBcIi4uL3N0eWxlL2Jhc2ljLXN0eWxlXCJcbmltcG9ydCB7XG4gIGJpbmRBbGxcbn0gZnJvbSBcIi4uL3V0aWwvdXRpbHNcIlxuaW1wb3J0IENhbWVyYTJkIGZyb20gXCIuLi92aWV3L2NhbWVyYTJkXCJcbmltcG9ydCBFdmVudEhhbmRlciBmcm9tIFwiLi4vdXRpbC9ldmVudC1oYW5kbGVyXCJcbmltcG9ydCBSZXNpemVTZW5zb3IgZnJvbSBcImNzcy1lbGVtZW50LXF1ZXJpZXMvc3JjL1Jlc2l6ZVNlbnNvclwiXG5pbXBvcnQgU3Ryb2tlU3R5bGUgZnJvbSBcIi4uL3N0eWxlL3N0cm9rZS1zdHlsZVwiXG5cbmNvbnN0IG1vdXNlZXZlbnRzID0gW1wibW91c2Vkb3duXCIsIFwibW91c2V1cFwiLCBcIm1vdXNlbW92ZVwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW91dFwiXVxuY29uc3QgbWFyZ2luUHJvcHMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl1cblxuZXhwb3J0IGNvbnN0IEV2ZW50Q29uc3RhbnRzID0ge1xuICBNT1VTRURPV046IFwibW91c2Vkb3duXCIsXG4gIE1PVVNFVVA6IFwibW91c2V1cFwiLFxuICBNT1VTRU1PVkU6IFwibW91c2Vtb3ZlXCIsXG4gIENMSUNLOiBcImNsaWNrXCIsXG4gIERCTENMSUNLOiBcImRibGNsaWNrXCIsXG4gIE1PVVNFT1ZFUjogXCJtb3VzZW92ZXJcIixcbiAgTU9VU0VPVVQ6IFwibW91c2VvdXRcIixcbiAgU0hBUEVfQUREOiBcInNoYXBlOmFkZFwiLFxuICBTSEFQRV9ERUxFVEU6IFwic2hhcGU6ZGVsZXRlXCJcbn1cblxuY2xhc3MgRHJhd1N0eWxlU3RhdGUgZXh0ZW5kcyBCYXNpY1N0eWxlIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpXG4gICAgdGhpcy5fZGVmYXVsdHMgPSB7XG4gICAgICBwYWNrZWRGaWxsQ29sb3I6IHRoaXMucGFja2VkRmlsbENvbG9yLFxuICAgICAgcGFja2VkU3Ryb2tlQ29sb3I6IHRoaXMucGFja2VkU3Ryb2tlQ29sb3IsXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5zdHJva2VXaWR0aCxcbiAgICAgIGxpbmVKb2luOiB0aGlzLmxpbmVKb2luLFxuICAgICAgbGluZUNhcDogdGhpcy5saW5lQ2FwLFxuICAgICAgZGFzaFBhdHRlcm46IHRoaXMuZGFzaFBhdHRlcm4sXG4gICAgICBkYXNoT2Zmc2V0OiB0aGlzLmRhc2hPZmZzZXRcbiAgICB9XG4gIH1cblxuICBzZXRGaWxsU3R5bGUoY3R4LCBmaWxsU3R5bGUpIHtcbiAgICBpZiAoZmlsbFN0eWxlLnBhY2tlZEZpbGxDb2xvciAhPT0gdGhpcy5wYWNrZWRGaWxsQ29sb3IpIHtcbiAgICAgIHRoaXMucGFja2VkRmlsbENvbG9yID0gZmlsbFN0eWxlLnBhY2tlZEZpbGxDb2xvclxuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuZmlsbENvbG9yXG4gICAgfVxuICB9XG5cbiAgc2V0U3Ryb2tlU3R5bGUoY3R4LCBzdHJva2VTdHlsZSkge1xuICAgIGlmIChzdHJva2VTdHlsZS5wYWNrZWRTdHJva2VDb2xvciAhPT0gdGhpcy5wYWNrZWRTdHJva2VDb2xvcikge1xuICAgICAgdGhpcy5wYWNrZWRTdHJva2VDb2xvciA9IHN0cm9rZVN0eWxlLnBhY2tlZFN0cm9rZUNvbG9yXG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZUNvbG9yXG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZS5zdHJva2VXaWR0aCAhPT0gdGhpcy5fc3Ryb2tlV2lkdGgpIHtcbiAgICAgIHRoaXMuc3Ryb2tlV2lkdGggPSBzdHJva2VTdHlsZS5zdHJva2VXaWR0aFxuICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuX3N0cm9rZVdpZHRoXG4gICAgfVxuICAgIGlmIChzdHJva2VTdHlsZS5saW5lSm9pbiAhPT0gdGhpcy5fbGluZUpvaW4pIHtcbiAgICAgIHRoaXMubGluZUpvaW4gPSBzdHJva2VTdHlsZS5saW5lSm9pblxuICAgICAgY3R4LmxpbmVKb2luID0gdGhpcy5fbGluZUpvaW5cbiAgICB9XG4gICAgaWYgKHN0cm9rZVN0eWxlLmxpbmVDYXAgIT09IHRoaXMuX2xpbmVDYXApIHtcbiAgICAgIHRoaXMubGluZUNhcCA9IHN0cm9rZVN0eWxlLmxpbmVDYXBcbiAgICAgIGN0eC5saW5lQ2FwID0gdGhpcy5fbGluZUNhcFxuICAgIH1cblxuICAgIGNvbnN0IGRhc2hQYXR0ZXJuID0gc3Ryb2tlU3R5bGUuX2Rhc2hQYXR0ZXJuXG4gICAgbGV0IGRpZmYgPSBmYWxzZVxuICAgIGlmIChkYXNoUGF0dGVybi5sZW5ndGggPT09IHRoaXMuX2Rhc2hQYXR0ZXJuLmxlbmd0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXNoUGF0dGVybi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZGFzaFBhdHRlcm5baV0gIT09IHRoaXMuX2Rhc2hQYXR0ZXJuW2ldKSB7XG4gICAgICAgICAgZGlmZiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZmYgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKGRpZmYpIHtcbiAgICAgIHRoaXMuZGFzaFBhdHRlcm4gPSBkYXNoUGF0dGVyblxuICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMuX2Rhc2hQYXR0ZXJuKVxuICAgIH1cblxuICAgIGlmIChzdHJva2VTdHlsZS5kYXNoT2Zmc2V0ICE9PSB0aGlzLl9kYXNoT2Zmc2V0KSB7XG4gICAgICB0aGlzLmRhc2hPZmZzZXQgPSBzdHJva2VTdHlsZS5kYXNoT2Zmc2V0XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB0aGlzLl9kYXNoT2Zmc2V0XG4gICAgfVxuICB9XG5cbiAgYXBwbHlEZWZhdWx0cyhjdHgpIHtcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLl9kZWZhdWx0cykuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHRoaXNbcHJvcF0gPSB0aGlzLl9kZWZhdWx0c1twcm9wXVxuICAgIH0pXG4gICAgdGhpcy5zZXRGaWxsQ3R4KGN0eClcbiAgICB0aGlzLnNldFN0cm9rZUN0eChjdHgpXG4gIH1cbn1cblxuY29uc3QgYm91bmRzU3Ryb2tlU3R5bGUgPSBuZXcgU3Ryb2tlU3R5bGUoe1xuICBzdHJva2VDb2xvcjogXCJkYXJrZ3JheVwiLFxuICBzdHJva2VXaWR0aDogMlxufSlcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50ICYmIChgICR7ZWxlbWVudC5jbGFzc05hbWV9IGApLmluZGV4T2YoYCAke2NsYXNzTmFtZX0gYCkgPCAwKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgKz0gKGVsZW1lbnQuY2xhc3NOYW1lID8gXCIgXCIgOiBcIlwiKSArIGNsYXNzTmFtZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhwYXJlbnQpIHtcbiAgY29uc3QgY2FudmFzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICBhZGRDbGFzcyhjYW52YXNDb250YWluZXIsIFwibWFwZC1kcmF3LWNhbnZhcy1jb250YWluZXJcIilcblxuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpXG4gIGNvbnN0IGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gIGNvbnN0IHJhdGlvID0gQ2FudmFzVXRpbHMubWFrZUNhbnZhc0F1dG9IaWdoRFBJKGNhbnZhc0NvbnRleHQpXG4gICAgLy8gY29uc3QgcmF0aW8gPSAxXG5cbiAgLy8gYWRkIGNsYXNzP1xuICBhZGRDbGFzcyhjYW52YXMsIFwibWFwZC1kcmF3LWNhbnZhc1wiKVxuICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIlxuXG4gIGNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjYW52YXMpXG5cbiAgLy8gY2FudmFzLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHJhdGlvICogcGFyZW50Lm9mZnNldFgpXG4gIC8vIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmF0aW8gKiBwYXJlbnQub2Zmc2V0WSlcbiAgLy8gcGFyZW50Lmluc2VydEJlZm9yZShjYW52YXMsIHBhcmVudC5maXJzdENoaWxkKVxuICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzQ29udGFpbmVyKVxuXG4gIHJldHVybiB7XG4gICAgY2FudmFzQ29udGFpbmVyLFxuICAgIGNhbnZhcyxcbiAgICBjYW52YXNDb250ZXh0LFxuICAgIHJhdGlvXG4gIH1cbn1cblxuXG5mdW5jdGlvbiBhZGRTaGFwZXNUb01hcChuZXdTaGFwZXMsIGV4aXN0aW5nT2JqZWN0c01hcCwgY3VycklkcywgcmVvcmRlckNiLCByZWRyYXdDYikge1xuICBuZXdTaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgZXhpc3RpbmdPYmplY3RzTWFwLnNldChzaGFwZSwge1xuICAgICAgc2hhcGVPYmo6IHNoYXBlLFxuICAgICAgc2hhcGVJZDogY3Vycklkcy5zaGFwZUlkLFxuICAgICAgc2hhcGVJZHg6IC0xXG4gICAgfSlcbiAgICBzaGFwZS5vbihbXCJjaGFuZ2VkOm9yZGVyXCIsIFwiY2hhbmdlZDp2aXNpYmlsaXR5XCIsIFwiY2hhbmdlZDpzdHlsZVwiXSwgcmVvcmRlckNiKVxuICAgIHNoYXBlLm9uKFtcImNoYW5nZWQ6Z2VvbVwiLCBcImNoYW5nZWQ6dmlzaWJpbGl0eVwiLCBcImNoYW5nZWQ6eGZvcm1cIl0sIHJlZHJhd0NiKVxuICAgIGN1cnJJZHMuc2hhcGVJZCArPSAxXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGRlbGV0ZVNoYXBlc0Zyb21NYXAoc2hhcGVzLCBleGlzdGluZ09iamVjdHNNYXAsIHJlb3JkZXJDYiwgcmVkcmF3Q2IpIHtcbiAgY29uc3QgaWR4cyA9IFtdXG4gIHNoYXBlcy5mb3JFYWNoKHNoYXBlID0+IHtcbiAgICBjb25zdCBzaGFwZUluZm8gPSBleGlzdGluZ09iamVjdHNNYXAuZ2V0KHNoYXBlKVxuICAgIGlmIChzaGFwZUluZm8pIHtcbiAgICAgIGlkeHMucHVzaChzaGFwZUluZm8uc2hhcGVJZHgpXG4gICAgfVxuICAgIGV4aXN0aW5nT2JqZWN0c01hcC5kZWxldGUoc2hhcGUpXG4gICAgc2hhcGUub2ZmKFtcImNoYW5nZWRcIl0sIFtyZW9yZGVyQ2IsIHJlZHJhd0NiXSlcbiAgfSlcbiAgcmV0dXJuIGlkeHNcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHJhd0VuZ2luZSBleHRlbmRzIEV2ZW50SGFuZGVyIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCBvcHRzKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2luaXQocGFyZW50LCBvcHRzKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLl9kZXN0cm95Q2FudmFzKClcblxuICAgIGlmICh0aGlzLl9vYmplY3RzKSB7XG4gICAgICB0aGlzLl9vYmplY3RzLmZvckVhY2goKHNoYXBlSW5mbywgc2hhcGUpID0+IHtcbiAgICAgICAgc2hhcGUub2ZmKFwiY2hhbmdlZFwiLCBbdGhpcy5fcmVvcmRlckNiLCB0aGlzLl9yZWRyYXdDYl0pXG4gICAgICB9KVxuICAgICAgdGhpcy5fb2JqZWN0cy5jbGVhcigpXG4gICAgICB0aGlzLl9zb3J0ZWRPYmpzID0gW11cbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuY2xlYXIoKVxuICAgIH1cbiAgfVxuXG4gIF9yZXNpemUob3B0cykge1xuICAgIGxldCB3aWR0aCA9IDBcbiAgICBpZiAodGhpcy5fcGFyZW50Lm9mZnNldFdpZHRoKSB7XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCB0aGlzLl9wYXJlbnQub2Zmc2V0V2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0KVxuICAgIH1cblxuICAgIGxldCBoZWlnaHQgPSAwXG4gICAgaWYgKHRoaXMuX3BhcmVudC5vZmZzZXRIZWlnaHQpIHtcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgdGhpcy5fcGFyZW50Lm9mZnNldEhlaWdodCAtIHRoaXMuX21hcmdpbnMudG9wIC0gdGhpcy5fbWFyZ2lucy5ib3R0b20pXG4gICAgfVxuXG4gICAgdGhpcy5fZHJhd0NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5fcGl4ZWxSYXRpb1xuICAgIHRoaXMuX2RyYXdDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5fcGl4ZWxSYXRpb1xuXG4gICAgdGhpcy5fZHJhd0NhbnZhcy5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5fbWFyZ2lucy5sZWZ0fXB4YFxuICAgIHRoaXMuX2RyYXdDYW52YXMuc3R5bGUudG9wID0gYCR7dGhpcy5fbWFyZ2lucy50b3B9cHhgXG4gICAgdGhpcy5fZHJhd0NhbnZhcy5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YFxuICAgIHRoaXMuX2RyYXdDYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YFxuXG4gICAgaWYgKHRoaXMuX2NhbWVyYSkge1xuICAgICAgLy8gY29uc3QgY3VyclZpZXdwb3J0ID0gdGhpcy5fY2FtZXJhLnZpZXdwb3J0XG4gICAgICAvLyBjb25zdCBjdXJyU3BhY2UgPSB0aGlzLl9jYW1lcmEucHJvamVjdGlvbkJvdW5kc1xuICAgICAgLy8gY29uc3Qgdmlld3BvcnRFeHRlbnRzID0gWzAsIDBdXG4gICAgICAvLyBBQUJveDJkLmdldEV4dGVudHModmlld3BvcnRFeHRlbnRzLCBjdXJyVmlld3BvcnQpXG4gICAgICAvLyBjb25zdCBzcGFjZUNlbnRlciA9IFswLCAwXVxuICAgICAgLy8gY29uc3Qgc3BhY2VFeHRlbnRzID0gWzAsIDBdXG4gICAgICAvLyBBQUJveDJkLmdldENlbnRlcihzcGFjZUNlbnRlciwgY3VyclNwYWNlKVxuICAgICAgLy8gQUFCb3gyZC5nZXRFeHRlbnRzKHNwYWNlRXh0ZW50cywgY3VyclNwYWNlKVxuICAgICAgLy8gY29uc3QgcmF0aW8gPSBzcGFjZUV4dGVudHNcbiAgICAgIC8vIFZlYzJkLmRpdihyYXRpbywgc3BhY2VFeHRlbnRzLCB2aWV3cG9ydEV4dGVudHMpXG4gICAgICAvLyBBQUJveDJkLnNldChjdXJyVmlld3BvcnQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpXG4gICAgICAvLyBBQUJveDJkLmdldEV4dGVudHModmlld3BvcnRFeHRlbnRzLCBjdXJyVmlld3BvcnQpXG4gICAgICAvLyBWZWMyZC5tdWx0aXBseShzcGFjZUV4dGVudHMsIHJhdGlvLCB2aWV3cG9ydEV4dGVudHMpXG4gICAgICAvLyBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKGN1cnJTcGFjZSwgc3BhY2VDZW50ZXIsIHNwYWNlRXh0ZW50cylcbiAgICAgIC8vIHRoaXMuX2NhbWVyYS52aWV3cG9ydCA9IGN1cnJWaWV3cG9ydFxuICAgICAgLy8gdGhpcy5fY2FtZXJhLnByb2plY3Rpb25Cb3VuZHMgPSBjdXJyU3BhY2VcbiAgICAgIC8vICAgLy8gdGhpcy5fY2FtZXJhLnZpZXdwb3J0ID0gWzAsIDAsIHdpZHRoLCBoZWlnaHRdXG4gICAgICAvLyAgIC8vIHRoaXMuX2NhbWVyYS5wcm9qZWN0aW9uQm91bmRzID0gWzAsIDAsIHdpZHRoLCBoZWlnaHRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByb2pEaW1zID0gKG9wdHMgJiYgb3B0cy5wcm9qZWN0aW9uRGltZW5zaW9ucyA/IG9wdHMucHJvamVjdGlvbkRpbWVuc2lvbnMgOiBbd2lkdGgsIGhlaWdodF0pXG4gICAgICB0aGlzLl9jYW1lcmEgPSBuZXcgQ2FtZXJhMmQoWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBwcm9qRGltcywgKG9wdHMuZmxpcFkgPyBCb29sZWFuKG9wdHMuZmxpcFkpIDogZmFsc2UpKVxuICAgICAgdGhpcy5fY2FtZXJhLnNldFBvc2l0aW9uKChvcHRzICYmIG9wdHMuY2FtZXJhUG9zaXRpb24gPyBvcHRzLmNhbWVyYVBvc2l0aW9uIDogW3dpZHRoIC8gMi4wLCBoZWlnaHQgLyAyLjBdKSlcbiAgICAgIHRoaXMuX2NhbWVyYS5vbihcImNoYW5nZWRcIiwgdGhpcy5fcmVyZW5kZXJDYilcbiAgICB9XG4gICAgLy8gdGhpcy5fY2FtZXJhID0gbmV3IENhbWVyYTJkKFswLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0sIFswLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodF0pXG4gICAgLy8gdGhpcy5fY2FtZXJhLm9uKFwiY2hhbmdlZFwiLCB0aGlzLl9yZXJlbmRlckNiKVxuXG4gICAgdGhpcy5fcmVyZW5kZXJDYigpXG4gIH1cblxuICBfbW91c2Vkb3duQ0IoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmlyZShcIm1vdXNlZG93blwiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfbW91c2V1cENCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJtb3VzZXVwXCIsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIF9tb3VzZW1vdmVDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwibW91c2Vtb3ZlXCIsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIF9jbGlja0NCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJjbGlja1wiLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBldmVudFxuICAgIH0pXG4gIH1cblxuICBfZGJsY2xpY2tDQihldmVudCkge1xuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuX3BhcmVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5maXJlKFwiZGJsY2xpY2tcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX21vdXNlb3ZlckNCKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5fcGFyZW50KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZpcmUoXCJtb3VzZW92ZXJcIiwge1xuICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnRcbiAgICB9KVxuICB9XG5cbiAgX21vdXNlb3V0Q0IoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuZmlyZShcIm1vdXNlb3V0XCIsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50XG4gICAgfSlcbiAgfVxuXG4gIF9lbmFibGVFdmVudHMoKSB7XG4gICAgdGhpcy5yZWdpc3RlckV2ZW50cyhtb3VzZWV2ZW50cylcbiAgICBjb25zdCBjYWxsYmFja3MgPSBtb3VzZWV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgcmV0dXJuIGBfJHtldmVudH1DQmBcbiAgICB9KVxuICAgIC8vIGJpbmRBbGwoY2FsbGJhY2tzLCB0aGlzKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW91c2VldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIobW91c2VldmVudHNbaV0sIHRoaXNbY2FsbGJhY2tzW2ldXSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBfZGlzYWJsZUV2ZW50cygpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBtb3VzZWV2ZW50cy5tYXAoZXZlbnQgPT4ge1xuICAgICAgcmV0dXJuIGBfJHtldmVudH1DQmBcbiAgICB9KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW91c2VldmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIobW91c2VldmVudHNbaV0sIHRoaXNbY2FsbGJhY2tzW2ldXSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICBfaW5pdENhbnZhcyhwYXJlbnQsIG9wdHMsIGZvcmNlRXZlbnRzID0gbnVsbCkge1xuICAgIHRoaXMuX21hcmdpbnMgPSAob3B0cyAmJiBvcHRzLm1hcmdpbnMgPyBPYmplY3QuYXNzaWduKHt9LCBvcHRzLm1hcmdpbnMpIDoge30pXG4gICAgbWFyZ2luUHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fbWFyZ2luc1twcm9wXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aGlzLl9tYXJnaW5zW3Byb3BdID0gMFxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250YWluZXIsXG4gICAgICBjYW52YXMsXG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgcmF0aW9cbiAgICB9ID0gY3JlYXRlQ2FudmFzKHBhcmVudClcblxuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNhbnZhc0NvbnRhaW5lclxuICAgIHRoaXMuX2RyYXdDYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLl9kcmF3Q3R4ID0gY2FudmFzQ29udGV4dFxuICAgIHRoaXMuX3BpeGVsUmF0aW8gPSByYXRpb1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuXG4gICAgYmluZEFsbChbXCJfcmVzaXplXCJdLCB0aGlzKVxuICAgIHRoaXMuX3Jlc2l6ZShvcHRzKVxuICAgIHRoaXMuX3Jlc2l6ZVNlbnNvciA9IG5ldyBSZXNpemVTZW5zb3IocGFyZW50LCB0aGlzLl9yZXNpemUpXG5cbiAgICBpZiAoZm9yY2VFdmVudHMgfHwgKGZvcmNlRXZlbnRzID09PSBudWxsICYmIG9wdHMgJiYgb3B0cy5lbmFibGVFdmVudHMpKSB7XG4gICAgICB0aGlzLl9lbmFibGVFdmVudHMoKVxuICAgIH1cbiAgfVxuXG4gIF9kZXN0cm95Q2FudmFzKCkge1xuICAgIGlmICh0aGlzLl9kcmF3Q2FudmFzKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlRXZlbnRzKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5fZHJhd0NhbnZhcylcblxuICAgICAgaWYgKHRoaXMuX3Jlc2l6ZVNlbnNvcikge1xuICAgICAgICB0aGlzLl9yZXNpemVTZW5zb3IuZGV0YWNoKHRoaXMuX3BhcmVudCwgdGhpcy5fcmVzaXplKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2RyYXdDYW52YXMgPSBudWxsXG4gICAgdGhpcy5fZHJhd0N0eCA9IG51bGxcbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsXG4gIH1cblxuICBfaW5pdChwYXJlbnQsIG9wdHMsIGZvcmNlRXZlbnRzID0gbnVsbCkge1xuICAgIHRoaXMucmVnaXN0ZXJFdmVudHMoW0V2ZW50Q29uc3RhbnRzLlNIQVBFX0FERCwgRXZlbnRDb25zdGFudHMuU0hBUEVfREVMRVRFXSlcblxuICAgIGJpbmRBbGwoW1wiX3Jlb3JkZXJDYlwiLCBcIl9yZXJlbmRlckNiXCJdLCB0aGlzKVxuICAgIGJpbmRBbGwoW1wiX21vdXNlZG93bkNCXCIsIFwiX21vdXNldXBDQlwiLCBcIl9tb3VzZW1vdmVDQlwiLCBcIl9jbGlja0NCXCIsIFwiX2RibGNsaWNrQ0JcIiwgXCJfbW91c2VvdmVyQ0JcIiwgXCJfbW91c2VvdXRDQlwiXSwgdGhpcylcblxuICAgIHRoaXMuX3JlbmRlckZyYW1lQ2IgPSB0aGlzLnJlbmRlckFsbC5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVuZGVyUmVxdWVzdElkID0gMFxuICAgIHRoaXMuX2lkcyA9IHtcbiAgICAgIHNoYXBlSWQ6IDFcbiAgICB9XG5cbiAgICB0aGlzLl9vYmplY3RzID0gbmV3IE1hcCgpXG4gICAgdGhpcy5fc29ydGVkT2JqcyA9IFtdXG4gICAgdGhpcy5fcmVvcmRlcmVkT2JqSWR4cyA9IG5ldyBTZXQoKVxuXG4gICAgdGhpcy5faW5pdENhbnZhcyhwYXJlbnQsIG9wdHMsIGZvcmNlRXZlbnRzKVxuXG4gICAgdGhpcy5fc3R5bGVTdGF0ZSA9IG5ldyBEcmF3U3R5bGVTdGF0ZSh7XG4gICAgICBmaWxsQ29sb3I6IFwicmVkXCJcbiAgICB9KVxuICB9XG5cbiAgZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRcbiAgfVxuXG4gIGdldENhbnZhc0NvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyXG4gIH1cblxuICBnZXRDYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RyYXdDYW52YXNcbiAgfVxuXG4gIGdldCBzb3J0ZWRTaGFwZXMoKSB7XG4gICAgaWYgKHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuc2l6ZSkge1xuICAgICAgY29uc29sZS5hc3NlcnQodGhpcy5fc29ydGVkT2Jqcy5sZW5ndGggPT09IHRoaXMuX29iamVjdHMuc2l6ZSxcbiAgICAgICAgYFNpemUgbWlzbWF0Y2ggd2hlbiByZW5kZXJpbmcgb2JqZXRzLiBTb21ldGhpbmcgZ290IG91dCBvZiBzeW5jIC0gc29ydGVkIG9ianMgbGVuZ3RoOiAke3RoaXMuX3NvcnRlZE9ianMubGVuZ3RofSwgb2JqZWN0cyBsZW5ndGg6ICR7dGhpcy5fb2JqZWN0cy5zaXplfWApXG5cbiAgICAgIC8vIGlmICh0aGlzLl9yZW9yZGVyZWRPYmpJZHhzLmxlbmd0aCAvIHRoaXMuX3NvcnRlZE9ianMubGVuZ3RoID4gMC43KSB7XG4gICAgICAvLyAgIC8vIG1pZ2h0IGFzIHdlbGwganVzdCByZXNvcnQgdGhlIHdob2xlIHRoaW5nIG92ZXJcbiAgICAgIC8vICAgdGhpcy5fc29ydGVkT2Jqcy5zb3J0KHNoYXBlSW5mb0NvbXBhcmUpXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gfVxuXG4gICAgICB0aGlzLl9zb3J0ZWRPYmpzLnNvcnQoQmFzZVNoYXBlLnNoYXBlQ29tcGFyZSlcbiAgICAgIHRoaXMuX3Jlb3JkZXJlZE9iaklkeHMuY2xlYXIoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc29ydGVkT2Jqc1xuICB9XG5cbiAgZ2V0IG1hcmdpbnMoKSB7XG4gICAgY29uc3QgcnRuID0ge31cbiAgICBtYXJnaW5Qcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcnRuW3Byb3BdID0gdGhpcy5fbWFyZ2luc1twcm9wXVxuICAgIH0pXG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbiAgc2V0IG1hcmdpbnMobWFyZ2lucykge1xuICAgIGxldCByZXNpemUgPSBmYWxzZVxuICAgIG1hcmdpblByb3BzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1hcmdpbnNbcHJvcF0gPT09IFwibnVtYmVyXCIgJiYgbWFyZ2luc1twcm9wXSAhPT0gdGhpcy5fbWFyZ2luc1twcm9wXSkge1xuICAgICAgICB0aGlzLl9tYXJnaW5zW3Byb3BdID0gbWFyZ2lucy5wcm9wXG4gICAgICAgIHJlc2l6ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5fcmVzaXplKClcbiAgfVxuXG4gIGdldCB2aWV3cG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FtZXJhLnZpZXdwb3J0XG4gIH1cblxuICBzZXQgdmlld3BvcnQodmlld3BvcnQpIHtcbiAgICB0aGlzLl9jYW1lcmEudmlld3BvcnQgPSB2aWV3cG9ydFxuICB9XG5cbiAgZ2V0IHByb2plY3Rpb25EaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jYW1lcmEucHJvamVjdGlvbkRpbWVuc2lvbnNcbiAgfVxuXG4gIHNldCBwcm9qZWN0aW9uRGltZW5zaW9ucyhwcm9qZWN0aW9uRGltZW5zaW9ucykge1xuICAgIHRoaXMuX2NhbWVyYS5wcm9qZWN0aW9uRGltZW5zaW9ucyA9IHByb2plY3Rpb25EaW1lbnNpb25zXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBjYW1lcmFQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FtZXJhLmdldFBvc2l0aW9uKClcbiAgfVxuXG4gIHNldCBjYW1lcmFQb3NpdGlvbihwb3MpIHtcbiAgICB0aGlzLl9jYW1lcmEuc2V0UG9zaXRpb24ocG9zKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcm9qZWN0KG91dCwgc2NyZWVuUHQpIHtcbiAgICBjb25zdCBzY3JlZW5Ub1dvcmxkTWF0cml4ID0gdGhpcy5fY2FtZXJhLnNjcmVlblRvV29ybGRNYXRyaXhcbiAgICByZXR1cm4gUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChvdXQsIHNjcmVlblB0LCBzY3JlZW5Ub1dvcmxkTWF0cml4KVxuICB9XG5cbiAgdW5wcm9qZWN0KG91dCwgd29ybGRQdCkge1xuICAgIGNvbnN0IHdvcmxkVG9TY3JlZW5NYXRyaXggPSB0aGlzLl9jYW1lcmEud29ybGRUb1NjcmVlbk1hdHJpeFxuICAgIHJldHVybiBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKG91dCwgd29ybGRQdCwgd29ybGRUb1NjcmVlbk1hdHJpeClcbiAgfVxuXG4gIGhhc1NoYXBlKHNoYXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuX29iamVjdHMuaGFzKHNoYXBlKVxuICB9XG5cbiAgYWRkU2hhcGUoc2hhcGUpIHtcbiAgICBsZXQgc2hhcGVzID0gc2hhcGVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuICAgICAgc2hhcGVzID0gW3NoYXBlXVxuICAgIH1cblxuICAgIGFkZFNoYXBlc1RvTWFwKHNoYXBlcywgdGhpcy5fb2JqZWN0cywgdGhpcy5faWRzLCB0aGlzLl9yZW9yZGVyQ2IsIHRoaXMuX3JlcmVuZGVyQ2IpXG5cbiAgICAvLyBmaXJlIGFkZCBldmVudFxuICAgIHRoaXMuZmlyZShcInNoYXBlOmFkZFwiLCB7XG4gICAgICBzaGFwZTogc2hhcGVzXG4gICAgfSlcblxuICAgIGNvbnN0IHByb3h5RXZlbnQgPSB7XG4gICAgICB0YXJnZXQ6IHNoYXBlc1xuICAgIH1cbiAgICB0aGlzLl9yZW9yZGVyQ2IocHJveHlFdmVudClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBkZWxldGVTaGFwZShzaGFwZSkge1xuICAgIGxldCBzaGFwZXMgPSBzaGFwZVxuICAgIGlmICghQXJyYXkuaXNBcnJheShzaGFwZXMpKSB7XG4gICAgICBzaGFwZXMgPSBbc2hhcGVdXG4gICAgfVxuXG4gICAgY29uc3QgaWR4cyA9IGRlbGV0ZVNoYXBlc0Zyb21NYXAoc2hhcGVzLCB0aGlzLl9vYmplY3RzLCB0aGlzLl9yZW9yZGVyQ2IsIHRoaXMuX3JlcmVuZGVyQ2IpXG4gICAgbGV0IGluZGV4ID0gLTFcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKChpbmRleCA9IHRoaXMuX3NvcnRlZE9ianMuaW5kZXhPZihzaGFwZXNbaV0pKSA+PSAwKSB7XG4gICAgICAgIHRoaXMuX3NvcnRlZE9ianMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVvcmRlcmVkT2JqSWR4cy5hZGQoaWR4c1tpXSlcbiAgICB9XG4gICAgdGhpcy5fcmVyZW5kZXJDYigpXG5cbiAgICB0aGlzLmZpcmUoXCJzaGFwZTpkZWxldGVcIiwge1xuICAgICAgc2hhcGU6IHNoYXBlc1xuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZGVsZXRlQWxsU2hhcGVzKCkge1xuICAgIHRoaXMuZGVsZXRlU2hhcGUodGhpcy5zb3J0ZWRTaGFwZXMuc2xpY2UoKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgbW92ZVNoYXBlVG9Ub3Aoc2hhcGUpIHtcbiAgICBpZiAodGhpcy5fb2JqZWN0cy5oYXMoc2hhcGUpKSB7XG4gICAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgICAgY29uc3QgemluZGV4ID0gc2hhcGVzW3NoYXBlcy5sZW5ndGggLSAxXS56SW5kZXhcbiAgICAgIHNoYXBlLnpJbmRleCA9IHppbmRleCArIDFcbiAgICB9XG4gIH1cblxuICBtb3ZlU2hhcGVUb0JhY2soc2hhcGUpIHtcbiAgICBpZiAodGhpcy5fb2JqZWN0cy5oYXMoc2hhcGUpKSB7XG4gICAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgICAgY29uc3QgemluZGV4ID0gc2hhcGVzWzBdLnpJbmRleFxuICAgICAgc2hhcGUuekluZGV4ID0gemluZGV4XG4gICAgfVxuICB9XG5cbiAgZ2V0U2hhcGVzQXNKU09OKCkge1xuICAgIGNvbnN0IHNoYXBlcyA9IHRoaXMuc29ydGVkU2hhcGVzXG4gICAgcmV0dXJuIHNoYXBlcy5tYXAoc2hhcGUgPT4ge1xuICAgICAgcmV0dXJuIHNoYXBlLnRvSlNPTigpXG4gICAgfSlcbiAgfVxuXG4gIF9yZXJlbmRlckNiKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX3JlbmRlclJlcXVlc3RJZCkge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlbmRlclJlcXVlc3RJZClcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyUmVxdWVzdElkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yZW5kZXJGcmFtZUNiKVxuICB9XG5cbiAgX3Jlb3JkZXJDYihldmVudCkge1xuICAgIGxldCBjaGFuZ2VkU2hhcGVzID0gZXZlbnQudGFyZ2V0XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNoYW5nZWRTaGFwZXMpKSB7XG4gICAgICBjaGFuZ2VkU2hhcGVzID0gW2V2ZW50LnRhcmdldF1cbiAgICB9XG4gICAgY2hhbmdlZFNoYXBlcy5mb3JFYWNoKGNoYW5nZWRTaGFwZSA9PiB7XG4gICAgICBjb25zb2xlLmFzc2VydChjaGFuZ2VkU2hhcGUsIFwiQSBjaGFuZ2VkIGV2ZW50IGRvZXNuJ3QgaGF2ZSBhbiBvYmplY3RcIilcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KGNoYW5nZWRTaGFwZSlcbiAgICAgIGNvbnNvbGUuYXNzZXJ0KHNoYXBlSW5mbywgXCJBIGNoYW5nZWQgZXZlbnQgdGFyZ2V0IGlzbid0IGluIHRoZSBsaXN0IG9mIHNoYXBlcyBcIiArIGNoYW5nZWRTaGFwZSlcbiAgICAgIGlmIChzaGFwZUluZm8uc2hhcGVJZHggPCAwKSB7XG4gICAgICAgIHNoYXBlSW5mby5zaGFwZUlkeCA9IHRoaXMuX3NvcnRlZE9ianMucHVzaChjaGFuZ2VkU2hhcGUpIC0gMVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVvcmRlcmVkT2JqSWR4cy5hZGQoc2hhcGVJbmZvLnNoYXBlSWR4KVxuICAgIH0pXG4gICAgdGhpcy5fcmVyZW5kZXJDYigpXG4gIH1cblxuICBfcmVuZGVyU2hhcGVzKGN0eCwgZHJhd1NoYXBlcywgY2FtZXJhKSB7XG4gICAgY29uc3Qgd29ybGRUb1NjcmVlbk1hdCA9IGNhbWVyYS53b3JsZFRvU2NyZWVuTWF0cml4XG4gICAgZHJhd1NoYXBlcy5mb3JFYWNoKHNoYXBlID0+IHtcbiAgICAgIGlmIChzaGFwZS52aXNpYmxlKSB7XG4gICAgICAgIHNoYXBlLnJlbmRlcihjdHgsIHdvcmxkVG9TY3JlZW5NYXQsIHRoaXMuX3N0eWxlU3RhdGUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlckFsbCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9kcmF3Q3R4XG4gICAgICAvLyBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fZHJhd0NhbnZhcy5vZmZzZXRXaWR0aCwgdGhpcy5fZHJhd0NhbnZhcy5vZmZzZXRIZWlnaHQpXG5cbiAgICBpZiAoIXRoaXMuX29iamVjdHMuc2l6ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKVxuICAgIGNvbnN0IGRyYXdTaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIHRoaXMuX3N0eWxlU3RhdGUuYXBwbHlEZWZhdWx0cyhjdHgpXG4gICAgdGhpcy5fcmVuZGVyU2hhcGVzKGN0eCwgZHJhd1NoYXBlcywgdGhpcy5fY2FtZXJhKVxuICAgIGN0eC5yZXN0b3JlKClcbiAgfVxufVxuXG5EcmF3RW5naW5lLkV2ZW50Q29uc3RhbnRzID0gRXZlbnRDb25zdGFudHNcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VuZ2luZS9kcmF3LWVuZ2luZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} RectOptions\n * @property {number} [width=0] Width of the rect in world space coords\n * @property {number} [height=0] Height of the rect in world space coords\n */\n\n/**\n * @class Class for defining a rectangle shape\n * @extends {BaseShape}\n */\nvar Rect = function (_BaseShape) {\n  _inherits(Rect, _BaseShape);\n\n  /**\n   * Creates a new rectangle shape\n   * @param  {RectOptions} [opts]\n   * @return {Rect}\n   */\n  function Rect(opts) {\n    _classCallCheck(this, Rect);\n\n    var _this = _possibleConstructorReturn(this, (Rect.__proto__ || Object.getPrototypeOf(Rect)).call(this, opts));\n\n    _this._width = 0;\n    _this._height = 0;\n    if (typeof opts.width !== \"undefined\") {\n      _this.width = opts.width;\n    }\n    if (typeof opts.height !== \"undefined\") {\n      _this.height = opts.height;\n    }\n    return _this;\n  }\n\n  /**\n   * Gets the untransformed width/height of the rect\n   * @return {Vec2d} Width/height of the rect\n   */\n\n\n  _createClass(Rect, [{\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return [this._width, this._height];\n    }\n\n    /**\n     * Sets the width of the rectangle\n     * @param  {number} width Width of the rect in world-space coordinates\n     * @return {Rect}       this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If width is not a valid number\n     */\n\n  }, {\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        AABox2d.initCenterExtents(this._aabox, [0, 0], [this._width / 2, this._height / 2]);\n        AABox2d.transformMat2d(this._aabox, this._aabox, this.globalXform);\n        this._geomDirty = this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the rect using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.rect(0 - this.width / 2, 0 - this.height / 2, this.width, this.height);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Rect\",\n        width: this.width,\n        height: this.height\n      }, _get(Rect.prototype.__proto__ || Object.getPrototypeOf(Rect.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"width\",\n    set: function set(width) {\n      if (typeof width !== \"number\") {\n        throw new Error(\"Width must be a number\");\n      }\n\n      if (width !== this._width) {\n        var prev = this._width;\n        this._width = width;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"width\",\n          prevVal: prev,\n          currVal: this._width\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current untransformed width of the rect\n     * @return {number} Width in world-space units\n     */\n    ,\n    get: function get() {\n      return this._width;\n    }\n\n    /**\n     * Sets the height of the rectangle\n     * @param  {number} height Height of the rect in world-space units\n     * @return {Rect}       this\n     * @fires {Shape#geomChanged}\n     * @throws {Error} If height is not a valid number\n     */\n\n  }, {\n    key: \"height\",\n    set: function set(height) {\n      if (typeof height !== \"number\") {\n        throw new Error(\"Height must be a number\");\n      }\n\n      if (height !== this._height) {\n        var prev = this._height;\n        this._height = height;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"height\",\n          prevVal: prev,\n          currVal: this._height\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current untransformed height of the rect\n     * @return {number} Height in world-space units\n     */\n    ,\n    get: function get() {\n      return this._height;\n    }\n  }]);\n\n  return Rect;\n}(_baseShape2.default);\n\nexports.default = Rect;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcmVjdC5qcz80ZDJiIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJSZWN0Iiwib3B0cyIsIl93aWR0aCIsIl9oZWlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJ0cmFuc2Zvcm1NYXQyZCIsImdsb2JhbFhmb3JtIiwiY3R4IiwicmVjdCIsIk9iamVjdCIsImFzc2lnbiIsInR5cGUiLCJFcnJvciIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7QUFNQTs7OztJQUlxQkMsSTs7O0FBQ25COzs7OztBQUtBLGdCQUFZQyxJQUFaLEVBQWtCO0FBQUE7O0FBQUEsNEdBQ1ZBLElBRFU7O0FBRWhCLFVBQUtDLE1BQUwsR0FBYyxDQUFkO0FBQ0EsVUFBS0MsT0FBTCxHQUFlLENBQWY7QUFDQSxRQUFJLE9BQU9GLEtBQUtHLEtBQVosS0FBc0IsV0FBMUIsRUFBdUM7QUFDckMsWUFBS0EsS0FBTCxHQUFhSCxLQUFLRyxLQUFsQjtBQUNEO0FBQ0QsUUFBSSxPQUFPSCxLQUFLSSxNQUFaLEtBQXVCLFdBQTNCLEVBQXdDO0FBQ3RDLFlBQUtBLE1BQUwsR0FBY0osS0FBS0ksTUFBbkI7QUFDRDtBQVRlO0FBVWpCOztBQUVEOzs7Ozs7OztvQ0FJZ0I7QUFDZCxhQUFPLENBQUMsS0FBS0gsTUFBTixFQUFjLEtBQUtDLE9BQW5CLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7Ozs7O0FBb0VBOzs7OzttQ0FLZTtBQUNiLFVBQUksS0FBS0csVUFBTCxJQUFtQixLQUFLQyxnQkFBNUIsRUFBOEM7QUFDNUNSLGdCQUFRUyxpQkFBUixDQUEwQixLQUFLQyxNQUEvQixFQUF1QyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQXZDLEVBQStDLENBQUMsS0FBS1AsTUFBTCxHQUFjLENBQWYsRUFBa0IsS0FBS0MsT0FBTCxHQUFlLENBQWpDLENBQS9DO0FBQ0FKLGdCQUFRVyxjQUFSLENBQXVCLEtBQUtELE1BQTVCLEVBQW9DLEtBQUtBLE1BQXpDLEVBQWlELEtBQUtFLFdBQXREO0FBQ0EsYUFBS0wsVUFBTCxHQUFrQixLQUFLQyxnQkFBTCxHQUF3QixLQUExQztBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzswQkFNTUssRyxFQUFLO0FBQ1RBLFVBQUlDLElBQUosQ0FBUyxJQUFJLEtBQUtULEtBQUwsR0FBYSxDQUExQixFQUE2QixJQUFJLEtBQUtDLE1BQUwsR0FBYyxDQUEvQyxFQUFrRCxLQUFLRCxLQUF2RCxFQUE4RCxLQUFLQyxNQUFuRTtBQUNEOztBQUVEOzs7Ozs7Ozs2QkFLUztBQUNQLGFBQU9TLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxNQURhO0FBRW5CWixlQUFPLEtBQUtBLEtBRk87QUFHbkJDLGdCQUFRLEtBQUtBO0FBSE0sT0FBZCxxR0FBUDtBQUtEOzs7c0JBL0ZTRCxLLEVBQU87QUFDZixVQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsY0FBTSxJQUFJYSxLQUFKLENBQVUsd0JBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUliLFVBQVUsS0FBS0YsTUFBbkIsRUFBMkI7QUFDekIsWUFBTWdCLE9BQU8sS0FBS2hCLE1BQWxCO0FBQ0EsYUFBS0EsTUFBTCxHQUFjRSxLQUFkO0FBQ0EsYUFBS0UsVUFBTCxHQUFrQixJQUFsQixDQUh5QixDQUdGOztBQUV2QixhQUFLYSxJQUFMLENBQVUsY0FBVixFQUEwQjtBQUN4QkMsZ0JBQU0sT0FEa0I7QUFFeEJDLG1CQUFTSCxJQUZlO0FBR3hCSSxtQkFBUyxLQUFLcEI7QUFIVSxTQUExQjtBQUtEO0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlZO0FBQ1YsYUFBTyxLQUFLQSxNQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7c0JBT1dHLE0sRUFBUTtBQUNqQixVQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUIsY0FBTSxJQUFJWSxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUlaLFdBQVcsS0FBS0YsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTWUsT0FBTyxLQUFLZixPQUFsQjtBQUNBLGFBQUtBLE9BQUwsR0FBZUUsTUFBZjtBQUNBLGFBQUtDLFVBQUwsR0FBa0IsSUFBbEIsQ0FIMkIsQ0FHSjs7QUFFdkIsYUFBS2EsSUFBTCxDQUFVLGNBQVYsRUFBMEI7QUFDeEJDLGdCQUFNLFFBRGtCO0FBRXhCQyxtQkFBU0gsSUFGZTtBQUd4QkksbUJBQVMsS0FBS25CO0FBSFUsU0FBMUI7QUFLRDtBQUNELGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJYTtBQUNYLGFBQU8sS0FBS0EsT0FBWjtBQUNEOzs7Ozs7a0JBNUZrQkgsSSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgQmFzZVNoYXBlIGZyb20gXCIuL2Jhc2Utc2hhcGUuanNcIlxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJlY3RPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3dpZHRoPTBdIFdpZHRoIG9mIHRoZSByZWN0IGluIHdvcmxkIHNwYWNlIGNvb3Jkc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtoZWlnaHQ9MF0gSGVpZ2h0IG9mIHRoZSByZWN0IGluIHdvcmxkIHNwYWNlIGNvb3Jkc1xuICovXG5cbi8qKlxuICogQGNsYXNzIENsYXNzIGZvciBkZWZpbmluZyBhIHJlY3RhbmdsZSBzaGFwZVxuICogQGV4dGVuZHMge0Jhc2VTaGFwZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjdCBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHJlY3RhbmdsZSBzaGFwZVxuICAgKiBAcGFyYW0gIHtSZWN0T3B0aW9uc30gW29wdHNdXG4gICAqIEByZXR1cm4ge1JlY3R9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl93aWR0aCA9IDBcbiAgICB0aGlzLl9oZWlnaHQgPSAwXG4gICAgaWYgKHR5cGVvZiBvcHRzLndpZHRoICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLndpZHRoID0gb3B0cy53aWR0aFxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuaGVpZ2h0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IG9wdHMuaGVpZ2h0XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHVudHJhbnNmb3JtZWQgd2lkdGgvaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAqIEByZXR1cm4ge1ZlYzJkfSBXaWR0aC9oZWlnaHQgb2YgdGhlIHJlY3RcbiAgICovXG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0XVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB0aGUgcmVjdCBpbiB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtSZWN0fSAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB3aWR0aCBpcyBub3QgYSB2YWxpZCBudW1iZXJcbiAgICovXG4gIHNldCB3aWR0aCh3aWR0aCkge1xuICAgIGlmICh0eXBlb2Ygd2lkdGggIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoIG11c3QgYmUgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoKSB7XG4gICAgICBjb25zdCBwcmV2ID0gdGhpcy5fd2lkdGhcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGhcbiAgICAgIHRoaXMuX2dlb21EaXJ0eSA9IHRydWUgLy8gZGlydHkgbmVlZHMgdG8gYmUgc2V0IGJlZm9yZSBmaXJpbmcgZXZlbnRcblxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZDpnZW9tXCIsIHtcbiAgICAgICAgYXR0cjogXCJ3aWR0aFwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl93aWR0aFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVudHJhbnNmb3JtZWQgd2lkdGggb2YgdGhlIHJlY3RcbiAgICogQHJldHVybiB7bnVtYmVyfSBXaWR0aCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aFxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXG4gICAqIEBwYXJhbSAge251bWJlcn0gaGVpZ2h0IEhlaWdodCBvZiB0aGUgcmVjdCBpbiB3b3JsZC1zcGFjZSB1bml0c1xuICAgKiBAcmV0dXJuIHtSZWN0fSAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBoZWlnaHQgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAqL1xuICBzZXQgaGVpZ2h0KGhlaWdodCkge1xuICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWlnaHQgbXVzdCBiZSBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIGlmIChoZWlnaHQgIT09IHRoaXMuX2hlaWdodCkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2hlaWdodFxuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0XG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwiaGVpZ2h0XCIsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IHRoaXMuX2hlaWdodFxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHVudHJhbnNmb3JtZWQgaGVpZ2h0IG9mIHRoZSByZWN0XG4gICAqIEByZXR1cm4ge251bWJlcn0gSGVpZ2h0IGluIHdvcmxkLXNwYWNlIHVuaXRzXG4gICAqL1xuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgYm91bmRpbmcgYm94IHJlcXVpcmVzIHVwZGF0aW5nXG4gICAqIEBwcml2YXRlXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX3VwZGF0ZUFBQm94KCkge1xuICAgIGlmICh0aGlzLl9nZW9tRGlydHkgfHwgdGhpcy5fYm91bmRzT3V0T2ZEYXRlKSB7XG4gICAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl93aWR0aCAvIDIsIHRoaXMuX2hlaWdodCAvIDJdKVxuICAgICAgQUFCb3gyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl9hYWJveCwgdGhpcy5fYWFib3gsIHRoaXMuZ2xvYmFsWGZvcm0pXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEcmF3cyB0aGUgcmVjdCB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5yZWN0KDAgLSB0aGlzLndpZHRoIC8gMiwgMCAtIHRoaXMuaGVpZ2h0IC8gMiwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGNvbnZlcnQgdGhlIHNoYXBlIHRvIGEgc2VyaWFsaXphYmxlIEpTT04gb2JqZWN0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogXCJSZWN0XCIsXG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9LCBzdXBlci50b0pTT04oKSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3JlY3QuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedColorRGBAClass = createEventedColorRGBAClass;\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Color keywords as defined by the CSS color modules\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value}\n * @type {Map}\n */\nvar colorKeywords = new Map([[\"aliceblue\", \"#F0F8FF\"], [\"antiquewhite\", \"#FAEBD7\"], [\"aqua\", \"#00FFFF\"], [\"aquamarine\", \"#7FFFD4\"], [\"azure\", \"#F0FFFF\"], [\"beige\", \"#F5F5DC\"], [\"bisque\", \"#FFE4C4\"], [\"black\", \"#000000\"], [\"blanchedalmond\", \"#FFEBCD\"], [\"blue\", \"#0000FF\"], [\"blueviolet\", \"#8A2BE2\"], [\"brown\", \"#A52A2A\"], [\"burlywood\", \"#DEB887\"], [\"cadetblue\", \"#5F9EA0\"], [\"chartreuse\", \"#7FFF00\"], [\"chocolate\", \"#D2691E\"], [\"coral\", \"#FF7F50\"], [\"cornflowerblue\", \"#6495ED\"], [\"cornsilk\", \"#FFF8DC\"], [\"crimson\", \"#DC143C\"], [\"cyan\", \"#00FFFF\"], [\"darkblue\", \"#00008B\"], [\"darkcyan\", \"#008B8B\"], [\"darkgoldenrod\", \"#B8860B\"], [\"darkgray\", \"#A9A9A9\"], [\"darkgreen\", \"#006400\"], [\"darkkhaki\", \"#BDB76B\"], [\"darkmagenta\", \"#8B008B\"], [\"darkolivegreen\", \"#556B2F\"], [\"darkorange\", \"#FF8C00\"], [\"darkorchid\", \"#9932CC\"], [\"darkred\", \"#8B0000\"], [\"darksalmon\", \"#E9967A\"], [\"darkseagreen\", \"#8FBC8F\"], [\"darkslateblue\", \"#483D8B\"], [\"darkslategray\", \"#2F4F4F\"], [\"darkturquoise\", \"#00CED1\"], [\"darkviolet\", \"#9400D3\"], [\"deeppink\", \"#FF1493\"], [\"deepskyblue\", \"#00BFFF\"], [\"dimgray\", \"#696969\"], [\"dodgerblue\", \"#1E90FF\"], [\"firebrick\", \"#B22222\"], [\"floralwhite\", \"#FFFAF0\"], [\"forestgreen\", \"#228B22\"], [\"fuchsia\", \"#FF00FF\"], [\"gainsboro\", \"#DCDCDC\"], [\"ghostwhite\", \"#F8F8FF\"], [\"gold\", \"#FFD700\"], [\"goldenrod\", \"#DAA520\"], [\"gray\", \"#808080\"], [\"green\", \"#008000\"], [\"greenyellow\", \"#ADFF2F\"], [\"honeydew\", \"#F0FFF0\"], [\"hotpink\", \"#FF69B4\"], [\"indianred\", \"#CD5C5C\"], [\"indigo\", \"#4B0082\"], [\"ivory\", \"#FFFFF0\"], [\"khaki\", \"#F0E68C\"], [\"lavender\", \"#E6E6FA\"], [\"lavenderblush\", \"#FFF0F5\"], [\"lawngreen\", \"#7CFC00\"], [\"lemonchiffon\", \"#FFFACD\"], [\"lightblue\", \"#ADD8E6\"], [\"lightcoral\", \"#F08080\"], [\"lightcyan\", \"#E0FFFF\"], [\"lightgoldenrodyellow\", \"#FAFAD2\"], [\"lightgray\", \"#D3D3D3\"], [\"lightgreen\", \"#90EE90\"], [\"lightpink\", \"#FFB6C1\"], [\"lightsalmon\", \"#FFA07A\"], [\"lightseagreen\", \"#20B2AA\"], [\"lightskyblue\", \"#87CEFA\"], [\"lightslategray\", \"#778899\"], [\"lightsteelblue\", \"#B0C4DE\"], [\"lightyellow\", \"#FFFFE0\"], [\"lime\", \"#00FF00\"], [\"limegreen\", \"#32CD32\"], [\"linen\", \"#FAF0E6\"], [\"magenta\", \"#FF00FF\"], [\"maroon\", \"#800000\"], [\"mediumaquamarine\", \"#66CDAA\"], [\"mediumblue\", \"#0000CD\"], [\"mediumorchid\", \"#BA55D3\"], [\"mediumpurple\", \"#9370DB\"], [\"mediumseagreen\", \"#3CB371\"], [\"mediumslateblue\", \"#7B68EE\"], [\"mediumspringgreen\", \"#00FA9A\"], [\"mediumturquoise\", \"#48D1CC\"], [\"mediumvioletred\", \"#C71585\"], [\"midnightblue\", \"#191970\"], [\"mintcream\", \"#F5FFFA\"], [\"mistyrose\", \"#FFE4E1\"], [\"moccasin\", \"#FFE4B5\"], [\"navajowhite\", \"#FFDEAD\"], [\"navy\", \"#000080\"], [\"oldlace\", \"#FDF5E6\"], [\"olive\", \"#808000\"], [\"olivedrab\", \"#6B8E23\"], [\"orange\", \"#FFA500\"], [\"orangered\", \"#FF4500\"], [\"orchid\", \"#DA70D6\"], [\"palegoldenrod\", \"#EEE8AA\"], [\"palegreen\", \"#98FB98\"], [\"paleturquoise\", \"#AFEEEE\"], [\"palevioletred\", \"#DB7093\"], [\"papayawhip\", \"#FFEFD5\"], [\"peachpuff\", \"#FFDAB9\"], [\"peru\", \"#CD853F\"], [\"pink\", \"#FFC0CB\"], [\"plum\", \"#DDA0DD\"], [\"powderblue\", \"#B0E0E6\"], [\"purple\", \"#800080\"], [\"rebeccapurple\", \"#663399\"], [\"red\", \"#FF0000\"], [\"rosybrown\", \"#BC8F8F\"], [\"royalblue\", \"#4169E1\"], [\"saddlebrown\", \"#8B4513\"], [\"salmon\", \"#FA8072\"], [\"sandybrown\", \"#F4A460\"], [\"seagreen\", \"#2E8B57\"], [\"seashell\", \"#FFF5EE\"], [\"sienna\", \"#A0522D\"], [\"silver\", \"#C0C0C0\"], [\"skyblue\", \"#87CEEB\"], [\"slateblue\", \"#6A5ACD\"], [\"slategray\", \"#708090\"], [\"snow\", \"#FFFAFA\"], [\"springgreen\", \"#00FF7F\"], [\"steelblue\", \"#4682B4\"], [\"tan\", \"#D2B48C\"], [\"teal\", \"#008080\"], [\"thistle\", \"#D8BFD8\"], [\"tomato\", \"#FF6347\"], [\"turquoise\", \"#40E0D0\"], [\"violet\", \"#EE82EE\"], [\"wheat\", \"#F5DEB3\"], [\"white\", \"#FFFFFF\"], [\"whitesmoke\", \"#F5F5F5\"], [\"yellow\", \"#FFFF00\"], [\"yellowgreen\", \"#9ACD32\"]]);\n\n/**\n * rgb regex to handle \"rgb([0-255],[0-255],[0-255])\" color strings\n * @type {RegExp}\n */\nvar rgbRegex = /^rgb\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)\\s*$/i;\n\n/**\n * rgba regex to handle \"rgba([0-255],[0-255],[0-255],[0.0-1.0])\" color strings\n * @type {RegExp}\n */\nvar rgbaRegex = /^rgba\\s*\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*([0,1](?:\\.\\d*)?)\\s*\\)\\s*$/i;\n\n/**\n * hex regex to handle \"#[00-FF][00-FF][00-FF]\" color strings.\n * @type {RegExp}\n */\nvar hexRegex = /^#([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})([0-9,a-f,A-F]{2})\\s*$/i;\n\n/**\n * Extracts an opacity from an rgba color packed into a 32-bit integer\n * @param  {number} packedRgbaColor\n * @return {number}                 opacity extracted in range of [0,1]\n */\nfunction getOpacity(packedRgbaColor) {\n  return (packedRgbaColor & 0xFF) / 255.0;\n}\n\n/**\n * packs an opacity value [0,1] into an 8-bit integer to be packed\n * into a 32-bit int\n * @param  {number} opacity [0,1]\n * @return {number}         [0,255]\n */\nfunction packOpacity(opacity) {\n  return _math2.default.floor(_math2.default.clamp01(opacity) * 255);\n}\n\n/**\n * Given a color packed into a 32-bit integer, returns a css-style \"rgba()\" string\n * @param  {number} packedRgbaColor\n * @return {string}                 int the form \"rgba([0,255],[0,255],[0,255],[0,1])\"\n */\nfunction getRGBAString(packedRgbaColor) {\n  return \"rgba(\" + (packedRgbaColor >>> 24) + \", \" + ((packedRgbaColor & 0xFF0000) >> 16) + \", \" + ((packedRgbaColor & 0xFF00) >> 8) + \", \" + getOpacity(packedRgbaColor) + \")\";\n}\n\n/**\n * Given an rgba() color string, extracts a numeric color packed into a 32-bit int\n * @param  {string} color\n * @return {number}\n */\nfunction getPackedColorRGBAFromString(color) {\n  if (typeof color !== \"string\") {\n    throw new Error(color + \" is not a valid color string\");\n  }\n\n  var packedColor = 0;\n\n  var match = null;\n  if (match = color.match(rgbRegex)) {\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 10), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 10), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 10), 0, 255) << 24;\n  } else if (match = color.match(rgbaRegex)) {\n    packedColor = packOpacity(Number.parseFloat(match[4], 10));\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 10), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 10), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 10), 0, 255) << 24;\n  } else if (match = color.match(hexRegex)) {\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 16), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 16), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 16), 0, 255) << 24;\n  } else if (colorKeywords.has(color)) {\n    match = colorKeywords.get(color).match(hexRegex);\n    packedColor = 255; // (fully opaque)\n    packedColor |= _math2.default.clamp(Number.parseInt(match[3], 16), 0, 255) << 8;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[2], 16), 0, 255) << 16;\n    packedColor |= _math2.default.clamp(Number.parseInt(match[1], 16), 0, 255) << 24;\n  } else {\n    throw new Error(color + \" is not a valid color string\");\n  }\n\n  return packedColor;\n}\n\n/** @class manages colors in the RGBA color space. Can also be used as a mixin */\n\nvar ColorRGBA = function () {\n  /**\n   * Creates a new color in the RGBA color space\n   * @param  {string}    initColorStr color string in the form \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"red\")\n   * @param  {...object} args         Additional arguments that may be passed to other initializers/constructors\n   *                                  if this class is used as a base class or mixin\n   * @return {ColorRGBA}\n   */\n  function ColorRGBA(initColorStr) {\n    _classCallCheck(this, ColorRGBA);\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this.initializer.apply(this, [initColorStr].concat(args));\n  }\n\n  /**\n   * initializes a color in the RGBA color space using a color string\n   * @param  {string} initColorStr initializer string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n   */\n\n\n  _createClass(ColorRGBA, [{\n    key: \"initializer\",\n    value: function initializer(initColorStr) {\n      this._color = 0;\n      if (initColorStr) {\n        this.value = initColorStr;\n      }\n    }\n\n    /**\n     * sets all the channels of the RGBA color given a color string\n     * @param  {string} color color string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"isTransparent\",\n\n\n    /**\n     * Returns true if the current opacity of the rgba color < 1\n     * @return {Boolean}\n     */\n    value: function isTransparent() {\n      return getOpacity(this._color) < 1.0;\n    }\n  }, {\n    key: \"value\",\n    set: function set(color) {\n      this._color = getPackedColorRGBAFromString(color);\n      return this;\n    }\n\n    /**\n     * Gets the rgba color as a color string \"rgba()\"\n     * @return {string} rgba color as a string\n     */\n    ,\n    get: function get() {\n      return getRGBAString(this._color);\n    }\n\n    /**\n     * Sets the value of the RGBA color packed as a 32-bit int\n     * @param  {number} packedColor\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"packedValue\",\n    set: function set(packedColor) {\n      this._color = 0;\n      this._color |= packedColor;\n      return this;\n    }\n\n    /**\n     * Gets the current value of the RGBA color as a packed 32-bit int\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._color;\n    }\n\n    /**\n     * sets the opacity of the RGBA color (modifies alpha channel only)\n     * @param  {number} opacity [0,1]\n     * @return {ColorRGBA}\n     */\n\n  }, {\n    key: \"opacity\",\n    set: function set(opacity) {\n      if (typeof opacity !== \"number\") {\n        throw new Error(\"Opacity must be a number between 0-1\");\n      }\n\n      var currOpacity = this._color & 0xFF;\n      var newOpacity = packOpacity(opacity);\n      if (newOpacity !== currOpacity) {\n        this._color &= 0xFFFFFF00;\n        this._color |= newOpacity;\n      }\n      return this;\n    }\n\n    /**\n     * Gets the current opacity (alpha channel) of the RGBA color\n     * @return {number} [0,1]\n     */\n    ,\n    get: function get() {\n      return getOpacity(this._color);\n    }\n  }]);\n\n  return ColorRGBA;\n}();\n\n/**\n * Creates a new color RGBA class that fires events whenever the color\n * is changed externally\n * @param  {string} eventName Event type to fire when color is modified\n * @param  {string} colorName Name of the color attribute. This string is used in the event object fired\n * @return {function}         New class constructor function\n */\n\n\nexports.default = ColorRGBA;\nfunction createEventedColorRGBAClass(eventName, colorName) {\n\n  /**\n   * @class New rgba color class that fires events when modified\n   * @extends {ColorRGBA}\n   */\n  return function (_ColorRGBA) {\n    _inherits(EventedColorRGBA, _ColorRGBA);\n\n    function EventedColorRGBA() {\n      _classCallCheck(this, EventedColorRGBA);\n\n      return _possibleConstructorReturn(this, (EventedColorRGBA.__proto__ || Object.getPrototypeOf(EventedColorRGBA)).apply(this, arguments));\n    }\n\n    _createClass(EventedColorRGBA, [{\n      key: \"initializer\",\n\n      /**\n       * Color modification event\n       * @event EventedColor#changed\n       * @type {object}\n       * @property {string} attr Name of the attribute modified\n       * @property {} prevVal Previous value of the attribute prior to modification\n       * @property {} currVal Value of the attribute post modification\n       */\n\n      /**\n       * Initializes the evented color\n       * @param  {string} initColorStr initial color as string\n       * @param  {EventHandler} eventHandler Event handler instance used to manage the color\n       *                                     modification events\n       * @protected\n       */\n      value: function initializer(initColorStr, eventHandler) {\n        this._eventHandler = eventHandler;\n        _get(EventedColorRGBA.prototype.__proto__ || Object.getPrototypeOf(EventedColorRGBA.prototype), \"initializer\", this).call(this, initColorStr);\n      }\n\n      /**\n       * Validates modification of the rgba color, and if modified, fires\n       * modification events\n       * @param  {number} newPackedColor Color defined by a 32-bit int\n       * @private\n       */\n\n    }, {\n      key: \"_checkPackedColorChanged\",\n      value: function _checkPackedColorChanged(newPackedColor) {\n        if (newPackedColor !== this._color) {\n          var prev = this._color;\n          var prevOpacity = getOpacity(prev);\n          var opacity = getOpacity(newPackedColor);\n          this._color = newPackedColor;\n\n          this._eventHandler.fire(eventName, {\n            attr: colorName,\n            prevVal: getRGBAString(prev),\n            currVal: getRGBAString(this._color)\n          });\n\n          if (opacity !== prevOpacity) {\n            this._eventHandler.fire(eventName, {\n              attr: \"opacity\",\n              prevVal: prevOpacity,\n              currVal: opacity\n            });\n          }\n        }\n      }\n\n      /**\n       * sets all the channels of the RGBA color from a color string\n       * @param  {string} color color string in the form \"rgb()\", \"rgba()\", \"#......\", or color keyword\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"value\",\n      set: function set(color) {\n        var tmpcolor = getPackedColorRGBAFromString(color);\n        this._checkPackedColorChanged(tmpcolor);\n        return this;\n      }\n\n      /**\n       * Gets the rgba color as a color string \"rgba()\"\n       * @return {string} rgba color as a string\n       */\n      ,\n      get: function get() {\n        return getRGBAString(this._color);\n      }\n\n      /**\n       * Sets the value of the RGBA color packed as a 32-bit int\n       * @param  {number} packedColor\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"packedValue\",\n      set: function set(packedColor) {\n        var tmpcolor = 0;\n        tmpcolor |= packedColor;\n        this._checkPackedColorChanged(tmpcolor);\n        return this;\n      }\n\n      /**\n       * Gets the current value of the RGBA color as a packed 32-bit int\n       * @return {number}\n       */\n      ,\n      get: function get() {\n        return this._color;\n      }\n\n      /**\n       * sets the opacity of the RGBA color (modifies alpha channel only)\n       * @param  {number} opacity [0,1]\n       * @fires  EventedColor#changed\n       * @return {ColorRGBA}\n       */\n\n    }, {\n      key: \"opacity\",\n      set: function set(opacity) {\n        if (typeof opacity !== \"number\") {\n          throw new Error(\"Opacity must be a number between 0-1\");\n        }\n\n        var currOpacity = this._color & 0xFF;\n        var newOpacity = packOpacity(opacity);\n        if (newOpacity !== currOpacity) {\n          this._color &= 0xFFFFFF00;\n          this._color |= newOpacity;\n\n          this._eventHandler.fire(eventName, {\n            attr: \"opacity\",\n            prevVal: currOpacity / 255.0,\n            currVal: newOpacity / 255.0\n          });\n        }\n        return this;\n      }\n\n      /**\n       * Gets the current opacity (alpha channel) of the RGBA color\n       * @return {number} [0,1]\n       */\n      ,\n      get: function get() {\n        return getOpacity(this._color);\n      }\n    }]);\n\n    return EventedColorRGBA;\n  }(ColorRGBA);\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9jb2xvci1yZ2JhLmpzPzdlYmEiXSwibmFtZXMiOlsiY3JlYXRlRXZlbnRlZENvbG9yUkdCQUNsYXNzIiwiY29sb3JLZXl3b3JkcyIsIk1hcCIsInJnYlJlZ2V4IiwicmdiYVJlZ2V4IiwiaGV4UmVnZXgiLCJnZXRPcGFjaXR5IiwicGFja2VkUmdiYUNvbG9yIiwicGFja09wYWNpdHkiLCJvcGFjaXR5IiwiZmxvb3IiLCJjbGFtcDAxIiwiZ2V0UkdCQVN0cmluZyIsImdldFBhY2tlZENvbG9yUkdCQUZyb21TdHJpbmciLCJjb2xvciIsIkVycm9yIiwicGFja2VkQ29sb3IiLCJtYXRjaCIsImNsYW1wIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJwYXJzZUZsb2F0IiwiaGFzIiwiZ2V0IiwiQ29sb3JSR0JBIiwiaW5pdENvbG9yU3RyIiwiYXJncyIsImluaXRpYWxpemVyIiwiX2NvbG9yIiwidmFsdWUiLCJjdXJyT3BhY2l0eSIsIm5ld09wYWNpdHkiLCJldmVudE5hbWUiLCJjb2xvck5hbWUiLCJldmVudEhhbmRsZXIiLCJfZXZlbnRIYW5kbGVyIiwibmV3UGFja2VkQ29sb3IiLCJwcmV2IiwicHJldk9wYWNpdHkiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIiwidG1wY29sb3IiLCJfY2hlY2tQYWNrZWRDb2xvckNoYW5nZWQiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O1FBc1ZnQkEsMkIsR0FBQUEsMkI7O0FBcFZoQjs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0EsSUFBTUMsZ0JBQWdCLElBQUlDLEdBQUosQ0FBUSxDQUFDLENBQUMsV0FBRCxFQUFjLFNBQWQsQ0FBRCxFQUNDLENBQUMsY0FBRCxFQUFpQixTQUFqQixDQURELEVBRUMsQ0FBQyxNQUFELEVBQVMsU0FBVCxDQUZELEVBR0MsQ0FBQyxZQUFELEVBQWUsU0FBZixDQUhELEVBSUMsQ0FBQyxPQUFELEVBQVUsU0FBVixDQUpELEVBS0MsQ0FBQyxP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LFdBN0VsQixFQTZFK0I7QUFDM0IsWUFBSTJCLFdBQVcsQ0FBZjtBQUNBQSxvQkFBWTNCLFdBQVo7QUFDQSxhQUFLNEIsd0JBQUwsQ0FBOEJELFFBQTlCO0FBQ0EsZUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7QUFwRkY7QUFBQSwwQkF3Rm9CO0FBQ2hCLGVBQU8sS0FBS2YsTUFBWjtBQUNEOztBQUVEOzs7Ozs7O0FBNUZGO0FBQUE7QUFBQSx3QkFrR2NuQixPQWxHZCxFQWtHdUI7QUFDbkIsWUFBSSxPQUFPQSxPQUFQLEtBQW1CLFFBQXZCLEVBQWlDO0FBQy9CLGdCQUFNLElBQUlNLEtBQUosQ0FBVSxzQ0FBVixDQUFOO0FBQ0Q7O0FBRUQsWUFBTWUsY0FBYyxLQUFLRixNQUFMLEdBQWMsSUFBbEM7QUFDQSxZQUFNRyxhQUFhdkIsWUFBWUMsT0FBWixDQUFuQjtBQUNBLFlBQUlzQixlQUFlRCxXQUFuQixFQUFnQztBQUM5QixlQUFLRixNQUFMLElBQWUsVUFBZjtBQUNBLGVBQUtBLE1BQUwsSUFBZUcsVUFBZjs7QUFFQSxlQUFLSSxhQUFMLENBQW1CSSxJQUFuQixDQUF3QlAsU0FBeEIsRUFBbUM7QUFDakNRLGtCQUFNLFNBRDJCO0FBRWpDQyxxQkFBU1gsY0FBYyxLQUZVO0FBR2pDWSxxQkFBU1gsYUFBYTtBQUhXLFdBQW5DO0FBS0Q7QUFDRCxlQUFPLElBQVA7QUFDRDs7QUFFRDs7OztBQXRIRjtBQUFBLDBCQTBIZ0I7QUFDWixlQUFPekIsV0FBVyxLQUFLc0IsTUFBaEIsQ0FBUDtBQUNEO0FBNUhIOztBQUFBO0FBQUEsSUFBc0NKLFNBQXRDO0FBOEhEIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0IE1hdGggZnJvbSBcIi4uL21hdGgvbWF0aFwiXG5cbi8qKlxuICogQ29sb3Iga2V5d29yZHMgYXMgZGVmaW5lZCBieSB0aGUgQ1NTIGNvbG9yIG1vZHVsZXNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZX1cbiAqIEB0eXBlIHtNYXB9XG4gKi9cbmNvbnN0IGNvbG9yS2V5d29yZHMgPSBuZXcgTWFwKFtbXCJhbGljZWJsdWVcIiwgXCIjRjBGOEZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImFudGlxdWV3aGl0ZVwiLCBcIiNGQUVCRDdcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYXF1YVwiLCBcIiMwMEZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYXF1YW1hcmluZVwiLCBcIiM3RkZGRDRcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYXp1cmVcIiwgXCIjRjBGRkZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJlaWdlXCIsIFwiI0Y1RjVEQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJiaXNxdWVcIiwgXCIjRkZFNEM0XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJsYWNrXCIsIFwiIzAwMDAwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJibGFuY2hlZGFsbW9uZFwiLCBcIiNGRkVCQ0RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmx1ZVwiLCBcIiMwMDAwRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmx1ZXZpb2xldFwiLCBcIiM4QTJCRTJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiYnJvd25cIiwgXCIjQTUyQTJBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImJ1cmx5d29vZFwiLCBcIiNERUI4ODdcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY2FkZXRibHVlXCIsIFwiIzVGOUVBMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjaGFydHJldXNlXCIsIFwiIzdGRkYwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjaG9jb2xhdGVcIiwgXCIjRDI2OTFFXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNvcmFsXCIsIFwiI0ZGN0Y1MFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJjb3JuZmxvd2VyYmx1ZVwiLCBcIiM2NDk1RURcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiY29ybnNpbGtcIiwgXCIjRkZGOERDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImNyaW1zb25cIiwgXCIjREMxNDNDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImN5YW5cIiwgXCIjMDBGRkZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtibHVlXCIsIFwiIzAwMDA4QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrY3lhblwiLCBcIiMwMDhCOEJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2dvbGRlbnJvZFwiLCBcIiNCODg2MEJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2dyYXlcIiwgXCIjQTlBOUE5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtncmVlblwiLCBcIiMwMDY0MDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya2toYWtpXCIsIFwiI0JEQjc2QlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkYXJrbWFnZW50YVwiLCBcIiM4QjAwOEJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya29saXZlZ3JlZW5cIiwgXCIjNTU2QjJGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtvcmFuZ2VcIiwgXCIjRkY4QzAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtvcmNoaWRcIiwgXCIjOTkzMkNDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtyZWRcIiwgXCIjOEIwMDAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtzYWxtb25cIiwgXCIjRTk5NjdBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhcmtzZWFncmVlblwiLCBcIiM4RkJDOEZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3NsYXRlYmx1ZVwiLCBcIiM0ODNEOEJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3NsYXRlZ3JheVwiLCBcIiMyRjRGNEZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3R1cnF1b2lzZVwiLCBcIiMwMENFRDFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGFya3Zpb2xldFwiLCBcIiM5NDAwRDNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZGVlcHBpbmtcIiwgXCIjRkYxNDkzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImRlZXBza3libHVlXCIsIFwiIzAwQkZGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkaW1ncmF5XCIsIFwiIzY5Njk2OVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJkb2RnZXJibHVlXCIsIFwiIzFFOTBGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJmaXJlYnJpY2tcIiwgXCIjQjIyMjIyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImZsb3JhbHdoaXRlXCIsIFwiI0ZGRkFGMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJmb3Jlc3RncmVlblwiLCBcIiMyMjhCMjJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZnVjaHNpYVwiLCBcIiNGRjAwRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiZ2FpbnNib3JvXCIsIFwiI0RDRENEQ1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJnaG9zdHdoaXRlXCIsIFwiI0Y4RjhGRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJnb2xkXCIsIFwiI0ZGRDcwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJnb2xkZW5yb2RcIiwgXCIjREFBNTIwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdyYXlcIiwgXCIjODA4MDgwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImdyZWVuXCIsIFwiIzAwODAwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJncmVlbnllbGxvd1wiLCBcIiNBREZGMkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaG9uZXlkZXdcIiwgXCIjRjBGRkYwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImhvdHBpbmtcIiwgXCIjRkY2OUI0XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImluZGlhbnJlZFwiLCBcIiNDRDVDNUNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaW5kaWdvXCIsIFwiIzRCMDA4MlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJpdm9yeVwiLCBcIiNGRkZGRjBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wia2hha2lcIiwgXCIjRjBFNjhDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxhdmVuZGVyXCIsIFwiI0U2RTZGQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsYXZlbmRlcmJsdXNoXCIsIFwiI0ZGRjBGNVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsYXduZ3JlZW5cIiwgXCIjN0NGQzAwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxlbW9uY2hpZmZvblwiLCBcIiNGRkZBQ0RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRibHVlXCIsIFwiI0FERDhFNlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodGNvcmFsXCIsIFwiI0YwODA4MFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodGN5YW5cIiwgXCIjRTBGRkZGXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsIFwiI0ZBRkFEMlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodGdyYXlcIiwgXCIjRDNEM0QzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0Z3JlZW5cIiwgXCIjOTBFRTkwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0cGlua1wiLCBcIiNGRkI2QzFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRzYWxtb25cIiwgXCIjRkZBMDdBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0c2VhZ3JlZW5cIiwgXCIjMjBCMkFBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0c2t5Ymx1ZVwiLCBcIiM4N0NFRkFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGlnaHRzbGF0ZWdyYXlcIiwgXCIjNzc4ODk5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcImxpZ2h0c3RlZWxibHVlXCIsIFwiI0IwQzRERVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaWdodHllbGxvd1wiLCBcIiNGRkZGRTBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGltZVwiLCBcIiMwMEZGMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibGltZWdyZWVuXCIsIFwiIzMyQ0QzMlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJsaW5lblwiLCBcIiNGQUYwRTZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWFnZW50YVwiLCBcIiNGRjAwRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWFyb29uXCIsIFwiIzgwMDAwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1hcXVhbWFyaW5lXCIsIFwiIzY2Q0RBQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1ibHVlXCIsIFwiIzAwMDBDRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtZWRpdW1vcmNoaWRcIiwgXCIjQkE1NUQzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bXB1cnBsZVwiLCBcIiM5MzcwREJcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtc2VhZ3JlZW5cIiwgXCIjM0NCMzcxXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bXNsYXRlYmx1ZVwiLCBcIiM3QjY4RUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtc3ByaW5nZ3JlZW5cIiwgXCIjMDBGQTlBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1lZGl1bXR1cnF1b2lzZVwiLCBcIiM0OEQxQ0NcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWVkaXVtdmlvbGV0cmVkXCIsIFwiI0M3MTU4NVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtaWRuaWdodGJsdWVcIiwgXCIjMTkxOTcwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm1pbnRjcmVhbVwiLCBcIiNGNUZGRkFcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibWlzdHlyb3NlXCIsIFwiI0ZGRTRFMVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJtb2NjYXNpblwiLCBcIiNGRkU0QjVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wibmF2YWpvd2hpdGVcIiwgXCIjRkZERUFEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm5hdnlcIiwgXCIjMDAwMDgwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9sZGxhY2VcIiwgXCIjRkRGNUU2XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9saXZlXCIsIFwiIzgwODAwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJvbGl2ZWRyYWJcIiwgXCIjNkI4RTIzXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIm9yYW5nZVwiLCBcIiNGRkE1MDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wib3JhbmdlcmVkXCIsIFwiI0ZGNDUwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJvcmNoaWRcIiwgXCIjREE3MEQ2XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBhbGVnb2xkZW5yb2RcIiwgXCIjRUVFOEFBXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInBhbGVncmVlblwiLCBcIiM5OEZCOThcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFsZXR1cnF1b2lzZVwiLCBcIiNBRkVFRUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFsZXZpb2xldHJlZFwiLCBcIiNEQjcwOTNcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGFwYXlhd2hpcFwiLCBcIiNGRkVGRDVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicGVhY2hwdWZmXCIsIFwiI0ZGREFCOVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwZXJ1XCIsIFwiI0NEODUzRlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwaW5rXCIsIFwiI0ZGQzBDQlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwbHVtXCIsIFwiI0REQTBERFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwb3dkZXJibHVlXCIsIFwiI0IwRTBFNlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJwdXJwbGVcIiwgXCIjODAwMDgwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInJlYmVjY2FwdXJwbGVcIiwgXCIjNjYzMzk5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInJlZFwiLCBcIiNGRjAwMDBcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wicm9zeWJyb3duXCIsIFwiI0JDOEY4RlwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJyb3lhbGJsdWVcIiwgXCIjNDE2OUUxXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNhZGRsZWJyb3duXCIsIFwiIzhCNDUxM1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzYWxtb25cIiwgXCIjRkE4MDcyXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNhbmR5YnJvd25cIiwgXCIjRjRBNDYwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNlYWdyZWVuXCIsIFwiIzJFOEI1N1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzZWFzaGVsbFwiLCBcIiNGRkY1RUVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2llbm5hXCIsIFwiI0EwNTIyRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzaWx2ZXJcIiwgXCIjQzBDMEMwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNreWJsdWVcIiwgXCIjODdDRUVCXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInNsYXRlYmx1ZVwiLCBcIiM2QTVBQ0RcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic2xhdGVncmF5XCIsIFwiIzcwODA5MFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzbm93XCIsIFwiI0ZGRkFGQVwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJzcHJpbmdncmVlblwiLCBcIiMwMEZGN0ZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wic3RlZWxibHVlXCIsIFwiIzQ2ODJCNFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ0YW5cIiwgXCIjRDJCNDhDXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInRlYWxcIiwgXCIjMDA4MDgwXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInRoaXN0bGVcIiwgXCIjRDhCRkQ4XCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcInRvbWF0b1wiLCBcIiNGRjYzNDdcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1widHVycXVvaXNlXCIsIFwiIzQwRTBEMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ2aW9sZXRcIiwgXCIjRUU4MkVFXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcIndoZWF0XCIsIFwiI0Y1REVCM1wiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ3aGl0ZVwiLCBcIiNGRkZGRkZcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wid2hpdGVzbW9rZVwiLCBcIiNGNUY1RjVcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wieWVsbG93XCIsIFwiI0ZGRkYwMFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbXCJ5ZWxsb3dncmVlblwiLCBcIiM5QUNEMzJcIl1dKVxuXG4vKipcbiAqIHJnYiByZWdleCB0byBoYW5kbGUgXCJyZ2IoWzAtMjU1XSxbMC0yNTVdLFswLTI1NV0pXCIgY29sb3Igc3RyaW5nc1xuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgcmdiUmVnZXggPSAvXnJnYlxccypcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKlxcKVxccyokL2lcblxuLyoqXG4gKiByZ2JhIHJlZ2V4IHRvIGhhbmRsZSBcInJnYmEoWzAtMjU1XSxbMC0yNTVdLFswLTI1NV0sWzAuMC0xLjBdKVwiIGNvbG9yIHN0cmluZ3NcbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IHJnYmFSZWdleCA9IC9ecmdiYVxccypcXChcXHMqKFxcZHsxLDN9KVxccyosXFxzKihcXGR7MSwzfSlcXHMqLFxccyooXFxkezEsM30pXFxzKixcXHMqKFswLDFdKD86XFwuXFxkKik/KVxccypcXClcXHMqJC9pXG5cbi8qKlxuICogaGV4IHJlZ2V4IHRvIGhhbmRsZSBcIiNbMDAtRkZdWzAwLUZGXVswMC1GRl1cIiBjb2xvciBzdHJpbmdzLlxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgaGV4UmVnZXggPSAvXiMoWzAtOSxhLWYsQS1GXXsyfSkoWzAtOSxhLWYsQS1GXXsyfSkoWzAtOSxhLWYsQS1GXXsyfSlcXHMqJC9pXG5cbi8qKlxuICogRXh0cmFjdHMgYW4gb3BhY2l0eSBmcm9tIGFuIHJnYmEgY29sb3IgcGFja2VkIGludG8gYSAzMi1iaXQgaW50ZWdlclxuICogQHBhcmFtICB7bnVtYmVyfSBwYWNrZWRSZ2JhQ29sb3JcbiAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgIG9wYWNpdHkgZXh0cmFjdGVkIGluIHJhbmdlIG9mIFswLDFdXG4gKi9cbmZ1bmN0aW9uIGdldE9wYWNpdHkocGFja2VkUmdiYUNvbG9yKSB7XG4gIHJldHVybiAocGFja2VkUmdiYUNvbG9yICYgMHhGRikgLyAyNTUuMFxufVxuXG4vKipcbiAqIHBhY2tzIGFuIG9wYWNpdHkgdmFsdWUgWzAsMV0gaW50byBhbiA4LWJpdCBpbnRlZ2VyIHRvIGJlIHBhY2tlZFxuICogaW50byBhIDMyLWJpdCBpbnRcbiAqIEBwYXJhbSAge251bWJlcn0gb3BhY2l0eSBbMCwxXVxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgIFswLDI1NV1cbiAqL1xuZnVuY3Rpb24gcGFja09wYWNpdHkob3BhY2l0eSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLmNsYW1wMDEob3BhY2l0eSkgKiAyNTUpXG59XG5cbi8qKlxuICogR2l2ZW4gYSBjb2xvciBwYWNrZWQgaW50byBhIDMyLWJpdCBpbnRlZ2VyLCByZXR1cm5zIGEgY3NzLXN0eWxlIFwicmdiYSgpXCIgc3RyaW5nXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZFJnYmFDb2xvclxuICogQHJldHVybiB7c3RyaW5nfSAgICAgICAgICAgICAgICAgaW50IHRoZSBmb3JtIFwicmdiYShbMCwyNTVdLFswLDI1NV0sWzAsMjU1XSxbMCwxXSlcIlxuICovXG5mdW5jdGlvbiBnZXRSR0JBU3RyaW5nKHBhY2tlZFJnYmFDb2xvcikge1xuICByZXR1cm4gYHJnYmEoJHsocGFja2VkUmdiYUNvbG9yKSA+Pj4gMjR9LCAkeyhwYWNrZWRSZ2JhQ29sb3IgJiAweEZGMDAwMCkgPj4gMTZ9LCAkeyhwYWNrZWRSZ2JhQ29sb3IgJiAweEZGMDApID4+IDh9LCAke2dldE9wYWNpdHkocGFja2VkUmdiYUNvbG9yKX0pYFxufVxuXG4vKipcbiAqIEdpdmVuIGFuIHJnYmEoKSBjb2xvciBzdHJpbmcsIGV4dHJhY3RzIGEgbnVtZXJpYyBjb2xvciBwYWNrZWQgaW50byBhIDMyLWJpdCBpbnRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29sb3JcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0UGFja2VkQ29sb3JSR0JBRnJvbVN0cmluZyhjb2xvcikge1xuICBpZiAodHlwZW9mIGNvbG9yICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbG9yfSBpcyBub3QgYSB2YWxpZCBjb2xvciBzdHJpbmdgKVxuICB9XG5cbiAgbGV0IHBhY2tlZENvbG9yID0gMFxuXG4gIGxldCBtYXRjaCA9IG51bGxcbiAgaWYgKChtYXRjaCA9IGNvbG9yLm1hdGNoKHJnYlJlZ2V4KSkpIHtcbiAgICBwYWNrZWRDb2xvciA9IDI1NSAvLyAoZnVsbHkgb3BhcXVlKVxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzNdLCAxMCksIDAsIDI1NSkgPDwgOFxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzJdLCAxMCksIDAsIDI1NSkgPDwgMTZcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTApLCAwLCAyNTUpIDw8IDI0XG4gIH0gZWxzZSBpZiAoKG1hdGNoID0gY29sb3IubWF0Y2gocmdiYVJlZ2V4KSkpIHtcbiAgICBwYWNrZWRDb2xvciA9IHBhY2tPcGFjaXR5KE51bWJlci5wYXJzZUZsb2F0KG1hdGNoWzRdLCAxMCkpXG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbM10sIDEwKSwgMCwgMjU1KSA8PCA4XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMl0sIDEwKSwgMCwgMjU1KSA8PCAxNlxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxMCksIDAsIDI1NSkgPDwgMjRcbiAgfSBlbHNlIGlmICgobWF0Y2ggPSBjb2xvci5tYXRjaChoZXhSZWdleCkpKSB7XG4gICAgcGFja2VkQ29sb3IgPSAyNTUgLy8gKGZ1bGx5IG9wYXF1ZSlcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFszXSwgMTYpLCAwLCAyNTUpIDw8IDhcbiAgICBwYWNrZWRDb2xvciB8PSBNYXRoLmNsYW1wKE51bWJlci5wYXJzZUludChtYXRjaFsyXSwgMTYpLCAwLCAyNTUpIDw8IDE2XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0sIDE2KSwgMCwgMjU1KSA8PCAyNFxuICB9IGVsc2UgaWYgKGNvbG9yS2V5d29yZHMuaGFzKGNvbG9yKSkge1xuICAgIG1hdGNoID0gY29sb3JLZXl3b3Jkcy5nZXQoY29sb3IpLm1hdGNoKGhleFJlZ2V4KVxuICAgIHBhY2tlZENvbG9yID0gMjU1IC8vIChmdWxseSBvcGFxdWUpXG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbM10sIDE2KSwgMCwgMjU1KSA8PCA4XG4gICAgcGFja2VkQ29sb3IgfD0gTWF0aC5jbGFtcChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMl0sIDE2KSwgMCwgMjU1KSA8PCAxNlxuICAgIHBhY2tlZENvbG9yIHw9IE1hdGguY2xhbXAoTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdLCAxNiksIDAsIDI1NSkgPDwgMjRcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29sb3J9IGlzIG5vdCBhIHZhbGlkIGNvbG9yIHN0cmluZ2ApXG4gIH1cblxuICByZXR1cm4gcGFja2VkQ29sb3Jcbn1cblxuLyoqIEBjbGFzcyBtYW5hZ2VzIGNvbG9ycyBpbiB0aGUgUkdCQSBjb2xvciBzcGFjZS4gQ2FuIGFsc28gYmUgdXNlZCBhcyBhIG1peGluICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2xvclJHQkEge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xvciBpbiB0aGUgUkdCQSBjb2xvciBzcGFjZVxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgIGluaXRDb2xvclN0ciBjb2xvciBzdHJpbmcgaW4gdGhlIGZvcm0gXCJyZ2IoKVwiLCBcInJnYmEoKVwiLCBcIiMuLi4uLi5cIiwgb3IgYSBjb2xvciBrZXl3b3JkIChpLmUuIFwicmVkXCIpXG4gICAqIEBwYXJhbSAgey4uLm9iamVjdH0gYXJncyAgICAgICAgIEFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgbWF5IGJlIHBhc3NlZCB0byBvdGhlciBpbml0aWFsaXplcnMvY29uc3RydWN0b3JzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIHRoaXMgY2xhc3MgaXMgdXNlZCBhcyBhIGJhc2UgY2xhc3Mgb3IgbWl4aW5cbiAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgKi9cbiAgY29uc3RydWN0b3IoaW5pdENvbG9yU3RyLCAuLi5hcmdzKSB7XG4gICAgdGhpcy5pbml0aWFsaXplcihpbml0Q29sb3JTdHIsIC4uLmFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogaW5pdGlhbGl6ZXMgYSBjb2xvciBpbiB0aGUgUkdCQSBjb2xvciBzcGFjZSB1c2luZyBhIGNvbG9yIHN0cmluZ1xuICAgKiBAcGFyYW0gIHtzdHJpbmd9IGluaXRDb2xvclN0ciBpbml0aWFsaXplciBzdHJpbmcgaW4gdGhlIGZvcm0gXCJyZ2IoKVwiLCBcInJnYmEoKVwiLCBcIiMuLi4uLi5cIiwgb3IgY29sb3Iga2V5d29yZFxuICAgKi9cbiAgaW5pdGlhbGl6ZXIoaW5pdENvbG9yU3RyKSB7XG4gICAgdGhpcy5fY29sb3IgPSAwXG4gICAgaWYgKGluaXRDb2xvclN0cikge1xuICAgICAgdGhpcy52YWx1ZSA9IGluaXRDb2xvclN0clxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBzZXRzIGFsbCB0aGUgY2hhbm5lbHMgb2YgdGhlIFJHQkEgY29sb3IgZ2l2ZW4gYSBjb2xvciBzdHJpbmdcbiAgICogQHBhcmFtICB7c3RyaW5nfSBjb2xvciBjb2xvciBzdHJpbmcgaW4gdGhlIGZvcm0gXCJyZ2IoKVwiLCBcInJnYmEoKVwiLCBcIiMuLi4uLi5cIiwgb3IgY29sb3Iga2V5d29yZFxuICAgKiBAcmV0dXJuIHtDb2xvclJHQkF9XG4gICAqL1xuICBzZXQgdmFsdWUoY29sb3IpIHtcbiAgICB0aGlzLl9jb2xvciA9IGdldFBhY2tlZENvbG9yUkdCQUZyb21TdHJpbmcoY29sb3IpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZ2JhIGNvbG9yIGFzIGEgY29sb3Igc3RyaW5nIFwicmdiYSgpXCJcbiAgICogQHJldHVybiB7c3RyaW5nfSByZ2JhIGNvbG9yIGFzIGEgc3RyaW5nXG4gICAqL1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIGdldFJHQkFTdHJpbmcodGhpcy5fY29sb3IpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIFJHQkEgY29sb3IgcGFja2VkIGFzIGEgMzItYml0IGludFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZENvbG9yXG4gICAqIEByZXR1cm4ge0NvbG9yUkdCQX1cbiAgICovXG4gIHNldCBwYWNrZWRWYWx1ZShwYWNrZWRDb2xvcikge1xuICAgIHRoaXMuX2NvbG9yID0gMFxuICAgIHRoaXMuX2NvbG9yIHw9IHBhY2tlZENvbG9yXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBSR0JBIGNvbG9yIGFzIGEgcGFja2VkIDMyLWJpdCBpbnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHBhY2tlZFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2xvclxuICB9XG5cbiAgLyoqXG4gICAqIHNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIFJHQkEgY29sb3IgKG1vZGlmaWVzIGFscGhhIGNoYW5uZWwgb25seSlcbiAgICogQHBhcmFtICB7bnVtYmVyfSBvcGFjaXR5IFswLDFdXG4gICAqIEByZXR1cm4ge0NvbG9yUkdCQX1cbiAgICovXG4gIHNldCBvcGFjaXR5KG9wYWNpdHkpIHtcbiAgICBpZiAodHlwZW9mIG9wYWNpdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk9wYWNpdHkgbXVzdCBiZSBhIG51bWJlciBiZXR3ZWVuIDAtMVwiKVxuICAgIH1cblxuICAgIGNvbnN0IGN1cnJPcGFjaXR5ID0gdGhpcy5fY29sb3IgJiAweEZGXG4gICAgY29uc3QgbmV3T3BhY2l0eSA9IHBhY2tPcGFjaXR5KG9wYWNpdHkpXG4gICAgaWYgKG5ld09wYWNpdHkgIT09IGN1cnJPcGFjaXR5KSB7XG4gICAgICB0aGlzLl9jb2xvciAmPSAweEZGRkZGRjAwXG4gICAgICB0aGlzLl9jb2xvciB8PSBuZXdPcGFjaXR5XG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBvcGFjaXR5IChhbHBoYSBjaGFubmVsKSBvZiB0aGUgUkdCQSBjb2xvclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFswLDFdXG4gICAqL1xuICBnZXQgb3BhY2l0eSgpIHtcbiAgICByZXR1cm4gZ2V0T3BhY2l0eSh0aGlzLl9jb2xvcilcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgb3BhY2l0eSBvZiB0aGUgcmdiYSBjb2xvciA8IDFcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVHJhbnNwYXJlbnQoKSB7XG4gICAgcmV0dXJuIGdldE9wYWNpdHkodGhpcy5fY29sb3IpIDwgMS4wXG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbG9yIFJHQkEgY2xhc3MgdGhhdCBmaXJlcyBldmVudHMgd2hlbmV2ZXIgdGhlIGNvbG9yXG4gKiBpcyBjaGFuZ2VkIGV4dGVybmFsbHlcbiAqIEBwYXJhbSAge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IHR5cGUgdG8gZmlyZSB3aGVuIGNvbG9yIGlzIG1vZGlmaWVkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNvbG9yTmFtZSBOYW1lIG9mIHRoZSBjb2xvciBhdHRyaWJ1dGUuIFRoaXMgc3RyaW5nIGlzIHVzZWQgaW4gdGhlIGV2ZW50IG9iamVjdCBmaXJlZFxuICogQHJldHVybiB7ZnVuY3Rpb259ICAgICAgICAgTmV3IGNsYXNzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3MoZXZlbnROYW1lLCBjb2xvck5hbWUpIHtcblxuICAvKipcbiAgICogQGNsYXNzIE5ldyByZ2JhIGNvbG9yIGNsYXNzIHRoYXQgZmlyZXMgZXZlbnRzIHdoZW4gbW9kaWZpZWRcbiAgICogQGV4dGVuZHMge0NvbG9yUkdCQX1cbiAgICovXG4gIHJldHVybiBjbGFzcyBFdmVudGVkQ29sb3JSR0JBIGV4dGVuZHMgQ29sb3JSR0JBIHtcbiAgICAvKipcbiAgICAgKiBDb2xvciBtb2RpZmljYXRpb24gZXZlbnRcbiAgICAgKiBAZXZlbnQgRXZlbnRlZENvbG9yI2NoYW5nZWRcbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhdHRyIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBtb2RpZmllZFxuICAgICAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gICAgICogQHByb3BlcnR5IHt9IGN1cnJWYWwgVmFsdWUgb2YgdGhlIGF0dHJpYnV0ZSBwb3N0IG1vZGlmaWNhdGlvblxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGV2ZW50ZWQgY29sb3JcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGluaXRDb2xvclN0ciBpbml0aWFsIGNvbG9yIGFzIHN0cmluZ1xuICAgICAqIEBwYXJhbSAge0V2ZW50SGFuZGxlcn0gZXZlbnRIYW5kbGVyIEV2ZW50IGhhbmRsZXIgaW5zdGFuY2UgdXNlZCB0byBtYW5hZ2UgdGhlIGNvbG9yXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpY2F0aW9uIGV2ZW50c1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplcihpbml0Q29sb3JTdHIsIGV2ZW50SGFuZGxlcikge1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyID0gZXZlbnRIYW5kbGVyXG4gICAgICBzdXBlci5pbml0aWFsaXplcihpbml0Q29sb3JTdHIpXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIG1vZGlmaWNhdGlvbiBvZiB0aGUgcmdiYSBjb2xvciwgYW5kIGlmIG1vZGlmaWVkLCBmaXJlc1xuICAgICAqIG1vZGlmaWNhdGlvbiBldmVudHNcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG5ld1BhY2tlZENvbG9yIENvbG9yIGRlZmluZWQgYnkgYSAzMi1iaXQgaW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tQYWNrZWRDb2xvckNoYW5nZWQobmV3UGFja2VkQ29sb3IpIHtcbiAgICAgIGlmIChuZXdQYWNrZWRDb2xvciAhPT0gdGhpcy5fY29sb3IpIHtcbiAgICAgICAgY29uc3QgcHJldiA9IHRoaXMuX2NvbG9yXG4gICAgICAgIGNvbnN0IHByZXZPcGFjaXR5ID0gZ2V0T3BhY2l0eShwcmV2KVxuICAgICAgICBjb25zdCBvcGFjaXR5ID0gZ2V0T3BhY2l0eShuZXdQYWNrZWRDb2xvcilcbiAgICAgICAgdGhpcy5fY29sb3IgPSBuZXdQYWNrZWRDb2xvclxuXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IGNvbG9yTmFtZSxcbiAgICAgICAgICBwcmV2VmFsOiBnZXRSR0JBU3RyaW5nKHByZXYpLFxuICAgICAgICAgIGN1cnJWYWw6IGdldFJHQkFTdHJpbmcodGhpcy5fY29sb3IpXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKG9wYWNpdHkgIT09IHByZXZPcGFjaXR5KSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyLmZpcmUoZXZlbnROYW1lLCB7XG4gICAgICAgICAgICBhdHRyOiBcIm9wYWNpdHlcIixcbiAgICAgICAgICAgIHByZXZWYWw6IHByZXZPcGFjaXR5LFxuICAgICAgICAgICAgY3VyclZhbDogb3BhY2l0eVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzZXRzIGFsbCB0aGUgY2hhbm5lbHMgb2YgdGhlIFJHQkEgY29sb3IgZnJvbSBhIGNvbG9yIHN0cmluZ1xuICAgICAqIEBwYXJhbSAge3N0cmluZ30gY29sb3IgY29sb3Igc3RyaW5nIGluIHRoZSBmb3JtIFwicmdiKClcIiwgXCJyZ2JhKClcIiwgXCIjLi4uLi4uXCIsIG9yIGNvbG9yIGtleXdvcmRcbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRDb2xvciNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgICAqL1xuICAgIHNldCB2YWx1ZShjb2xvcikge1xuICAgICAgY29uc3QgdG1wY29sb3IgPSBnZXRQYWNrZWRDb2xvclJHQkFGcm9tU3RyaW5nKGNvbG9yKVxuICAgICAgdGhpcy5fY2hlY2tQYWNrZWRDb2xvckNoYW5nZWQodG1wY29sb3IpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJnYmEgY29sb3IgYXMgYSBjb2xvciBzdHJpbmcgXCJyZ2JhKClcIlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gcmdiYSBjb2xvciBhcyBhIHN0cmluZ1xuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBnZXRSR0JBU3RyaW5nKHRoaXMuX2NvbG9yKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBSR0JBIGNvbG9yIHBhY2tlZCBhcyBhIDMyLWJpdCBpbnRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHBhY2tlZENvbG9yXG4gICAgICogQGZpcmVzICBFdmVudGVkQ29sb3IjY2hhbmdlZFxuICAgICAqIEByZXR1cm4ge0NvbG9yUkdCQX1cbiAgICAgKi9cbiAgICBzZXQgcGFja2VkVmFsdWUocGFja2VkQ29sb3IpIHtcbiAgICAgIGxldCB0bXBjb2xvciA9IDBcbiAgICAgIHRtcGNvbG9yIHw9IHBhY2tlZENvbG9yXG4gICAgICB0aGlzLl9jaGVja1BhY2tlZENvbG9yQ2hhbmdlZCh0bXBjb2xvcilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgUkdCQSBjb2xvciBhcyBhIHBhY2tlZCAzMi1iaXQgaW50XG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBwYWNrZWRWYWx1ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb2xvclxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIFJHQkEgY29sb3IgKG1vZGlmaWVzIGFscGhhIGNoYW5uZWwgb25seSlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9wYWNpdHkgWzAsMV1cbiAgICAgKiBAZmlyZXMgIEV2ZW50ZWRDb2xvciNjaGFuZ2VkXG4gICAgICogQHJldHVybiB7Q29sb3JSR0JBfVxuICAgICAqL1xuICAgIHNldCBvcGFjaXR5KG9wYWNpdHkpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcGFjaXR5IG11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwLTFcIilcbiAgICAgIH1cblxuICAgICAgY29uc3QgY3Vyck9wYWNpdHkgPSB0aGlzLl9jb2xvciAmIDB4RkZcbiAgICAgIGNvbnN0IG5ld09wYWNpdHkgPSBwYWNrT3BhY2l0eShvcGFjaXR5KVxuICAgICAgaWYgKG5ld09wYWNpdHkgIT09IGN1cnJPcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuX2NvbG9yICY9IDB4RkZGRkZGMDBcbiAgICAgICAgdGhpcy5fY29sb3IgfD0gbmV3T3BhY2l0eVxuXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlci5maXJlKGV2ZW50TmFtZSwge1xuICAgICAgICAgIGF0dHI6IFwib3BhY2l0eVwiLFxuICAgICAgICAgIHByZXZWYWw6IGN1cnJPcGFjaXR5IC8gMjU1LjAsXG4gICAgICAgICAgY3VyclZhbDogbmV3T3BhY2l0eSAvIDI1NS4wXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgb3BhY2l0eSAoYWxwaGEgY2hhbm5lbCkgb2YgdGhlIFJHQkEgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFswLDFdXG4gICAgICovXG4gICAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgICByZXR1cm4gZ2V0T3BhY2l0eSh0aGlzLl9jb2xvcilcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3N0eWxlL2NvbG9yLXJnYmEuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nexports.createEventedFillStyleMixin = createEventedFillStyleMixin;\n\nvar _colorRgba = __webpack_require__(18);\n\nvar _colorRgba2 = _interopRequireDefault(_colorRgba);\n\nvar _aggregation = __webpack_require__(8);\n\nvar _aggregation2 = _interopRequireDefault(_aggregation);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @typedef {object} FillStyleOptions\n * @property {string} [fillColor=\"black\"] Fill color defined as a string\n * @property {number} [fillOpacity=1] Opacity of the fill color. This supersedes any opacity inherent in fillColor\n */\n\n/**\n * Manages the fill style of a 2d rendering context. Can be used as a mixin or base class\n * @class\n * @mixin\n */\nvar FillStyle = function () {\n  /**\n   * Creates a new fill style object\n   * @param {FillStyleOptions} [opts]\n   * @return {FillStyle}\n   */\n  function FillStyle(opts) {\n    _classCallCheck(this, FillStyle);\n\n    // TODO(croot): support gradients and patterns\n    this.initializer(opts);\n  }\n\n  /**\n   * initializes the fill style object from an options object\n   * @param  {FillStyleOptions} [opts]\n   * @private\n   */\n\n\n  _createClass(FillStyle, [{\n    key: \"_initFillStyleFromOptions\",\n    value: function _initFillStyleFromOptions(opts) {\n      if (opts) {\n        if (typeof opts.fillColor !== \"undefined\") {\n          this.fillColor = opts.fillColor;\n        }\n        if (typeof opts.fillOpacity !== \"undefined\") {\n          this.fillOpacity = opts.fillOpacity;\n        }\n      }\n    }\n\n    /**\n     * Initializer method to initialize a fill style. Used for both initializing\n     * via base-class and mixin hierarchy.\n     * @param  {FillStyleOptions} [opts]\n     */\n\n  }, {\n    key: \"initializer\",\n    value: function initializer(opts) {\n      this._fillColor = new _colorRgba2.default(\"black\");\n      this._initFillStyleFromOptions(opts);\n    }\n\n    /**\n     * Sets the fill color\n     * @param  {string} fillColor Color as a string, \"rgb()\", \"rgba()\", \"#......\", or a color keyword (i.e. \"black\")\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"isFillVisible\",\n\n\n    /**\n     * Returns true if the fill style is visible, i.e. it has an opacity > 0\n     * @return {Boolean}\n     */\n    value: function isFillVisible() {\n      return this._fillColor.opacity > 0;\n    }\n\n    /**\n     * Returns true if the fill style is transparent in any way, i.e. opacity < 1\n     * @return {Boolean}\n     */\n\n  }, {\n    key: \"isTransparent\",\n    value: function isTransparent() {\n      return this._fillColor.isTransparent();\n    }\n\n    /**\n     * Sets the fill style state of a 2d rendering context\n     * @param {CanvasRenderingContext2D} ctx\n     */\n\n  }, {\n    key: \"setFillCtx\",\n    value: function setFillCtx(ctx) {\n      ctx.fillStyle = this.fillColor;\n    }\n\n    /**\n     * Copies the properties of one fill style to another\n     * @param  {FillStyle} srcStyle FillStyle object to copy from\n     * @param  {FillStyle} dstStyle FillStyle object to copy to\n     */\n\n  }, {\n    key: \"fillColor\",\n    set: function set(fillColor) {\n      this._fillColor.value = fillColor;\n      return this;\n    }\n\n    /**\n     * Gets the fill color of the style\n     * @return {string}\n     */\n    ,\n    get: function get() {\n      return this._fillColor.value;\n    }\n\n    /**\n     * Sets the opacity of the fill style\n     * @param  {number} opacity [0,1]\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"fillOpacity\",\n    set: function set(opacity) {\n      this._fillColor.opacity = opacity;\n      return this;\n    }\n\n    /**\n     * Gets the current opacity of the fill style [0,1]\n     * @return {number} Opacity in the range [0,1]\n     */\n    ,\n    get: function get() {\n      return this._fillColor.opacity;\n    }\n\n    /**\n     * Sets the fill color of the style defined as a 32-bit int\n     * @param  {number} packedFillColor Color value as a 32-bit int (i.e. 0xFFFFFFFF)\n     * @return {FillStyle}\n     */\n\n  }, {\n    key: \"packedFillColor\",\n    set: function set(packedFillColor) {\n      this._fillColor.packedValue = packedFillColor;\n      return this;\n    }\n\n    /**\n     * Gets the current value of the color of the fill style as a 32-bit int\n     * @return {number} i.e. 0xFFFFFFFF\n     */\n    ,\n    get: function get() {\n      return this._fillColor.packedValue;\n    }\n  }], [{\n    key: \"copyFillStyle\",\n    value: function copyFillStyle(srcStyle, dstStyle) {\n      if (typeof srcStyle.packedFillColor !== \"undefined\") {\n        dstStyle.packedFillColor = srcStyle.packedFillColor;\n      } else {\n        if (typeof srcStyle.fillColor !== \"undefined\") {\n          dstStyle.fillColor = srcStyle.fillColor;\n        }\n        if (typeof srcStyle.fillOpacity !== \"undefined\") {\n          dstStyle.fillOpacity = srcStyle.fillOpacity;\n        }\n      }\n    }\n\n    /**\n     * Comparison operator between two FillStyle objects. This is primarily\n     * used for sorting to minimize context switching of a 2d renderer\n     * @param  {FillStyle} fillStyleA\n     * @param  {FillStyle} fillStyleB\n     * @return {number}            Returns < 0 if fillStyleA < fillStyleB, > 0 if fillStyleA > fillStyleB, or 0 if they are equal.\n     */\n\n  }, {\n    key: \"compareFillStyle\",\n    value: function compareFillStyle(fillStyleA, fillStyleB) {\n      var valA = fillStyleA.isFillVisible();\n      var valB = fillStyleB.isFillVisible();\n      if (valA !== valB) {\n        return valA - valB;\n      }\n      return fillStyleA.packedFillColor - fillStyleB.packedFillColor;\n    }\n\n    /**\n     * Returns a json object of a FillStyle object\n     * @param  {FillStyle} fillStyleObj\n     * @return {{fillColor: string}}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON(fillStyleObj) {\n      return {\n        fillColor: fillStyleObj.fillColor\n      };\n    }\n  }]);\n\n  return FillStyle;\n}();\n\n/**\n * Creates a new fill style class that fires events whenever the style\n * is modified.\n * @param  {string} eventName Event type to fire when fill style is modified\n * @return {function}         New class constructor function\n */\n\n\nexports.default = FillStyle;\nfunction createEventedFillStyleMixin(eventName) {\n  /**\n   * Evented fill color class to handle fill color modifications\n   * @type {ColorRGBA}\n   */\n  var FillColorClass = (0, _colorRgba.createEventedColorRGBAClass)(eventName, \"fillColor\");\n\n  /**\n   * @mixin New evented fill style mixin. Will fire events whenever\n   *        the fill color is modified\n   */\n  return (0, _aggregation2.default)(null, FillStyle, function () {\n    function EventedFillStyle() {\n      _classCallCheck(this, EventedFillStyle);\n    }\n\n    _createClass(EventedFillStyle, [{\n      key: \"initializer\",\n      value: function initializer(opts) {\n        this._fillColor = new FillColorClass(\"red\", this);\n        this._initFillStyleFromOptions(opts);\n      }\n    }]);\n\n    return EventedFillStyle;\n  }());\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZS9maWxsLXN0eWxlLmpzP2I3MGIiXSwibmFtZXMiOlsiY3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGluIiwiRmlsbFN0eWxlIiwib3B0cyIsImluaXRpYWxpemVyIiwiZmlsbENvbG9yIiwiZmlsbE9wYWNpdHkiLCJfZmlsbENvbG9yIiwiX2luaXRGaWxsU3R5bGVGcm9tT3B0aW9ucyIsIm9wYWNpdHkiLCJpc1RyYW5zcGFyZW50IiwiY3R4IiwiZmlsbFN0eWxlIiwidmFsdWUiLCJwYWNrZWRGaWxsQ29sb3IiLCJwYWNrZWRWYWx1ZSIsInNyY1N0eWxlIiwiZHN0U3R5bGUiLCJmaWxsU3R5bGVBIiwiZmlsbFN0eWxlQiIsInZhbEEiLCJpc0ZpbGxWaXNpYmxlIiwidmFsQiIsImZpbGxTdHlsZU9iaiIsImV2ZW50TmFtZSIsIkZpbGxDb2xvckNsYXNzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7UUF1TGdCQSwyQixHQUFBQSwyQjs7QUFyTGhCOzs7O0FBQ0E7Ozs7Ozs7O0FBRUE7Ozs7OztBQU1BOzs7OztJQUtxQkMsUztBQUNuQjs7Ozs7QUFLQSxxQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUNoQjtBQUNBLFNBQUtDLFdBQUwsQ0FBaUJELElBQWpCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs4Q0FLMEJBLEksRUFBTTtBQUM5QixVQUFJQSxJQUFKLEVBQVU7QUFDUixZQUFJLE9BQU9BLEtBQUtFLFNBQVosS0FBMEIsV0FBOUIsRUFBMkM7QUFDekMsZUFBS0EsU0FBTCxHQUFpQkYsS0FBS0UsU0FBdEI7QUFDRDtBQUNELFlBQUksT0FBT0YsS0FBS0csV0FBWixLQUE0QixXQUFoQyxFQUE2QztBQUMzQyxlQUFLQSxXQUFMLEdBQW1CSCxLQUFLRyxXQUF4QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7Z0NBS1lILEksRUFBTTtBQUNoQixXQUFLSSxVQUFMLEdBQWtCLHdCQUFjLE9BQWQsQ0FBbEI7QUFDQSxXQUFLQyx5QkFBTCxDQUErQkwsSUFBL0I7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQXNEQTs7OztvQ0FJZ0I7QUFDZCxhQUFPLEtBQUtJLFVBQUwsQ0FBZ0JFLE9BQWhCLEdBQTBCLENBQWpDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7b0NBSWdCO0FBQ2QsYUFBTyxLQUFLRixVQUFMLENBQWdCRyxhQUFoQixFQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7K0JBSVdDLEcsRUFBSztBQUNkQSxVQUFJQyxTQUFKLEdBQWdCLEtBQUtQLFNBQXJCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3NCQXpFY0EsUyxFQUFXO0FBQ3ZCLFdBQUtFLFVBQUwsQ0FBZ0JNLEtBQWhCLEdBQXdCUixTQUF4QjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJZ0I7QUFDZCxhQUFPLEtBQUtFLFVBQUwsQ0FBZ0JNLEtBQXZCO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O3NCQUtnQkosTyxFQUFTO0FBQ3ZCLFdBQUtGLFVBQUwsQ0FBZ0JFLE9BQWhCLEdBQTBCQSxPQUExQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVEOzs7Ozt3QkFJa0I7QUFDaEIsYUFBTyxLQUFLRixVQUFMLENBQWdCRSxPQUF2QjtBQUNEOztBQUVEOzs7Ozs7OztzQkFLb0JLLGUsRUFBaUI7QUFDbkMsV0FBS1AsVUFBTCxDQUFnQlEsV0FBaEIsR0FBOEJELGVBQTlCO0FBQ0EsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7O3dCQUlzQjtBQUNwQixhQUFPLEtBQUtQLFVBQUwsQ0FBZ0JRLFdBQXZCO0FBQ0Q7OztrQ0ErQm9CQyxRLEVBQVVDLFEsRUFBVTtBQUN2QyxVQUFJLE9BQU9ELFNBQVNGLGVBQWhCLEtBQW9DLFdBQXhDLEVBQXFEO0FBQ25ERyxpQkFBU0gsZUFBVCxHQUEyQkUsU0FBU0YsZUFBcEM7QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJLE9BQU9FLFNBQVNYLFNBQWhCLEtBQThCLFdBQWxDLEVBQStDO0FBQzdDWSxtQkFBU1osU0FBVCxHQUFxQlcsU0FBU1gsU0FBOUI7QUFDRDtBQUNELFlBQUksT0FBT1csU0FBU1YsV0FBaEIsS0FBZ0MsV0FBcEMsRUFBaUQ7QUFDL0NXLG1CQUFTWCxXQUFULEdBQXVCVSxTQUFTVixXQUFoQztBQUNEO0FBQ0Y7QUFDRjs7QUFFRDs7Ozs7Ozs7OztxQ0FPd0JZLFUsRUFBWUMsVSxFQUFZO0FBQzlDLFVBQU1DLE9BQU9GLFdBQVdHLGFBQVgsRUFBYjtBQUNBLFVBQU1DLE9BQU9ILFdBQVdFLGFBQVgsRUFBYjtBQUNBLFVBQUlELFNBQVNFLElBQWIsRUFBbUI7QUFDakIsZUFBT0YsT0FBT0UsSUFBZDtBQUNEO0FBQ0QsYUFBT0osV0FBV0osZUFBWCxHQUE2QkssV0FBV0wsZUFBL0M7QUFDRDs7QUFFRDs7Ozs7Ozs7MkJBS2NTLFksRUFBYztBQUMxQixhQUFPO0FBQ0xsQixtQkFBV2tCLGFBQWFsQjtBQURuQixPQUFQO0FBR0Q7Ozs7OztBQUdIOzs7Ozs7OztrQkFqS3FCSCxTO0FBdUtkLFNBQVNELDJCQUFULENBQXFDdUIsU0FBckMsRUFBZ0Q7QUFDckQ7Ozs7QUFJQSxNQUFNQyxpQkFBaUIsNENBQTRCRCxTQUE1QixFQUF1QyxXQUF2QyxDQUF2Qjs7QUFFQTs7OztBQUlBLFNBQU8sMkJBQVksSUFBWixFQUFrQnRCLFNBQWxCO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQSxrQ0FDT0MsSUFEUCxFQUNhO0FBQ2hCLGFBQUtJLFVBQUwsR0FBa0IsSUFBSWtCLGNBQUosQ0FBbUIsS0FBbkIsRUFBMEIsSUFBMUIsQ0FBbEI7QUFDQSxhQUFLakIseUJBQUwsQ0FBK0JMLElBQS9CO0FBQ0Q7QUFKSTs7QUFBQTtBQUFBLE1BQVA7QUFNRCIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCBDb2xvclJHQkEsIHtjcmVhdGVFdmVudGVkQ29sb3JSR0JBQ2xhc3N9IGZyb20gXCIuL2NvbG9yLXJnYmFcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGaWxsU3R5bGVPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZpbGxDb2xvcj1cImJsYWNrXCJdIEZpbGwgY29sb3IgZGVmaW5lZCBhcyBhIHN0cmluZ1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFtmaWxsT3BhY2l0eT0xXSBPcGFjaXR5IG9mIHRoZSBmaWxsIGNvbG9yLiBUaGlzIHN1cGVyc2VkZXMgYW55IG9wYWNpdHkgaW5oZXJlbnQgaW4gZmlsbENvbG9yXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBmaWxsIHN0eWxlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHQuIENhbiBiZSB1c2VkIGFzIGEgbWl4aW4gb3IgYmFzZSBjbGFzc1xuICogQGNsYXNzXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRmlsbFN0eWxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgZmlsbCBzdHlsZSBvYmplY3RcbiAgICogQHBhcmFtIHtGaWxsU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICogQHJldHVybiB7RmlsbFN0eWxlfVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8vIFRPRE8oY3Jvb3QpOiBzdXBwb3J0IGdyYWRpZW50cyBhbmQgcGF0dGVybnNcbiAgICB0aGlzLmluaXRpYWxpemVyKG9wdHMpXG4gIH1cblxuICAvKipcbiAgICogaW5pdGlhbGl6ZXMgdGhlIGZpbGwgc3R5bGUgb2JqZWN0IGZyb20gYW4gb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtICB7RmlsbFN0eWxlT3B0aW9uc30gW29wdHNdXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5pdEZpbGxTdHlsZUZyb21PcHRpb25zKG9wdHMpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLmZpbGxDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmZpbGxDb2xvciA9IG9wdHMuZmlsbENvbG9yXG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9wdHMuZmlsbE9wYWNpdHkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5maWxsT3BhY2l0eSA9IG9wdHMuZmlsbE9wYWNpdHlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgbWV0aG9kIHRvIGluaXRpYWxpemUgYSBmaWxsIHN0eWxlLiBVc2VkIGZvciBib3RoIGluaXRpYWxpemluZ1xuICAgKiB2aWEgYmFzZS1jbGFzcyBhbmQgbWl4aW4gaGllcmFyY2h5LlxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGVPcHRpb25zfSBbb3B0c11cbiAgICovXG4gIGluaXRpYWxpemVyKG9wdHMpIHtcbiAgICB0aGlzLl9maWxsQ29sb3IgPSBuZXcgQ29sb3JSR0JBKFwiYmxhY2tcIilcbiAgICB0aGlzLl9pbml0RmlsbFN0eWxlRnJvbU9wdGlvbnMob3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxsIGNvbG9yXG4gICAqIEBwYXJhbSAge3N0cmluZ30gZmlsbENvbG9yIENvbG9yIGFzIGEgc3RyaW5nLCBcInJnYigpXCIsIFwicmdiYSgpXCIsIFwiIy4uLi4uLlwiLCBvciBhIGNvbG9yIGtleXdvcmQgKGkuZS4gXCJibGFja1wiKVxuICAgKiBAcmV0dXJuIHtGaWxsU3R5bGV9XG4gICAqL1xuICBzZXQgZmlsbENvbG9yKGZpbGxDb2xvcikge1xuICAgIHRoaXMuX2ZpbGxDb2xvci52YWx1ZSA9IGZpbGxDb2xvclxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlsbCBjb2xvciBvZiB0aGUgc3R5bGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IGZpbGxDb2xvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLnZhbHVlXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgb3BhY2l0eSBvZiB0aGUgZmlsbCBzdHlsZVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IG9wYWNpdHkgWzAsMV1cbiAgICogQHJldHVybiB7RmlsbFN0eWxlfVxuICAgKi9cbiAgc2V0IGZpbGxPcGFjaXR5KG9wYWNpdHkpIHtcbiAgICB0aGlzLl9maWxsQ29sb3Iub3BhY2l0eSA9IG9wYWNpdHlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgb3BhY2l0eSBvZiB0aGUgZmlsbCBzdHlsZSBbMCwxXVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE9wYWNpdHkgaW4gdGhlIHJhbmdlIFswLDFdXG4gICAqL1xuICBnZXQgZmlsbE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvci5vcGFjaXR5XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZmlsbCBjb2xvciBvZiB0aGUgc3R5bGUgZGVmaW5lZCBhcyBhIDMyLWJpdCBpbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwYWNrZWRGaWxsQ29sb3IgQ29sb3IgdmFsdWUgYXMgYSAzMi1iaXQgaW50IChpLmUuIDB4RkZGRkZGRkYpXG4gICAqIEByZXR1cm4ge0ZpbGxTdHlsZX1cbiAgICovXG4gIHNldCBwYWNrZWRGaWxsQ29sb3IocGFja2VkRmlsbENvbG9yKSB7XG4gICAgdGhpcy5fZmlsbENvbG9yLnBhY2tlZFZhbHVlID0gcGFja2VkRmlsbENvbG9yXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb2xvciBvZiB0aGUgZmlsbCBzdHlsZSBhcyBhIDMyLWJpdCBpbnRcbiAgICogQHJldHVybiB7bnVtYmVyfSBpLmUuIDB4RkZGRkZGRkZcbiAgICovXG4gIGdldCBwYWNrZWRGaWxsQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvci5wYWNrZWRWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsbCBzdHlsZSBpcyB2aXNpYmxlLCBpLmUuIGl0IGhhcyBhbiBvcGFjaXR5ID4gMFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgaXNGaWxsVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsbENvbG9yLm9wYWNpdHkgPiAwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxsIHN0eWxlIGlzIHRyYW5zcGFyZW50IGluIGFueSB3YXksIGkuZS4gb3BhY2l0eSA8IDFcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzVHJhbnNwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGxDb2xvci5pc1RyYW5zcGFyZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBmaWxsIHN0eWxlIHN0YXRlIG9mIGEgMmQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKi9cbiAgc2V0RmlsbEN0eChjdHgpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsQ29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3BpZXMgdGhlIHByb3BlcnRpZXMgb2Ygb25lIGZpbGwgc3R5bGUgdG8gYW5vdGhlclxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGV9IHNyY1N0eWxlIEZpbGxTdHlsZSBvYmplY3QgdG8gY29weSBmcm9tXG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZX0gZHN0U3R5bGUgRmlsbFN0eWxlIG9iamVjdCB0byBjb3B5IHRvXG4gICAqL1xuICBzdGF0aWMgY29weUZpbGxTdHlsZShzcmNTdHlsZSwgZHN0U3R5bGUpIHtcbiAgICBpZiAodHlwZW9mIHNyY1N0eWxlLnBhY2tlZEZpbGxDb2xvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgZHN0U3R5bGUucGFja2VkRmlsbENvbG9yID0gc3JjU3R5bGUucGFja2VkRmlsbENvbG9yXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2Ygc3JjU3R5bGUuZmlsbENvbG9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRzdFN0eWxlLmZpbGxDb2xvciA9IHNyY1N0eWxlLmZpbGxDb2xvclxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBzcmNTdHlsZS5maWxsT3BhY2l0eSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkc3RTdHlsZS5maWxsT3BhY2l0eSA9IHNyY1N0eWxlLmZpbGxPcGFjaXR5XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmlzb24gb3BlcmF0b3IgYmV0d2VlbiB0d28gRmlsbFN0eWxlIG9iamVjdHMuIFRoaXMgaXMgcHJpbWFyaWx5XG4gICAqIHVzZWQgZm9yIHNvcnRpbmcgdG8gbWluaW1pemUgY29udGV4dCBzd2l0Y2hpbmcgb2YgYSAyZCByZW5kZXJlclxuICAgKiBAcGFyYW0gIHtGaWxsU3R5bGV9IGZpbGxTdHlsZUFcbiAgICogQHBhcmFtICB7RmlsbFN0eWxlfSBmaWxsU3R5bGVCXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICBSZXR1cm5zIDwgMCBpZiBmaWxsU3R5bGVBIDwgZmlsbFN0eWxlQiwgPiAwIGlmIGZpbGxTdHlsZUEgPiBmaWxsU3R5bGVCLCBvciAwIGlmIHRoZXkgYXJlIGVxdWFsLlxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmVGaWxsU3R5bGUoZmlsbFN0eWxlQSwgZmlsbFN0eWxlQikge1xuICAgIGNvbnN0IHZhbEEgPSBmaWxsU3R5bGVBLmlzRmlsbFZpc2libGUoKVxuICAgIGNvbnN0IHZhbEIgPSBmaWxsU3R5bGVCLmlzRmlsbFZpc2libGUoKVxuICAgIGlmICh2YWxBICE9PSB2YWxCKSB7XG4gICAgICByZXR1cm4gdmFsQSAtIHZhbEJcbiAgICB9XG4gICAgcmV0dXJuIGZpbGxTdHlsZUEucGFja2VkRmlsbENvbG9yIC0gZmlsbFN0eWxlQi5wYWNrZWRGaWxsQ29sb3JcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEganNvbiBvYmplY3Qgb2YgYSBGaWxsU3R5bGUgb2JqZWN0XG4gICAqIEBwYXJhbSAge0ZpbGxTdHlsZX0gZmlsbFN0eWxlT2JqXG4gICAqIEByZXR1cm4ge3tmaWxsQ29sb3I6IHN0cmluZ319XG4gICAqL1xuICBzdGF0aWMgdG9KU09OKGZpbGxTdHlsZU9iaikge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsQ29sb3I6IGZpbGxTdHlsZU9iai5maWxsQ29sb3JcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGwgc3R5bGUgY2xhc3MgdGhhdCBmaXJlcyBldmVudHMgd2hlbmV2ZXIgdGhlIHN0eWxlXG4gKiBpcyBtb2RpZmllZC5cbiAqIEBwYXJhbSAge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IHR5cGUgdG8gZmlyZSB3aGVuIGZpbGwgc3R5bGUgaXMgbW9kaWZpZWRcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSAgICAgICAgIE5ldyBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRlZEZpbGxTdHlsZU1peGluKGV2ZW50TmFtZSkge1xuICAvKipcbiAgICogRXZlbnRlZCBmaWxsIGNvbG9yIGNsYXNzIHRvIGhhbmRsZSBmaWxsIGNvbG9yIG1vZGlmaWNhdGlvbnNcbiAgICogQHR5cGUge0NvbG9yUkdCQX1cbiAgICovXG4gIGNvbnN0IEZpbGxDb2xvckNsYXNzID0gY3JlYXRlRXZlbnRlZENvbG9yUkdCQUNsYXNzKGV2ZW50TmFtZSwgXCJmaWxsQ29sb3JcIilcblxuICAvKipcbiAgICogQG1peGluIE5ldyBldmVudGVkIGZpbGwgc3R5bGUgbWl4aW4uIFdpbGwgZmlyZSBldmVudHMgd2hlbmV2ZXJcbiAgICogICAgICAgIHRoZSBmaWxsIGNvbG9yIGlzIG1vZGlmaWVkXG4gICAqL1xuICByZXR1cm4gYWdncmVnYXRpb24obnVsbCwgRmlsbFN0eWxlLCBjbGFzcyBFdmVudGVkRmlsbFN0eWxlIHtcbiAgICBpbml0aWFsaXplcihvcHRzKSB7XG4gICAgICB0aGlzLl9maWxsQ29sb3IgPSBuZXcgRmlsbENvbG9yQ2xhc3MoXCJyZWRcIiwgdGhpcylcbiAgICAgIHRoaXMuX2luaXRGaWxsU3R5bGVGcm9tT3B0aW9ucyhvcHRzKVxuICAgIH1cbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3N0eWxlL2ZpbGwtc3R5bGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 3x3 Matrix\n * @name mat3\n */\nvar mat3 = {};\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nmat3.fromMat4 = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n};\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Create a new mat3 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} A new mat3\n */\nmat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    var out = new glMatrix.ARRAY_TYPE(9);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n};\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\n * @returns {mat3} out\n */\nmat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n};\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nmat3.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n    \n    return out;\n};\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.invert = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b01 = a22 * a11 - a12 * a21,\n        b11 = -a22 * a10 + a12 * a20,\n        b21 = a21 * a10 - a11 * a20,\n\n        // Calculate the determinant\n        det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.adjoint = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    out[0] = (a11 * a22 - a12 * a21);\n    out[1] = (a02 * a21 - a01 * a22);\n    out[2] = (a01 * a12 - a02 * a11);\n    out[3] = (a12 * a20 - a10 * a22);\n    out[4] = (a00 * a22 - a02 * a20);\n    out[5] = (a02 * a10 - a00 * a12);\n    out[6] = (a10 * a21 - a11 * a20);\n    out[7] = (a01 * a20 - a00 * a21);\n    out[8] = (a00 * a11 - a01 * a10);\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nmat3.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n};\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b00 = b[0], b01 = b[1], b02 = b[2],\n        b10 = b[3], b11 = b[4], b12 = b[5],\n        b20 = b[6], b21 = b[7], b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n};\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nmat3.mul = mat3.multiply;\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nmat3.translate = function(out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n        x = v[0], y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n};\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.rotate = function (out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nmat3.scale = function(out, a, v) {\n    var x = v[0], y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.translate(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat3} out\n */\nmat3.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = v[0];\n    out[7] = v[1];\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.rotate(dest, dest, rad);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.fromRotation = function(out, rad) {\n    var s = Math.sin(rad), c = Math.cos(rad);\n\n    out[0] = c;\n    out[1] = s;\n    out[2] = 0;\n\n    out[3] = -s;\n    out[4] = c;\n    out[5] = 0;\n\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat3.identity(dest);\n *     mat3.scale(dest, dest, vec);\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat3} out\n */\nmat3.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n\n    out[3] = 0;\n    out[4] = v[1];\n    out[5] = 0;\n\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nmat3.fromMat2d = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = 0;\n\n    out[3] = a[2];\n    out[4] = a[3];\n    out[5] = 0;\n\n    out[6] = a[4];\n    out[7] = a[5];\n    out[8] = 1;\n    return out;\n};\n\n/**\n* Calculates a 3x3 matrix from the given quaternion\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {quat} q Quaternion to create matrix from\n*\n* @returns {mat3} out\n*/\nmat3.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n};\n\n/**\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n*\n* @param {mat3} out mat3 receiving operation result\n* @param {mat4} a Mat4 to derive the normal matrix from\n*\n* @returns {mat3} out\n*/\nmat3.normalFromMat4 = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) { \n        return null; \n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat3.str = function (a) {\n    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + \n                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + \n                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat3.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))\n};\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n};\n\n/**\n * Alias for {@link mat3.subtract}\n * @function\n */\nmat3.sub = mat3.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nmat3.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n};\n\n/**\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat3} out the receiving vector\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat3} out\n */\nmat3.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    out[6] = a[6] + (b[6] * scale);\n    out[7] = a[7] + (b[7] * scale);\n    out[8] = a[8] + (b[8] * scale);\n    return out;\n};\n\n/*\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat3.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && \n           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&\n           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat3} a The first matrix.\n * @param {mat3} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat3.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = a[6], b7 = b[7], b8 = b[8];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));\n};\n\n\nmodule.exports = mat3;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzPzhlYTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGU7QUFDQSxvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0Esb0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDN4MyBNYXRyaXhcbiAqIEBuYW1lIG1hdDNcbiAqL1xudmFyIG1hdDMgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDNcbiAqXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgM3gzIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzRdO1xuICAgIG91dFs0XSA9IGFbNV07XG4gICAgb3V0WzVdID0gYVs2XTtcbiAgICBvdXRbNl0gPSBhWzhdO1xuICAgIG91dFs3XSA9IGFbOV07XG4gICAgb3V0WzhdID0gYVsxMF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDMgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcbiAqL1xubWF0My5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMTA7XG4gICAgb3V0WzRdID0gbTExO1xuICAgIG91dFs1XSA9IG0xMjtcbiAgICBvdXRbNl0gPSBtMjA7XG4gICAgb3V0WzddID0gbTIxO1xuICAgIG91dFs4XSA9IG0yMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0xMDtcbiAgICBvdXRbNF0gPSBtMTE7XG4gICAgb3V0WzVdID0gbTEyO1xuICAgIG91dFs2XSA9IG0yMDtcbiAgICBvdXRbN10gPSBtMjE7XG4gICAgb3V0WzhdID0gbTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGExMiA9IGFbNV07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGEwMTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYTAyO1xuICAgICAgICBvdXRbN10gPSBhMTI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVszXTtcbiAgICAgICAgb3V0WzJdID0gYVs2XTtcbiAgICAgICAgb3V0WzNdID0gYVsxXTtcbiAgICAgICAgb3V0WzRdID0gYVs0XTtcbiAgICAgICAgb3V0WzVdID0gYVs3XTtcbiAgICAgICAgb3V0WzZdID0gYVsyXTtcbiAgICAgICAgb3V0WzddID0gYVs1XTtcbiAgICAgICAgb3V0WzhdID0gYVs4XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxLFxuICAgICAgICBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwLFxuICAgICAgICBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjAsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gICAgb3V0WzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICAgIG91dFszXSA9IGIxMSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gICAgb3V0WzZdID0gYjIxICogZGV0O1xuICAgIG91dFs3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGEyMiAtIGExMiAqIGEyMSk7XG4gICAgb3V0WzFdID0gKGEwMiAqIGEyMSAtIGEwMSAqIGEyMik7XG4gICAgb3V0WzJdID0gKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gICAgb3V0WzNdID0gKGExMiAqIGEyMCAtIGExMCAqIGEyMik7XG4gICAgb3V0WzRdID0gKGEwMCAqIGEyMiAtIGEwMiAqIGEyMCk7XG4gICAgb3V0WzVdID0gKGEwMiAqIGExMCAtIGEwMCAqIGExMik7XG4gICAgb3V0WzZdID0gKGExMCAqIGEyMSAtIGExMSAqIGEyMCk7XG4gICAgb3V0WzddID0gKGEwMSAqIGEyMCAtIGEwMCAqIGEyMSk7XG4gICAgb3V0WzhdID0gKGEwMCAqIGExMSAtIGEwMSAqIGExMCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDMuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgcmV0dXJuIGEwMCAqIChhMjIgKiBhMTEgLSBhMTIgKiBhMjEpICsgYTAxICogKC1hMjIgKiBhMTAgKyBhMTIgKiBhMjApICsgYTAyICogKGEyMSAqIGExMCAtIGExMSAqIGEyMCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQzLm11bCA9IG1hdDMubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0MyBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcbiAgICAgICAgeCA9IHZbMF0sIHkgPSB2WzFdO1xuXG4gICAgb3V0WzBdID0gYTAwO1xuICAgIG91dFsxXSA9IGEwMTtcbiAgICBvdXRbMl0gPSBhMDI7XG5cbiAgICBvdXRbM10gPSBhMTA7XG4gICAgb3V0WzRdID0gYTExO1xuICAgIG91dFs1XSA9IGExMjtcblxuICAgIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICAgIG91dFs3XSA9IHggKiBhMDEgKyB5ICogYTExICsgYTIxO1xuICAgIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYyAqIGEwMCArIHMgKiBhMTA7XG4gICAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gICAgb3V0WzJdID0gYyAqIGEwMiArIHMgKiBhMTI7XG5cbiAgICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgICBvdXRbNF0gPSBjICogYTExIC0gcyAqIGEwMTtcbiAgICBvdXRbNV0gPSBjICogYTEyIC0gcyAqIGEwMjtcblxuICAgIG91dFs2XSA9IGEyMDtcbiAgICBvdXRbN10gPSBhMjE7XG4gICAgb3V0WzhdID0gYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKiovXG5tYXQzLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IHggKiBhWzBdO1xuICAgIG91dFsxXSA9IHggKiBhWzFdO1xuICAgIG91dFsyXSA9IHggKiBhWzJdO1xuXG4gICAgb3V0WzNdID0geSAqIGFbM107XG4gICAgb3V0WzRdID0geSAqIGFbNF07XG4gICAgb3V0WzVdID0geSAqIGFbNV07XG5cbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IHZbMF07XG4gICAgb3V0WzddID0gdlsxXTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSwgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IC1zO1xuICAgIG91dFs0XSA9IGM7XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDMuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuXG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB2WzFdO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIGZyb20gYSBtYXQyZCBpbnRvIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5mcm9tTWF0MmQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IGFbMl07XG4gICAgb3V0WzRdID0gYVszXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gYVs0XTtcbiAgICBvdXRbN10gPSBhWzVdO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzNdID0geXggLSB3ejtcbiAgICBvdXRbNl0gPSB6eCArIHd5O1xuXG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgICBvdXRbN10gPSB6eSAtIHd4O1xuXG4gICAgb3V0WzJdID0genggLSB3eTtcbiAgICBvdXRbNV0gPSB6eSArIHd4O1xuICAgIG91dFs4XSA9IDEgLSB4eCAtIHl5O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuKiBDYWxjdWxhdGVzIGEgM3gzIG5vcm1hbCBtYXRyaXggKHRyYW5zcG9zZSBpbnZlcnNlKSBmcm9tIHRoZSA0eDQgbWF0cml4XG4qXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiogQHBhcmFtIHttYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cbipcbiogQHJldHVybnMge21hdDN9IG91dFxuKi9cbm1hdDMubm9ybWFsRnJvbU1hdDQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG5cbiAgICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXG4gKi9cbm1hdDMuZnJvYiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyBNYXRoLnBvdyhhWzZdLCAyKSArIE1hdGgucG93KGFbN10sIDIpICsgTWF0aC5wb3coYVs4XSwgMikpKVxufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSArIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5zdWIgPSBtYXQzLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgb3V0WzRdID0gYVs0XSAqIGI7XG4gICAgb3V0WzVdID0gYVs1XSAqIGI7XG4gICAgb3V0WzZdID0gYVs2XSAqIGI7XG4gICAgb3V0WzddID0gYVs3XSAqIGI7XG4gICAgb3V0WzhdID0gYVs4XSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgb3V0WzRdID0gYVs0XSArIChiWzRdICogc2NhbGUpO1xuICAgIG91dFs1XSA9IGFbNV0gKyAoYls1XSAqIHNjYWxlKTtcbiAgICBvdXRbNl0gPSBhWzZdICsgKGJbNl0gKiBzY2FsZSk7XG4gICAgb3V0WzddID0gYVs3XSArIChiWzddICogc2NhbGUpO1xuICAgIG91dFs4XSA9IGFbOF0gKyAoYls4XSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLypcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0M30gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0My5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIFxuICAgICAgICAgICBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJlxuICAgICAgICAgICBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQzLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sIGE2ID0gYVs2XSwgYTcgPSBhWzddLCBhOCA9IGFbOF07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXSwgYjQgPSBiWzRdLCBiNSA9IGJbNV0sIGI2ID0gYVs2XSwgYjcgPSBiWzddLCBiOCA9IGJbOF07XG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpKTtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 3 Dimensional Vector\n * @name vec3\n */\nvar vec3 = {};\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nvec3.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nvec3.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nvec3.fromValues = function(x, y, z) {\n    var out = new glMatrix.ARRAY_TYPE(3);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nvec3.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nvec3.set = function(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nvec3.sub = vec3.subtract;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nvec3.mul = vec3.multiply;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nvec3.div = vec3.divide;\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nvec3.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    out[2] = Math.ceil(a[2]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nvec3.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    out[2] = Math.floor(a[2]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nvec3.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    out[2] = Math.round(a[2]);\n    return out;\n};\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nvec3.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n};\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nvec3.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nvec3.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nvec3.dist = vec3.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec3.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return x*x + y*y + z*z;\n};\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nvec3.sqrDist = vec3.squaredDistance;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec3.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return Math.sqrt(x*x + y*y + z*z);\n};\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nvec3.len = vec3.length;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec3.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return x*x + y*y + z*z;\n};\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nvec3.sqrLen = vec3.squaredLength;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nvec3.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nvec3.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n};\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nvec3.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    var len = x*x + y*y + z*z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n        out[2] = a[2] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.cross = function(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n};\n\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.hermite = function (out, a, b, c, d, t) {\n  var factorTimes2 = t * t,\n      factor1 = factorTimes2 * (2 * t - 3) + 1,\n      factor2 = factorTimes2 * (t - 2) + t,\n      factor3 = factorTimes2 * (t - 1),\n      factor4 = factorTimes2 * (3 - 2 * t);\n  \n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  \n  return out;\n};\n\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {vec3} c the third operand\n * @param {vec3} d the fourth operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.bezier = function (out, a, b, c, d, t) {\n  var inverseFactor = 1 - t,\n      inverseFactorTimesTwo = inverseFactor * inverseFactor,\n      factorTimes2 = t * t,\n      factor1 = inverseFactorTimesTwo * inverseFactor,\n      factor2 = 3 * t * inverseFactorTimesTwo,\n      factor3 = 3 * factorTimes2 * inverseFactor,\n      factor4 = factorTimes2 * t;\n  \n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  \n  return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nvec3.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n    var z = (glMatrix.RANDOM() * 2.0) - 1.0;\n    var zScale = Math.sqrt(1.0-z*z) * scale;\n\n    out[0] = Math.cos(r) * zScale;\n    out[1] = Math.sin(r) * zScale;\n    out[2] = z * scale;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat4 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat3 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n};\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nvec3.transformQuat = function(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return out;\n};\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateX = function(out, a, b, c){\n   var p = [], r=[];\n\t  //Translate point to the origin\n\t  p[0] = a[0] - b[0];\n\t  p[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n\n\t  //perform rotation\n\t  r[0] = p[0];\n\t  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);\n\t  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);\n\n\t  //translate to correct position\n\t  out[0] = r[0] + b[0];\n\t  out[1] = r[1] + b[1];\n\t  out[2] = r[2] + b[2];\n\n  \treturn out;\n};\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateY = function(out, a, b, c){\n  \tvar p = [], r=[];\n  \t//Translate point to the origin\n  \tp[0] = a[0] - b[0];\n  \tp[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n  \n  \t//perform rotation\n  \tr[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);\n  \tr[1] = p[1];\n  \tr[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);\n  \n  \t//translate to correct position\n  \tout[0] = r[0] + b[0];\n  \tout[1] = r[1] + b[1];\n  \tout[2] = r[2] + b[2];\n  \n  \treturn out;\n};\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nvec3.rotateZ = function(out, a, b, c){\n  \tvar p = [], r=[];\n  \t//Translate point to the origin\n  \tp[0] = a[0] - b[0];\n  \tp[1] = a[1] - b[1];\n  \tp[2] = a[2] - b[2];\n  \n  \t//perform rotation\n  \tr[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);\n  \tr[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);\n  \tr[2] = p[2];\n  \n  \t//translate to correct position\n  \tout[0] = r[0] + b[0];\n  \tout[1] = r[1] + b[1];\n  \tout[2] = r[2] + b[2];\n  \n  \treturn out;\n};\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec3.forEach = (function() {\n    var vec = vec3.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 3;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nvec3.angle = function(a, b) {\n   \n    var tempA = vec3.fromValues(a[0], a[1], a[2]);\n    var tempB = vec3.fromValues(b[0], b[1], b[2]);\n \n    vec3.normalize(tempA, tempA);\n    vec3.normalize(tempB, tempB);\n \n    var cosine = vec3.dot(tempA, tempB);\n\n    if(cosine > 1.0){\n        return 0;\n    } else {\n        return Math.acos(cosine);\n    }     \n};\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec3.str = function (a) {\n    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n};\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec3.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec3.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2];\n    var b0 = b[0], b1 = b[1], b2 = b[2];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));\n};\n\nmodule.exports = vec3;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzP2RkOGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QiwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEs7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jZWlsID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5jZWlsKGFbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5mbG9vciA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubWluID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1heCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gcm91bmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3VuZCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmhlcm1pdGUgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDEsXG4gICAgICBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQsXG4gICAgICBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKSxcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYmV6aWVyID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0LFxuICAgICAgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvLFxuICAgICAgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoZ2xNYXRyaXguUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbnZlYzMuYW5nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICBcbiAgICB2YXIgdGVtcEEgPSB2ZWMzLmZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgdmFyIHRlbXBCID0gdmVjMy5mcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuIFxuICAgIHZlYzMubm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiBcbiAgICB2YXIgY29zaW5lID0gdmVjMy5kb3QodGVtcEEsIHRlbXBCKTtcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9ICAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWMzLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzMuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 4 Dimensional Vector\n * @name vec4\n */\nvar vec4 = {};\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nvec4.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nvec4.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nvec4.fromValues = function(x, y, z, w) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nvec4.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nvec4.set = function(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nvec4.sub = vec4.subtract;\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    out[3] = a[3] * b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nvec4.mul = vec4.multiply;\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    out[3] = a[3] / b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nvec4.div = vec4.divide;\n\n/**\n * Math.ceil the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to ceil\n * @returns {vec4} out\n */\nvec4.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    out[2] = Math.ceil(a[2]);\n    out[3] = Math.ceil(a[3]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to floor\n * @returns {vec4} out\n */\nvec4.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    out[2] = Math.floor(a[2]);\n    out[3] = Math.floor(a[3]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    out[3] = Math.min(a[3], b[3]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    out[3] = Math.max(a[3], b[3]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to round\n * @returns {vec4} out\n */\nvec4.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    out[2] = Math.round(a[2]);\n    out[3] = Math.round(a[3]);\n    return out;\n};\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nvec4.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nvec4.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nvec4.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return Math.sqrt(x*x + y*y + z*z + w*w);\n};\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nvec4.dist = vec4.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec4.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return x*x + y*y + z*z + w*w;\n};\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nvec4.sqrDist = vec4.squaredDistance;\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec4.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return Math.sqrt(x*x + y*y + z*z + w*w);\n};\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nvec4.len = vec4.length;\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec4.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return x*x + y*y + z*z + w*w;\n};\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nvec4.sqrLen = vec4.squaredLength;\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nvec4.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = -a[3];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to invert\n * @returns {vec4} out\n */\nvec4.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  out[3] = 1.0 / a[3];\n  return out;\n};\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nvec4.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    var len = x*x + y*y + z*z + w*w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n        out[0] = x * len;\n        out[1] = y * len;\n        out[2] = z * len;\n        out[3] = w * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nvec4.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nvec4.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    //TODO: This is a pretty awful way of doing this. Find something better.\n    out[0] = glMatrix.RANDOM();\n    out[1] = glMatrix.RANDOM();\n    out[2] = glMatrix.RANDOM();\n    out[3] = glMatrix.RANDOM();\n    vec4.normalize(out, out);\n    vec4.scale(out, out, scale);\n    return out;\n};\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nvec4.transformMat4 = function(out, a, m) {\n    var x = a[0], y = a[1], z = a[2], w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return out;\n};\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nvec4.transformQuat = function(out, a, q) {\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec4.forEach = (function() {\n    var vec = vec4.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 4;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec4.str = function (a) {\n    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec4.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec4} a The first vector.\n * @param {vec4} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec4.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n};\n\nmodule.exports = vec4;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWM0LmpzP2ZhYTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QiwwQkFBMEIsaUJBQWlCLGlCQUFpQjtBQUM1RDtBQUNBLDBCQUEwQixpQkFBaUIsaUJBQWlCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjZWlsXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY2VpbCA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLmNlaWwoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBmbG9vclxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmZsb29yID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICAgIG91dFszXSA9IE1hdGguZmxvb3IoYVszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQucm91bmQgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5yb3VuZChhWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZGlzdCA9IHZlYzQuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJEaXN0ID0gdmVjNC5zcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5sZW4gPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWM0LnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZExlbmd0aH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnNxckxlbiA9IHZlYzQuc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5lZ2F0ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9IC1hWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gaW52ZXJ0XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuaW52ZXJzZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICBvdXRbM10gPSAxLjAgLyBhWzNdO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSB4ICogbGVuO1xuICAgICAgICBvdXRbMV0gPSB5ICogbGVuO1xuICAgICAgICBvdXRbMl0gPSB6ICogbGVuO1xuICAgICAgICBvdXRbM10gPSB3ICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnJhbmRvbSA9IGZ1bmN0aW9uIChvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG5cbiAgICAvL1RPRE86IFRoaXMgaXMgYSBwcmV0dHkgYXdmdWwgd2F5IG9mIGRvaW5nIHRoaXMuIEZpbmQgc29tZXRoaW5nIGJldHRlci5cbiAgICBvdXRbMF0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMV0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbMl0gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICBvdXRbM10gPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgICB2ZWM0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgdmVjNC5zY2FsZShvdXQsIG91dCwgc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSwgdyA9IGFbM107XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0gKiB3O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0gKiB3O1xuICAgIG91dFszXSA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XSAqIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjNCB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzQuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWM0cyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWM0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzQuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjNH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG52ZWM0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanNcbi8vIG1vZHVsZSBpZCA9IDIyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _interactUtils = __webpack_require__(24);\n\nvar InteractUtils = _interopRequireWildcard(_interactUtils);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _basicStyle = __webpack_require__(9);\n\nvar _basicStyle2 = _interopRequireDefault(_basicStyle);\n\nvar _drawEngine = __webpack_require__(16);\n\nvar _drawEngine2 = _interopRequireDefault(_drawEngine);\n\nvar _mat2d = __webpack_require__(7);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _polyLine = __webpack_require__(13);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nvar _strokeStyle = __webpack_require__(10);\n\nvar _strokeStyle2 = _interopRequireDefault(_strokeStyle);\n\nvar _vertEditableShape = __webpack_require__(25);\n\nvar _vertEditableShape2 = _interopRequireDefault(_vertEditableShape);\n\nvar _xformShape = __webpack_require__(26);\n\nvar _xformShape2 = _interopRequireDefault(_xformShape);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar scaleSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpolygon style='fill:%23ffffff;' points='16,20 16,12 4,24 16,36 16,28 32,28 32,36 44,24 32,12 32,20 '/%3E%3Cpolygon points='14,22 14,17 7,24 14,31 14,26 34,26 34,31 41,24 34,17 34,22 '/%3E%3C/g%3E%3C/svg%3E\\\") no-repeat\";\n\nvar rotateSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cg transform='rotate(<degrees>,24,24)'%3E%3Cpath style='fill:%23ffffff;' d='M25.9,4C16.6,4,8.8,11.2,7.4,20.8H6.7H3.3l1.6,2.9l3.8,7.1l1.8,3.3l1.8-3.3l3.8-7.1l1.6-2.9h-3.3h-0.1 c1.3-5.7,6.1-9.9,11.7-9.9c8,0,12.1,4.4,12.1,13.1c0,7.2-5.4,13.1-12.1,13.1h-2v2V42v2h2c10.4,0,18.8-9,18.8-20 C44.7,11.7,37.5,4,25.9,4L25.9,4z'/%3E%3Cpath d='M25.9,6c10.5,0,16.8,6.7,16.8,18c0,9.9-7.5,18-16.8,18v-2.9c7.8,0,14.1-6.8,14.1-15.1c0-5.6-1.8-15.1-14.1-15.1 c-7.4,0-13.4,6.1-14,13.9h2.4l-3.8,7.1l-3.8-7.1h2.5C9.7,13.4,17,6,25.9,6'/%3E%3C/g%3E%3C/svg%3E\\\") no-repeat\";\n\nvar addSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpolygon style='fill:%23ffffff;' points='31.2,28 24.8,28 24.8,32.8 20,32.8 20,39.2 24.8,39.2 24.8,44 31.2,44 31.2,39.2 36,39.2 36,32.8 31.2,32.8 '/%3E %3Cpolygon style='fill:%23ffffff' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='29.6,29.6 29.6,34.4 34.4,34.4 34.4,37.6 29.6,37.6 29.6,42.4 26.4,42.4 26.4,37.6 21.6,37.6 21.6,34.4 26.4,34.4 26.4,29.6 29.6,29.6  '/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar removeSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Crect style='fill:%23ffffff;' x='20' y='32.8' width='16' height='6.4'/%3E%3Cpolygon  style='fill:%23ffffff;' points='12,32 12,4 32.3,24.3 20,24.3 19.7,24.6 '/%3E%3Cpolygon points='13.8,8.2 13.8,27.8 19,22.8 19.2,22.5 28,22.5 '/%3E%3Cpolyline points='34.4,34.4 34.4,37.6 21.6,37.6 21.6,34.4 '/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar repositionSvg = \"url(\\\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 48 48'%3E%3Cpath style='fill:%23ffffff;' d='M24,17.5c-3.6,0-6.5,2.9-6.5,6.5s2.9,6.5,6.5,6.5s6.5-2.9,6.5-6.5S27.6,17.5,24,17.5L24,17.5z'/%3E%3Cpath style='fill:%23ffffff;' d='M24,4L4,24l20,20l20-20L24,4z M31.5,31.5h-15v-15h15V31.5z'/%3E%3Cpolygon points='17,34 24,40.5 31,34  '/%3E%3Cpolygon points='31,14 24,7.5 17,14     '/%3E%3Cpolygon points='14,17 7.5,24 14,31   '/%3E%3Cpolygon points='34,31 40.5,24 34,17    '/%3E%3Cpath d='M24,20c2.2,0,4,1.8,4,4s-1.8,4-4,4s-4-1.8-4-4S21.8,20,24,20'/%3E%3C/svg%3E\\\") no-repeat\";\n\nvar EventConstants = {\n  SELECTION_CHANGED: \"draw:selectionChanged\",\n  DRAG_BEGIN: \"draw:drag:begin\",\n  DRAG_END: \"draw:drag:end\"\n};\n\nvar tmpPt1 = Point2d.create(0, 0);\nvar tmpPt2 = Point2d.create(0, 0);\n\nvar boundsStrokeStyle = new _strokeStyle2.default({\n  strokeColor: \"darkgray\",\n  strokeWidth: 2\n});\n\nvar defaultXformStyle = {\n  fillColor: \"white\",\n  strokeColor: \"black\",\n  strokeWidth: 2\n};\n\nfunction inCanvas(canvas, x, y) {\n  var domrect = canvas.getBoundingClientRect();\n  var localX = 0;\n  var localY = 0;\n  return (localX = x - domrect.left - canvas.clientLeft) >= 0 && localX <= canvas.clientWidth && (localY = y - domrect.top - canvas.clientTop) >= 0 && localY <= canvas.clientHeight;\n}\n\nfunction getLocalMousePos(out, elem, event) {\n  var domrect = elem.getBoundingClientRect();\n  out[0] = event.clientX - domrect.left - elem.clientLeft;\n  out[1] = event.clientY - domrect.top - elem.clientTop;\n}\n\nfunction transformSelectedShape(canvas, event, selectedInfo, camera) {\n  getLocalMousePos(tmpPt1, canvas, event);\n  Point2d.transformMat2d(tmpPt2, tmpPt1, camera.screenToWorldMatrix);\n  var shape = selectedInfo.shape;\n  if (shape instanceof _xformShape2.default) {\n    InteractUtils.transformXformShape(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  } else if (shape instanceof _vertEditableShape2.default) {\n    InteractUtils.translateVert(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  } else {\n    InteractUtils.translateShape(shape, selectedInfo, tmpPt1, tmpPt2, camera);\n  }\n}\n\nfunction addEventKeysToSelectedInfo(event, selectedInfo) {\n  selectedInfo.keys = {\n    altKey: event.altKey,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    metaKey: event.metaKey\n  };\n}\n\nfunction getSelectedObjsFromMap(selectionMap) {\n  var selectedObjs = [];\n  selectionMap.forEach(function (subshape, shape) {\n    selectedObjs.push(shape);\n  });\n  return selectedObjs;\n}\n\nfunction _selectShape(selectedShape, sortedShapes, currSelectedShapes, selectStyle, xformStyle, selectOpts) {\n  var fireObject = {\n    unselectedShapes: getSelectedObjsFromMap(currSelectedShapes)\n  };\n  clearSelectedShapes(currSelectedShapes);\n  selectedShape.save();\n  var maxZ = sortedShapes[sortedShapes.length - 1].zIndex;\n  selectedShape.zIndex = maxZ + 1;\n  _basicStyle2.default.copyBasicStyle(selectStyle, selectedShape);\n  selectedShape.selected = true;\n  // const dimensions = selectedShape.getDimensions()\n\n  var newSelectShape = null;\n  if (selectOpts.scalable || selectOpts.rotatable) {\n    newSelectShape = new _xformShape2.default(xformStyle || defaultXformStyle, selectOpts);\n    selectedShape.addChildXform(newSelectShape);\n  }\n  currSelectedShapes.set(selectedShape, newSelectShape);\n\n  fireObject.selectedShapes = [selectedShape];\n  return fireObject;\n}\n\nfunction clearSelectedShapes(selectedShapeMap) {\n  selectedShapeMap.forEach(function (selectedShape, shape) {\n    shape.restore();\n    shape.selected = false;\n    shape.removeChildXform(selectedShape);\n  });\n  selectedShapeMap.clear();\n}\n\nfunction clearSpecificShapes(selectedShapeMap, shapes) {\n  var clearedShapes = [];\n  shapes.forEach(function (shape) {\n    var selectedShape = selectedShapeMap.get(shape);\n    shape.restore();\n    shape.selected = false;\n    shape.removeChildXform(selectedShape);\n    selectedShapeMap.delete(shape);\n    clearedShapes.push(shape);\n  });\n  return clearedShapes;\n}\n\nvar hideCursor = function hideCursor() {\n  var cursor = document.getElementById('cursor');\n  if (cursor !== null) {\n    cursor.style.display = 'none';\n  }\n};\n\nvar showCursor = function showCursor() {\n  var cursor = document.getElementById('cursor');\n  if (cursor !== null) {\n    cursor.style.display = 'block';\n  }\n};\n\nvar hideCursorWithPointer = function hideCursorWithPointer(e) {\n  e.target.parentNode.style.cursor = 'default';\n  hideCursor();\n};\n\nvar showCursorWithPointer = function showCursorWithPointer(e) {\n  e.target.parentNode.style.cursor = 'none';\n  showCursor();\n};\n\n// understands how to return mouse coordinates as an object in the format {x: <X-COORD>, y: <Y-COORD>}\n// accepts a mouse event and a DOM element as arguments\nfunction getMouseCoordinates(e, target) {\n  var canvas = document.querySelector(\"\" + ('#' + target.id + ' canvas'));\n\n  var coords = {\n    'x': e.offsetX + canvas.offsetLeft,\n    'y': e.offsetY + canvas.offsetTop\n  };\n\n  return coords;\n}\n\n// understands how to append custom cursors to the DOM\n// accepts a mouse event, a DOM element, a cursorStyle, and pixel offsets as arguments\nfunction appendCustomCursor(_event, target, cursorStyle) {\n  var offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -14;\n  var offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -14;\n\n  var cursor = document.getElementById('cursor');\n  var mouse = getMouseCoordinates(_event, target);\n\n  if (cursor === null) {\n    var newCursor = document.createElement('span');\n    newCursor.setAttribute('id', 'cursor');\n    newCursor.setAttribute('style', \"position: absolute; top: \" + (mouse.y + 'px') + \"; left: \" + (mouse.x + 'px') + \"; width: 28px; height: 28px; background: \" + cursorStyle + \"; cursor: none; z-index: 10; pointer-events: none; transform: translate(\" + offsetX + \"px, \" + offsetY + \"px)\");\n    target.appendChild(newCursor);\n  } else if (cursor.style.background !== cursorStyle) {\n    cursor.style.background = cursorStyle;\n    updateCursorPosition(_event, target);\n  } else {\n    updateCursorPosition(_event, target);\n  }\n}\n\n// understands how to remove the custom cursor from the DOM\nfunction removeCustomCursor() {\n  var cursor = document.getElementById('cursor');\n  if (cursor !== null) {\n    cursor.parentNode.removeChild(cursor);\n  }\n}\n\n// understands how to change the position of the custom cursor on the page\n// accepts a mouse event and a DOM element as arguments\nfunction updateCursorPosition(_event, target) {\n  var cursor = document.getElementById('cursor');\n  var mouse = getMouseCoordinates(_event, target);\n\n  if (cursor !== null) {\n    cursor.style.top = \"\" + (mouse.y + 'px');\n    cursor.style.left = \"\" + (mouse.x + 'px');\n  }\n}\n\nvar ShapeBuilder = function (_DrawEngine) {\n  _inherits(ShapeBuilder, _DrawEngine);\n\n  function ShapeBuilder(parent, opts) {\n    _classCallCheck(this, ShapeBuilder);\n\n    return _possibleConstructorReturn(this, (ShapeBuilder.__proto__ || Object.getPrototypeOf(ShapeBuilder)).call(this, parent, opts));\n  }\n\n  _createClass(ShapeBuilder, [{\n    key: \"_mousedownCB\",\n    value: function _mousedownCB(event) {\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY)) {\n        return;\n      }\n\n      this.timer = performance.now();\n\n      Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n      Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      var shapes = this.sortedShapes;\n      var i = -1;\n      var selectedShape = null;\n      var selectedInfo = null;\n      for (i = shapes.length - 1; i >= 0; i -= 1) {\n        var shapeInfo = this._objects.get(shapes[i]);\n        if (shapes[i].selected) {\n          selectedShape = this._selectedShapes.get(shapes[i]);\n          selectedInfo = shapeInfo;\n          var hitInfo = null;\n          if (selectedShape && (hitInfo = selectedShape.containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)).hit) {\n            if (selectedShape instanceof _vertEditableShape2.default && event.altKey && hitInfo.controlIndex < shapes[i].numVerts) {\n              shapes[i].removeVert(hitInfo.controlIndex);\n              selectedShape = null;\n            } else {\n              var localXform = selectedShape.parent.localXform;\n              var invLocalXform = _mat2d2.default.clone(localXform);\n              _mat2d2.default.invert(invLocalXform, invLocalXform);\n              var startObjPos = Point2d.clone(tmpPt2);\n              Point2d.transformMat2d(startObjPos, startObjPos, invLocalXform);\n              this._dragInfo = Object.assign({\n                rotate: Boolean(hitInfo.rotate),\n                controlIndex: hitInfo.controlIndex,\n                startObjectPos: startObjPos,\n                worldToObjectMatrix: invLocalXform,\n                startLocalPos: selectedShape.parent.getPosition(),\n                startLocalScale: selectedShape.parent.getScale(),\n                startLocalRot: selectedShape.parent.getRotation(),\n                shapeWidth: selectedShape.parent.width,\n                shapeHeight: selectedShape.parent.height\n              }, selectedInfo);\n            }\n            break;\n          } else if (shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n            selectedShape = shapes[i];\n            break;\n          }\n        }\n        // else if (shapeInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n        //   selectedShape = shapes[i]\n        //   selectedInfo = shapeInfo\n        //   const selectEventObj = selectShape(selectedShape, shapes, this._selectedShapes, this._selectStyle, this._xformStyle, selectedInfo)\n        //   this.fire(EventConstants.SELECTION_CHANGED, selectEventObj)\n        //   break\n        // }\n      }\n\n      if (i < 0 && this._selectedShapes.size) {\n        if (this._selectedShapes.size) {\n          this.fire(EventConstants.SELECTION_CHANGED, {\n            unselectedShapes: getSelectedObjsFromMap(this._selectedShapes),\n            selectedShapes: []\n          });\n        }\n        this._dragInfo = null;\n        clearSelectedShapes(this._selectedShapes);\n      } else if (selectedShape && selectedInfo && (selectedInfo.movable || selectedInfo.rotatable || selectedInfo.scalable)) {\n        var canvas = document.querySelector(\"\" + ('#' + this._parent.id + ' > canvas'));\n        if (canvas !== null) {\n          canvas.addEventListener('mouseout', hideCursorWithPointer);\n          canvas.addEventListener('mouseover', showCursorWithPointer);\n        } else {\n          this._parent.addEventListener('mouseout', hideCursor);\n          this._parent.addEventListener('mouseover', showCursor);\n        }\n        if (!this._dragInfo && selectedInfo.movable) {\n          this._dragInfo = {\n            startLocalPos: selectedShape.getPosition()\n          };\n        }\n\n        if (this._dragInfo) {\n          this._dragInfo.shape = selectedShape;\n          this._dragInfo.startPos = Point2d.clone(tmpPt1);\n          this._dragInfo.startWorldPos = Point2d.clone(tmpPt2);\n          this._dragInfo.objectToWorldMatrix = _mat2d2.default.clone(selectedShape.globalXform);\n          addEventKeysToSelectedInfo(event, this._dragInfo);\n          event.stopImmediatePropagation();\n          this.fire(EventConstants.DRAG_BEGIN, {\n            shapes: getSelectedObjsFromMap(this._selectedShapes)\n          });\n        }\n      }\n      event.preventDefault();\n    }\n  }, {\n    key: \"_mouseupCB\",\n    value: function _mouseupCB(event) {\n      if (this._dragInfo && this._dragInfo.shape) {\n        event.stopImmediatePropagation();\n        event.preventDefault();\n        var canvas = document.querySelector(\"\" + ('#' + this._parent.id + ' > canvas'));\n        if (canvas !== null) {\n          canvas.removeEventListener('mouseout', hideCursorWithPointer);\n          canvas.removeEventListener('mouseover', showCursorWithPointer);\n        } else {\n          this._parent.removeEventListener('mouseout', hideCursor);\n          this._parent.removeEventListener('mouseover', showCursor);\n        }\n        this._dragInfo = null;\n        this.fire(EventConstants.DRAG_END, {\n          shapes: getSelectedObjsFromMap(this._selectedShapes)\n        });\n      } else if (performance.now() - this.timer < 500) {\n        // this is a relatively quick click\n        Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n        Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n        var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n        var shapes = this.sortedShapes;\n        var selectedShape = null;\n        var selectedInfo = null;\n        for (var i = shapes.length - 1; i >= 0; i -= 1) {\n          selectedInfo = this._objects.get(shapes[i]);\n          if (selectedInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n            selectedShape = shapes[i];\n            break;\n          }\n        }\n        if (selectedShape && !selectedShape.selected) {\n          var selectEventObj = _selectShape(selectedShape, shapes, this._selectedShapes, this._selectStyle, this._xformStyle, selectedInfo);\n          this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n        }\n      }\n    }\n  }, {\n    key: \"_mousemoveCB\",\n    value: function _mousemoveCB(event) {\n      var incanvas = false;\n      if (!(incanvas = inCanvas(this._drawCanvas, event.clientX, event.clientY)) && !this._dragInfo) {\n        return;\n      }\n\n      if (this._dragInfo && this._dragInfo.shape) {\n        updateCursorPosition(event, this._parent);\n        addEventKeysToSelectedInfo(event, this._dragInfo);\n        transformSelectedShape(this._drawCanvas, event, this._dragInfo, this._camera);\n        event.stopImmediatePropagation();\n        event.preventDefault();\n      } else if (!event.buttons && this._selectedShapes.size) {\n        Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n        Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n        var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n        var shapes = this.sortedShapes;\n        var i = 0;\n        var flipy = this._camera.isYFlipped();\n        for (i = shapes.length - 1; i >= 0; i -= 1) {\n          if (shapes[i].selected) {\n            var selectInfo = this._objects.get(shapes[i]);\n            var selectedShape = this._selectedShapes.get(shapes[i]);\n            var hitInfo = null;\n            var cursor = document.getElementById('cursor');\n            this._parent.style.cursor = 'none';\n            // forEach not supported on nodelist in IE/Edge\n            for (var _i = 0; _i < this._parent.childNodes.length; _i++) {\n              this._parent.childNodes[_i].style.cursor = 'none';\n              if (this._parent.childNodes[_i].nodeName.toLowerCase() === 'canvas') {\n                continue;\n              }\n              this._parent.childNodes[_i].style.pointerEvents = 'none';\n            }\n            if (selectedShape && (hitInfo = selectedShape.containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)).hit) {\n              if (selectedShape instanceof _xformShape2.default) {\n                if (hitInfo.rotate) {\n                  var degrees = shapes[i].getRotation();\n                  if (flipy) {\n                    degrees *= -1;\n                    if (hitInfo.controlIndex === 1) {\n                      degrees -= 90;\n                    } else if (hitInfo.controlIndex === 0) {\n                      degrees += 180;\n                    } else if (hitInfo.controlIndex === 2) {\n                      degrees += 90;\n                    }\n                  } else {\n                    if (hitInfo.controlIndex === 0) {\n                      degrees -= 90;\n                    } else if (hitInfo.controlIndex === 1) {\n                      degrees += 180;\n                    } else if (hitInfo.controlIndex === 3) {\n                      degrees += 90;\n                    }\n                  }\n                  appendCustomCursor(event, this._parent, \"\" + rotateSvg.replace(/\\<degrees\\>/g, \"\" + degrees));\n                } else if (hitInfo.controlIndex < 4) {\n                  if (hitInfo.controlIndex === 0 || hitInfo.controlIndex === 3) {\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/\\<degrees\\>/g, \"\" + (-shapes[i].getRotation() - 45)));\n                  } else if (hitInfo.controlIndex === 1 || hitInfo.controlIndex === 2) {\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/\\<degrees\\>/g, \"\" + (-shapes[i].getRotation() + 45)));\n                  }\n                } else {\n                  if (hitInfo.controlIndex % 2 === 0) {\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/\\<degrees\\>/g, \"\" + -shapes[i].getRotation()));\n                  } else {\n                    appendCustomCursor(event, this._parent, \"\" + scaleSvg.replace(/\\<degrees\\>/g, \"\" + (-shapes[i].getRotation() + 90)));\n                  }\n                }\n              } else if (selectedShape instanceof _vertEditableShape2.default) {\n                this._parent.style.cursor = 'none';\n                // forEach not supported on nodelist in IE/Edge\n                for (var _i2 = 0; _i2 < this._parent.childNodes.length; _i2++) {\n                  this._parent.childNodes[_i2].style.cursor = 'none';\n                  if (this._parent.childNodes[_i2].nodeName.toLowerCase() === 'canvas') {\n                    continue;\n                  }\n                  this._parent.childNodes[_i2].style.pointerEvents = 'none';\n                }\n                if (hitInfo.controlIndex >= shapes[i].numVerts) {\n                  appendCustomCursor(event, this._parent, addSvg, -8, -6);\n                } else if (event.altKey) {\n                  appendCustomCursor(event, this._parent, removeSvg, -8, -6);\n                } else {\n                  appendCustomCursor(event, this._parent, repositionSvg, -14, -14);\n                }\n              }\n              event.stopImmediatePropagation();\n              event.preventDefault();\n              break;\n            } else if (shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n              if (selectInfo && selectInfo.movable) {\n                var _cursor = document.getElementById('cursor');\n                if (_cursor !== null) {\n                  _cursor.parentNode.removeChild(_cursor);\n                }\n                this._parent.style.cursor = \"move\";\n                for (var _i3 = 0; _i3 < this._parent.childNodes.length; _i3++) {\n                  this._parent.childNodes[_i3].style.cursor = 'move';\n                }\n                event.stopImmediatePropagation();\n                event.preventDefault();\n              }\n              break;\n            }\n          }\n        }\n\n        if (i < 0) {\n          removeCustomCursor();\n          this._parent.style.cursor = \"default\";\n          // forEach not supported on nodelist in IE/Edge\n          for (var _i4 = 0; _i4 < this._parent.childNodes.length; _i4++) {\n            this._parent.childNodes[_i4].style.cursor = 'default';\n            if (this._parent.childNodes[_i4].nodeName.toLowerCase() === 'canvas') {\n              continue;\n            }\n            this._parent.childNodes[_i4].style.pointerEvents = 'auto';\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_clickCB\",\n    value: function _clickCB(event) {\n      // noop\n    }\n  }, {\n    key: \"_dblclickCB\",\n    value: function _dblclickCB(event) {\n      if (!inCanvas(this._drawCanvas, event.clientX, event.clientY)) {\n        return;\n      }\n\n      Point2d.set(tmpPt1, event.offsetX, event.offsetY);\n      Point2d.transformMat2d(tmpPt2, tmpPt1, this._camera.screenToWorldMatrix);\n      var worldToScreenMatrix = this._camera.worldToScreenMatrix;\n      var shapes = this.sortedShapes;\n      var i = -1;\n      for (i = shapes.length - 1; i >= 0; i -= 1) {\n        var shapeInfo = this._objects.get(shapes[i]);\n        if (shapeInfo.selectable && shapes[i].containsPoint(tmpPt1, tmpPt2, worldToScreenMatrix, this._drawCtx)) {\n          if (shapeInfo.editable && shapes[i] instanceof _polyLine2.default) {\n            var selectedShape = shapes[i];\n            var doXform = false;\n            if (shapes[i].selected) {\n              var interactiveShape = this._selectedShapes.get(shapes[i]);\n              if (interactiveShape) {\n                selectedShape.restore();\n                selectedShape.removeChildXform(interactiveShape);\n                doXform = !(interactiveShape instanceof _xformShape2.default);\n              }\n            }\n\n            selectedShape.selected = true;\n            selectedShape.save();\n            var maxZ = shapes[shapes.length - 1].zIndex;\n            selectedShape.zIndex = maxZ + 1;\n            _basicStyle2.default.copyBasicStyle(this._selectStyle, selectedShape);\n            var newSelectShape = null;\n            if (doXform) {\n              if (shapeInfo.rotatable || shapeInfo.scalable) {\n                newSelectShape = new _xformShape2.default(this._xformStyle || defaultXformStyle, shapeInfo);\n                selectedShape.addChildXform(newSelectShape);\n              }\n            } else {\n              newSelectShape = new _vertEditableShape2.default(selectedShape, this._xformStyle);\n              selectedShape.addChildXform(newSelectShape);\n            }\n            this._selectedShapes.set(selectedShape, newSelectShape);\n          } else if (!shapes[i].selected) {\n            var selectEventObj = _selectShape(shapes[i], shapes, this._selectedShapes, this._selectStyle, this._xformStyle, shapeInfo);\n            this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n          }\n          break;\n        }\n      }\n\n      if (i < 0 && this._selectedShapes.size) {\n        if (this._selectedShapes.size) {\n          this.fire(EventConstants.SELECTION_CHANGED, {\n            unselectedShapes: getSelectedObjsFromMap(this._selectedShapes),\n            selectedShapes: []\n          });\n        }\n        this._dragInfo = null;\n        clearSelectedShapes(this._selectedShapes);\n      } else {\n        event.stopImmediatePropagation();\n      }\n      event.preventDefault();\n    }\n  }, {\n    key: \"_mouseoverCB\",\n    value: function _mouseoverCB(event) {\n      // noop\n    }\n  }, {\n    key: \"_mouseoutCB\",\n    value: function _mouseoutCB(event) {\n      // noop\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(parent, opts) {\n      this._activated = opts && opts.enableInteractions;\n      _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"_init\", this).call(this, parent, opts, this._activated);\n      var myevents = Object.getOwnPropertyNames(EventConstants).map(function (event) {\n        return EventConstants[event];\n      });\n      this.registerEvents(myevents);\n      this._dragInfo = null;\n      this._selectedShapes = new Map();\n      this._selectStyle = new _basicStyle2.default(opts && opts.selectStyle ? opts.selectStyle : {\n        fillColor: \"orange\"\n      });\n\n      this._xformStyle = new _basicStyle2.default(opts && opts.xformStyle ? opts.xformStyle : {\n        fillColor: \"white\",\n        strokeColor: \"black\",\n        strokeWidth: 2\n      });\n\n      this.timer = 0;\n    }\n  }, {\n    key: \"_renderShapes\",\n    value: function _renderShapes(ctx, drawShapes, camera) {\n      var _this2 = this;\n\n      var worldToScreenMat = camera.worldToScreenMatrix;\n      drawShapes.forEach(function (shape) {\n        if (shape.visible) {\n          shape.render(ctx, worldToScreenMat, _this2._styleState);\n          // shape.renderBounds(ctx, worldToScreenMat, boundsStrokeStyle)\n          if (shape.selected) {\n            var interacShape = _this2._selectedShapes.get(shape);\n            if (interacShape) {\n              interacShape.render(ctx, worldToScreenMat, _this2._styleState);\n              // interacShape.renderBounds(ctx, worldToScreenMat, boundsStrokeStyle)\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"selectShape\",\n    value: function selectShape(shape) {\n      var shapeInfo = this._objects.get(shape);\n      if (shapeInfo && shapeInfo.selectable) {\n        var selectEventObj = _selectShape(shape, this.sortedShapes, this._selectedShapes, this._selectStyle, this._xformStyle, shapeInfo);\n        this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n      }\n    }\n  }, {\n    key: \"clearSelection\",\n    value: function clearSelection() {\n      if (this._selectedShapes.size) {\n        var selectedShapes = getSelectedObjsFromMap(this._selectedShapes);\n        clearSelectedShapes(this._selectedShapes);\n        this.fire(EventConstants.SELECTION_CHANGED, {\n          unselectedShapes: selectedShapes,\n          selectedShapes: []\n        });\n        this._rerenderCb();\n      }\n    }\n  }, {\n    key: \"addShape\",\n    value: function addShape(shape) {\n      var _this3 = this;\n\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var select = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n\n      _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"addShape\", this).call(this, shapes);\n      shapes.forEach(function (shape) {\n        var shapeInfo = _this3._objects.get(shape);\n        if (shapeInfo) {\n          shapeInfo.selectable = opts && typeof opts.selectable !== \"undefined\" ? Boolean(opts.selectable) : true;\n          shapeInfo.movable = opts && typeof opts.movable !== \"undefined\" ? Boolean(opts.movable) : true;\n          shapeInfo.rotatable = opts && typeof opts.rotatable !== \"undefined\" ? Boolean(opts.rotatable) : true;\n          shapeInfo.scalable = opts && typeof opts.scalable !== \"undefined\" ? Boolean(opts.scalable) : true;\n          shapeInfo.uniformScaleOnly = opts && typeof opts.uniformScaleOnly !== \"undefined\" ? Boolean(opts.uniformScaleOnly) : false;\n          shapeInfo.centerScaleOnly = opts && typeof opts.centerScaleOnly !== \"undefined\" ? Boolean(opts.centerScaleOnly) : false;\n          shapeInfo.editable = opts && typeof opts.editable !== \"undefined\" ? Boolean(opts.editable) : true;\n        }\n      });\n\n      if (select) {\n        var selectEventObj = {\n          unselectedShapes: getSelectedObjsFromMap(this._selectedShapes)\n        };\n        var selectedShapes = [];\n        shapes.forEach(function (shape) {\n          var shapeInfo = _this3._objects.get(shape);\n          if (shapeInfo.selectable) {\n            _selectShape(shape, _this3.sortedShapes, _this3._selectedShapes, _this3._selectStyle, _this3._xformStyle, shapeInfo);\n            selectedShapes.push(shape);\n          }\n        });\n\n        if (selectedShapes.length) {\n          selectEventObj.selectedShapes = selectedShapes;\n          this.fire(EventConstants.SELECTION_CHANGED, selectEventObj);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"deleteShape\",\n    value: function deleteShape(shape) {\n      var shapes = shape;\n      if (!Array.isArray(shapes)) {\n        shapes = [shape];\n      }\n      var selectClearedShapes = clearSpecificShapes(this._selectedShapes, shapes);\n      this.fire(EventConstants.SELECTION_CHANGED, {\n        unselectedShapes: selectClearedShapes,\n        selectedShapes: getSelectedObjsFromMap(this._selectedShapes)\n      });\n\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\";\n      // forEach not supported on nodelist in IE/Edge\n      for (var i = 0; i < this._parent.childNodes.length; i++) {\n        this._parent.childNodes[i].style.cursor = 'default';\n        this._parent.childNodes[i].style.pointerEvents = 'auto';\n      }\n\n      return _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"deleteShape\", this).call(this, shapes);\n    }\n  }, {\n    key: \"deleteSelectedShapes\",\n    value: function deleteSelectedShapes() {\n      var selectedShapes = getSelectedObjsFromMap(this._selectedShapes);\n      clearSelectedShapes(this._selectedShapes);\n      this.fire(EventConstants.SELECTION_CHANGED, {\n        unselectedShapes: selectedShapes,\n        selectedShapes: []\n      });\n\n      removeCustomCursor();\n      this._parent.style.cursor = \"default\";\n      // forEach not supported on nodelist in IE/Edge\n      for (var i = 0; i < this._parent.childNodes.length; i++) {\n        this._parent.childNodes[i].style.cursor = 'default';\n        this._parent.childNodes[i].style.pointerEvents = 'auto';\n      }\n\n      return _get(ShapeBuilder.prototype.__proto__ || Object.getPrototypeOf(ShapeBuilder.prototype), \"deleteShape\", this).call(this, selectedShapes);\n    }\n  }, {\n    key: \"enableInteractions\",\n    value: function enableInteractions() {\n      this._enableEvents();\n      this._activated = true;\n      return this;\n    }\n  }, {\n    key: \"disableInteractions\",\n    value: function disableInteractions() {\n      var clearSelection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (clearSelection) {\n        this.clearSelection();\n      }\n      this._disableEvents();\n      this._activated = false;\n      return this;\n    }\n  }, {\n    key: \"selectStyle\",\n    set: function set(selectStyle) {\n      _basicStyle2.default.copyBasicStyle(selectStyle, this._selectStyle);\n    },\n    get: function get() {\n      return this._selectStyle;\n    }\n  }, {\n    key: \"selectedShapes\",\n    get: function get() {\n      return getSelectedObjsFromMap(this._selectedShapes);\n    }\n  }, {\n    key: \"interactionsEnabled\",\n    get: function get() {\n      return this._activated;\n    }\n  }]);\n\n  return ShapeBuilder;\n}(_drawEngine2.default);\n\nexports.default = ShapeBuilder;\n\n\nObject.assign(EventConstants, _drawEngine2.default.EventConstants);\nShapeBuilder.EventConstants = EventConstants;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9lbmdpbmUvc2hhcGUtYnVpbGRlci5qcz8yNjg0Il0sIm5hbWVzIjpbIkludGVyYWN0VXRpbHMiLCJQb2ludDJkIiwic2NhbGVTdmciLCJyb3RhdGVTdmciLCJhZGRTdmciLCJyZW1vdmVTdmciLCJyZXBvc2l0aW9uU3ZnIiwiRXZlbnRDb25zdGFudHMiLCJTRUxFQ1RJT05fQ0hBTkdFRCIsIkRSQUdfQkVHSU4iLCJEUkFHX0VORCIsInRtcFB0MSIsImNyZWF0ZSIsInRtcFB0MiIsImJvdW5kc1N0cm9rZVN0eWxlIiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsImRlZmF1bHRYZm9ybVN0eWxlIiwiZmlsbENvbG9yIiwiaW5DYW52YXMiLCJjYW52YXMiLCJ4IiwieSIsImRvbXJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsb2NhbFgiLCJsb2NhbFkiLCJsZWZ0IiwiY2xpZW50TGVmdCIsImNsaWVudFdpZHRoIiwidG9wIiwiY2xpZW50VG9wIiwiY2xpZW50SGVpZ2h0IiwiZ2V0TG9jYWxNb3VzZVBvcyIsIm91dCIsImVsZW0iLCJldmVudCIsImNsaWVudFgiLCJjbGllbnRZIiwidHJhbnNmb3JtU2VsZWN0ZWRTaGFwZSIsInNlbGVjdGVkSW5mbyIsImNhbWVyYSIsInRyYW5zZm9ybU1hdDJkIiwic2NyZWVuVG9Xb3JsZE1hdHJpeCIsInNoYXBlIiwidHJhbnNmb3JtWGZvcm1TaGFwZSIsInRyYW5zbGF0ZVZlcnQiLCJ0cmFuc2xhdGVTaGFwZSIsImFkZEV2ZW50S2V5c1RvU2VsZWN0ZWRJbmZvIiwia2V5cyIsImFsdEtleSIsImN0cmxLZXkiLCJzaGlmdEtleSIsIm1ldGFLZXkiLCJnZXRTZWxlY3RlZE9ianNGcm9tTWFwIiwic2VsZWN0aW9uTWFwIiwic2VsZWN0ZWRPYmpzIiwiZm9yRWFjaCIsInN1YnNoYXBlIiwicHVzaCIsInNlbGVjdFNoYXBlIiwic2VsZWN0ZWRTaGFwZSIsInNvcnRlZFNoYXBlcyIsImN1cnJTZWxlY3RlZFNoYXBlcyIsInNlbGVjdFN0eWxlIiwieGZvcm1TdHlsZSIsInNlbGVjdE9wdHMiLCJmaXJlT2JqZWN0IiwidW5zZWxlY3RlZFNoYXBlcyIsImNsZWFyU2VsZWN0ZWRTaGFwZXMiLCJzYXZlIiwibWF4WiIsImxlbmd0aCIsInpJbmRleCIsImNvcHlCYXNpY1N0eWxlIiwic2VsZWN0ZWQiLCJuZXdTZWxlY3RTaGFwZSIsInNjYWxhYmxlIiwicm90YXRhYmxlIiwiYWRkQ2hpbGRYZm9ybSIsInNldCIsInNlbGVjdGVkU2hhcGVzIiwic2VsZWN0ZWRTaGFwZU1hcCIsInJlc3RvcmUiLCJyZW1vdmVDaGlsZFhmb3JtIiwiY2xlYXIiLCJjbGVhclNwZWNpZmljU2hhcGVzIiwic2hhcGVzIiwiY2xlYXJlZFNoYXBlcyIsImdldCIsImRlbGV0ZSIsImhpZGVDdXJzb3IiLCJjdXJzb3IiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3R5bGUiLCJkaXNwbGF5Iiwic2hvd0N1cnNvciIsImhpZGVDdXJzb3JXaXRoUG9pbnRlciIsImUiLCJ0YXJnZXQiLCJwYXJlbnROb2RlIiwic2hvd0N1cnNvcldpdGhQb2ludGVyIiwiZ2V0TW91c2VDb29yZGluYXRlcyIsInF1ZXJ5U2VsZWN0b3IiLCJpZCIsImNvb3JkcyIsIm9mZnNldFgiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0WSIsIm9mZnNldFRvcCIsImFwcGVuZEN1c3RvbUN1cnNvciIsIl9ldmVudCIsImN1cnNvclN0eWxlIiwibW91c2UiLCJuZXdDdXJzb3IiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJiYWNrZ3JvdW5kIiwidXBkYXRlQ3Vyc29yUG9zaXRpb24iLCJyZW1vdmVDdXN0b21DdXJzb3IiLCJyZW1vdmVDaGlsZCIsIlNoYXBlQnVpbGRlciIsInBhcmVudCIsIm9wdHMiLCJfZHJhd0NhbnZhcyIsInRpbWVyIiwicGVyZm9ybWFuY2UiLCJub3ciLCJfY2FtZXJhIiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImkiLCJzaGFwZUluZm8iLCJfb2JqZWN0cyIsIl9zZWxlY3RlZFNoYXBlcyIsImhpdEluZm8iLCJjb250YWluc1BvaW50IiwiX2RyYXdDdHgiLCJoaXQiLCJjb250cm9sSW5kZXgiLCJudW1WZXJ0cyIsInJlbW92ZVZlcnQiLCJsb2NhbFhmb3JtIiwiaW52TG9jYWxYZm9ybSIsImNsb25lIiwiaW52ZXJ0Iiwic3RhcnRPYmpQb3MiLCJfZHJhZ0luZm8iLCJPYmplY3QiLCJhc3NpZ24iLCJyb3RhdGUiLCJCb29sZWFuIiwic3RhcnRPYmplY3RQb3MiLCJ3b3JsZFRvT2JqZWN0TWF0cml4Iiwic3RhcnRMb2NhbFBvcyIsImdldFBvc2l0aW9uIiwic3RhcnRMb2NhbFNjYWxlIiwiZ2V0U2NhbGUiLCJzdGFydExvY2FsUm90IiwiZ2V0Um90YXRpb24iLCJzaGFwZVdpZHRoIiwid2lkdGgiLCJzaGFwZUhlaWdodCIsImhlaWdodCIsInNpemUiLCJmaXJlIiwibW92YWJsZSIsIl9wYXJlbnQiLCJhZGRFdmVudExpc3RlbmVyIiwic3RhcnRQb3MiLCJzdGFydFdvcmxkUG9zIiwib2JqZWN0VG9Xb3JsZE1hdHJpeCIsImdsb2JhbFhmb3JtIiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2VsZWN0YWJsZSIsInNlbGVjdEV2ZW50T2JqIiwiX3NlbGVjdFN0eWxlIiwiX3hmb3JtU3R5bGUiLCJpbmNhbnZhcyIsImJ1dHRvbnMiLCJmbGlweSIsImlzWUZsaXBwZWQiLCJzZWxlY3RJbmZvIiwiY2hpbGROb2RlcyIsIm5vZGVOYW1lIiwidG9Mb3dlckNhc2UiLCJwb2ludGVyRXZlbnRzIiwiZGVncmVlcyIsInJlcGxhY2UiLCJlZGl0YWJsZSIsImRvWGZvcm0iLCJpbnRlcmFjdGl2ZVNoYXBlIiwiX2FjdGl2YXRlZCIsImVuYWJsZUludGVyYWN0aW9ucyIsIm15ZXZlbnRzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm1hcCIsInJlZ2lzdGVyRXZlbnRzIiwiTWFwIiwiY3R4IiwiZHJhd1NoYXBlcyIsIndvcmxkVG9TY3JlZW5NYXQiLCJ2aXNpYmxlIiwicmVuZGVyIiwiX3N0eWxlU3RhdGUiLCJpbnRlcmFjU2hhcGUiLCJfcmVyZW5kZXJDYiIsInNlbGVjdCIsIkFycmF5IiwiaXNBcnJheSIsInVuaWZvcm1TY2FsZU9ubHkiLCJjZW50ZXJTY2FsZU9ubHkiLCJzZWxlY3RDbGVhcmVkU2hhcGVzIiwiX2VuYWJsZUV2ZW50cyIsImNsZWFyU2VsZWN0aW9uIiwiX2Rpc2FibGVFdmVudHMiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7O0lBQVlBLGE7O0FBQ1o7O0lBQVlDLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUMsV0FBVyxtV0FBakI7O0FBRUEsSUFBTUMsWUFBWSwrbkJBQWxCOztBQUVBLElBQU1DLFNBQVMsa2tCQUFmOztBQUVBLElBQU1DLFlBQVksMlpBQWxCOztBQUVBLElBQU1DLGdCQUFnQixzbEJBQXRCOztBQUVBLElBQU1DLGlCQUFpQjtBQUNyQkMscUJBQW1CLHVCQURFO0FBRXJCQyxjQUFZLGlCQUZTO0FBR3JCQyxZQUFVO0FBSFcsQ0FBdkI7O0FBTUEsSUFBTUMsU0FBU1YsUUFBUVcsTUFBUixDQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZjtBQUNBLElBQU1DLFNBQVNaLFFBQVFXLE1BQVIsQ0FBZSxDQUFmLEVBQWtCLENBQWxCLENBQWY7O0FBRUEsSUFBTUUsb0JBQW9CLDBCQUFnQjtBQUN4Q0MsZUFBYSxVQUQyQjtBQUV4Q0MsZUFBYTtBQUYyQixDQUFoQixDQUExQjs7QUFLQSxJQUFNQyxvQkFBb0I7QUFDeEJDLGFBQVcsT0FEYTtBQUV4QkgsZUFBYSxPQUZXO0FBR3hCQyxlQUFhO0FBSFcsQ0FBMUI7O0FBTUEsU0FBU0csUUFBVCxDQUFrQkMsTUFBbEIsRUFBMEJDLENBQTFCLEVBQTZCQyxDQUE3QixFQUFn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dkIsVUFBTCxHQUFrQixLQUFsQjtBQUNBLGFBQU8sSUFBUDtBQUNEOzs7c0JBckllbkksVyxFQUFhO0FBQzNCLDJCQUFXVSxjQUFYLENBQTBCVixXQUExQixFQUF1QyxLQUFLbUgsWUFBNUM7QUFDRCxLO3dCQUVpQjtBQUNoQixhQUFPLEtBQUtBLFlBQVo7QUFDRDs7O3dCQUVvQjtBQUNuQixhQUFPN0gsdUJBQXVCLEtBQUtpRixlQUE1QixDQUFQO0FBQ0Q7Ozt3QkEwR3lCO0FBQ3hCLGFBQU8sS0FBSzRELFVBQVo7QUFDRDs7Ozs7O2tCQWhma0J4RSxZOzs7QUFrZ0JyQjBCLE9BQU9DLE1BQVAsQ0FBYy9JLGNBQWQsRUFBOEIscUJBQVdBLGNBQXpDO0FBQ0FvSCxhQUFhcEgsY0FBYixHQUE4QkEsY0FBOUIiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBJbnRlcmFjdFV0aWxzIGZyb20gXCIuLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3QtdXRpbHNcIlxuaW1wb3J0ICogYXMgUG9pbnQyZCBmcm9tIFwiLi4vY29yZS9wb2ludDJkXCJcbmltcG9ydCBCYXNpY1N0eWxlIGZyb20gXCIuLi9zdHlsZS9iYXNpYy1zdHlsZVwiXG5pbXBvcnQgRHJhd0VuZ2luZSBmcm9tIFwiLi9kcmF3LWVuZ2luZVwiXG5pbXBvcnQgTWF0MmQgZnJvbSBcIi4uL2NvcmUvbWF0MmRcIlxuaW1wb3J0IFBvbHlMaW5lIGZyb20gXCIuLi9zaGFwZXMvcG9seS1saW5lXCJcbmltcG9ydCBTdHJva2VTdHlsZSBmcm9tIFwiLi4vc3R5bGUvc3Ryb2tlLXN0eWxlXCJcbmltcG9ydCBWZXJ0RWRpdGFibGVTaGFwZSBmcm9tIFwiLi4vaW50ZXJhY3Rpb25zL3ZlcnQtZWRpdGFibGUtc2hhcGVcIlxuaW1wb3J0IFhmb3JtU2hhcGUgZnJvbSBcIi4uL2ludGVyYWN0aW9ucy94Zm9ybS1zaGFwZVwiXG5cbmNvbnN0IHNjYWxlU3ZnID0gXCJ1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgNDggNDgnJTNFJTNDZyB0cmFuc2Zvcm09J3JvdGF0ZSg8ZGVncmVlcz4sMjQsMjQpJyUzRSUzQ3BvbHlnb24gc3R5bGU9J2ZpbGw6JTIzZmZmZmZmOycgcG9pbnRzPScxNiwyMCAxNiwxMiA0LDI0IDE2LDM2IDE2LDI4IDMyLDI4IDMyLDM2IDQ0LDI0IDMyLDEyIDMyLDIwICcvJTNFJTNDcG9seWdvbiBwb2ludHM9JzE0LDIyIDE0LDE3IDcsMjQgMTQsMzEgMTQsMjYgMzQsMjYgMzQsMzEgNDEsMjQgMzQsMTcgMzQsMjIgJy8lM0UlM0MvZyUzRSUzQy9zdmclM0VcXFwiKSBuby1yZXBlYXRcIlxuXG5jb25zdCByb3RhdGVTdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0NnIHRyYW5zZm9ybT0ncm90YXRlKDxkZWdyZWVzPiwyNCwyNCknJTNFJTNDcGF0aCBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBkPSdNMjUuOSw0QzE2LjYsNCw4LjgsMTEuMiw3LjQsMjAuOEg2LjdIMy4zbDEuNiwyLjlsMy44LDcuMWwxLjgsMy4zbDEuOC0zLjNsMy44LTcuMWwxLjYtMi45aC0zLjNoLTAuMSBjMS4zLTUuNyw2LjEtOS45LDExLjctOS45YzgsMCwxMi4xLDQuNCwxMi4xLDEzLjFjMCw3LjItNS40LDEzLjEtMTIuMSwxMy4xaC0ydjJWNDJ2MmgyYzEwLjQsMCwxOC44LTksMTguOC0yMCBDNDQuNywxMS43LDM3LjUsNCwyNS45LDRMMjUuOSw0eicvJTNFJTNDcGF0aCBkPSdNMjUuOSw2YzEwLjUsMCwxNi44LDYuNywxNi44LDE4YzAsOS45LTcuNSwxOC0xNi44LDE4di0yLjljNy44LDAsMTQuMS02LjgsMTQuMS0xNS4xYzAtNS42LTEuOC0xNS4xLTE0LjEtMTUuMSBjLTcuNCwwLTEzLjQsNi4xLTE0LDEzLjloMi40bC0zLjgsNy4xbC0zLjgtNy4xaDIuNUM5LjcsMTMuNCwxNyw2LDI1LjksNicvJTNFJTNDL2clM0UlM0Mvc3ZnJTNFXFxcIikgbm8tcmVwZWF0XCJcblxuY29uc3QgYWRkU3ZnID0gXCJ1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgNDggNDgnJTNFJTNDcG9seWdvbiBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBwb2ludHM9JzMxLjIsMjggMjQuOCwyOCAyNC44LDMyLjggMjAsMzIuOCAyMCwzOS4yIDI0LjgsMzkuMiAyNC44LDQ0IDMxLjIsNDQgMzEuMiwzOS4yIDM2LDM5LjIgMzYsMzIuOCAzMS4yLDMyLjggJy8lM0UgJTNDcG9seWdvbiBzdHlsZT0nZmlsbDolMjNmZmZmZmYnIHBvaW50cz0nMTIsMzIgMTIsNCAzMi4zLDI0LjMgMjAsMjQuMyAxOS43LDI0LjYgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMTMuOCw4LjIgMTMuOCwyNy44IDE5LDIyLjggMTkuMiwyMi41IDI4LDIyLjUgJy8lM0UlM0Nwb2x5bGluZSBwb2ludHM9JzI5LjYsMjkuNiAyOS42LDM0LjQgMzQuNCwzNC40IDM0LjQsMzcuNiAyOS42LDM3LjYgMjkuNiw0Mi40IDI2LjQsNDIuNCAyNi40LDM3LjYgMjEuNiwzNy42IDIxLjYsMzQuNCAyNi40LDM0LjQgMjYuNCwyOS42IDI5LjYsMjkuNiAgJy8lM0UlM0Mvc3ZnJTNFXFxcIikgbm8tcmVwZWF0XCJcblxuY29uc3QgcmVtb3ZlU3ZnID0gXCJ1cmwoXFxcImRhdGE6aW1hZ2Uvc3ZnK3htbCwlM0NzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgNDggNDgnJTNFJTNDcmVjdCBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyB4PScyMCcgeT0nMzIuOCcgd2lkdGg9JzE2JyBoZWlnaHQ9JzYuNCcvJTNFJTNDcG9seWdvbiAgc3R5bGU9J2ZpbGw6JTIzZmZmZmZmOycgcG9pbnRzPScxMiwzMiAxMiw0IDMyLjMsMjQuMyAyMCwyNC4zIDE5LjcsMjQuNiAnLyUzRSUzQ3BvbHlnb24gcG9pbnRzPScxMy44LDguMiAxMy44LDI3LjggMTksMjIuOCAxOS4yLDIyLjUgMjgsMjIuNSAnLyUzRSUzQ3BvbHlsaW5lIHBvaW50cz0nMzQuNCwzNC40IDM0LjQsMzcuNiAyMS42LDM3LjYgMjEuNiwzNC40ICcvJTNFJTNDL3N2ZyUzRVxcXCIpIG5vLXJlcGVhdFwiXG5cbmNvbnN0IHJlcG9zaXRpb25TdmcgPSBcInVybChcXFwiZGF0YTppbWFnZS9zdmcreG1sLCUzQ3N2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0OCA0OCclM0UlM0NwYXRoIHN0eWxlPSdmaWxsOiUyM2ZmZmZmZjsnIGQ9J00yNCwxNy41Yy0zLjYsMC02LjUsMi45LTYuNSw2LjVzMi45LDYuNSw2LjUsNi41czYuNS0yLjksNi41LTYuNVMyNy42LDE3LjUsMjQsMTcuNUwyNCwxNy41eicvJTNFJTNDcGF0aCBzdHlsZT0nZmlsbDolMjNmZmZmZmY7JyBkPSdNMjQsNEw0LDI0bDIwLDIwbDIwLTIwTDI0LDR6IE0zMS41LDMxLjVoLTE1di0xNWgxNVYzMS41eicvJTNFJTNDcG9seWdvbiBwb2ludHM9JzE3LDM0IDI0LDQwLjUgMzEsMzQgICcvJTNFJTNDcG9seWdvbiBwb2ludHM9JzMxLDE0IDI0LDcuNSAxNywxNCAgICAgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMTQsMTcgNy41LDI0IDE0LDMxICAgJy8lM0UlM0Nwb2x5Z29uIHBvaW50cz0nMzQsMzEgNDAuNSwyNCAzNCwxNyAgICAnLyUzRSUzQ3BhdGggZD0nTTI0LDIwYzIuMiwwLDQsMS44LDQsNHMtMS44LDQtNCw0cy00LTEuOC00LTRTMjEuOCwyMCwyNCwyMCcvJTNFJTNDL3N2ZyUzRVxcXCIpIG5vLXJlcGVhdFwiXG5cbmNvbnN0IEV2ZW50Q29uc3RhbnRzID0ge1xuICBTRUxFQ1RJT05fQ0hBTkdFRDogXCJkcmF3OnNlbGVjdGlvbkNoYW5nZWRcIixcbiAgRFJBR19CRUdJTjogXCJkcmF3OmRyYWc6YmVnaW5cIixcbiAgRFJBR19FTkQ6IFwiZHJhdzpkcmFnOmVuZFwiXG59XG5cbmNvbnN0IHRtcFB0MSA9IFBvaW50MmQuY3JlYXRlKDAsIDApXG5jb25zdCB0bXBQdDIgPSBQb2ludDJkLmNyZWF0ZSgwLCAwKVxuXG5jb25zdCBib3VuZHNTdHJva2VTdHlsZSA9IG5ldyBTdHJva2VTdHlsZSh7XG4gIHN0cm9rZUNvbG9yOiBcImRhcmtncmF5XCIsXG4gIHN0cm9rZVdpZHRoOiAyXG59KVxuXG5jb25zdCBkZWZhdWx0WGZvcm1TdHlsZSA9IHtcbiAgZmlsbENvbG9yOiBcIndoaXRlXCIsXG4gIHN0cm9rZUNvbG9yOiBcImJsYWNrXCIsXG4gIHN0cm9rZVdpZHRoOiAyXG59XG5cbmZ1bmN0aW9uIGluQ2FudmFzKGNhbnZhcywgeCwgeSkge1xuICBjb25zdCBkb21yZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gIGxldCBsb2NhbFggPSAwXG4gIGxldCBsb2NhbFkgPSAwXG4gIHJldHVybiAoKGxvY2FsWCA9IHggLSBkb21yZWN0LmxlZnQgLSBjYW52YXMuY2xpZW50TGVmdCkgPj0gMCAmJiBsb2NhbFggPD0gY2FudmFzLmNsaWVudFdpZHRoICYmIChsb2NhbFkgPSB5IC0gZG9tcmVjdC50b3AgLSBjYW52YXMuY2xpZW50VG9wKSA+PSAwICYmIGxvY2FsWSA8PSBjYW52YXMuY2xpZW50SGVpZ2h0KVxufVxuXG5mdW5jdGlvbiBnZXRMb2NhbE1vdXNlUG9zKG91dCwgZWxlbSwgZXZlbnQpIHtcbiAgY29uc3QgZG9tcmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgb3V0WzBdID0gZXZlbnQuY2xpZW50WCAtIGRvbXJlY3QubGVmdCAtIGVsZW0uY2xpZW50TGVmdFxuICBvdXRbMV0gPSBldmVudC5jbGllbnRZIC0gZG9tcmVjdC50b3AgLSBlbGVtLmNsaWVudFRvcFxufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TZWxlY3RlZFNoYXBlKGNhbnZhcywgZXZlbnQsIHNlbGVjdGVkSW5mbywgY2FtZXJhKSB7XG4gIGdldExvY2FsTW91c2VQb3ModG1wUHQxLCBjYW52YXMsIGV2ZW50KVxuICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCBjYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgY29uc3Qgc2hhcGUgPSBzZWxlY3RlZEluZm8uc2hhcGVcbiAgaWYgKHNoYXBlIGluc3RhbmNlb2YgWGZvcm1TaGFwZSkge1xuICAgIEludGVyYWN0VXRpbHMudHJhbnNmb3JtWGZvcm1TaGFwZShzaGFwZSwgc2VsZWN0ZWRJbmZvLCB0bXBQdDEsIHRtcFB0MiwgY2FtZXJhKVxuICB9IGVsc2UgaWYgKHNoYXBlIGluc3RhbmNlb2YgVmVydEVkaXRhYmxlU2hhcGUpIHtcbiAgICBJbnRlcmFjdFV0aWxzLnRyYW5zbGF0ZVZlcnQoc2hhcGUsIHNlbGVjdGVkSW5mbywgdG1wUHQxLCB0bXBQdDIsIGNhbWVyYSlcbiAgfSBlbHNlIHtcbiAgICBJbnRlcmFjdFV0aWxzLnRyYW5zbGF0ZVNoYXBlKHNoYXBlLCBzZWxlY3RlZEluZm8sIHRtcFB0MSwgdG1wUHQyLCBjYW1lcmEpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRLZXlzVG9TZWxlY3RlZEluZm8oZXZlbnQsIHNlbGVjdGVkSW5mbykge1xuICBzZWxlY3RlZEluZm8ua2V5cyA9IHtcbiAgICBhbHRLZXk6IGV2ZW50LmFsdEtleSxcbiAgICBjdHJsS2V5OiBldmVudC5jdHJsS2V5LFxuICAgIHNoaWZ0S2V5OiBldmVudC5zaGlmdEtleSxcbiAgICBtZXRhS2V5OiBldmVudC5tZXRhS2V5XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcChzZWxlY3Rpb25NYXApIHtcbiAgY29uc3Qgc2VsZWN0ZWRPYmpzID0gW11cbiAgc2VsZWN0aW9uTWFwLmZvckVhY2goKHN1YnNoYXBlLCBzaGFwZSkgPT4ge1xuICAgIHNlbGVjdGVkT2Jqcy5wdXNoKHNoYXBlKVxuICB9KVxuICByZXR1cm4gc2VsZWN0ZWRPYmpzXG59XG5cbmZ1bmN0aW9uIHNlbGVjdFNoYXBlKHNlbGVjdGVkU2hhcGUsIHNvcnRlZFNoYXBlcywgY3VyclNlbGVjdGVkU2hhcGVzLCBzZWxlY3RTdHlsZSwgeGZvcm1TdHlsZSwgc2VsZWN0T3B0cykge1xuICBjb25zdCBmaXJlT2JqZWN0ID0ge1xuICAgIHVuc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAoY3VyclNlbGVjdGVkU2hhcGVzKVxuICB9XG4gIGNsZWFyU2VsZWN0ZWRTaGFwZXMoY3VyclNlbGVjdGVkU2hhcGVzKVxuICBzZWxlY3RlZFNoYXBlLnNhdmUoKVxuICBjb25zdCBtYXhaID0gc29ydGVkU2hhcGVzW3NvcnRlZFNoYXBlcy5sZW5ndGggLSAxXS56SW5kZXhcbiAgc2VsZWN0ZWRTaGFwZS56SW5kZXggPSBtYXhaICsgMVxuICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHNlbGVjdFN0eWxlLCBzZWxlY3RlZFNoYXBlKVxuICBzZWxlY3RlZFNoYXBlLnNlbGVjdGVkID0gdHJ1ZVxuICAgIC8vIGNvbnN0IGRpbWVuc2lvbnMgPSBzZWxlY3RlZFNoYXBlLmdldERpbWVuc2lvbnMoKVxuXG4gIGxldCBuZXdTZWxlY3RTaGFwZSA9IG51bGxcbiAgaWYgKHNlbGVjdE9wdHMuc2NhbGFibGUgfHwgc2VsZWN0T3B0cy5yb3RhdGFibGUpIHtcbiAgICBuZXdTZWxlY3RTaGFwZSA9IG5ldyBYZm9ybVNoYXBlKHhmb3JtU3R5bGUgfHwgZGVmYXVsdFhmb3JtU3R5bGUsIHNlbGVjdE9wdHMpXG4gICAgc2VsZWN0ZWRTaGFwZS5hZGRDaGlsZFhmb3JtKG5ld1NlbGVjdFNoYXBlKVxuICB9XG4gIGN1cnJTZWxlY3RlZFNoYXBlcy5zZXQoc2VsZWN0ZWRTaGFwZSwgbmV3U2VsZWN0U2hhcGUpXG5cbiAgZmlyZU9iamVjdC5zZWxlY3RlZFNoYXBlcyA9IFtzZWxlY3RlZFNoYXBlXVxuICByZXR1cm4gZmlyZU9iamVjdFxufVxuXG5mdW5jdGlvbiBjbGVhclNlbGVjdGVkU2hhcGVzKHNlbGVjdGVkU2hhcGVNYXApIHtcbiAgc2VsZWN0ZWRTaGFwZU1hcC5mb3JFYWNoKChzZWxlY3RlZFNoYXBlLCBzaGFwZSkgPT4ge1xuICAgIHNoYXBlLnJlc3RvcmUoKVxuICAgIHNoYXBlLnNlbGVjdGVkID0gZmFsc2VcbiAgICBzaGFwZS5yZW1vdmVDaGlsZFhmb3JtKHNlbGVjdGVkU2hhcGUpXG4gIH0pXG4gIHNlbGVjdGVkU2hhcGVNYXAuY2xlYXIoKVxufVxuXG5mdW5jdGlvbiBjbGVhclNwZWNpZmljU2hhcGVzKHNlbGVjdGVkU2hhcGVNYXAsIHNoYXBlcykge1xuICBjb25zdCBjbGVhcmVkU2hhcGVzID0gW11cbiAgc2hhcGVzLmZvckVhY2goc2hhcGUgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGVkU2hhcGUgPSBzZWxlY3RlZFNoYXBlTWFwLmdldChzaGFwZSlcbiAgICBzaGFwZS5yZXN0b3JlKClcbiAgICBzaGFwZS5zZWxlY3RlZCA9IGZhbHNlXG4gICAgc2hhcGUucmVtb3ZlQ2hpbGRYZm9ybShzZWxlY3RlZFNoYXBlKVxuICAgIHNlbGVjdGVkU2hhcGVNYXAuZGVsZXRlKHNoYXBlKVxuICAgIGNsZWFyZWRTaGFwZXMucHVzaChzaGFwZSlcbiAgfSlcbiAgcmV0dXJuIGNsZWFyZWRTaGFwZXNcbn1cblxuY29uc3QgaGlkZUN1cnNvciA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnNvcicpXG4gIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICBjdXJzb3Iuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICB9XG59XG5cbmNvbnN0IHNob3dDdXJzb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJzb3InKVxuICBpZiAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgY3Vyc29yLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gIH1cbn1cblxuY29uc3QgaGlkZUN1cnNvcldpdGhQb2ludGVyID0gKGUpID0+IHtcbiAgZS50YXJnZXQucGFyZW50Tm9kZS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCdcbiAgaGlkZUN1cnNvcigpXG59XG5cbmNvbnN0IHNob3dDdXJzb3JXaXRoUG9pbnRlciA9IChlKSA9PiB7XG4gIGUudGFyZ2V0LnBhcmVudE5vZGUuc3R5bGUuY3Vyc29yID0gJ25vbmUnXG4gIHNob3dDdXJzb3IoKVxufVxuXG4vLyB1bmRlcnN0YW5kcyBob3cgdG8gcmV0dXJuIG1vdXNlIGNvb3JkaW5hdGVzIGFzIGFuIG9iamVjdCBpbiB0aGUgZm9ybWF0IHt4OiA8WC1DT09SRD4sIHk6IDxZLUNPT1JEPn1cbi8vIGFjY2VwdHMgYSBtb3VzZSBldmVudCBhbmQgYSBET00gZWxlbWVudCBhcyBhcmd1bWVudHNcbmZ1bmN0aW9uIGdldE1vdXNlQ29vcmRpbmF0ZXMoZSwgdGFyZ2V0KSB7XG4gIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCR7JyMnICsgdGFyZ2V0LmlkICsgICcgY2FudmFzJ31gKVxuXG4gIGNvbnN0IGNvb3JkcyA9IHtcbiAgICAneCc6IGUub2Zmc2V0WCArIGNhbnZhcy5vZmZzZXRMZWZ0LFxuICAgICd5JzogZS5vZmZzZXRZICsgY2FudmFzLm9mZnNldFRvcFxuICB9XG5cbiAgcmV0dXJuIGNvb3Jkc1xufVxuXG4vLyB1bmRlcnN0YW5kcyBob3cgdG8gYXBwZW5kIGN1c3RvbSBjdXJzb3JzIHRvIHRoZSBET01cbi8vIGFjY2VwdHMgYSBtb3VzZSBldmVudCwgYSBET00gZWxlbWVudCwgYSBjdXJzb3JTdHlsZSwgYW5kIHBpeGVsIG9mZnNldHMgYXMgYXJndW1lbnRzXG5mdW5jdGlvbiBhcHBlbmRDdXN0b21DdXJzb3IoX2V2ZW50LCB0YXJnZXQsIGN1cnNvclN0eWxlLCBvZmZzZXRYID0gLTE0LCBvZmZzZXRZID0gLTE0KSB7XG4gIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJzb3InKVxuICBjb25zdCBtb3VzZSA9IGdldE1vdXNlQ29vcmRpbmF0ZXMoX2V2ZW50LCB0YXJnZXQpXG5cbiAgaWYgKGN1cnNvciA9PT0gbnVsbCkge1xuICAgIGNvbnN0IG5ld0N1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICAgIG5ld0N1cnNvci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2N1cnNvcicpXG4gICAgbmV3Q3Vyc29yLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgcG9zaXRpb246IGFic29sdXRlOyB0b3A6ICR7bW91c2UueSArICdweCd9OyBsZWZ0OiAke21vdXNlLnggKyAncHgnfTsgd2lkdGg6IDI4cHg7IGhlaWdodDogMjhweDsgYmFja2dyb3VuZDogJHtjdXJzb3JTdHlsZX07IGN1cnNvcjogbm9uZTsgei1pbmRleDogMTA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgke29mZnNldFh9cHgsICR7b2Zmc2V0WX1weClgKVxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChuZXdDdXJzb3IpXG4gIH0gZWxzZSBpZiAoY3Vyc29yLnN0eWxlLmJhY2tncm91bmQgIT09IGN1cnNvclN0eWxlKSB7XG4gICAgY3Vyc29yLnN0eWxlLmJhY2tncm91bmQgPSBjdXJzb3JTdHlsZVxuICAgIHVwZGF0ZUN1cnNvclBvc2l0aW9uKF9ldmVudCwgdGFyZ2V0KVxuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUN1cnNvclBvc2l0aW9uKF9ldmVudCwgdGFyZ2V0KVxuICB9XG59XG5cbi8vIHVuZGVyc3RhbmRzIGhvdyB0byByZW1vdmUgdGhlIGN1c3RvbSBjdXJzb3IgZnJvbSB0aGUgRE9NXG5mdW5jdGlvbiByZW1vdmVDdXN0b21DdXJzb3IoKSB7XG4gIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJzb3InKVxuICBpZiAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgY3Vyc29yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY3Vyc29yKVxuICB9XG59XG5cbi8vIHVuZGVyc3RhbmRzIGhvdyB0byBjaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXN0b20gY3Vyc29yIG9uIHRoZSBwYWdlXG4vLyBhY2NlcHRzIGEgbW91c2UgZXZlbnQgYW5kIGEgRE9NIGVsZW1lbnQgYXMgYXJndW1lbnRzXG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JQb3NpdGlvbihfZXZlbnQsIHRhcmdldCkge1xuICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3Vyc29yJylcbiAgY29uc3QgbW91c2UgPSBnZXRNb3VzZUNvb3JkaW5hdGVzKF9ldmVudCwgdGFyZ2V0KVxuXG4gIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICBjdXJzb3Iuc3R5bGUudG9wID0gYCR7bW91c2UueSArICdweCd9YFxuICAgIGN1cnNvci5zdHlsZS5sZWZ0ID0gYCR7bW91c2UueCArICdweCd9YFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNoYXBlQnVpbGRlciBleHRlbmRzIERyYXdFbmdpbmUge1xuICBjb25zdHJ1Y3RvcihwYXJlbnQsIG9wdHMpIHtcbiAgICBzdXBlcihwYXJlbnQsIG9wdHMpXG4gIH1cblxuICBfbW91c2Vkb3duQ0IoZXZlbnQpIHtcbiAgICBpZiAoIWluQ2FudmFzKHRoaXMuX2RyYXdDYW52YXMsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnRpbWVyID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCB0aGlzLl9jYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIGxldCBpID0gLTFcbiAgICBsZXQgc2VsZWN0ZWRTaGFwZSA9IG51bGxcbiAgICBsZXQgc2VsZWN0ZWRJbmZvID0gbnVsbFxuICAgIGZvciAoaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGVzW2ldKVxuICAgICAgaWYgKHNoYXBlc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZFNoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgc2VsZWN0ZWRJbmZvID0gc2hhcGVJbmZvXG4gICAgICAgIGxldCBoaXRJbmZvID0gbnVsbFxuICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSAmJiAoaGl0SW5mbyA9IHNlbGVjdGVkU2hhcGUuY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpLmhpdCkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZFNoYXBlIGluc3RhbmNlb2YgVmVydEVkaXRhYmxlU2hhcGUgJiYgZXZlbnQuYWx0S2V5ICYmIGhpdEluZm8uY29udHJvbEluZGV4IDwgc2hhcGVzW2ldLm51bVZlcnRzKSB7XG4gICAgICAgICAgICBzaGFwZXNbaV0ucmVtb3ZlVmVydChoaXRJbmZvLmNvbnRyb2xJbmRleClcbiAgICAgICAgICAgIHNlbGVjdGVkU2hhcGUgPSBudWxsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsWGZvcm0gPSBzZWxlY3RlZFNoYXBlLnBhcmVudC5sb2NhbFhmb3JtXG4gICAgICAgICAgICBjb25zdCBpbnZMb2NhbFhmb3JtID0gTWF0MmQuY2xvbmUobG9jYWxYZm9ybSlcbiAgICAgICAgICAgIE1hdDJkLmludmVydChpbnZMb2NhbFhmb3JtLCBpbnZMb2NhbFhmb3JtKVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRPYmpQb3MgPSBQb2ludDJkLmNsb25lKHRtcFB0MilcbiAgICAgICAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQoc3RhcnRPYmpQb3MsIHN0YXJ0T2JqUG9zLCBpbnZMb2NhbFhmb3JtKVxuICAgICAgICAgICAgdGhpcy5fZHJhZ0luZm8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgcm90YXRlOiBCb29sZWFuKGhpdEluZm8ucm90YXRlKSxcbiAgICAgICAgICAgICAgY29udHJvbEluZGV4OiBoaXRJbmZvLmNvbnRyb2xJbmRleCxcbiAgICAgICAgICAgICAgc3RhcnRPYmplY3RQb3M6IHN0YXJ0T2JqUG9zLFxuICAgICAgICAgICAgICB3b3JsZFRvT2JqZWN0TWF0cml4OiBpbnZMb2NhbFhmb3JtLFxuICAgICAgICAgICAgICBzdGFydExvY2FsUG9zOiBzZWxlY3RlZFNoYXBlLnBhcmVudC5nZXRQb3NpdGlvbigpLFxuICAgICAgICAgICAgICBzdGFydExvY2FsU2NhbGU6IHNlbGVjdGVkU2hhcGUucGFyZW50LmdldFNjYWxlKCksXG4gICAgICAgICAgICAgIHN0YXJ0TG9jYWxSb3Q6IHNlbGVjdGVkU2hhcGUucGFyZW50LmdldFJvdGF0aW9uKCksXG4gICAgICAgICAgICAgIHNoYXBlV2lkdGg6IHNlbGVjdGVkU2hhcGUucGFyZW50LndpZHRoLFxuICAgICAgICAgICAgICBzaGFwZUhlaWdodDogc2VsZWN0ZWRTaGFwZS5wYXJlbnQuaGVpZ2h0XG4gICAgICAgICAgICB9LCBzZWxlY3RlZEluZm8pXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLmNvbnRhaW5zUG9pbnQodG1wUHQxLCB0bXBQdDIsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHRoaXMuX2RyYXdDdHgpKSB7XG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZSA9IHNoYXBlc1tpXVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgaWYgKHNoYXBlSW5mby5zZWxlY3RhYmxlICYmIHNoYXBlc1tpXS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkge1xuICAgICAgLy8gICBzZWxlY3RlZFNoYXBlID0gc2hhcGVzW2ldXG4gICAgICAvLyAgIHNlbGVjdGVkSW5mbyA9IHNoYXBlSW5mb1xuICAgICAgLy8gICBjb25zdCBzZWxlY3RFdmVudE9iaiA9IHNlbGVjdFNoYXBlKHNlbGVjdGVkU2hhcGUsIHNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzZWxlY3RlZEluZm8pXG4gICAgICAvLyAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwgc2VsZWN0RXZlbnRPYmopXG4gICAgICAvLyAgIGJyZWFrXG4gICAgICAvLyB9XG4gICAgfVxuXG4gICAgaWYgKGkgPCAwICYmIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNpemUpIHtcbiAgICAgIGlmICh0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgICAgIHVuc2VsZWN0ZWRTaGFwZXM6IGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpLFxuICAgICAgICAgIHNlbGVjdGVkU2hhcGVzOiBbXVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ0luZm8gPSBudWxsXG4gICAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0ZWRTaGFwZSAmJiBzZWxlY3RlZEluZm8gJiYgKHNlbGVjdGVkSW5mby5tb3ZhYmxlIHx8IHNlbGVjdGVkSW5mby5yb3RhdGFibGUgfHwgc2VsZWN0ZWRJbmZvLnNjYWxhYmxlKSkge1xuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgJHsnIycgKyB0aGlzLl9wYXJlbnQuaWQgKyAgJyA+IGNhbnZhcyd9YClcbiAgICAgIGlmKCBjYW52YXMgIT09IG51bGwpIHtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgaGlkZUN1cnNvcldpdGhQb2ludGVyKVxuICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgc2hvd0N1cnNvcldpdGhQb2ludGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgaGlkZUN1cnNvcilcbiAgICAgICAgdGhpcy5fcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHNob3dDdXJzb3IpXG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2RyYWdJbmZvICYmIHNlbGVjdGVkSW5mby5tb3ZhYmxlKSB7XG4gICAgICAgIHRoaXMuX2RyYWdJbmZvID0ge1xuICAgICAgICAgIHN0YXJ0TG9jYWxQb3M6IHNlbGVjdGVkU2hhcGUuZ2V0UG9zaXRpb24oKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9kcmFnSW5mbykge1xuICAgICAgICB0aGlzLl9kcmFnSW5mby5zaGFwZSA9IHNlbGVjdGVkU2hhcGVcbiAgICAgICAgdGhpcy5fZHJhZ0luZm8uc3RhcnRQb3MgPSBQb2ludDJkLmNsb25lKHRtcFB0MSlcbiAgICAgICAgdGhpcy5fZHJhZ0luZm8uc3RhcnRXb3JsZFBvcyA9IFBvaW50MmQuY2xvbmUodG1wUHQyKVxuICAgICAgICB0aGlzLl9kcmFnSW5mby5vYmplY3RUb1dvcmxkTWF0cml4ID0gTWF0MmQuY2xvbmUoc2VsZWN0ZWRTaGFwZS5nbG9iYWxYZm9ybSlcbiAgICAgICAgYWRkRXZlbnRLZXlzVG9TZWxlY3RlZEluZm8oZXZlbnQsIHRoaXMuX2RyYWdJbmZvKVxuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuRFJBR19CRUdJTiwge1xuICAgICAgICAgIHNoYXBlczogZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgX21vdXNldXBDQihldmVudCkge1xuICAgIGlmICh0aGlzLl9kcmFnSW5mbyAmJiB0aGlzLl9kcmFnSW5mby5zaGFwZSkge1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYCR7JyMnICsgdGhpcy5fcGFyZW50LmlkICsgICcgPiBjYW52YXMnfWApXG4gICAgICBpZiggY2FudmFzICE9PSBudWxsKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGhpZGVDdXJzb3JXaXRoUG9pbnRlcilcbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHNob3dDdXJzb3JXaXRoUG9pbnRlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIGhpZGVDdXJzb3IpXG4gICAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBzaG93Q3Vyc29yKVxuICAgICAgfVxuICAgICAgdGhpcy5fZHJhZ0luZm8gPSBudWxsXG4gICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuRFJBR19FTkQsIHtcbiAgICAgICAgc2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy50aW1lciA8IDUwMCkge1xuICAgICAgLy8gdGhpcyBpcyBhIHJlbGF0aXZlbHkgcXVpY2sgY2xpY2tcbiAgICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodG1wUHQyLCB0bXBQdDEsIHRoaXMuX2NhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4KVxuICAgICAgY29uc3Qgd29ybGRUb1NjcmVlbk1hdHJpeCA9IHRoaXMuX2NhbWVyYS53b3JsZFRvU2NyZWVuTWF0cml4XG4gICAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgICAgbGV0IHNlbGVjdGVkU2hhcGUgPSBudWxsXG4gICAgICBsZXQgc2VsZWN0ZWRJbmZvID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzZWxlY3RlZEluZm8gPSB0aGlzLl9vYmplY3RzLmdldChzaGFwZXNbaV0pXG4gICAgICAgIGlmIChzZWxlY3RlZEluZm8uc2VsZWN0YWJsZSAmJiBzaGFwZXNbaV0uY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpIHtcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlID0gc2hhcGVzW2ldXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkU2hhcGUgJiYgIXNlbGVjdGVkU2hhcGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0RXZlbnRPYmogPSBzZWxlY3RTaGFwZShzZWxlY3RlZFNoYXBlLCBzaGFwZXMsIHRoaXMuX3NlbGVjdGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RTdHlsZSwgdGhpcy5feGZvcm1TdHlsZSwgc2VsZWN0ZWRJbmZvKVxuICAgICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuU0VMRUNUSU9OX0NIQU5HRUQsIHNlbGVjdEV2ZW50T2JqKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9tb3VzZW1vdmVDQihldmVudCkge1xuICAgIGxldCBpbmNhbnZhcyA9IGZhbHNlXG4gICAgaWYgKCEoaW5jYW52YXMgPSBpbkNhbnZhcyh0aGlzLl9kcmF3Q2FudmFzLCBldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKSkgJiYgIXRoaXMuX2RyYWdJbmZvKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZHJhZ0luZm8gJiYgdGhpcy5fZHJhZ0luZm8uc2hhcGUpIHtcbiAgICAgIHVwZGF0ZUN1cnNvclBvc2l0aW9uKGV2ZW50LCB0aGlzLl9wYXJlbnQpXG4gICAgICBhZGRFdmVudEtleXNUb1NlbGVjdGVkSW5mbyhldmVudCwgdGhpcy5fZHJhZ0luZm8pXG4gICAgICB0cmFuc2Zvcm1TZWxlY3RlZFNoYXBlKHRoaXMuX2RyYXdDYW52YXMsIGV2ZW50LCB0aGlzLl9kcmFnSW5mbywgdGhpcy5fY2FtZXJhKVxuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9IGVsc2UgaWYgKCFldmVudC5idXR0b25zICYmIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNpemUpIHtcbiAgICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQodG1wUHQyLCB0bXBQdDEsIHRoaXMuX2NhbWVyYS5zY3JlZW5Ub1dvcmxkTWF0cml4KVxuICAgICAgY29uc3Qgd29ybGRUb1NjcmVlbk1hdHJpeCA9IHRoaXMuX2NhbWVyYS53b3JsZFRvU2NyZWVuTWF0cml4XG4gICAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgICAgbGV0IGkgPSAwXG4gICAgICBjb25zdCBmbGlweSA9IHRoaXMuX2NhbWVyYS5pc1lGbGlwcGVkKClcbiAgICAgIGZvciAoaSA9IHNoYXBlcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBpZiAoc2hhcGVzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0SW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgICBjb25zdCBzZWxlY3RlZFNoYXBlID0gdGhpcy5fc2VsZWN0ZWRTaGFwZXMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgICAgICBsZXQgaGl0SW5mbyA9IG51bGxcbiAgICAgICAgICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3Vyc29yJylcbiAgICAgICAgICB0aGlzLl9wYXJlbnQuc3R5bGUuY3Vyc29yID0gJ25vbmUnXG4gICAgICAgICAgLy8gZm9yRWFjaCBub3Qgc3VwcG9ydGVkIG9uIG5vZGVsaXN0IGluIElFL0VkZ2VcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tpXS5zdHlsZS5jdXJzb3IgPSAnbm9uZSdcbiAgICAgICAgICAgIGlmKHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tpXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzZWxlY3RlZFNoYXBlICYmIChoaXRJbmZvID0gc2VsZWN0ZWRTaGFwZS5jb250YWluc1BvaW50KHRtcFB0MSwgdG1wUHQyLCB3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl9kcmF3Q3R4KSkuaGl0KSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRTaGFwZSBpbnN0YW5jZW9mIFhmb3JtU2hhcGUpIHtcbiAgICAgICAgICAgICAgaWYgKGhpdEluZm8ucm90YXRlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRlZ3JlZXMgPSBzaGFwZXNbaV0uZ2V0Um90YXRpb24oKVxuICAgICAgICAgICAgICAgIGlmIChmbGlweSkge1xuICAgICAgICAgICAgICAgICAgZGVncmVlcyAqPSAtMVxuICAgICAgICAgICAgICAgICAgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZ3JlZXMgLT0gOTBcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVncmVlcyArPSAxODBcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVncmVlcyArPSA5MFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVncmVlcyAtPSA5MFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWdyZWVzICs9IDE4MFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBkZWdyZWVzICs9IDkwXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBgJHtyb3RhdGVTdmcucmVwbGFjZSgvXFw8ZGVncmVlc1xcPi9nLCBgJHtkZWdyZWVzfWApfWApXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPCA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpdEluZm8uY29udHJvbEluZGV4ID09PSAwIHx8IGhpdEluZm8uY29udHJvbEluZGV4ID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYCR7c2NhbGVTdmcucmVwbGFjZSgvXFw8ZGVncmVlc1xcPi9nLCBgJHstc2hhcGVzW2ldLmdldFJvdGF0aW9uKCkgLSA0NX1gKX1gKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPT09IDEgfHwgaGl0SW5mby5jb250cm9sSW5kZXggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBgJHtzY2FsZVN2Zy5yZXBsYWNlKC9cXDxkZWdyZWVzXFw+L2csIGAkey1zaGFwZXNbaV0uZ2V0Um90YXRpb24oKSArIDQ1fWApfWApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChoaXRJbmZvLmNvbnRyb2xJbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCBgJHtzY2FsZVN2Zy5yZXBsYWNlKC9cXDxkZWdyZWVzXFw+L2csIGAkey1zaGFwZXNbaV0uZ2V0Um90YXRpb24oKX1gKX1gKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgYCR7c2NhbGVTdmcucmVwbGFjZSgvXFw8ZGVncmVlc1xcPi9nLCBgJHstc2hhcGVzW2ldLmdldFJvdGF0aW9uKCkgKyA5MH1gKX1gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3RlZFNoYXBlIGluc3RhbmNlb2YgVmVydEVkaXRhYmxlU2hhcGUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9ICdub25lJ1xuICAgICAgICAgICAgICAvLyBmb3JFYWNoIG5vdCBzdXBwb3J0ZWQgb24gbm9kZWxpc3QgaW4gSUUvRWRnZVxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbaV0uc3R5bGUuY3Vyc29yID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbaV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2NhbnZhcycpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2ldLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaGl0SW5mby5jb250cm9sSW5kZXggPj0gc2hhcGVzW2ldLm51bVZlcnRzKSB7XG4gICAgICAgICAgICAgICAgYXBwZW5kQ3VzdG9tQ3Vyc29yKGV2ZW50LCB0aGlzLl9wYXJlbnQsIGFkZFN2ZywgLTgsIC02KVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgIGFwcGVuZEN1c3RvbUN1cnNvcihldmVudCwgdGhpcy5fcGFyZW50LCByZW1vdmVTdmcsIC04LCAtNilcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRDdXN0b21DdXJzb3IoZXZlbnQsIHRoaXMuX3BhcmVudCwgcmVwb3NpdGlvblN2ZywgLTE0LCAtMTQpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLmNvbnRhaW5zUG9pbnQodG1wUHQxLCB0bXBQdDIsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHRoaXMuX2RyYXdDdHgpKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0SW5mbyAmJiBzZWxlY3RJbmZvLm1vdmFibGUpIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N1cnNvcicpXG4gICAgICAgICAgICAgIGlmIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJzb3IpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwibW92ZVwiXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tpXS5zdHlsZS5jdXJzb3IgPSAnbW92ZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgcmVtb3ZlQ3VzdG9tQ3Vyc29yKClcbiAgICAgICAgdGhpcy5fcGFyZW50LnN0eWxlLmN1cnNvciA9IFwiZGVmYXVsdFwiXG4gICAgICAgIC8vIGZvckVhY2ggbm90IHN1cHBvcnRlZCBvbiBub2RlbGlzdCBpbiBJRS9FZGdlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tpXS5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCdcbiAgICAgICAgICBpZih0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnY2FudmFzJykge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbaV0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NsaWNrQ0IoZXZlbnQpIHtcbiAgICAvLyBub29wXG4gIH1cblxuICBfZGJsY2xpY2tDQihldmVudCkge1xuICAgIGlmICghaW5DYW52YXModGhpcy5fZHJhd0NhbnZhcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIFBvaW50MmQuc2V0KHRtcFB0MSwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSlcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRtcFB0MiwgdG1wUHQxLCB0aGlzLl9jYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0cml4ID0gdGhpcy5fY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICBjb25zdCBzaGFwZXMgPSB0aGlzLnNvcnRlZFNoYXBlc1xuICAgIGxldCBpID0gLTFcbiAgICBmb3IgKGkgPSBzaGFwZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KHNoYXBlc1tpXSlcbiAgICAgIGlmIChzaGFwZUluZm8uc2VsZWN0YWJsZSAmJiBzaGFwZXNbaV0uY29udGFpbnNQb2ludCh0bXBQdDEsIHRtcFB0Miwgd29ybGRUb1NjcmVlbk1hdHJpeCwgdGhpcy5fZHJhd0N0eCkpIHtcbiAgICAgICAgaWYgKHNoYXBlSW5mby5lZGl0YWJsZSAmJiBzaGFwZXNbaV0gaW5zdGFuY2VvZiBQb2x5TGluZSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkU2hhcGUgPSBzaGFwZXNbaV1cbiAgICAgICAgICBsZXQgZG9YZm9ybSA9IGZhbHNlXG4gICAgICAgICAgaWYgKHNoYXBlc1tpXS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJhY3RpdmVTaGFwZSA9IHRoaXMuX3NlbGVjdGVkU2hhcGVzLmdldChzaGFwZXNbaV0pXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3RpdmVTaGFwZSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZFNoYXBlLnJlc3RvcmUoKVxuICAgICAgICAgICAgICBzZWxlY3RlZFNoYXBlLnJlbW92ZUNoaWxkWGZvcm0oaW50ZXJhY3RpdmVTaGFwZSlcbiAgICAgICAgICAgICAgZG9YZm9ybSA9ICEoaW50ZXJhY3RpdmVTaGFwZSBpbnN0YW5jZW9mIFhmb3JtU2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZS5zZWxlY3RlZCA9IHRydWVcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlLnNhdmUoKVxuICAgICAgICAgIGNvbnN0IG1heFogPSBzaGFwZXNbc2hhcGVzLmxlbmd0aCAtIDFdLnpJbmRleFxuICAgICAgICAgIHNlbGVjdGVkU2hhcGUuekluZGV4ID0gbWF4WiArIDFcbiAgICAgICAgICBCYXNpY1N0eWxlLmNvcHlCYXNpY1N0eWxlKHRoaXMuX3NlbGVjdFN0eWxlLCBzZWxlY3RlZFNoYXBlKVxuICAgICAgICAgIGxldCBuZXdTZWxlY3RTaGFwZSA9IG51bGxcbiAgICAgICAgICBpZiAoZG9YZm9ybSkge1xuICAgICAgICAgICAgaWYgKHNoYXBlSW5mby5yb3RhdGFibGUgfHwgc2hhcGVJbmZvLnNjYWxhYmxlKSB7XG4gICAgICAgICAgICAgIG5ld1NlbGVjdFNoYXBlID0gbmV3IFhmb3JtU2hhcGUodGhpcy5feGZvcm1TdHlsZSB8fCBkZWZhdWx0WGZvcm1TdHlsZSwgc2hhcGVJbmZvKVxuICAgICAgICAgICAgICBzZWxlY3RlZFNoYXBlLmFkZENoaWxkWGZvcm0obmV3U2VsZWN0U2hhcGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld1NlbGVjdFNoYXBlID0gbmV3IFZlcnRFZGl0YWJsZVNoYXBlKHNlbGVjdGVkU2hhcGUsIHRoaXMuX3hmb3JtU3R5bGUpXG4gICAgICAgICAgICBzZWxlY3RlZFNoYXBlLmFkZENoaWxkWGZvcm0obmV3U2VsZWN0U2hhcGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNldChzZWxlY3RlZFNoYXBlLCBuZXdTZWxlY3RTaGFwZSlcbiAgICAgICAgfSBlbHNlIGlmICghc2hhcGVzW2ldLnNlbGVjdGVkKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0RXZlbnRPYmogPSBzZWxlY3RTaGFwZShzaGFwZXNbaV0sIHNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzaGFwZUluZm8pXG4gICAgICAgICAgdGhpcy5maXJlKEV2ZW50Q29uc3RhbnRzLlNFTEVDVElPTl9DSEFOR0VELCBzZWxlY3RFdmVudE9iailcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIDwgMCAmJiB0aGlzLl9zZWxlY3RlZFNoYXBlcy5zaXplKSB7XG4gICAgICBpZiAodGhpcy5fc2VsZWN0ZWRTaGFwZXMuc2l6ZSkge1xuICAgICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuU0VMRUNUSU9OX0NIQU5HRUQsIHtcbiAgICAgICAgICB1bnNlbGVjdGVkU2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKSxcbiAgICAgICAgICBzZWxlY3RlZFNoYXBlczogW11cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RyYWdJbmZvID0gbnVsbFxuICAgICAgY2xlYXJTZWxlY3RlZFNoYXBlcyh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKClcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgX21vdXNlb3ZlckNCKGV2ZW50KSB7XG4gICAgLy8gbm9vcFxuICB9XG5cbiAgX21vdXNlb3V0Q0IoZXZlbnQpIHtcbiAgICAvLyBub29wXG4gIH1cblxuICBfaW5pdChwYXJlbnQsIG9wdHMpIHtcbiAgICB0aGlzLl9hY3RpdmF0ZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZUludGVyYWN0aW9ucylcbiAgICBzdXBlci5faW5pdChwYXJlbnQsIG9wdHMsIHRoaXMuX2FjdGl2YXRlZClcbiAgICBjb25zdCBteWV2ZW50cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEV2ZW50Q29uc3RhbnRzKS5tYXAoZXZlbnQgPT4ge1xuICAgICAgcmV0dXJuIEV2ZW50Q29uc3RhbnRzW2V2ZW50XVxuICAgIH0pXG4gICAgdGhpcy5yZWdpc3RlckV2ZW50cyhteWV2ZW50cylcbiAgICB0aGlzLl9kcmFnSW5mbyA9IG51bGxcbiAgICB0aGlzLl9zZWxlY3RlZFNoYXBlcyA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX3NlbGVjdFN0eWxlID0gbmV3IEJhc2ljU3R5bGUoKG9wdHMgJiYgb3B0cy5zZWxlY3RTdHlsZSA/IG9wdHMuc2VsZWN0U3R5bGUgOiB7XG4gICAgICBmaWxsQ29sb3I6IFwib3JhbmdlXCJcbiAgICB9KSlcblxuICAgIHRoaXMuX3hmb3JtU3R5bGUgPSBuZXcgQmFzaWNTdHlsZSgob3B0cyAmJiBvcHRzLnhmb3JtU3R5bGUgPyBvcHRzLnhmb3JtU3R5bGUgOiB7XG4gICAgICBmaWxsQ29sb3I6IFwid2hpdGVcIixcbiAgICAgIHN0cm9rZUNvbG9yOiBcImJsYWNrXCIsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0pKVxuXG4gICAgdGhpcy50aW1lciA9IDBcbiAgfVxuXG4gIF9yZW5kZXJTaGFwZXMoY3R4LCBkcmF3U2hhcGVzLCBjYW1lcmEpIHtcbiAgICBjb25zdCB3b3JsZFRvU2NyZWVuTWF0ID0gY2FtZXJhLndvcmxkVG9TY3JlZW5NYXRyaXhcbiAgICBkcmF3U2hhcGVzLmZvckVhY2goc2hhcGUgPT4ge1xuICAgICAgaWYgKHNoYXBlLnZpc2libGUpIHtcbiAgICAgICAgc2hhcGUucmVuZGVyKGN0eCwgd29ybGRUb1NjcmVlbk1hdCwgdGhpcy5fc3R5bGVTdGF0ZSlcbiAgICAgICAgLy8gc2hhcGUucmVuZGVyQm91bmRzKGN0eCwgd29ybGRUb1NjcmVlbk1hdCwgYm91bmRzU3Ryb2tlU3R5bGUpXG4gICAgICAgIGlmIChzaGFwZS5zZWxlY3RlZCkge1xuICAgICAgICAgIGNvbnN0IGludGVyYWNTaGFwZSA9IHRoaXMuX3NlbGVjdGVkU2hhcGVzLmdldChzaGFwZSlcbiAgICAgICAgICBpZiAoaW50ZXJhY1NoYXBlKSB7XG4gICAgICAgICAgICBpbnRlcmFjU2hhcGUucmVuZGVyKGN0eCwgd29ybGRUb1NjcmVlbk1hdCwgdGhpcy5fc3R5bGVTdGF0ZSlcbiAgICAgICAgICAgIC8vIGludGVyYWNTaGFwZS5yZW5kZXJCb3VuZHMoY3R4LCB3b3JsZFRvU2NyZWVuTWF0LCBib3VuZHNTdHJva2VTdHlsZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc2V0IHNlbGVjdFN0eWxlKHNlbGVjdFN0eWxlKSB7XG4gICAgQmFzaWNTdHlsZS5jb3B5QmFzaWNTdHlsZShzZWxlY3RTdHlsZSwgdGhpcy5fc2VsZWN0U3R5bGUpXG4gIH1cblxuICBnZXQgc2VsZWN0U3R5bGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdFN0eWxlXG4gIH1cblxuICBnZXQgc2VsZWN0ZWRTaGFwZXMoKSB7XG4gICAgcmV0dXJuIGdldFNlbGVjdGVkT2Jqc0Zyb21NYXAodGhpcy5fc2VsZWN0ZWRTaGFwZXMpXG4gIH1cblxuICBzZWxlY3RTaGFwZShzaGFwZSkge1xuICAgIGNvbnN0IHNoYXBlSW5mbyA9IHRoaXMuX29iamVjdHMuZ2V0KHNoYXBlKVxuICAgIGlmIChzaGFwZUluZm8gJiYgc2hhcGVJbmZvLnNlbGVjdGFibGUpIHtcbiAgICAgIGNvbnN0IHNlbGVjdEV2ZW50T2JqID0gc2VsZWN0U2hhcGUoc2hhcGUsIHRoaXMuc29ydGVkU2hhcGVzLCB0aGlzLl9zZWxlY3RlZFNoYXBlcywgdGhpcy5fc2VsZWN0U3R5bGUsIHRoaXMuX3hmb3JtU3R5bGUsIHNoYXBlSW5mbylcbiAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwgc2VsZWN0RXZlbnRPYmopXG4gICAgfVxuICB9XG5cbiAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGVkU2hhcGVzLnNpemUpIHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkU2hhcGVzID0gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICAgIGNsZWFyU2VsZWN0ZWRTaGFwZXModGhpcy5fc2VsZWN0ZWRTaGFwZXMpXG4gICAgICB0aGlzLmZpcmUoRXZlbnRDb25zdGFudHMuU0VMRUNUSU9OX0NIQU5HRUQsIHtcbiAgICAgICAgdW5zZWxlY3RlZFNoYXBlczogc2VsZWN0ZWRTaGFwZXMsXG4gICAgICAgIHNlbGVjdGVkU2hhcGVzOiBbXVxuICAgICAgfSlcbiAgICAgIHRoaXMuX3JlcmVuZGVyQ2IoKVxuICAgIH1cbiAgfVxuXG4gIGFkZFNoYXBlKHNoYXBlLCBvcHRzID0gbnVsbCwgc2VsZWN0ID0gZmFsc2UpIHtcbiAgICBsZXQgc2hhcGVzID0gc2hhcGVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuICAgICAgc2hhcGVzID0gW3NoYXBlXVxuICAgIH1cblxuICAgIHN1cGVyLmFkZFNoYXBlKHNoYXBlcylcbiAgICBzaGFwZXMuZm9yRWFjaChzaGFwZSA9PiB7XG4gICAgICBjb25zdCBzaGFwZUluZm8gPSB0aGlzLl9vYmplY3RzLmdldChzaGFwZSlcbiAgICAgIGlmIChzaGFwZUluZm8pIHtcbiAgICAgICAgc2hhcGVJbmZvLnNlbGVjdGFibGUgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy5zZWxlY3RhYmxlICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLnNlbGVjdGFibGUpIDogdHJ1ZSlcbiAgICAgICAgc2hhcGVJbmZvLm1vdmFibGUgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy5tb3ZhYmxlICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLm1vdmFibGUpIDogdHJ1ZSlcbiAgICAgICAgc2hhcGVJbmZvLnJvdGF0YWJsZSA9IChvcHRzICYmIHR5cGVvZiBvcHRzLnJvdGF0YWJsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IEJvb2xlYW4ob3B0cy5yb3RhdGFibGUpIDogdHJ1ZSlcbiAgICAgICAgc2hhcGVJbmZvLnNjYWxhYmxlID0gKG9wdHMgJiYgdHlwZW9mIG9wdHMuc2NhbGFibGUgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMuc2NhbGFibGUpIDogdHJ1ZSlcbiAgICAgICAgc2hhcGVJbmZvLnVuaWZvcm1TY2FsZU9ubHkgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy51bmlmb3JtU2NhbGVPbmx5ICE9PSBcInVuZGVmaW5lZFwiID8gQm9vbGVhbihvcHRzLnVuaWZvcm1TY2FsZU9ubHkpIDogZmFsc2UpXG4gICAgICAgIHNoYXBlSW5mby5jZW50ZXJTY2FsZU9ubHkgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy5jZW50ZXJTY2FsZU9ubHkgIT09IFwidW5kZWZpbmVkXCIgPyBCb29sZWFuKG9wdHMuY2VudGVyU2NhbGVPbmx5KSA6IGZhbHNlKVxuICAgICAgICBzaGFwZUluZm8uZWRpdGFibGUgPSAob3B0cyAmJiB0eXBlb2Ygb3B0cy5lZGl0YWJsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IEJvb2xlYW4ob3B0cy5lZGl0YWJsZSkgOiB0cnVlKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBpZiAoc2VsZWN0KSB7XG4gICAgICBjb25zdCBzZWxlY3RFdmVudE9iaiA9IHtcbiAgICAgICAgdW5zZWxlY3RlZFNoYXBlczogZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGVkU2hhcGVzID0gW11cbiAgICAgIHNoYXBlcy5mb3JFYWNoKHNoYXBlID0+IHtcbiAgICAgICAgY29uc3Qgc2hhcGVJbmZvID0gdGhpcy5fb2JqZWN0cy5nZXQoc2hhcGUpXG4gICAgICAgIGlmIChzaGFwZUluZm8uc2VsZWN0YWJsZSkge1xuICAgICAgICAgIHNlbGVjdFNoYXBlKHNoYXBlLCB0aGlzLnNvcnRlZFNoYXBlcywgdGhpcy5fc2VsZWN0ZWRTaGFwZXMsIHRoaXMuX3NlbGVjdFN0eWxlLCB0aGlzLl94Zm9ybVN0eWxlLCBzaGFwZUluZm8pXG4gICAgICAgICAgc2VsZWN0ZWRTaGFwZXMucHVzaChzaGFwZSlcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKHNlbGVjdGVkU2hhcGVzLmxlbmd0aCkge1xuICAgICAgICBzZWxlY3RFdmVudE9iai5zZWxlY3RlZFNoYXBlcyA9IHNlbGVjdGVkU2hhcGVzXG4gICAgICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwgc2VsZWN0RXZlbnRPYmopXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG5cbiAgZGVsZXRlU2hhcGUoc2hhcGUpIHtcbiAgICBsZXQgc2hhcGVzID0gc2hhcGVcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2hhcGVzKSkge1xuICAgICAgc2hhcGVzID0gW3NoYXBlXVxuICAgIH1cbiAgICBjb25zdCBzZWxlY3RDbGVhcmVkU2hhcGVzID0gY2xlYXJTcGVjaWZpY1NoYXBlcyh0aGlzLl9zZWxlY3RlZFNoYXBlcywgc2hhcGVzKVxuICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgdW5zZWxlY3RlZFNoYXBlczogc2VsZWN0Q2xlYXJlZFNoYXBlcyxcbiAgICAgIHNlbGVjdGVkU2hhcGVzOiBnZXRTZWxlY3RlZE9ianNGcm9tTWFwKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIH0pXG5cbiAgICByZW1vdmVDdXN0b21DdXJzb3IoKVxuICAgIHRoaXMuX3BhcmVudC5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIlxuICAgIC8vIGZvckVhY2ggbm90IHN1cHBvcnRlZCBvbiBub2RlbGlzdCBpbiBJRS9FZGdlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbaV0uc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnXG4gICAgICB0aGlzLl9wYXJlbnQuY2hpbGROb2Rlc1tpXS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nXG4gICAgfVxuXG4gICAgcmV0dXJuIHN1cGVyLmRlbGV0ZVNoYXBlKHNoYXBlcylcbiAgfVxuXG4gIGRlbGV0ZVNlbGVjdGVkU2hhcGVzKCkge1xuICAgIGNvbnN0IHNlbGVjdGVkU2hhcGVzID0gZ2V0U2VsZWN0ZWRPYmpzRnJvbU1hcCh0aGlzLl9zZWxlY3RlZFNoYXBlcylcbiAgICBjbGVhclNlbGVjdGVkU2hhcGVzKHRoaXMuX3NlbGVjdGVkU2hhcGVzKVxuICAgIHRoaXMuZmlyZShFdmVudENvbnN0YW50cy5TRUxFQ1RJT05fQ0hBTkdFRCwge1xuICAgICAgdW5zZWxlY3RlZFNoYXBlczogc2VsZWN0ZWRTaGFwZXMsXG4gICAgICBzZWxlY3RlZFNoYXBlczogW11cbiAgICB9KVxuXG4gICAgcmVtb3ZlQ3VzdG9tQ3Vyc29yKClcbiAgICB0aGlzLl9wYXJlbnQuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCJcbiAgICAvLyBmb3JFYWNoIG5vdCBzdXBwb3J0ZWQgb24gbm9kZWxpc3QgaW4gSUUvRWRnZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhcmVudC5jaGlsZE5vZGVzW2ldLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0J1xuICAgICAgdGhpcy5fcGFyZW50LmNoaWxkTm9kZXNbaV0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJ1xuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5kZWxldGVTaGFwZShzZWxlY3RlZFNoYXBlcylcbiAgfVxuXG4gIGdldCBpbnRlcmFjdGlvbnNFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmF0ZWRcbiAgfVxuXG4gIGVuYWJsZUludGVyYWN0aW9ucygpIHtcbiAgICB0aGlzLl9lbmFibGVFdmVudHMoKVxuICAgIHRoaXMuX2FjdGl2YXRlZCA9IHRydWVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZGlzYWJsZUludGVyYWN0aW9ucyhjbGVhclNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBpZiAoY2xlYXJTZWxlY3Rpb24pIHtcbiAgICAgIHRoaXMuY2xlYXJTZWxlY3Rpb24oKVxuICAgIH1cbiAgICB0aGlzLl9kaXNhYmxlRXZlbnRzKClcbiAgICB0aGlzLl9hY3RpdmF0ZWQgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihFdmVudENvbnN0YW50cywgRHJhd0VuZ2luZS5FdmVudENvbnN0YW50cylcblNoYXBlQnVpbGRlci5FdmVudENvbnN0YW50cyA9IEV2ZW50Q29uc3RhbnRzXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbmdpbmUvc2hhcGUtYnVpbGRlci5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.transformXformShape = transformXformShape;\nexports.translateShape = translateShape;\nexports.translateVert = translateVert;\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _mat2d = __webpack_require__(7);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _vec2d = __webpack_require__(11);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction rotateOBBox(shape, parentShape, selectedInfo, screenPos, worldPos, camera) {\n  var pt = [0, 0];\n  var scale = [0, 0];\n  _mat2d2.default.svd(pt, scale, null, selectedInfo.objectToWorldMatrix);\n  var startDir = [0, 0];\n  Point2d.sub(startDir, selectedInfo.startWorldPos, pt);\n  _vec2d2.default.normalize(startDir, startDir);\n  var dir = pt;\n  Point2d.sub(dir, worldPos, pt);\n  _vec2d2.default.normalize(dir, dir);\n  var angle = _vec2d2.default.angle(startDir, dir);\n\n  if (selectedInfo.keys.shiftKey) {\n    angle = Math.round(angle / Math.QUATER_PI) * Math.QUATER_PI;\n  }\n\n  // if (!camera.isYFlipped()) {\n  //   angle *= -1\n  // }\n\n  parentShape.setRotation(selectedInfo.startLocalRot + Math.RAD_TO_DEG * angle);\n}\n\nfunction transformXformShape(shape, selectedInfo, screenPos, worldPos, camera, selectOpts) {\n  var parentShape = shape.parent;\n  var objPos = [0, 0];\n  var deltaPos = [0, 0];\n  var deltaDims = [0, 0];\n\n  if (selectedInfo.rotate) {\n    rotateOBBox(shape, parentShape, selectedInfo, screenPos, worldPos, camera);\n    return;\n  }\n\n  var uniformScale = selectedInfo.keys.shiftKey || selectedInfo.uniformScaleOnly;\n  var centerScale = selectedInfo.keys.altKey || selectedInfo.centerScaleOnly;\n\n  // get the position of the shape at start of transform\n  var pt = [0, 0];\n  _mat2d2.default.svd(pt, null, null, selectedInfo.objectToWorldMatrix);\n\n  // get the mouse delta in world space\n  _vec2d2.default.sub(deltaPos, worldPos, selectedInfo.startWorldPos);\n\n  if (uniformScale && selectedInfo.controlIndex < 4) {\n    var xAxisDir = [selectedInfo.objectToWorldMatrix[0], selectedInfo.objectToWorldMatrix[1]];\n    var yAxisDir = [selectedInfo.objectToWorldMatrix[2], selectedInfo.objectToWorldMatrix[3]];\n    var diagDir = [0, 0];\n\n    if (selectedInfo.controlIndex < 2) {\n      _vec2d2.default.negate(xAxisDir, xAxisDir);\n    }\n    if (selectedInfo.controlIndex % 2 === 0) {\n      _vec2d2.default.negate(yAxisDir, yAxisDir);\n    }\n\n    _vec2d2.default.normalize(xAxisDir, xAxisDir);\n    _vec2d2.default.normalize(yAxisDir, yAxisDir);\n\n    _vec2d2.default.add(diagDir, xAxisDir, yAxisDir);\n    _vec2d2.default.normalize(diagDir, diagDir);\n\n    var cross = _vec2d2.default.cross2d(deltaPos, diagDir);\n    var axisToUse = null;\n    if (selectedInfo.controlIndex === 0 || selectedInfo.controlIndex === 3) {\n      axisToUse = yAxisDir;\n      if (cross < 0) {\n        axisToUse = xAxisDir;\n      }\n    } else {\n      axisToUse = xAxisDir;\n      if (cross < 0) {\n        axisToUse = yAxisDir;\n      }\n    }\n    var mindist = _vec2d2.default.dot(deltaPos, axisToUse);\n    mindist = Math.sign(mindist) * Math.sqrt(2 * mindist * mindist);\n    _vec2d2.default.scale(deltaPos, diagDir, mindist);\n    Point2d.addVec2(worldPos, selectedInfo.startWorldPos, deltaPos);\n  }\n\n  // first convert world point to object space\n  Point2d.copy(objPos, worldPos);\n  Point2d.transformMat2d(objPos, objPos, selectedInfo.worldToObjectMatrix);\n\n  // get the mouse delta in object space and multipy by the\n  // scale of the selected object at the start of the transform\n  // to get the scale delta in object space\n  _vec2d2.default.sub(deltaDims, objPos, selectedInfo.startObjectPos);\n\n  Point2d.copy(pt, selectedInfo.startLocalPos);\n\n  // now determine the transform direction depending\n  // on which control vertex of the object-oriented bounds\n  // was selected\n  var xScale = 0;\n  var yScale = 0;\n  if (selectedInfo.controlIndex < 4) {\n    // dragging a corner vertex\n    xScale = selectedInfo.controlIndex < 2 ? -1 : 1;\n    yScale = selectedInfo.controlIndex % 2 === 0 ? -1 : 1;\n\n    // can translate based on the mouse delta in world space\n    // This is done to offset the scale, which is done at\n    // the shape's center. This ultimately acts as a pivot\n    // for the transformation. Only do this if the alt key\n    // isn't pressed\n    if (!centerScale) {\n      Point2d.addVec2(pt, pt, _vec2d2.default.scale(deltaPos, deltaPos, 0.5));\n    }\n\n    parentShape.setPosition(pt);\n  } else {\n    // dragging a side vertex, which means we only scale in\n    // one dimension, rather than 2. So we need to figure\n    // out that direction based on the orientation of the\n    // shape\n    var idx = selectedInfo.controlIndex - 4;\n    var axisDir = [0, 0];\n    if (idx % 2 === 0) {\n      // scaling in the object's X direction\n      _vec2d2.default.set(axisDir, selectedInfo.objectToWorldMatrix[0], selectedInfo.objectToWorldMatrix[1]);\n      yScale = 0;\n      xScale = idx < 2 ? -1 : 1;\n      if (uniformScale) {\n        yScale = xScale;\n        deltaDims[1] = deltaDims[0];\n      }\n    } else {\n      // scaling in the object's Y direction\n      _vec2d2.default.set(axisDir, selectedInfo.objectToWorldMatrix[2], selectedInfo.objectToWorldMatrix[3]);\n      xScale = 0;\n      yScale = idx < 2 ? -1 : 1;\n      if (uniformScale) {\n        xScale = yScale;\n        deltaDims[0] = deltaDims[1];\n      }\n    }\n\n    // now find the pivot offset for the axis-aligned scale\n    if (!centerScale) {\n      _vec2d2.default.normalize(axisDir, axisDir);\n      _vec2d2.default.scale(axisDir, axisDir, _vec2d2.default.dot(deltaPos, axisDir));\n      Point2d.addVec2(pt, pt, _vec2d2.default.scale(axisDir, axisDir, 0.5));\n    }\n\n    parentShape.setPosition(pt);\n  }\n\n  if (centerScale) {\n    xScale *= 2;\n    yScale *= 2;\n  }\n\n  // perform the scale\n  parentShape.setScale([selectedInfo.startLocalScale[0] * (1 + xScale * deltaDims[0] / selectedInfo.shapeWidth), selectedInfo.startLocalScale[1] * (1 + yScale * deltaDims[1] / selectedInfo.shapeHeight)]);\n}\n\nfunction translateShape(shape, selectedInfo, screenPos, worldPos, camera) {\n  var diff = [0, 0];\n  var pt = [0, 0];\n  _mat2d2.default.svd(pt, null, null, selectedInfo.objectToWorldMatrix);\n  if (selectedInfo.keys.shiftKey) {\n    Point2d.sub(diff, screenPos, selectedInfo.startPos);\n    var angle = Math.atan2(diff[1], diff[0]);\n    angle = Math.round(angle / Math.QUATER_PI) * Math.QUATER_PI;\n    var transformDir = [Math.cos(angle), Math.sin(angle)];\n    _vec2d2.default.scale(diff, transformDir, _vec2d2.default.dot(diff, transformDir));\n    _vec2d2.default.transformMat2(diff, diff, camera.screenToWorldMatrix);\n  } else {\n    _vec2d2.default.sub(diff, worldPos, selectedInfo.startWorldPos);\n  }\n  Point2d.addVec2(pt, selectedInfo.startLocalPos, diff);\n\n  shape.setPosition(pt);\n}\n\nfunction translateVert(shape, selectedInfo, screenPos, worldPos, camera) {\n  var parentShape = shape.parent;\n\n  // get the position of the shape at start of transform\n  // const pt = [0, 0]\n  // Mat2d.svd(pt, null, null, selectedInfo.objectToWorldMatrix)\n\n  // get the mouse delta in world space\n  // Vec2d.sub(deltaPos, worldPos, selectedInfo.startWorldPos)\n\n  // first convert world point to object space\n  // Point2d.copy(objPos, worldPos)\n  // Point2d.transformMat2d(objPos, objPos, selectedInfo.worldToObjectMatrix)\n\n  // get the diff\n  // const diff = objPos\n  // Point2d.sub(diff, objPos, selectedInfo.startObjectPos)\n\n  var numVerts = parentShape.numVerts;\n  if (selectedInfo.controlIndex >= numVerts) {\n    var idx1 = Math.min(selectedInfo.controlIndex - numVerts, numVerts - 1);\n    var idx2 = idx1 === numVerts - 1 ? 0 : idx1 + 1;\n    var pt = [0, 0];\n    var pt1 = [0, 0];\n    var pt2 = [0, 0];\n    var vec = [0, 0];\n    var verts = parentShape.vertsRef;\n    var xform = parentShape.globalXform;\n    Point2d.transformMat2d(pt1, verts[idx1], xform);\n    Point2d.transformMat2d(pt2, verts[idx2], xform);\n    Point2d.sub(vec, pt2, pt1);\n    _vec2d2.default.scale(vec, vec, 0.5);\n    Point2d.addVec2(pt, pt1, vec);\n    selectedInfo.controlIndex = parentShape.insertVert(idx1 + 1, pt);\n  } else {\n    parentShape.setVertPosition(selectedInfo.controlIndex, worldPos);\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3QtdXRpbHMuanM/NzE0YiJdLCJuYW1lcyI6WyJ0cmFuc2Zvcm1YZm9ybVNoYXBlIiwidHJhbnNsYXRlU2hhcGUiLCJ0cmFuc2xhdGVWZXJ0IiwiUG9pbnQyZCIsInJvdGF0ZU9CQm94Iiwic2hhcGUiLCJwYXJlbnRTaGFwZSIsInNlbGVjdGVkSW5mbyIsInNjcmVlblBvcyIsIndvcmxkUG9zIiwiY2FtZXJhIiwicHQiLCJzY2FsZSIsInN2ZCIsIm9iamVjdFRvV29ybGRNYXRyaXgiLCJzdGFydERpciIsInN1YiIsInN0YXJ0V29ybGRQb3MiLCJub3JtYWxpemUiLCJkaXIiLCJhbmdsZSIsImtleXMiLCJzaGlmdEtleSIsIk1hdGgiLCJyb3VuZCIsIlFVQVRFUl9QSSIsInNldFJvdGF0aW9uIiwic3RhcnRMb2NhbFJvdCIsIlJBRF9UT19ERUciLCJzZWxlY3RPcHRzIiwicGFyZW50Iiwib2JqUG9zIiwiZGVsdGFQb3MiLCJkZWx0YURpbXMiLCJyb3RhdGUiLCJ1bmlmb3JtU2NhbGUiLCJ1bmlmb3JtU2NhbGVPbmx5IiwiY2VudGVyU2NhbGUiLCJhbHRLZXkiLCJjZW50ZXJTY2FsZU9ubHkiLCJjb250cm9sSW5kZXgiLCJ4QXhpc0RpciIsInlBeGlzRGlyIiwiZGlhZ0RpciIsIm5lZ2F0ZSIsImFkZCIsImNyb3NzIiwiY3Jvc3MyZCIsImF4aXNUb1VzZSIsIm1pbmRpc3QiLCJkb3QiLCJzaWduIiwic3FydCIsImFkZFZlYzIiLCJjb3B5IiwidHJhbnNmb3JtTWF0MmQiLCJ3b3JsZFRvT2JqZWN0TWF0cml4Iiwic3RhcnRPYmplY3RQb3MiLCJzdGFydExvY2FsUG9zIiwieFNjYWxlIiwieVNjYWxlIiwic2V0UG9zaXRpb24iLCJpZHgiLCJheGlzRGlyIiwic2V0Iiwic2V0U2NhbGUiLCJzdGFydExvY2FsU2NhbGUiLCJzaGFwZVdpZHRoIiwic2hhcGVIZWlnaHQiLCJkaWZmIiwic3RhcnRQb3MiLCJhdGFuMiIsInRyYW5zZm9ybURpciIsImNvcyIsInNpbiIsInRyYW5zZm9ybU1hdDIiLCJzY3JlZW5Ub1dvcmxkTWF0cml4IiwibnVtVmVydHMiLCJpZHgxIiwibWluIiwiaWR4MiIsInB0MSIsInB0MiIsInZlYyIsInZlcnRzIiwidmVydHNSZWYiLCJ4Zm9ybSIsImdsb2JhbFhmb3JtIiwiaW5zZXJ0VmVydCIsInNldFZlcnRQb3NpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O1FBNkJnQkEsbUIsR0FBQUEsbUI7UUF1SUFDLGMsR0FBQUEsYztRQW1CQUMsYSxHQUFBQSxhOztBQXJMaEI7O0lBQVlDLE87O0FBQ1o7Ozs7QUFDQTs7Ozs7Ozs7QUFFQSxTQUFTQyxXQUFULENBQXFCQyxLQUFyQixFQUE0QkMsV0FBNUIsRUFBeUNDLFlBQXpDLEVBQXVEQyxTQUF2RCxFQUFrRUMsUUFBbEUsRUFBNEVDLE1BQTVFLEVBQW9GO0FBQ2xGLE1BQU1DLEtBQUssQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFYO0FBQ0EsTUFBTUMsUUFBUSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQWQ7QUFDQSxrQkFBTUMsR0FBTixDQUFVRixFQUFWLEVBQWNDLEtBQWQsRUFBcUIsSUFBckIsRUFBMkJMLGFBQWFPLG1CQUF4QztBQUNBLE1BQU1DLFdBQVcsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFqQjtBQUNBWixVQUFRYSxHQUFSLENBQVlELFFBQVosRUFBc0JSLGFBQWFVLGFBQW5DLEVBQWtETixFQUFsRDtBQUNBLGtCQUFNTyxTQUFOLENBQWdCSCxRQUFoQixFQUEwQkEsUUFBMUI7QUFDQSxNQUFNSSxNQUFNUixFQUFaO0FBQ0FSLFVBQVFhLEdBQVIsQ0FBWUcsR0FBWixFQUFpQlYsUUFBakIsRUFBMkJFLEVBQTNCO0FBQ0Esa0JBQU1PLFNBQU4sQ0FBZ0JDLEdBQWhCLEVBQXFCQSxHQUFyQjtBQUNBLE1BQUlDLFFBQVEsZ0JBQU1BLEtBQU4sQ0FBWUwsUUFBWixFQUFzQkksR0FBdEIsQ0FBWjs7QUFFQSxNQUFJWixhQUFhYyxJ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LEdBQTRCcUMsUUFBckMsRUFBK0NBLFdBQVcsQ0FBMUQsQ0FBYjtBQUNBLFFBQU1HLE9BQVFGLFNBQVNELFdBQVcsQ0FBcEIsR0FBd0IsQ0FBeEIsR0FBNEJDLE9BQU8sQ0FBakQ7QUFDQSxRQUFNbkUsS0FBSyxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVg7QUFDQSxRQUFNc0UsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQSxRQUFNQyxNQUFNLENBQUMsQ0FBRCxFQUFJLENBQUosQ0FBWjtBQUNBLFFBQU1DLE1BQU0sQ0FBQyxDQUFELEVBQUksQ0FBSixDQUFaO0FBQ0EsUUFBTUMsUUFBUTlFLFlBQVkrRSxRQUExQjtBQUNBLFFBQU1DLFFBQVFoRixZQUFZaUYsV0FBMUI7QUFDQXBGLFlBQVFvRCxjQUFSLENBQXVCMEIsR0FBdkIsRUFBNEJHLE1BQU1OLElBQU4sQ0FBNUIsRUFBeUNRLEtBQXpDO0FBQ0FuRixZQUFRb0QsY0FBUixDQUF1QjJCLEdBQXZCLEVBQTRCRSxNQUFNSixJQUFOLENBQTVCLEVBQXlDTSxLQUF6QztBQUNBbkYsWUFBUWEsR0FBUixDQUFZbUUsR0FBWixFQUFpQkQsR0FBakIsRUFBc0JELEdBQXRCO0FBQ0Esb0JBQU1yRSxLQUFOLENBQVl1RSxHQUFaLEVBQWlCQSxHQUFqQixFQUFzQixHQUF0QjtBQUNBaEYsWUFBUWtELE9BQVIsQ0FBZ0IxQyxFQUFoQixFQUFvQnNFLEdBQXBCLEVBQXlCRSxHQUF6QjtBQUNBNUUsaUJBQWFpQyxZQUFiLEdBQTRCbEMsWUFBWWtGLFVBQVosQ0FBdUJWLE9BQU8sQ0FBOUIsRUFBaUNuRSxFQUFqQyxDQUE1QjtBQUNELEdBZkQsTUFlTztBQUNMTCxnQkFBWW1GLGVBQVosQ0FBNEJsRixhQUFhaUMsWUFBekMsRUFBdUQvQixRQUF2RDtBQUNEO0FBQ0YiLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IE1hdDJkIGZyb20gXCIuLi9jb3JlL21hdDJkXCJcbmltcG9ydCBWZWMyZCBmcm9tIFwiLi4vY29yZS92ZWMyZFwiXG5cbmZ1bmN0aW9uIHJvdGF0ZU9CQm94KHNoYXBlLCBwYXJlbnRTaGFwZSwgc2VsZWN0ZWRJbmZvLCBzY3JlZW5Qb3MsIHdvcmxkUG9zLCBjYW1lcmEpIHtcbiAgY29uc3QgcHQgPSBbMCwgMF1cbiAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgTWF0MmQuc3ZkKHB0LCBzY2FsZSwgbnVsbCwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXgpXG4gIGNvbnN0IHN0YXJ0RGlyID0gWzAsIDBdXG4gIFBvaW50MmQuc3ViKHN0YXJ0RGlyLCBzZWxlY3RlZEluZm8uc3RhcnRXb3JsZFBvcywgcHQpXG4gIFZlYzJkLm5vcm1hbGl6ZShzdGFydERpciwgc3RhcnREaXIpXG4gIGNvbnN0IGRpciA9IHB0XG4gIFBvaW50MmQuc3ViKGRpciwgd29ybGRQb3MsIHB0KVxuICBWZWMyZC5ub3JtYWxpemUoZGlyLCBkaXIpXG4gIGxldCBhbmdsZSA9IFZlYzJkLmFuZ2xlKHN0YXJ0RGlyLCBkaXIpXG5cbiAgaWYgKHNlbGVjdGVkSW5mby5rZXlzLnNoaWZ0S2V5KSB7XG4gICAgYW5nbGUgPSBNYXRoLnJvdW5kKGFuZ2xlIC8gTWF0aC5RVUFURVJfUEkpICogTWF0aC5RVUFURVJfUElcbiAgfVxuXG4gIC8vIGlmICghY2FtZXJhLmlzWUZsaXBwZWQoKSkge1xuICAvLyAgIGFuZ2xlICo9IC0xXG4gIC8vIH1cblxuICBwYXJlbnRTaGFwZS5zZXRSb3RhdGlvbihzZWxlY3RlZEluZm8uc3RhcnRMb2NhbFJvdCArIE1hdGguUkFEX1RPX0RFRyAqIGFuZ2xlKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtWGZvcm1TaGFwZShzaGFwZSwgc2VsZWN0ZWRJbmZvLCBzY3JlZW5Qb3MsIHdvcmxkUG9zLCBjYW1lcmEsIHNlbGVjdE9wdHMpIHtcbiAgY29uc3QgcGFyZW50U2hhcGUgPSBzaGFwZS5wYXJlbnRcbiAgY29uc3Qgb2JqUG9zID0gWzAsIDBdXG4gIGNvbnN0IGRlbHRhUG9zID0gWzAsIDBdXG4gIGNvbnN0IGRlbHRhRGltcyA9IFswLCAwXVxuXG4gIGlmIChzZWxlY3RlZEluZm8ucm90YXRlKSB7XG4gICAgcm90YXRlT0JCb3goc2hhcGUsIHBhcmVudFNoYXBlLCBzZWxlY3RlZEluZm8sIHNjcmVlblBvcywgd29ybGRQb3MsIGNhbWVyYSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHVuaWZvcm1TY2FsZSA9IChzZWxlY3RlZEluZm8ua2V5cy5zaGlmdEtleSB8fCBzZWxlY3RlZEluZm8udW5pZm9ybVNjYWxlT25seSlcbiAgY29uc3QgY2VudGVyU2NhbGUgPSAoc2VsZWN0ZWRJbmZvLmtleXMuYWx0S2V5IHx8IHNlbGVjdGVkSW5mby5jZW50ZXJTY2FsZU9ubHkpXG5cbiAgLy8gZ2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc2hhcGUgYXQgc3RhcnQgb2YgdHJhbnNmb3JtXG4gIGNvbnN0IHB0ID0gWzAsIDBdXG4gIE1hdDJkLnN2ZChwdCwgbnVsbCwgbnVsbCwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXgpXG5cbiAgLy8gZ2V0IHRoZSBtb3VzZSBkZWx0YSBpbiB3b3JsZCBzcGFjZVxuICBWZWMyZC5zdWIoZGVsdGFQb3MsIHdvcmxkUG9zLCBzZWxlY3RlZEluZm8uc3RhcnRXb3JsZFBvcylcblxuICBpZiAodW5pZm9ybVNjYWxlICYmIHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggPCA0KSB7XG4gICAgY29uc3QgeEF4aXNEaXIgPSBbc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMF0sIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzFdXVxuICAgIGNvbnN0IHlBeGlzRGlyID0gW3NlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzJdLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeFszXV1cbiAgICBjb25zdCBkaWFnRGlyID0gWzAsIDBdXG5cbiAgICBpZiAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDIpIHtcbiAgICAgIFZlYzJkLm5lZ2F0ZSh4QXhpc0RpciwgeEF4aXNEaXIpXG4gICAgfVxuICAgIGlmIChzZWxlY3RlZEluZm8uY29udHJvbEluZGV4ICUgMiA9PT0gMCkge1xuICAgICAgVmVjMmQubmVnYXRlKHlBeGlzRGlyLCB5QXhpc0RpcilcbiAgICB9XG5cbiAgICBWZWMyZC5ub3JtYWxpemUoeEF4aXNEaXIsIHhBeGlzRGlyKVxuICAgIFZlYzJkLm5vcm1hbGl6ZSh5QXhpc0RpciwgeUF4aXNEaXIpXG5cbiAgICBWZWMyZC5hZGQoZGlhZ0RpciwgeEF4aXNEaXIsIHlBeGlzRGlyKVxuICAgIFZlYzJkLm5vcm1hbGl6ZShkaWFnRGlyLCBkaWFnRGlyKVxuXG4gICAgY29uc3QgY3Jvc3MgPSBWZWMyZC5jcm9zczJkKGRlbHRhUG9zLCBkaWFnRGlyKVxuICAgIGxldCBheGlzVG9Vc2UgPSBudWxsXG4gICAgaWYgKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggPT09IDAgfHwgc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA9PT0gMykge1xuICAgICAgYXhpc1RvVXNlID0geUF4aXNEaXJcbiAgICAgIGlmIChjcm9zcyA8IDApIHtcbiAgICAgICAgYXhpc1RvVXNlID0geEF4aXNEaXJcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1RvVXNlID0geEF4aXNEaXJcbiAgICAgIGlmIChjcm9zcyA8IDApIHtcbiAgICAgICAgYXhpc1RvVXNlID0geUF4aXNEaXJcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG1pbmRpc3QgPSBWZWMyZC5kb3QoZGVsdGFQb3MsIGF4aXNUb1VzZSlcbiAgICBtaW5kaXN0ID0gTWF0aC5zaWduKG1pbmRpc3QpICogTWF0aC5zcXJ0KDIgKiBtaW5kaXN0ICogbWluZGlzdClcbiAgICBWZWMyZC5zY2FsZShkZWx0YVBvcywgZGlhZ0RpciwgbWluZGlzdClcbiAgICBQb2ludDJkLmFkZFZlYzIod29ybGRQb3MsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zLCBkZWx0YVBvcylcbiAgfVxuXG4gIC8vIGZpcnN0IGNvbnZlcnQgd29ybGQgcG9pbnQgdG8gb2JqZWN0IHNwYWNlXG4gIFBvaW50MmQuY29weShvYmpQb3MsIHdvcmxkUG9zKVxuICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKG9ialBvcywgb2JqUG9zLCBzZWxlY3RlZEluZm8ud29ybGRUb09iamVjdE1hdHJpeClcblxuICAvLyBnZXQgdGhlIG1vdXNlIGRlbHRhIGluIG9iamVjdCBzcGFjZSBhbmQgbXVsdGlweSBieSB0aGVcbiAgLy8gc2NhbGUgb2YgdGhlIHNlbGVjdGVkIG9iamVjdCBhdCB0aGUgc3RhcnQgb2YgdGhlIHRyYW5zZm9ybVxuICAvLyB0byBnZXQgdGhlIHNjYWxlIGRlbHRhIGluIG9iamVjdCBzcGFjZVxuICBWZWMyZC5zdWIoZGVsdGFEaW1zLCBvYmpQb3MsIHNlbGVjdGVkSW5mby5zdGFydE9iamVjdFBvcylcblxuICBQb2ludDJkLmNvcHkocHQsIHNlbGVjdGVkSW5mby5zdGFydExvY2FsUG9zKVxuXG4gIC8vIG5vdyBkZXRlcm1pbmUgdGhlIHRyYW5zZm9ybSBkaXJlY3Rpb24gZGVwZW5kaW5nXG4gIC8vIG9uIHdoaWNoIGNvbnRyb2wgdmVydGV4IG9mIHRoZSBvYmplY3Qtb3JpZW50ZWQgYm91bmRzXG4gIC8vIHdhcyBzZWxlY3RlZFxuICBsZXQgeFNjYWxlID0gMFxuICBsZXQgeVNjYWxlID0gMFxuICBpZiAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDQpIHtcbiAgICAvLyBkcmFnZ2luZyBhIGNvcm5lciB2ZXJ0ZXhcbiAgICB4U2NhbGUgPSAoc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCA8IDIgPyAtMSA6IDEpXG4gICAgeVNjYWxlID0gKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggJSAyID09PSAwID8gLTEgOiAxKVxuXG4gICAgLy8gY2FuIHRyYW5zbGF0ZSBiYXNlZCBvbiB0aGUgbW91c2UgZGVsdGEgaW4gd29ybGQgc3BhY2VcbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gb2Zmc2V0IHRoZSBzY2FsZSwgd2hpY2ggaXMgZG9uZSBhdFxuICAgIC8vIHRoZSBzaGFwZSdzIGNlbnRlci4gVGhpcyB1bHRpbWF0ZWx5IGFjdHMgYXMgYSBwaXZvdFxuICAgIC8vIGZvciB0aGUgdHJhbnNmb3JtYXRpb24uIE9ubHkgZG8gdGhpcyBpZiB0aGUgYWx0IGtleVxuICAgIC8vIGlzbid0IHByZXNzZWRcbiAgICBpZiAoIWNlbnRlclNjYWxlKSB7XG4gICAgICBQb2ludDJkLmFkZFZlYzIocHQsIHB0LCBWZWMyZC5zY2FsZShkZWx0YVBvcywgZGVsdGFQb3MsIDAuNSkpXG4gICAgfVxuXG4gICAgcGFyZW50U2hhcGUuc2V0UG9zaXRpb24ocHQpXG4gIH0gZWxzZSB7XG4gICAgLy8gZHJhZ2dpbmcgYSBzaWRlIHZlcnRleCwgd2hpY2ggbWVhbnMgd2Ugb25seSBzY2FsZSBpblxuICAgIC8vIG9uZSBkaW1lbnNpb24sIHJhdGhlciB0aGFuIDIuIFNvIHdlIG5lZWQgdG8gZmlndXJlXG4gICAgLy8gb3V0IHRoYXQgZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGVcbiAgICAvLyBzaGFwZVxuICAgIGNvbnN0IGlkeCA9IHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggLSA0XG4gICAgY29uc3QgYXhpc0RpciA9IFswLCAwXVxuICAgIGlmIChpZHggJSAyID09PSAwKSB7XG4gICAgICAvLyBzY2FsaW5nIGluIHRoZSBvYmplY3QncyBYIGRpcmVjdGlvblxuICAgICAgVmVjMmQuc2V0KGF4aXNEaXIsIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzBdLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeFsxXSlcbiAgICAgIHlTY2FsZSA9IDBcbiAgICAgIHhTY2FsZSA9IChpZHggPCAyID8gLTEgOiAxKVxuICAgICAgaWYgKHVuaWZvcm1TY2FsZSkge1xuICAgICAgICB5U2NhbGUgPSB4U2NhbGVcbiAgICAgICAgZGVsdGFEaW1zWzFdID0gZGVsdGFEaW1zWzBdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNjYWxpbmcgaW4gdGhlIG9iamVjdCdzIFkgZGlyZWN0aW9uXG4gICAgICBWZWMyZC5zZXQoYXhpc0Rpciwgc2VsZWN0ZWRJbmZvLm9iamVjdFRvV29ybGRNYXRyaXhbMl0sIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4WzNdKVxuICAgICAgeFNjYWxlID0gMFxuICAgICAgeVNjYWxlID0gKGlkeCA8IDIgPyAtMSA6IDEpXG4gICAgICBpZiAodW5pZm9ybVNjYWxlKSB7XG4gICAgICAgIHhTY2FsZSA9IHlTY2FsZVxuICAgICAgICBkZWx0YURpbXNbMF0gPSBkZWx0YURpbXNbMV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBub3cgZmluZCB0aGUgcGl2b3Qgb2Zmc2V0IGZvciB0aGUgYXhpcy1hbGlnbmVkIHNjYWxlXG4gICAgaWYgKCFjZW50ZXJTY2FsZSkge1xuICAgICAgVmVjMmQubm9ybWFsaXplKGF4aXNEaXIsIGF4aXNEaXIpXG4gICAgICBWZWMyZC5zY2FsZShheGlzRGlyLCBheGlzRGlyLCBWZWMyZC5kb3QoZGVsdGFQb3MsIGF4aXNEaXIpKVxuICAgICAgUG9pbnQyZC5hZGRWZWMyKHB0LCBwdCwgVmVjMmQuc2NhbGUoYXhpc0RpciwgYXhpc0RpciwgMC41KSlcbiAgICB9XG5cbiAgICBwYXJlbnRTaGFwZS5zZXRQb3NpdGlvbihwdClcbiAgfVxuXG4gIGlmIChjZW50ZXJTY2FsZSkge1xuICAgIHhTY2FsZSAqPSAyXG4gICAgeVNjYWxlICo9IDJcbiAgfVxuXG4gIC8vIHBlcmZvcm0gdGhlIHNjYWxlXG4gIHBhcmVudFNoYXBlLnNldFNjYWxlKFtzZWxlY3RlZEluZm8uc3RhcnRMb2NhbFNjYWxlWzBdICogKDEgKyB4U2NhbGUgKiBkZWx0YURpbXNbMF0gLyBzZWxlY3RlZEluZm8uc2hhcGVXaWR0aCksIHNlbGVjdGVkSW5mby5zdGFydExvY2FsU2NhbGVbMV0gKiAoMSArIHlTY2FsZSAqIGRlbHRhRGltc1sxXSAvIHNlbGVjdGVkSW5mby5zaGFwZUhlaWdodCldKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlU2hhcGUoc2hhcGUsIHNlbGVjdGVkSW5mbywgc2NyZWVuUG9zLCB3b3JsZFBvcywgY2FtZXJhKSB7XG4gIGNvbnN0IGRpZmYgPSBbMCwgMF1cbiAgY29uc3QgcHQgPSBbMCwgMF1cbiAgTWF0MmQuc3ZkKHB0LCBudWxsLCBudWxsLCBzZWxlY3RlZEluZm8ub2JqZWN0VG9Xb3JsZE1hdHJpeClcbiAgaWYgKHNlbGVjdGVkSW5mby5rZXlzLnNoaWZ0S2V5KSB7XG4gICAgUG9pbnQyZC5zdWIoZGlmZiwgc2NyZWVuUG9zLCBzZWxlY3RlZEluZm8uc3RhcnRQb3MpXG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaWZmWzFdLCBkaWZmWzBdKVxuICAgIGFuZ2xlID0gTWF0aC5yb3VuZChhbmdsZSAvIE1hdGguUVVBVEVSX1BJKSAqIE1hdGguUVVBVEVSX1BJXG4gICAgY29uc3QgdHJhbnNmb3JtRGlyID0gW01hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpXVxuICAgIFZlYzJkLnNjYWxlKGRpZmYsIHRyYW5zZm9ybURpciwgVmVjMmQuZG90KGRpZmYsIHRyYW5zZm9ybURpcikpXG4gICAgVmVjMmQudHJhbnNmb3JtTWF0MihkaWZmLCBkaWZmLCBjYW1lcmEuc2NyZWVuVG9Xb3JsZE1hdHJpeClcbiAgfSBlbHNlIHtcbiAgICBWZWMyZC5zdWIoZGlmZiwgd29ybGRQb3MsIHNlbGVjdGVkSW5mby5zdGFydFdvcmxkUG9zKVxuICB9XG4gIFBvaW50MmQuYWRkVmVjMihwdCwgc2VsZWN0ZWRJbmZvLnN0YXJ0TG9jYWxQb3MsIGRpZmYpXG5cbiAgc2hhcGUuc2V0UG9zaXRpb24ocHQpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGVWZXJ0KHNoYXBlLCBzZWxlY3RlZEluZm8sIHNjcmVlblBvcywgd29ybGRQb3MsIGNhbWVyYSkge1xuICBjb25zdCBwYXJlbnRTaGFwZSA9IHNoYXBlLnBhcmVudFxuXG4gIC8vIGdldCB0aGUgcG9zaXRpb24gb2YgdGhlIHNoYXBlIGF0IHN0YXJ0IG9mIHRyYW5zZm9ybVxuICAvLyBjb25zdCBwdCA9IFswLCAwXVxuICAvLyBNYXQyZC5zdmQocHQsIG51bGwsIG51bGwsIHNlbGVjdGVkSW5mby5vYmplY3RUb1dvcmxkTWF0cml4KVxuXG4gIC8vIGdldCB0aGUgbW91c2UgZGVsdGEgaW4gd29ybGQgc3BhY2VcbiAgLy8gVmVjMmQuc3ViKGRlbHRhUG9zLCB3b3JsZFBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0V29ybGRQb3MpXG5cbiAgLy8gZmlyc3QgY29udmVydCB3b3JsZCBwb2ludCB0byBvYmplY3Qgc3BhY2VcbiAgLy8gUG9pbnQyZC5jb3B5KG9ialBvcywgd29ybGRQb3MpXG4gIC8vIFBvaW50MmQudHJhbnNmb3JtTWF0MmQob2JqUG9zLCBvYmpQb3MsIHNlbGVjdGVkSW5mby53b3JsZFRvT2JqZWN0TWF0cml4KVxuXG4gIC8vIGdldCB0aGUgZGlmZlxuICAvLyBjb25zdCBkaWZmID0gb2JqUG9zXG4gIC8vIFBvaW50MmQuc3ViKGRpZmYsIG9ialBvcywgc2VsZWN0ZWRJbmZvLnN0YXJ0T2JqZWN0UG9zKVxuXG4gIGNvbnN0IG51bVZlcnRzID0gcGFyZW50U2hhcGUubnVtVmVydHNcbiAgaWYgKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXggPj0gbnVtVmVydHMpIHtcbiAgICBjb25zdCBpZHgxID0gTWF0aC5taW4oc2VsZWN0ZWRJbmZvLmNvbnRyb2xJbmRleCAtIG51bVZlcnRzLCBudW1WZXJ0cyAtIDEpXG4gICAgY29uc3QgaWR4MiA9IChpZHgxID09PSBudW1WZXJ0cyAtIDEgPyAwIDogaWR4MSArIDEpXG4gICAgY29uc3QgcHQgPSBbMCwgMF1cbiAgICBjb25zdCBwdDEgPSBbMCwgMF1cbiAgICBjb25zdCBwdDIgPSBbMCwgMF1cbiAgICBjb25zdCB2ZWMgPSBbMCwgMF1cbiAgICBjb25zdCB2ZXJ0cyA9IHBhcmVudFNoYXBlLnZlcnRzUmVmXG4gICAgY29uc3QgeGZvcm0gPSBwYXJlbnRTaGFwZS5nbG9iYWxYZm9ybVxuICAgIFBvaW50MmQudHJhbnNmb3JtTWF0MmQocHQxLCB2ZXJ0c1tpZHgxXSwgeGZvcm0pXG4gICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZChwdDIsIHZlcnRzW2lkeDJdLCB4Zm9ybSlcbiAgICBQb2ludDJkLnN1Yih2ZWMsIHB0MiwgcHQxKVxuICAgIFZlYzJkLnNjYWxlKHZlYywgdmVjLCAwLjUpXG4gICAgUG9pbnQyZC5hZGRWZWMyKHB0LCBwdDEsIHZlYylcbiAgICBzZWxlY3RlZEluZm8uY29udHJvbEluZGV4ID0gcGFyZW50U2hhcGUuaW5zZXJ0VmVydChpZHgxICsgMSwgcHQpXG4gIH0gZWxzZSB7XG4gICAgcGFyZW50U2hhcGUuc2V0VmVydFBvc2l0aW9uKHNlbGVjdGVkSW5mby5jb250cm9sSW5kZXgsIHdvcmxkUG9zKVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3QtdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar VertEditableShape = function (_BaseShape) {\n  _inherits(VertEditableShape, _BaseShape);\n\n  function VertEditableShape(baseVertShape, opts) {\n    _classCallCheck(this, VertEditableShape);\n\n    var _this = _possibleConstructorReturn(this, (VertEditableShape.__proto__ || Object.getPrototypeOf(VertEditableShape)).call(this, opts));\n\n    _this._baseVertShape = baseVertShape;\n    _this._vertRadius = 4;\n    _this._transformedVerts = [];\n    _this._baseaabox = AABox2d.create();\n    _this._worldToScreenMatrix = _glMatrix.mat2d.create();\n    return _this;\n  }\n\n  _createClass(VertEditableShape, [{\n    key: \"_updateAABox\",\n    value: function _updateAABox(worldToScreenMatrix) {\n      var aabox = this._baseVertShape.aabox;\n      if (!AABox2d.equals(aabox, this._baseaabox) || !_glMatrix.mat2d.equals(worldToScreenMatrix, this._worldToScreenMatrix)) {\n        AABox2d.copy(this._baseaabox, aabox);\n        _glMatrix.mat2d.copy(this._worldToScreenMatrix, worldToScreenMatrix);\n        AABox2d.transformMat2d(this._aabox, this._baseaabox, this._worldToScreenMatrix);\n        var pad = this._vertRadius + this.strokeWidth;\n        AABox2d.expand(this._aabox, this._aabox, [pad, pad]);\n      }\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtnObj = {\n        hit: false,\n        controlIndex: -1\n      };\n\n      this._updateAABox(worldToScreenMatrix);\n      if (this.visible && AABox2d.containsPt(this._aabox, screenPt)) {\n        var aabox = AABox2d.create();\n        var pad = this._vertRadius + this.strokeWidth / 2;\n        var extents = [pad, pad];\n\n        var i = 0;\n        for (i = 0; i < this._transformedVerts.length; i += 1) {\n          AABox2d.initCenterExtents(aabox, this._transformedVerts[i], extents);\n          if (AABox2d.containsPt(aabox, screenPt)) {\n            rtnObj.hit = true;\n            rtnObj.controlIndex = i;\n            break;\n          }\n        }\n\n        if (!rtnObj.hit) {\n          var tmpPt = [0, 0];\n          var tmpVec = [0, 0];\n          var radius = ctx.lineWidth * 1.5;\n          _glMatrix.vec2.set(extents, radius, radius);\n          for (i = 0; i < this._transformedVerts.length - 1; i += 1) {\n            Point2d.sub(tmpVec, this._transformedVerts[i + 1], this._transformedVerts[i]);\n            _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n            Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n            AABox2d.initCenterExtents(aabox, tmpPt, extents);\n            if (AABox2d.containsPt(aabox, screenPt)) {\n              rtnObj.hit = true;\n              rtnObj.controlIndex = this._transformedVerts.length + i;\n              break;\n            }\n          }\n\n          if (i > 0 && i === this._transformedVerts.length - 1) {\n            Point2d.sub(tmpVec, this._transformedVerts[0], this._transformedVerts[i]);\n            _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n            Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n            AABox2d.initCenterExtents(aabox, tmpPt, extents);\n            if (AABox2d.containsPt(aabox, screenPt)) {\n              rtnObj.hit = true;\n              rtnObj.controlIndex = this._transformedVerts.length + i;\n            }\n          }\n        }\n      }\n\n      return rtnObj;\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      // we're storing our AABox in screen space here, so worldToScreenMatrix is\n      // unused\n      this._updateAABox(worldToScreenMatrix);\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      AABox2d.getCenter(center, this._aabox);\n      AABox2d.getExtents(extents, this._aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      var _this2 = this;\n\n      ctx.save();\n\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      var objToScreenMatrix = this._baseVertShape._fullXform;\n      var verts = this._baseVertShape.vertsRef;\n      this._transformedVerts = new Array(verts.length);\n      var tmpPt = [0, 0];\n      var tmpVec = [0, 0];\n\n      ctx.beginPath();\n      var i = 0;\n      this._transformedVerts[i] = [0, 0];\n      Point2d.transformMat2d(this._transformedVerts[i], verts[i], objToScreenMatrix);\n\n      var radius = Math.max(ctx.lineWidth * 1.5, 2.5);\n      for (i = 0; i < verts.length - 1; i += 1) {\n        this._transformedVerts[i + 1] = [0, 0];\n        Point2d.transformMat2d(this._transformedVerts[i + 1], verts[i + 1], objToScreenMatrix);\n        Point2d.sub(tmpVec, this._transformedVerts[i + 1], this._transformedVerts[i]);\n        _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n        Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n\n        ctx.moveTo(tmpPt[0] + radius, tmpPt[1]);\n        ctx.arc(tmpPt[0], tmpPt[1], radius, 0, Math.TWO_PI);\n      }\n\n      if (i > 0) {\n        Point2d.sub(tmpVec, this._transformedVerts[0], this._transformedVerts[i]);\n        _glMatrix.vec2.scale(tmpVec, tmpVec, 0.5);\n        Point2d.addVec2(tmpPt, this._transformedVerts[i], tmpVec);\n        ctx.moveTo(tmpPt[0] + radius, tmpPt[1]);\n        ctx.arc(tmpPt[0], tmpPt[1], radius, 0, Math.TWO_PI);\n\n        // TODO(croot): Is this appropriate? Can the fill/stroke style\n        // be cross compatible? What about gradients/patterns?\n        // We can probably safely assume no gradients/patterns at\n        // this point\n        ctx.fillStyle = ctx.strokeStyle;\n        ctx.fill();\n      }\n\n      ctx.beginPath();\n\n      this._transformedVerts.forEach(function (vert) {\n        ctx.moveTo(vert[0] + _this2._vertRadius, vert[1]);\n        ctx.arc(vert[0], vert[1], _this2._vertRadius, 0, Math.TWO_PI);\n      });\n\n      if (this.isFillVisible()) {\n        this.setFillCtx(ctx);\n        ctx.fill();\n      }\n\n      if (this.isStrokeVisible()) {\n        this.setStrokeCtx(ctx);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }]);\n\n  return VertEditableShape;\n}(_baseShape2.default);\n\nexports.default = VertEditableShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMvdmVydC1lZGl0YWJsZS1zaGFwZS5qcz80ZWQzIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJQb2ludDJkIiwiVmVydEVkaXRhYmxlU2hhcGUiLCJiYXNlVmVydFNoYXBlIiwib3B0cyIsIl9iYXNlVmVydFNoYXBlIiwiX3ZlcnRSYWRpdXMiLCJfdHJhbnNmb3JtZWRWZXJ0cyIsIl9iYXNlYWFib3giLCJjcmVhdGUiLCJfd29ybGRUb1NjcmVlbk1hdHJpeCIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJhYWJveCIsImVxdWFscyIsImNvcHkiLCJ0cmFuc2Zvcm1NYXQyZCIsIl9hYWJveCIsInBhZCIsInN0cm9rZVdpZHRoIiwiZXhwYW5kIiwic2NyZWVuUHQiLCJ3b3JsZFB0IiwiY3R4IiwicnRuT2JqIiwiaGl0IiwiY29udHJvbEluZGV4IiwiX3VwZGF0ZUFBQm94IiwidmlzaWJsZSIsImNvbnRhaW5zUHQiLCJleHRlbnRzIiwiaSIsImxlbmd0aCIsImluaXRDZW50ZXJFeHRlbnRzIiwidG1wUHQiLCJ0bXBWZWMiLCJyYWRpdXMiLCJsaW5lV2lkdGgiLCJzZXQiLCJzdWIiLCJzY2FsZSIsImFkZFZlYzIiLCJib3VuZHNTdHJva2VTdHlsZSIsInNhdmUiLCJzZXRUcmFuc2Zvcm0iLCJzZXRTdHJva2VDdHgiLCJjZW50ZXIiLCJnZXRDZW50ZXIiLCJnZXRFeHRlbnRzIiwiYmVnaW5QYXRoIiwicmVjdCIsInN0cm9rZSIsInJlc3RvcmUiLCJzdHlsZVN0YXRlIiwib2JqVG9TY3JlZW5NYXRyaXgiLCJfZnVsbFhmb3JtIiwidmVydHMiLCJ2ZXJ0c1JlZiIsIkFycmF5IiwiTWF0aCIsIm1heCIsIm1vdmVUbyIsImFyYyIsIlRXT19QSSIsImZpbGxTdHlsZSIsInN0cm9rZVN0eWxlIiwiZmlsbCIsImZvckVhY2giLCJ2ZXJ0IiwiaXNGaWxsVmlzaWJsZSIsInNldEZpbGxDdHgiLCJpc1N0cm9rZVZpc2libGUiXSwibWFwcGlu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QyxZQUFJMkMsSUFBSjtBQUNEOztBQUVEM0MsVUFBSTBCLFNBQUo7O0FBRUEsV0FBS3pDLGlCQUFMLENBQXVCMkQsT0FBdkIsQ0FBK0IsZ0JBQVE7QUFDckM1QyxZQUFJc0MsTUFBSixDQUFXTyxLQUFLLENBQUwsSUFBVSxPQUFLN0QsV0FBMUIsRUFBdUM2RCxLQUFLLENBQUwsQ0FBdkM7QUFDQTdDLFlBQUl1QyxHQUFKLENBQVFNLEtBQUssQ0FBTCxDQUFSLEVBQWlCQSxLQUFLLENBQUwsQ0FBakIsRUFBMEIsT0FBSzdELFdBQS9CLEVBQTRDLENBQTVDLEVBQStDb0QsS0FBS0ksTUFBcEQ7QUFDRCxPQUhEOztBQUtBLFVBQUksS0FBS00sYUFBTCxFQUFKLEVBQTBCO0FBQ3hCLGFBQUtDLFVBQUwsQ0FBZ0IvQyxHQUFoQjtBQUNBQSxZQUFJMkMsSUFBSjtBQUNEOztBQUVELFVBQUksS0FBS0ssZUFBTCxFQUFKLEVBQTRCO0FBQzFCLGFBQUsxQixZQUFMLENBQWtCdEIsR0FBbEI7QUFDQUEsWUFBSTRCLE1BQUo7QUFDRDs7QUFFRDVCLFVBQUk2QixPQUFKO0FBQ0Q7Ozs7OztrQkE3SmtCakQsaUIiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0ICogYXMgUG9pbnQyZCBmcm9tIFwiLi4vY29yZS9wb2ludDJkXCJcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSBcIi4uL3NoYXBlcy9iYXNlLXNoYXBlXCJcbmltcG9ydCB7XG4gIG1hdDJkIGFzIE1hdDJkLFxuICB2ZWMyIGFzIFZlYzJkXG59IGZyb20gXCJnbC1tYXRyaXhcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZXJ0RWRpdGFibGVTaGFwZSBleHRlbmRzIEJhc2VTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKGJhc2VWZXJ0U2hhcGUsIG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX2Jhc2VWZXJ0U2hhcGUgPSBiYXNlVmVydFNoYXBlXG4gICAgdGhpcy5fdmVydFJhZGl1cyA9IDRcbiAgICB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzID0gW11cbiAgICB0aGlzLl9iYXNlYWFib3ggPSBBQUJveDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG4gIH1cblxuICBfdXBkYXRlQUFCb3god29ybGRUb1NjcmVlbk1hdHJpeCkge1xuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5fYmFzZVZlcnRTaGFwZS5hYWJveFxuICAgIGlmICghQUFCb3gyZC5lcXVhbHMoYWFib3gsIHRoaXMuX2Jhc2VhYWJveCkgfHwgIU1hdDJkLmVxdWFscyh3b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4KSkge1xuICAgICAgQUFCb3gyZC5jb3B5KHRoaXMuX2Jhc2VhYWJveCwgYWFib3gpXG4gICAgICBNYXQyZC5jb3B5KHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXgsIHdvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICBBQUJveDJkLnRyYW5zZm9ybU1hdDJkKHRoaXMuX2FhYm94LCB0aGlzLl9iYXNlYWFib3gsIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICBjb25zdCBwYWQgPSB0aGlzLl92ZXJ0UmFkaXVzICsgdGhpcy5zdHJva2VXaWR0aFxuICAgICAgQUFCb3gyZC5leHBhbmQodGhpcy5fYWFib3gsIHRoaXMuX2FhYm94LCBbcGFkLCBwYWRdKVxuICAgIH1cbiAgfVxuXG4gIGNvbnRhaW5zUG9pbnQoc2NyZWVuUHQsIHdvcmxkUHQsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIGN0eCkge1xuICAgIC8vIFNob3VsZCB3ZSB1cGRhdGUgaGVyZSwgb3IgaXMgaXQgc2FmZSB0b1xuICAgIC8vIHNheSB0aGF0IHRoaXMgaXMgc3RhdGVmdWwsIG1lYW5pbmcgYSByZW5kZXJcbiAgICAvLyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCBiZWZvcmVoYW5kIHdoaWNoXG4gICAgLy8gd291bGQndmUgdXBkYXRlZCBpdHMgc3RhdGVcbiAgICBjb25zdCBydG5PYmogPSB7XG4gICAgICBoaXQ6IGZhbHNlLFxuICAgICAgY29udHJvbEluZGV4OiAtMVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUFBQm94KHdvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgaWYgKHRoaXMudmlzaWJsZSAmJiBBQUJveDJkLmNvbnRhaW5zUHQodGhpcy5fYWFib3gsIHNjcmVlblB0KSkge1xuICAgICAgY29uc3QgYWFib3ggPSBBQUJveDJkLmNyZWF0ZSgpXG4gICAgICBjb25zdCBwYWQgPSB0aGlzLl92ZXJ0UmFkaXVzICsgdGhpcy5zdHJva2VXaWR0aCAvIDJcbiAgICAgIGNvbnN0IGV4dGVudHMgPSBbcGFkLCBwYWRdXG5cbiAgICAgIGxldCBpID0gMFxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3RyYW5zZm9ybWVkVmVydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgQUFCb3gyZC5pbml0Q2VudGVyRXh0ZW50cyhhYWJveCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgZXh0ZW50cylcbiAgICAgICAgaWYgKEFBQm94MmQuY29udGFpbnNQdChhYWJveCwgc2NyZWVuUHQpKSB7XG4gICAgICAgICAgcnRuT2JqLmhpdCA9IHRydWVcbiAgICAgICAgICBydG5PYmouY29udHJvbEluZGV4ID0gaVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFydG5PYmouaGl0KSB7XG4gICAgICAgIGNvbnN0IHRtcFB0ID0gWzAsIDBdXG4gICAgICAgIGNvbnN0IHRtcFZlYyA9IFswLCAwXVxuICAgICAgICBjb25zdCByYWRpdXMgPSBjdHgubGluZVdpZHRoICogMS41XG4gICAgICAgIFZlYzJkLnNldChleHRlbnRzLCByYWRpdXMsIHJhZGl1cylcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX3RyYW5zZm9ybWVkVmVydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgICAgUG9pbnQyZC5zdWIodG1wVmVjLCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2kgKyAxXSwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSlcbiAgICAgICAgICBWZWMyZC5zY2FsZSh0bXBWZWMsIHRtcFZlYywgMC41KVxuICAgICAgICAgIFBvaW50MmQuYWRkVmVjMih0bXBQdCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgdG1wVmVjKVxuICAgICAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHMoYWFib3gsIHRtcFB0LCBleHRlbnRzKVxuICAgICAgICAgIGlmIChBQUJveDJkLmNvbnRhaW5zUHQoYWFib3gsIHNjcmVlblB0KSkge1xuICAgICAgICAgICAgcnRuT2JqLmhpdCA9IHRydWVcbiAgICAgICAgICAgIHJ0bk9iai5jb250cm9sSW5kZXggPSB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aCArIGlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPT09IHRoaXMuX3RyYW5zZm9ybWVkVmVydHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIFBvaW50MmQuc3ViKHRtcFZlYywgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1swXSwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSlcbiAgICAgICAgICBWZWMyZC5zY2FsZSh0bXBWZWMsIHRtcFZlYywgMC41KVxuICAgICAgICAgIFBvaW50MmQuYWRkVmVjMih0bXBQdCwgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpXSwgdG1wVmVjKVxuICAgICAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHMoYWFib3gsIHRtcFB0LCBleHRlbnRzKVxuICAgICAgICAgIGlmIChBQUJveDJkLmNvbnRhaW5zUHQoYWFib3gsIHNjcmVlblB0KSkge1xuICAgICAgICAgICAgcnRuT2JqLmhpdCA9IHRydWVcbiAgICAgICAgICAgIHJ0bk9iai5jb250cm9sSW5kZXggPSB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzLmxlbmd0aCArIGlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnRuT2JqXG4gIH1cblxuICByZW5kZXJCb3VuZHMoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBib3VuZHNTdHJva2VTdHlsZSkge1xuICAgIC8vIHdlJ3JlIHN0b3Jpbmcgb3VyIEFBQm94IGluIHNjcmVlbiBzcGFjZSBoZXJlLCBzbyB3b3JsZFRvU2NyZWVuTWF0cml4IGlzXG4gICAgLy8gdW51c2VkXG4gICAgdGhpcy5fdXBkYXRlQUFCb3god29ybGRUb1NjcmVlbk1hdHJpeClcbiAgICBjdHguc2F2ZSgpXG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgIGJvdW5kc1N0cm9rZVN0eWxlLnNldFN0cm9rZUN0eChjdHgpXG4gICAgY29uc3QgY2VudGVyID0gWzAsIDBdXG4gICAgY29uc3QgZXh0ZW50cyA9IFswLCAwXVxuICAgIEFBQm94MmQuZ2V0Q2VudGVyKGNlbnRlciwgdGhpcy5fYWFib3gpXG4gICAgQUFCb3gyZC5nZXRFeHRlbnRzKGV4dGVudHMsIHRoaXMuX2FhYm94KVxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGN0eC5yZWN0KGNlbnRlclswXSAtIGV4dGVudHNbMF0sIGNlbnRlclsxXSAtIGV4dGVudHNbMV0sIGV4dGVudHNbMF0gKiAyLCBleHRlbnRzWzFdICogMilcbiAgICBjdHguc3Ryb2tlKClcbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cblxuICByZW5kZXIoY3R4LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBzdHlsZVN0YXRlKSB7XG4gICAgY3R4LnNhdmUoKVxuXG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICAgIGNvbnN0IG9ialRvU2NyZWVuTWF0cml4ID0gdGhpcy5fYmFzZVZlcnRTaGFwZS5fZnVsbFhmb3JtXG4gICAgY29uc3QgdmVydHMgPSB0aGlzLl9iYXNlVmVydFNoYXBlLnZlcnRzUmVmXG4gICAgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0cyA9IG5ldyBBcnJheSh2ZXJ0cy5sZW5ndGgpXG4gICAgY29uc3QgdG1wUHQgPSBbMCwgMF1cbiAgICBjb25zdCB0bXBWZWMgPSBbMCwgMF1cblxuICAgIGN0eC5iZWdpblBhdGgoKVxuICAgIGxldCBpID0gMFxuICAgIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0gPSBbMCwgMF1cbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0sIHZlcnRzW2ldLCBvYmpUb1NjcmVlbk1hdHJpeClcblxuICAgIGNvbnN0IHJhZGl1cyA9IE1hdGgubWF4KGN0eC5saW5lV2lkdGggKiAxLjUsIDIuNSlcbiAgICBmb3IgKGkgPSAwOyBpIDwgdmVydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2kgKyAxXSA9IFswLCAwXVxuICAgICAgUG9pbnQyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2kgKyAxXSwgdmVydHNbaSArIDFdLCBvYmpUb1NjcmVlbk1hdHJpeClcbiAgICAgIFBvaW50MmQuc3ViKHRtcFZlYywgdGhpcy5fdHJhbnNmb3JtZWRWZXJ0c1tpICsgMV0sIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0pXG4gICAgICBWZWMyZC5zY2FsZSh0bXBWZWMsIHRtcFZlYywgMC41KVxuICAgICAgUG9pbnQyZC5hZGRWZWMyKHRtcFB0LCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldLCB0bXBWZWMpXG5cbiAgICAgIGN0eC5tb3ZlVG8odG1wUHRbMF0gKyByYWRpdXMsIHRtcFB0WzFdKVxuICAgICAgY3R4LmFyYyh0bXBQdFswXSwgdG1wUHRbMV0sIHJhZGl1cywgMCwgTWF0aC5UV09fUEkpXG4gICAgfVxuXG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBQb2ludDJkLnN1Yih0bXBWZWMsIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbMF0sIHRoaXMuX3RyYW5zZm9ybWVkVmVydHNbaV0pXG4gICAgICBWZWMyZC5zY2FsZSh0bXBWZWMsIHRtcFZlYywgMC41KVxuICAgICAgUG9pbnQyZC5hZGRWZWMyKHRtcFB0LCB0aGlzLl90cmFuc2Zvcm1lZFZlcnRzW2ldLCB0bXBWZWMpXG4gICAgICBjdHgubW92ZVRvKHRtcFB0WzBdICsgcmFkaXVzLCB0bXBQdFsxXSlcbiAgICAgIGN0eC5hcmModG1wUHRbMF0sIHRtcFB0WzFdLCByYWRpdXMsIDAsIE1hdGguVFdPX1BJKVxuXG4gICAgICAvLyBUT0RPKGNyb290KTogSXMgdGhpcyBhcHByb3ByaWF0ZT8gQ2FuIHRoZSBmaWxsL3N0cm9rZSBzdHlsZVxuICAgICAgLy8gYmUgY3Jvc3MgY29tcGF0aWJsZT8gV2hhdCBhYm91dCBncmFkaWVudHMvcGF0dGVybnM/XG4gICAgICAvLyBXZSBjYW4gcHJvYmFibHkgc2FmZWx5IGFzc3VtZSBubyBncmFkaWVudHMvcGF0dGVybnMgYXRcbiAgICAgIC8vIHRoaXMgcG9pbnRcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBjdHguc3Ryb2tlU3R5bGVcbiAgICAgIGN0eC5maWxsKClcbiAgICB9XG5cbiAgICBjdHguYmVnaW5QYXRoKClcblxuICAgIHRoaXMuX3RyYW5zZm9ybWVkVmVydHMuZm9yRWFjaCh2ZXJ0ID0+IHtcbiAgICAgIGN0eC5tb3ZlVG8odmVydFswXSArIHRoaXMuX3ZlcnRSYWRpdXMsIHZlcnRbMV0pXG4gICAgICBjdHguYXJjKHZlcnRbMF0sIHZlcnRbMV0sIHRoaXMuX3ZlcnRSYWRpdXMsIDAsIE1hdGguVFdPX1BJKVxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5pc0ZpbGxWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuc2V0RmlsbEN0eChjdHgpXG4gICAgICBjdHguZmlsbCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTdHJva2VWaXNpYmxlKCkpIHtcbiAgICAgIHRoaXMuc2V0U3Ryb2tlQ3R4KGN0eClcbiAgICAgIGN0eC5zdHJva2UoKVxuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKClcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vaW50ZXJhY3Rpb25zL3ZlcnQtZWRpdGFibGUtc2hhcGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _transform2d = __webpack_require__(14);\n\nvar _mat2d = __webpack_require__(7);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _rect = __webpack_require__(17);\n\nvar _rect2 = _interopRequireDefault(_rect);\n\nvar _vec2d = __webpack_require__(11);\n\nvar _vec2d2 = _interopRequireDefault(_vec2d);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction drawOBBoxModifierRect(ctx, pt, objToScreenMat, modifierSize, modifierHalfSize, modifierRotation, scale, text) {\n  Point2d.transformMat2d(pt, pt, objToScreenMat);\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.translate(pt[0], pt[1]);\n  ctx.rotate(modifierRotation[1]);\n  ctx.scale(scale[0], scale[1]);\n  ctx.rotate(modifierRotation[0]);\n  ctx.translate(-pt[0], -pt[1]);\n  ctx.rect(pt[0] - modifierHalfSize, pt[1] - modifierHalfSize, modifierSize, modifierSize);\n\n  // ctx.moveTo(pt[0], pt[1])\n  // ctx.lineTo(pt[0], pt[1] + 20)\n  // ctx.moveTo(pt[0], pt[1])\n  // ctx.lineTo(pt[0] + 20, pt[1])\n\n  // ctx.font = \"24px serif\"\n  // ctx.fillText(text, pt[0], pt[1])\n}\n\nfunction isPointInOBBoxModifierRect(screenPt, modifierPt, objToScreenMat, modifierMat, halfBoxSz, boxSz, padBoxSz, padBoxRadius, xScale, yScale) {\n  var hit = false;\n  var rotate = false;\n  Point2d.transformMat2d(modifierPt, modifierPt, objToScreenMat);\n  if (Point2d.distance(modifierPt, screenPt) <= padBoxRadius) {\n    _vec2d2.default.negate(modifierPt, modifierPt);\n    modifierMat[4] = modifierMat[0] * modifierPt[0] + modifierMat[2] * modifierPt[1];\n    modifierMat[5] = modifierMat[1] * modifierPt[0] + modifierMat[3] * modifierPt[1];\n\n    var x = 0;\n    var y = 0;\n    Point2d.transformMat2d(modifierPt, screenPt, modifierMat);\n    if (Math.abs(modifierPt[0]) <= halfBoxSz && Math.abs(modifierPt[1]) <= halfBoxSz || Boolean(xScale) && Boolean(yScale) && (rotate = (x = xScale * modifierPt[0]) > -halfBoxSz && x <= padBoxSz && (y = yScale * modifierPt[1]) > -halfBoxSz && y <= padBoxSz)) {\n      hit = true;\n    }\n  }\n  return {\n    hit: hit,\n    rotate: rotate\n  };\n}\n\nvar XformShape = function (_Rect) {\n  _inherits(XformShape, _Rect);\n\n  function XformShape(opts) {\n    var selectOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      scalable: true,\n      rotatable: true\n    };\n\n    _classCallCheck(this, XformShape);\n\n    var _this = _possibleConstructorReturn(this, (XformShape.__proto__ || Object.getPrototypeOf(XformShape)).call(this, opts));\n\n    _this._interactiveBoxSize = 8;\n    _this._interactiveBoxPadding = 10;\n    if (opts && typeof opts.vertexSize !== \"undefined\") {\n      _this._interactiveBoxSize = opts.vertexSize;\n    }\n\n    _this._scalable = true;\n    _this._rotatable = true;\n    if (selectOpts) {\n      if (typeof selectOpts.scalable !== \"undefined\") {\n        _this._scalable = Boolean(selectOpts.scalable);\n      }\n\n      if (typeof selectOpts.rotatable !== \"undefined\") {\n        _this._rotatable = Boolean(selectOpts.rotatable);\n      }\n    }\n    return _this;\n  }\n\n  _createClass(XformShape, [{\n    key: \"containsPoint\",\n    value: function containsPoint(screenPt, worldPt, worldToScreenMatrix, ctx) {\n      // Should we update here, or is it safe to\n      // say that this is stateful, meaning a render\n      // should have been performed beforehand which\n      // would've updated its state\n      var rtnObj = {\n        hit: false,\n        rotate: false,\n        controlIndex: -1\n      };\n\n      var aabox = this.aabox;\n      if ((this._rotatable || this._scalable) && this.visible && AABox2d.containsPt(aabox, screenPt)) {\n        var scale = [0, 0];\n        var rot = [0, 0];\n        _mat2d2.default.svd(null, scale, rot, this._fullXform);\n        var mat = _mat2d2.default.create();\n\n        scale[0] = scale[0] < 0 ? -1 : 1;\n        scale[1] = scale[1] < 0 ? -1 : 1;\n\n        if (scale[0] * scale[1] > 0) {\n          _vec2d2.default.negate(rot, rot);\n        }\n\n        _mat2d2.default.rotate(mat, mat, rot[1]);\n        _mat2d2.default.scale(mat, mat, scale);\n        _mat2d2.default.rotate(mat, mat, rot[0]);\n\n        var boxPadding = this._rotatable ? this._interactiveBoxPadding : 0;\n        var halfBoxSz = this._interactiveBoxSize / 2;\n        var halfWidth = this.width / 2;\n        var halfHeight = this.height / 2;\n        var pt = [0, 0];\n        var padSz = halfBoxSz + boxPadding;\n        var padRadius = Math.sqrt(2 * padSz * padSz);\n        var xScale = 0;\n        var yScale = 0;\n\n        for (var i = 0; i < 4; i += 1) {\n          xScale = i < 2 ? -1 : 1;\n          yScale = i % 2 === 0 ? -1 : 1;\n          Point2d.set(pt, xScale * halfWidth, yScale * halfHeight);\n          rtnObj = isPointInOBBoxModifierRect(screenPt, pt, this._fullXform, mat, halfBoxSz, this._interactiveBoxSize, padSz, padRadius, xScale, yScale, scale);\n          if (rtnObj.hit) {\n            rtnObj.controlIndex = i;\n            break;\n          }\n        }\n\n        if (!rtnObj.hit && this._scalable) {\n          for (var _i = 0; _i < 4; _i += 1) {\n            xScale = _i % 2 === 0 ? _i < 2 ? -1 : 1 : 0;\n            yScale = _i % 2 === 0 ? 0 : _i < 2 ? -1 : 1;\n            Point2d.set(pt, xScale * halfWidth, yScale * halfHeight);\n            rtnObj = isPointInOBBoxModifierRect(screenPt, pt, this._fullXform, mat, halfBoxSz, this._interactiveBoxSize, padSz, padRadius, xScale, yScale, scale);\n            if (rtnObj.hit) {\n              rtnObj.controlIndex = _i + 4;\n              break;\n            }\n          }\n        }\n\n        if (rtnObj.rotate && !this._rotatable) {\n          rtnObj.rotate = false;\n        } else if (!rtnObj.rotate && !this._scalable) {\n          rtnObj.rotate = true;\n        }\n      }\n\n      return rtnObj;\n    }\n  }, {\n    key: \"_updatelocalxform\",\n    value: function _updatelocalxform(force) {\n      if (this._lxformDirty || force) {\n        var pos = Point2d.clone(this._pos);\n        Point2d.addVec2(pos, pos, this._parent.pivotRef);\n        (0, _transform2d.buildXformMatrix)(this._localXform, this._rotDeg, this._scale, pos, this._pivot);\n        if (this._localXformUpdated) {\n          this._localXformUpdated();\n        }\n        this._lxformDirty = false;\n      }\n    }\n  }, {\n    key: \"_updateglobalxform\",\n    value: function _updateglobalxform() {\n      if (this._lxformDirty || this._xformDirty) {\n        this._updatelocalxform(true);\n        if (this._parent) {\n          _mat2d2.default.multiply(this._globalXform, this._parent.globalXform, this._localXform);\n        } else {\n          _mat2d2.default.copy(this._globalXform, this._localXform);\n        }\n        if (this._globalXformUpdated) {\n          this._globalXformUpdated();\n        }\n        this._xformDirty = false;\n      }\n    }\n  }, {\n    key: \"_updateAABox\",\n    value: function _updateAABox() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (force || this._geomDirty || this._boundsOutOfDate) {\n        var boxPadding = this._rotatable ? this._interactiveBoxPadding : 0;\n        var padding = boxPadding + this._interactiveBoxSize / 2;\n        AABox2d.initCenterExtents(this._aabox, [0, 0], [this.width / 2, this.height / 2]);\n        AABox2d.transformMat2d(this._aabox, this._aabox, this._fullXform);\n        AABox2d.expand(this._aabox, this._aabox, [padding, padding]);\n        this._aaboxUpdated = true;\n        this._geomDirty = this._boundsOutOfDate = false;\n      }\n    }\n  }, {\n    key: \"renderBounds\",\n    value: function renderBounds(ctx, worldToScreenMatrix, boundsStrokeStyle) {\n      // we're storing our AABox in screen space here, so worldToScreenMatrix is\n      // unused\n      var aabox = this.aabox;\n      ctx.save();\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      boundsStrokeStyle.setStrokeCtx(ctx);\n      var center = [0, 0];\n      var extents = [0, 0];\n      AABox2d.getCenter(center, aabox);\n      AABox2d.getExtents(extents, aabox);\n      ctx.beginPath();\n      ctx.rect(center[0] - extents[0], center[1] - extents[1], extents[0] * 2, extents[1] * 2);\n      ctx.stroke();\n      ctx.restore();\n    }\n  }, {\n    key: \"render\",\n    value: function render(ctx, worldToScreenMatrix, styleState) {\n      if (!this.parent || typeof this.parent.width === \"undefined\" || this.parent.height === \"undefined\") {\n        return;\n      }\n\n      this._aaboxUpdated = false;\n      // do not fill the primary rectangle\n      _get(XformShape.prototype.__proto__ || Object.getPrototypeOf(XformShape.prototype), \"render\", this).call(this, ctx, worldToScreenMatrix, styleState, false);\n      if (!this._aaboxUpdated) {\n        this._updateAABox(true);\n      }\n\n      var scale = [0, 0];\n      var rot = [0, 0];\n      _mat2d2.default.svd(null, scale, rot, this._fullXform);\n      scale[0] = scale[0] < 0 ? -1 : 1;\n      scale[1] = scale[1] < 0 ? -1 : 1;\n\n      var halfBoxSz = this._interactiveBoxSize / 2;\n      var halfWidth = this.width / 2;\n      var halfHeight = this.height / 2;\n      var pt = [halfWidth, halfHeight];\n\n      ctx.save();\n\n      ctx.beginPath();\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"3\");\n\n      Point2d.set(pt, halfWidth, -halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"2\");\n\n      Point2d.set(pt, -halfWidth, -halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"0\");\n\n      Point2d.set(pt, -halfWidth, halfHeight);\n      drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale, \"1\");\n\n      if (this._scalable) {\n        Point2d.set(pt, 0, halfHeight);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, 0, -halfHeight);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, halfWidth, 0);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n\n        Point2d.set(pt, -halfWidth, 0);\n        drawOBBoxModifierRect(ctx, pt, this._fullXform, this._interactiveBoxSize, halfBoxSz, rot, scale);\n      }\n\n      if (this.isFillVisible()) {\n        styleState.setFillStyle(ctx, this);\n        ctx.fill();\n      }\n\n      if (this.isStrokeVisible()) {\n        styleState.setStrokeStyle(ctx, this);\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.parent && this.parent.width !== \"undefined\" ? this.parent.width : 0;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.parent && this.parent.height !== \"undefined\" ? this.parent.height : 0;\n    }\n  }]);\n\n  return XformShape;\n}(_rect2.default);\n\nexports.default = XformShape;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbnRlcmFjdGlvbnMveGZvcm0tc2hhcGUuanM/MmU2MyJdLCJuYW1lcyI6WyJBQUJveDJkIiwiUG9pbnQyZCIsImRyYXdPQkJveE1vZGlmaWVyUmVjdCIsImN0eCIsInB0Iiwib2JqVG9TY3JlZW5NYXQiLCJtb2RpZmllclNpemUiLCJtb2RpZmllckhhbGZTaXplIiwibW9kaWZpZXJSb3RhdGlvbiIsInNjYWxlIiwidGV4dCIsInRyYW5zZm9ybU1hdDJkIiwic2V0VHJhbnNmb3JtIiwidHJhbnNsYXRlIiwicm90YXRlIiwicmVjdCIsImlzUG9pbnRJbk9CQm94TW9kaWZpZXJSZWN0Iiwic2NyZWVuUHQiLCJtb2RpZmllclB0IiwibW9kaWZpZXJNYXQiLCJoYWxmQm94U3oiLCJib3hTeiIsInBhZEJveFN6IiwicGFkQm94UmFkaXVzIiwieFNjYWxlIiwieVNjYWxlIiwiaGl0IiwiZGlzdGFuY2UiLCJuZWdhdGUiLCJ4IiwieSIsIk1hdGgiLCJhYnMiLCJCb29sZWFuIiwiWGZvcm1TaGFwZSIsIm9wdHMiLCJzZWxlY3RPcHRzIiwic2NhbGFibGUiLCJyb3RhdGFibGUiLCJfaW50ZXJhY3RpdmVCb3hTaXplIiwiX2ludGVyYWN0aXZlQm94UGFkZGluZyIsInZlcnRleFNpemUiLCJfc2NhbGFibGUiLCJfcm90YXRhYmxlIiwid29ybGRQdCIsIndvcmxkVG9TY3JlZW5NYXRyaXgiLCJydG5PYmoiLCJjb250cm9sSW5kZXgiLCJhYWJveCIsInZpc2libGUiLCJjb250YWluc1B0Iiwicm90Iiwic3ZkIiwiX2Z1bGxYZm9ybSIsIm1hdCIsImNyZWF0ZSIsImJveFBhZGRpbmciLCJoYWxmV2lkdGgiLCJ3aWR0aCIsImhhbGZIZWlnaHQiLCJoZWlnaHQiLCJwYWRTeiIsInBhZFJhZGl1cyIsInNxcnQiLCJpIiwic2V0IiwiZm9yY2UiLCJfbHhmb3JtRGlydHkiLCJwb3MiLCJjbG9uZSIsIl9wb3MiLCJhZGRWZWMyIiwiX3BhcmVudCIsInBpdm90UmVmIiwiX2xvY2FsWGZvcm0iLCJfcm90RGVnIiwiX3NjYWxlIiwiX3Bpdm90IiwiX2xvY2FsWGZvcm1VcGRhdGVkIiwiX3hmb3JtRGlydHkiLCJfdXBkYXRlbG9jYWx4Zm9ybSIsIm11bHRpcGx5IiwiX2dsb2JhbFhmb3JtIiwiZ2xvYmFsWGZvcm0iLCJjb3B5IiwiX2dsb2JhbFhmb3JtVXBkYXRlZCIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwicGFkZGluZyIsImluaXRDZW50ZXJFeHRlbnRzIiwiX2FhYm94IiwiZXhwYW5kIiwiX2FhYm94VXBkYXRlZCIsImJvdW5kc1N0cm9rZVN0eWxlIiwic2F2ZSIsInNldFN0cm9rZUN0eCIsImNlbnRlciIsImV4dGVudHMiLCJnZXRDZW50ZXIiLCJnZXRFeHRlbnRzIiwiYmVnaW5QYXRoIiwic3Ryb2tlIiwicmVzdG9yZSIsInN0eWxlU3RhdGUiLCJwYXJlbnQiLCJfdXBkYXRlQUFCb3giLCJpc0ZpbGxWaXNpYmxlIiwic2V0RmlsbFN0eWxlIiwiZmlsbCIsImlzU3Ryb2tlVmlzaWJsZSIsInNldFN0cm9rZVN0eWxlIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOztJQUFZQyxPOztBQUNaOztBQUdBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxTQUFTQyxxQkFBVCxDQUErQkMsR0FBL0IsRUFBb0NDLEVBQXBDLEVBQXdDQyxjQUF4QyxFQUF3REMsWUFBeEQsRUFBc0VDLGdCQUF0RSxFQUF3RkMsZ0JBQXhGLEVBQTBHQyxLQUExRyxFQUFpSEMsSUFBakgsRUFBdUg7QUFDckhULFVBQVFVLGNBQVIsQ0FBdUJQLEVBQXZCLEVBQTJCQSxFQUEzQixFQUErQkMsY0FBL0I7QUFDQUYsTUFBSVMsWUFBSixDQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxDQUFoQztBQUNBVCxNQUFJVSxTQUFKLENBQWNULEdBQUcsQ0FBSCxD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QVgsQ0FBMEIzRyxHQUExQixFQUErQixJQUEvQjtBQUNBQSxZQUFJUyxZQUFKLENBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLENBQTdCLEVBQWdDLENBQWhDO0FBQ0FULFlBQUlrRyxNQUFKO0FBQ0Q7O0FBRURsRyxVQUFJbUcsT0FBSjtBQUNEOzs7d0JBeEZXO0FBQ1YsYUFBUSxLQUFLRSxNQUFMLElBQWUsS0FBS0EsTUFBTCxDQUFZOUMsS0FBWixLQUFzQixXQUFyQyxHQUFtRCxLQUFLOEMsTUFBTCxDQUFZOUMsS0FBL0QsR0FBdUUsQ0FBL0U7QUFDRDs7O3dCQUVZO0FBQ1gsYUFBUSxLQUFLOEMsTUFBTCxJQUFlLEtBQUtBLE1BQUwsQ0FBWTVDLE1BQVosS0FBdUIsV0FBdEMsR0FBb0QsS0FBSzRDLE1BQUwsQ0FBWTVDLE1BQWhFLEdBQXlFLENBQWpGO0FBQ0Q7Ozs7OztrQkFoSmtCMUIsVSIsImZpbGUiOiIyNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IHtcbiAgYnVpbGRYZm9ybU1hdHJpeFxufSBmcm9tIFwiLi4vc2hhcGVzL3RyYW5zZm9ybTJkXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgUmVjdCBmcm9tIFwiLi4vc2hhcGVzL3JlY3RcIlxuaW1wb3J0IFZlYzJkIGZyb20gXCIuLi9jb3JlL3ZlYzJkXCJcblxuZnVuY3Rpb24gZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIG9ialRvU2NyZWVuTWF0LCBtb2RpZmllclNpemUsIG1vZGlmaWVySGFsZlNpemUsIG1vZGlmaWVyUm90YXRpb24sIHNjYWxlLCB0ZXh0KSB7XG4gIFBvaW50MmQudHJhbnNmb3JtTWF0MmQocHQsIHB0LCBvYmpUb1NjcmVlbk1hdClcbiAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKVxuICBjdHgudHJhbnNsYXRlKHB0WzBdLCBwdFsxXSlcbiAgY3R4LnJvdGF0ZShtb2RpZmllclJvdGF0aW9uWzFdKVxuICBjdHguc2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdKVxuICBjdHgucm90YXRlKG1vZGlmaWVyUm90YXRpb25bMF0pXG4gIGN0eC50cmFuc2xhdGUoLXB0WzBdLCAtcHRbMV0pXG4gIGN0eC5yZWN0KHB0WzBdIC0gbW9kaWZpZXJIYWxmU2l6ZSwgcHRbMV0gLSBtb2RpZmllckhhbGZTaXplLCBtb2RpZmllclNpemUsIG1vZGlmaWVyU2l6ZSlcblxuICAvLyBjdHgubW92ZVRvKHB0WzBdLCBwdFsxXSlcbiAgLy8gY3R4LmxpbmVUbyhwdFswXSwgcHRbMV0gKyAyMClcbiAgLy8gY3R4Lm1vdmVUbyhwdFswXSwgcHRbMV0pXG4gIC8vIGN0eC5saW5lVG8ocHRbMF0gKyAyMCwgcHRbMV0pXG5cbiAgLy8gY3R4LmZvbnQgPSBcIjI0cHggc2VyaWZcIlxuICAvLyBjdHguZmlsbFRleHQodGV4dCwgcHRbMF0sIHB0WzFdKVxufVxuXG5mdW5jdGlvbiBpc1BvaW50SW5PQkJveE1vZGlmaWVyUmVjdChzY3JlZW5QdCwgbW9kaWZpZXJQdCwgb2JqVG9TY3JlZW5NYXQsIG1vZGlmaWVyTWF0LCBoYWxmQm94U3osIGJveFN6LCBwYWRCb3hTeiwgcGFkQm94UmFkaXVzLCB4U2NhbGUsIHlTY2FsZSkge1xuICBsZXQgaGl0ID0gZmFsc2VcbiAgbGV0IHJvdGF0ZSA9IGZhbHNlXG4gIFBvaW50MmQudHJhbnNmb3JtTWF0MmQobW9kaWZpZXJQdCwgbW9kaWZpZXJQdCwgb2JqVG9TY3JlZW5NYXQpXG4gIGlmIChQb2ludDJkLmRpc3RhbmNlKG1vZGlmaWVyUHQsIHNjcmVlblB0KSA8PSBwYWRCb3hSYWRpdXMpIHtcbiAgICBWZWMyZC5uZWdhdGUobW9kaWZpZXJQdCwgbW9kaWZpZXJQdClcbiAgICBtb2RpZmllck1hdFs0XSA9IG1vZGlmaWVyTWF0WzBdICogbW9kaWZpZXJQdFswXSArIG1vZGlmaWVyTWF0WzJdICogbW9kaWZpZXJQdFsxXVxuICAgIG1vZGlmaWVyTWF0WzVdID0gbW9kaWZpZXJNYXRbMV0gKiBtb2RpZmllclB0WzBdICsgbW9kaWZpZXJNYXRbM10gKiBtb2RpZmllclB0WzFdXG5cbiAgICBsZXQgeCA9IDBcbiAgICBsZXQgeSA9IDBcbiAgICBQb2ludDJkLnRyYW5zZm9ybU1hdDJkKG1vZGlmaWVyUHQsIHNjcmVlblB0LCBtb2RpZmllck1hdClcbiAgICBpZiAoKE1hdGguYWJzKG1vZGlmaWVyUHRbMF0pIDw9IGhhbGZCb3hTeiAmJiBNYXRoLmFicyhtb2RpZmllclB0WzFdKSA8PSBoYWxmQm94U3opIHx8XG4gICAgICAoQm9vbGVhbih4U2NhbGUpICYmIEJvb2xlYW4oeVNjYWxlKSAmJlxuICAgICAgICAocm90YXRlID0gKCh4ID0geFNjYWxlICogbW9kaWZpZXJQdFswXSkgPiAtaGFsZkJveFN6ICYmIHggPD0gcGFkQm94U3ogJiZcbiAgICAgICAgICAoeSA9IHlTY2FsZSAqIG1vZGlmaWVyUHRbMV0pID4gLWhhbGZCb3hTeiAmJiB5IDw9IHBhZEJveFN6KSkpKSB7XG4gICAgICBoaXQgPSB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgaGl0LFxuICAgIHJvdGF0ZVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhmb3JtU2hhcGUgZXh0ZW5kcyBSZWN0IHtcbiAgY29uc3RydWN0b3Iob3B0cywgc2VsZWN0T3B0cyA9IHtcbiAgICBzY2FsYWJsZTogdHJ1ZSxcbiAgICByb3RhdGFibGU6IHRydWVcbiAgfSkge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplID0gOFxuICAgIHRoaXMuX2ludGVyYWN0aXZlQm94UGFkZGluZyA9IDEwXG4gICAgaWYgKG9wdHMgJiYgdHlwZW9mIG9wdHMudmVydGV4U2l6ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplID0gb3B0cy52ZXJ0ZXhTaXplXG4gICAgfVxuXG4gICAgdGhpcy5fc2NhbGFibGUgPSB0cnVlXG4gICAgdGhpcy5fcm90YXRhYmxlID0gdHJ1ZVxuICAgIGlmIChzZWxlY3RPcHRzKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdE9wdHMuc2NhbGFibGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fc2NhbGFibGUgPSBCb29sZWFuKHNlbGVjdE9wdHMuc2NhbGFibGUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0T3B0cy5yb3RhdGFibGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5fcm90YXRhYmxlID0gQm9vbGVhbihzZWxlY3RPcHRzLnJvdGF0YWJsZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb250YWluc1BvaW50KHNjcmVlblB0LCB3b3JsZFB0LCB3b3JsZFRvU2NyZWVuTWF0cml4LCBjdHgpIHtcbiAgICAvLyBTaG91bGQgd2UgdXBkYXRlIGhlcmUsIG9yIGlzIGl0IHNhZmUgdG9cbiAgICAvLyBzYXkgdGhhdCB0aGlzIGlzIHN0YXRlZnVsLCBtZWFuaW5nIGEgcmVuZGVyXG4gICAgLy8gc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgYmVmb3JlaGFuZCB3aGljaFxuICAgIC8vIHdvdWxkJ3ZlIHVwZGF0ZWQgaXRzIHN0YXRlXG4gICAgbGV0IHJ0bk9iaiA9IHtcbiAgICAgIGhpdDogZmFsc2UsXG4gICAgICByb3RhdGU6IGZhbHNlLFxuICAgICAgY29udHJvbEluZGV4OiAtMVxuICAgIH1cblxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuICAgIGlmICgodGhpcy5fcm90YXRhYmxlIHx8IHRoaXMuX3NjYWxhYmxlKSAmJiB0aGlzLnZpc2libGUgJiYgQUFCb3gyZC5jb250YWluc1B0KGFhYm94LCBzY3JlZW5QdCkpIHtcbiAgICAgIGNvbnN0IHNjYWxlID0gWzAsIDBdXG4gICAgICBjb25zdCByb3QgPSBbMCwgMF1cbiAgICAgIE1hdDJkLnN2ZChudWxsLCBzY2FsZSwgcm90LCB0aGlzLl9mdWxsWGZvcm0pXG4gICAgICBjb25zdCBtYXQgPSBNYXQyZC5jcmVhdGUoKVxuXG4gICAgICBzY2FsZVswXSA9IChzY2FsZVswXSA8IDAgPyAtMSA6IDEpXG4gICAgICBzY2FsZVsxXSA9IChzY2FsZVsxXSA8IDAgPyAtMSA6IDEpXG5cbiAgICAgIGlmIChzY2FsZVswXSAqIHNjYWxlWzFdID4gMCkge1xuICAgICAgICBWZWMyZC5uZWdhdGUocm90LCByb3QpXG4gICAgICB9XG5cbiAgICAgIE1hdDJkLnJvdGF0ZShtYXQsIG1hdCwgcm90WzFdKVxuICAgICAgTWF0MmQuc2NhbGUobWF0LCBtYXQsIHNjYWxlKVxuICAgICAgTWF0MmQucm90YXRlKG1hdCwgbWF0LCByb3RbMF0pXG5cbiAgICAgIGNvbnN0IGJveFBhZGRpbmcgPSAodGhpcy5fcm90YXRhYmxlID8gdGhpcy5faW50ZXJhY3RpdmVCb3hQYWRkaW5nIDogMClcbiAgICAgIGNvbnN0IGhhbGZCb3hTeiA9IHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSAvIDJcbiAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHRoaXMud2lkdGggLyAyXG4gICAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyAyXG4gICAgICBjb25zdCBwdCA9IFswLCAwXVxuICAgICAgY29uc3QgcGFkU3ogPSBoYWxmQm94U3ogKyBib3hQYWRkaW5nXG4gICAgICBjb25zdCBwYWRSYWRpdXMgPSBNYXRoLnNxcnQoMiAqIHBhZFN6ICogcGFkU3opXG4gICAgICBsZXQgeFNjYWxlID0gMFxuICAgICAgbGV0IHlTY2FsZSA9IDBcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgeFNjYWxlID0gKGkgPCAyID8gLTEgOiAxKVxuICAgICAgICB5U2NhbGUgPSAoaSAlIDIgPT09IDAgPyAtMSA6IDEpXG4gICAgICAgIFBvaW50MmQuc2V0KHB0LCB4U2NhbGUgKiBoYWxmV2lkdGgsIHlTY2FsZSAqIGhhbGZIZWlnaHQpXG4gICAgICAgIHJ0bk9iaiA9IGlzUG9pbnRJbk9CQm94TW9kaWZpZXJSZWN0KHNjcmVlblB0LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCBtYXQsIGhhbGZCb3hTeiwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBwYWRTeiwgcGFkUmFkaXVzLCB4U2NhbGUsIHlTY2FsZSwgc2NhbGUpXG4gICAgICAgIGlmIChydG5PYmouaGl0KSB7XG4gICAgICAgICAgcnRuT2JqLmNvbnRyb2xJbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghcnRuT2JqLmhpdCAmJiB0aGlzLl9zY2FsYWJsZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgIHhTY2FsZSA9IChpICUgMiA9PT0gMCA/IChpIDwgMiA/IC0xIDogMSkgOiAwKVxuICAgICAgICAgIHlTY2FsZSA9IChpICUgMiA9PT0gMCA/IDAgOiAoaSA8IDIgPyAtMSA6IDEpKVxuICAgICAgICAgIFBvaW50MmQuc2V0KHB0LCB4U2NhbGUgKiBoYWxmV2lkdGgsIHlTY2FsZSAqIGhhbGZIZWlnaHQpXG4gICAgICAgICAgcnRuT2JqID0gaXNQb2ludEluT0JCb3hNb2RpZmllclJlY3Qoc2NyZWVuUHQsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIG1hdCwgaGFsZkJveFN6LCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIHBhZFN6LCBwYWRSYWRpdXMsIHhTY2FsZSwgeVNjYWxlLCBzY2FsZSlcbiAgICAgICAgICBpZiAocnRuT2JqLmhpdCkge1xuICAgICAgICAgICAgcnRuT2JqLmNvbnRyb2xJbmRleCA9IGkgKyA0XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocnRuT2JqLnJvdGF0ZSAmJiAhdGhpcy5fcm90YXRhYmxlKSB7XG4gICAgICAgIHJ0bk9iai5yb3RhdGUgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmICghcnRuT2JqLnJvdGF0ZSAmJiAhdGhpcy5fc2NhbGFibGUpIHtcbiAgICAgICAgcnRuT2JqLnJvdGF0ZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnRuT2JqXG4gIH1cblxuICBfdXBkYXRlbG9jYWx4Zm9ybShmb3JjZSkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCBmb3JjZSkge1xuICAgICAgY29uc3QgcG9zID0gUG9pbnQyZC5jbG9uZSh0aGlzLl9wb3MpXG4gICAgICBQb2ludDJkLmFkZFZlYzIocG9zLCBwb3MsIHRoaXMuX3BhcmVudC5waXZvdFJlZilcbiAgICAgIGJ1aWxkWGZvcm1NYXRyaXgodGhpcy5fbG9jYWxYZm9ybSwgdGhpcy5fcm90RGVnLCB0aGlzLl9zY2FsZSwgcG9zLCB0aGlzLl9waXZvdClcbiAgICAgIGlmICh0aGlzLl9sb2NhbFhmb3JtVXBkYXRlZCkge1xuICAgICAgICB0aGlzLl9sb2NhbFhmb3JtVXBkYXRlZCgpXG4gICAgICB9XG4gICAgICB0aGlzLl9seGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZWdsb2JhbHhmb3JtKCkge1xuICAgIGlmICh0aGlzLl9seGZvcm1EaXJ0eSB8fCB0aGlzLl94Zm9ybURpcnR5KSB7XG4gICAgICB0aGlzLl91cGRhdGVsb2NhbHhmb3JtKHRydWUpXG4gICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgIE1hdDJkLm11bHRpcGx5KHRoaXMuX2dsb2JhbFhmb3JtLCB0aGlzLl9wYXJlbnQuZ2xvYmFsWGZvcm0sIHRoaXMuX2xvY2FsWGZvcm0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBNYXQyZC5jb3B5KHRoaXMuX2dsb2JhbFhmb3JtLCB0aGlzLl9sb2NhbFhmb3JtKVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2dsb2JhbFhmb3JtVXBkYXRlZCkge1xuICAgICAgICB0aGlzLl9nbG9iYWxYZm9ybVVwZGF0ZWQoKVxuICAgICAgfVxuICAgICAgdGhpcy5feGZvcm1EaXJ0eSA9IGZhbHNlXG4gICAgfVxuICB9XG5cblxuICBfdXBkYXRlQUFCb3goZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmIChmb3JjZSB8fCB0aGlzLl9nZW9tRGlydHkgfHwgdGhpcy5fYm91bmRzT3V0T2ZEYXRlKSB7XG4gICAgICBjb25zdCBib3hQYWRkaW5nID0gKHRoaXMuX3JvdGF0YWJsZSA/IHRoaXMuX2ludGVyYWN0aXZlQm94UGFkZGluZyA6IDApXG4gICAgICBjb25zdCBwYWRkaW5nID0gYm94UGFkZGluZyArIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSAvIDJcbiAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHModGhpcy5fYWFib3gsIFswLCAwXSwgW3RoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDJdKVxuICAgICAgQUFCb3gyZC50cmFuc2Zvcm1NYXQyZCh0aGlzLl9hYWJveCwgdGhpcy5fYWFib3gsIHRoaXMuX2Z1bGxYZm9ybSlcbiAgICAgIEFBQm94MmQuZXhwYW5kKHRoaXMuX2FhYm94LCB0aGlzLl9hYWJveCwgW3BhZGRpbmcsIHBhZGRpbmddKVxuICAgICAgdGhpcy5fYWFib3hVcGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC53aWR0aCAhPT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMucGFyZW50LndpZHRoIDogMClcbiAgfVxuXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5oZWlnaHQgIT09IFwidW5kZWZpbmVkXCIgPyB0aGlzLnBhcmVudC5oZWlnaHQgOiAwKVxuICB9XG5cbiAgcmVuZGVyQm91bmRzKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgYm91bmRzU3Ryb2tlU3R5bGUpIHtcbiAgICAvLyB3ZSdyZSBzdG9yaW5nIG91ciBBQUJveCBpbiBzY3JlZW4gc3BhY2UgaGVyZSwgc28gd29ybGRUb1NjcmVlbk1hdHJpeCBpc1xuICAgIC8vIHVudXNlZFxuICAgIGNvbnN0IGFhYm94ID0gdGhpcy5hYWJveFxuICAgIGN0eC5zYXZlKClcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgYm91bmRzU3Ryb2tlU3R5bGUuc2V0U3Ryb2tlQ3R4KGN0eClcbiAgICBjb25zdCBjZW50ZXIgPSBbMCwgMF1cbiAgICBjb25zdCBleHRlbnRzID0gWzAsIDBdXG4gICAgQUFCb3gyZC5nZXRDZW50ZXIoY2VudGVyLCBhYWJveClcbiAgICBBQUJveDJkLmdldEV4dGVudHMoZXh0ZW50cywgYWFib3gpXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgY3R4LnJlY3QoY2VudGVyWzBdIC0gZXh0ZW50c1swXSwgY2VudGVyWzFdIC0gZXh0ZW50c1sxXSwgZXh0ZW50c1swXSAqIDIsIGV4dGVudHNbMV0gKiAyKVxuICAgIGN0eC5zdHJva2UoKVxuICAgIGN0eC5yZXN0b3JlKClcbiAgfVxuXG4gIHJlbmRlcihjdHgsIHdvcmxkVG9TY3JlZW5NYXRyaXgsIHN0eWxlU3RhdGUpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50IHx8IHR5cGVvZiB0aGlzLnBhcmVudC53aWR0aCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0aGlzLnBhcmVudC5oZWlnaHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2FhYm94VXBkYXRlZCA9IGZhbHNlXG4gICAgLy8gZG8gbm90IGZpbGwgdGhlIHByaW1hcnkgcmVjdGFuZ2xlXG4gICAgc3VwZXIucmVuZGVyKGN0eCwgd29ybGRUb1NjcmVlbk1hdHJpeCwgc3R5bGVTdGF0ZSwgZmFsc2UpXG4gICAgaWYgKCF0aGlzLl9hYWJveFVwZGF0ZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUFBQm94KHRydWUpXG4gICAgfVxuXG4gICAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgICBjb25zdCByb3QgPSBbMCwgMF1cbiAgICBNYXQyZC5zdmQobnVsbCwgc2NhbGUsIHJvdCwgdGhpcy5fZnVsbFhmb3JtKVxuICAgIHNjYWxlWzBdID0gKHNjYWxlWzBdIDwgMCA/IC0xIDogMSlcbiAgICBzY2FsZVsxXSA9IChzY2FsZVsxXSA8IDAgPyAtMSA6IDEpXG5cbiAgICBjb25zdCBoYWxmQm94U3ogPSB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUgLyAyXG4gICAgY29uc3QgaGFsZldpZHRoID0gdGhpcy53aWR0aCAvIDJcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyAyXG4gICAgY29uc3QgcHQgPSBbaGFsZldpZHRoLCBoYWxmSGVpZ2h0XVxuXG4gICAgY3R4LnNhdmUoKVxuXG4gICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUsIFwiM1wiKVxuXG4gICAgUG9pbnQyZC5zZXQocHQsIGhhbGZXaWR0aCwgLWhhbGZIZWlnaHQpXG4gICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUsIFwiMlwiKVxuXG4gICAgUG9pbnQyZC5zZXQocHQsIC1oYWxmV2lkdGgsIC1oYWxmSGVpZ2h0KVxuICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlLCBcIjBcIilcblxuICAgIFBvaW50MmQuc2V0KHB0LCAtaGFsZldpZHRoLCBoYWxmSGVpZ2h0KVxuICAgIGRyYXdPQkJveE1vZGlmaWVyUmVjdChjdHgsIHB0LCB0aGlzLl9mdWxsWGZvcm0sIHRoaXMuX2ludGVyYWN0aXZlQm94U2l6ZSwgaGFsZkJveFN6LCByb3QsIHNjYWxlLCBcIjFcIilcblxuICAgIGlmICh0aGlzLl9zY2FsYWJsZSkge1xuICAgICAgUG9pbnQyZC5zZXQocHQsIDAsIGhhbGZIZWlnaHQpXG4gICAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSlcblxuICAgICAgUG9pbnQyZC5zZXQocHQsIDAsIC1oYWxmSGVpZ2h0KVxuICAgICAgZHJhd09CQm94TW9kaWZpZXJSZWN0KGN0eCwgcHQsIHRoaXMuX2Z1bGxYZm9ybSwgdGhpcy5faW50ZXJhY3RpdmVCb3hTaXplLCBoYWxmQm94U3osIHJvdCwgc2NhbGUpXG5cbiAgICAgIFBvaW50MmQuc2V0KHB0LCBoYWxmV2lkdGgsIDApXG4gICAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSlcblxuICAgICAgUG9pbnQyZC5zZXQocHQsIC1oYWxmV2lkdGgsIDApXG4gICAgICBkcmF3T0JCb3hNb2RpZmllclJlY3QoY3R4LCBwdCwgdGhpcy5fZnVsbFhmb3JtLCB0aGlzLl9pbnRlcmFjdGl2ZUJveFNpemUsIGhhbGZCb3hTeiwgcm90LCBzY2FsZSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ZpbGxWaXNpYmxlKCkpIHtcbiAgICAgIHN0eWxlU3RhdGUuc2V0RmlsbFN0eWxlKGN0eCwgdGhpcylcbiAgICAgIGN0eC5maWxsKClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1N0cm9rZVZpc2libGUoKSkge1xuICAgICAgc3R5bGVTdGF0ZS5zZXRTdHJva2VTdHlsZShjdHgsIHRoaXMpXG4gICAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApXG4gICAgICBjdHguc3Ryb2tlKClcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2ludGVyYWN0aW9ucy94Zm9ybS1zaGFwZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} CircleOptions\n * @property {number} [radius=10] Radius of the circle in world-space coordinates\n */\n\n/**\n * @class Shape class describing a circle\n * @extends {BaseShape}\n */\nvar Circle = function (_BaseShape) {\n  _inherits(Circle, _BaseShape);\n\n  /**\n   * Creates a new Circle shape\n   * @param  {CircleOptions} [opts]\n   * @return {Circle}\n   */\n  function Circle(opts) {\n    _classCallCheck(this, Circle);\n\n    var _this = _possibleConstructorReturn(this, (Circle.__proto__ || Object.getPrototypeOf(Circle)).call(this, opts));\n\n    _this._radius = 10;\n    if (typeof opts.radius !== \"undefined\") {\n      _this.radius = opts.radius;\n    }\n    AABox2d.initCenterExtents(_this._aabox, [0, 0], [_this._radius, _this._radius]);\n    return _this;\n  }\n\n  /**\n   * Sets the radius of the circle\n   * @param  {number} radius Radius of circle in world-space coordinates\n   * @return {Circle}        this\n   * @fires {Shape#geomChanged}\n   * @throws {Error} If radius is not a valid number\n   */\n\n\n  _createClass(Circle, [{\n    key: \"getDimensions\",\n\n\n    /**\n     * Gets the untransformed width/height of the circle\n     * @return {Vec2d} Width/height of the circle, untransformed\n     */\n    value: function getDimensions() {\n      var diameter = this.radius * 2;\n      return [diameter, diameter];\n    }\n\n    /**\n     * Gets the untransformed width of the circle\n     * @return {number}\n     */\n\n  }, {\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        var pos = this._pos;\n        var scale = this._scale;\n        var rot = _math2.default.DEG_TO_RAD * this._rotDeg;\n        var cossqr = _math2.default.pow(_math2.default.cos(rot), 2);\n        var sinsqr = _math2.default.pow(_math2.default.sin(rot), 2);\n        var asqr = _math2.default.pow(scale[0] * this._radius, 2);\n        var bsqr = _math2.default.pow(scale[1] * this._radius, 2);\n        var A = _math2.default.sqrt(bsqr * sinsqr + asqr * cossqr);\n        var B = _math2.default.sqrt(asqr * sinsqr + bsqr * cossqr);\n        AABox2d.initCenterExtents(this._aabox, pos, [A, B]);\n        this._geomDirty = false;\n        this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the circle using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.arc(0, 0, this._radius, 0, _math2.default.TWO_PI, false);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Circle\", // NOTE: this much match the name of the class\n        radius: this.radius\n      }, _get(Circle.prototype.__proto__ || Object.getPrototypeOf(Circle.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"radius\",\n    set: function set(radius) {\n      if (typeof radius !== \"number\") {\n        throw new Error(\"Radius must be a number\");\n      }\n\n      if (radius !== this._radius) {\n        var prev = this._radius;\n        this._radius = radius;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"radius\",\n          prevVal: prev,\n          currVal: this._radius\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Gets the current radius of the circle\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._radius;\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.radius * 2;\n    }\n\n    /**\n     * Gets the untransformed height of the circle\n     * @return {number}\n     */\n\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.radius * 2;\n    }\n  }]);\n\n  return Circle;\n}(_baseShape2.default);\n\nexports.default = Circle;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvY2lyY2xlLmpzP2FkOWQiXSwibmFtZXMiOlsiQUFCb3gyZCIsIkNpcmNsZSIsIm9wdHMiLCJfcmFkaXVzIiwicmFkaXVzIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJkaWFtZXRlciIsIl9nZW9tRGlydHkiLCJfYm91bmRzT3V0T2ZEYXRlIiwicG9zIiwiX3BvcyIsInNjYWxlIiwiX3NjYWxlIiwicm90IiwiREVHX1RPX1JBRCIsIl9yb3REZWciLCJjb3NzcXIiLCJwb3ciLCJjb3MiLCJzaW5zcXIiLCJzaW4iLCJhc3FyIiwiYnNxciIsIkEiLCJzcXJ0IiwiQiIsImN0eCIsImFyYyIsIlRXT19QSSIsIk9iamVjdCIsImFzc2lnbiIsInR5cGUiLCJFcnJvciIsInByZXYiLCJmaXJlIiwiYXR0ciIsInByZXZWYWwiLCJjdXJyVmFsIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7OztBQUVBOztJQUFZQSxPOztBQUNaOzs7O0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7O0FBS0E7Ozs7SUFJcUJDLE07OztBQUNuQjs7Ozs7QUFLQSxrQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLGdIQUNWQSxJQURVOztBQUVoQixVQUFLQyxPQUFMLEdBQWUsRUFBZjtBQUNBLFFBQUksT0FBT0QsS0FBS0UsTUFBWixLQUF1QixXQUEzQixFQUF3QztBQUN0QyxZQUFLQSxNQUFMLEdBQWNGLEtBQUtFLE1BQW5CO0FBQ0Q7QUFDREosWUFBUUssaUJBQVIsQ0FBMEIsTUFBS0MsTUFBL0IsRUFBdUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUF2QyxFQUErQyxDQUFDLE1BQUtILE9BQU4sRUFBZSxNQUFLQSxPQUFwQixDQUEvQztBQU5nQjtBQU9qQjs7QUFFRDs7Ozs7Ozs7Ozs7OztBQW1DQTs7OztvQ0FJZ0I7QUFDZCxVQUFNSSxXQUFXLEtBQUtILE1BQUwsR0FBYyxDQUEvQjtBQUNBLGFBQU8sQ0FBQ0csUUFBRCxFQUFXQSxRQUFYLENBQVA7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBZ0JBOzs7OzttQ0FLZTtBQUNiLFVBQUksS0FBS0MsVUFBTCxJQUFtQixLQUFLQyxnQkFBNUIsRUFBOEM7QUFDNUMsWUFBTUMsTUFBTSxLQUFLQyxJQUFqQjtBQUNBLFlBQU1DLFFBQVEsS0FBS0MsTUFBbkI7QUFDQSxZQUFNQyxNQUFNLGVBQUtDLFVBQUwsR0FBa0IsS0FBS0MsT0FBbkM7QUFDQSxZQUFNQyxTQUFTLGVBQUtDLEdBQUwsQ0FBUyxlQUFLQyxHQUFMLENBQVNMLEdBQVQsQ0FBVCxFQUF3QixDQUF4QixDQUFmO0FBQ0EsWUFBTU0sU0FBUyxlQUFLRixHQUFMLENBQVMsZUFBS0csR0FBTCxDQUFTUCxHQUFULENBQVQsRUFBd0IsQ0FBeEIsQ0FBZjtBQUNBLFlBQU1RLE9BQU8sZUFBS0osR0FBTCxDQUFTTixNQUFNLENBQU4sSUFBVyxLQUFLVCxPQUF6QixFQUFrQyxDQUFsQyxDQUFiO0FBQ0EsWUFBTW9CLE9BQU8sZUFBS0wsR0FBTCxDQUFTTixNQUFNLENBQU4sSUFBVyxLQUFLVCxPQUF6QixFQUFrQyxDQUFsQyxDQUFiO0FBQ0EsWUFBTXFCLElBQUksZUFBS0MsSUFBTCxDQUFVRixPQUFPSCxNQUFQLEdBQWdCRSxPQUFPTCxNQUFqQyxDQUFWO0FBQ0EsWUFBTVMsSUFBSSxlQUFLRCxJQUFMLENBQVVILE9BQU9GLE1BQVAsR0FBZ0JHLE9BQU9OLE1BQWpDLENBQVY7QUFDQWpCLGdCQUFRSyxpQkFBUixDQUEwQixLQUFLQyxNQUEvQixFQUF1Q0ksR0FBdkMsRUFBNEMsQ0FBQ2MsQ0FBRCxFQUFJRSxDQUFKLENBQTVDO0FBQ0EsYUFBS2xCLFVBQUwsR0FBa0IsS0FBbEI7QUFDQSxhQUFLQyxnQkFBTCxHQUF3QixLQUF4QjtBQUNEO0FBQ0Y7O0FBRUQ7Ozs7Ozs7OzswQkFNTWtCLEcsRUFBSztBQUNUQSxVQUFJQyxHQUFKLENBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxLQUFLekIsT0FBbkIsRUFBNEIsQ0FBNUIsRUFBK0IsZUFBSzBCLE1BQXBDLEVBQTRDLEtBQTVDO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OzZCQUtTO0FBQ1AsYUFBT0MsT0FBT0MsTUFBUCxDQUFjO0FBQ25CQyxjQUFNLFFBRGEsRUFDSDtBQUNoQjVCLGdCQUFRLEtBQUtBO0FBRk0sT0FBZCx5R0FBUDtBQUlEOzs7c0JBL0ZVQSxNLEVBQVE7QUFDakIsVUFBSSxPQUFPQSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO0FBQzlCLGNBQU0sSUFBSTZCLEtBQUosQ0FBVSx5QkFBVixDQUFOO0FBQ0Q7O0FBRUQsVUFBSTdCLFdBQVcsS0FBS0QsT0FBcEIsRUFBNkI7QUFDM0IsWUFBTStCLE9BQU8sS0FBSy9CLE9BQWxCO0FBQ0EsYUFBS0EsT0FBTCxHQUFlQyxNQUFmO0FBQ0EsYUFBS0ksVUFBTCxHQUFrQixJQUFsQixDQUgyQixDQUdKOztBQUV2QixhQUFLMkIsSUFBTCxDQUFVLGNBQVYsRUFBMEI7QUFDeEJDLGdCQUFNLFFBRGtCO0FBRXhCQyxtQkFBU0gsSUFGZTtBQUd4QkksbUJBQVMsS0FBS25DO0FBSFUsU0FBMUI7QUFLRDs7QUFFRCxhQUFPLElBQVA7QUFDRDs7QUFFRDs7Ozs7d0JBSWE7QUFDWCxhQUFPLEtBQUtBLE9BQVo7QUFDRDs7O3dCQWVXO0FBQ1YsYUFBTyxLQUFLQyxNQUFMLEdBQWMsQ0FBckI7QUFDRDs7QUFFRDs7Ozs7Ozt3QkFJYTtBQUNYLGFBQU8sS0FBS0EsTUFBTCxHQUFjLENBQXJCO0FBQ0Q7Ozs7OztrQkF6RWtCSCxNIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCJcblxuaW1wb3J0ICogYXMgQUFCb3gyZCBmcm9tIFwiLi4vY29yZS9hYWJveDJkXCJcbmltcG9ydCBCYXNlU2hhcGUgZnJvbSBcIi4vYmFzZS1zaGFwZS5qc1wiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDaXJjbGVPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGl1cz0xMF0gUmFkaXVzIG9mIHRoZSBjaXJjbGUgaW4gd29ybGQtc3BhY2UgY29vcmRpbmF0ZXNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBTaGFwZSBjbGFzcyBkZXNjcmliaW5nIGEgY2lyY2xlXG4gKiBAZXh0ZW5kcyB7QmFzZVNoYXBlfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGUgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDaXJjbGUgc2hhcGVcbiAgICogQHBhcmFtICB7Q2lyY2xlT3B0aW9uc30gW29wdHNdXG4gICAqIEByZXR1cm4ge0NpcmNsZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3JhZGl1cyA9IDEwXG4gICAgaWYgKHR5cGVvZiBvcHRzLnJhZGl1cyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1c1xuICAgIH1cbiAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c10pXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSByYWRpdXMgUmFkaXVzIG9mIGNpcmNsZSBpbiB3b3JsZC1zcGFjZSBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtDaXJjbGV9ICAgICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiByYWRpdXMgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAqL1xuICBzZXQgcmFkaXVzKHJhZGl1cykge1xuICAgIGlmICh0eXBlb2YgcmFkaXVzICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYWRpdXMgbXVzdCBiZSBhIG51bWJlclwiKVxuICAgIH1cblxuICAgIGlmIChyYWRpdXMgIT09IHRoaXMuX3JhZGl1cykge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3JhZGl1c1xuICAgICAgdGhpcy5fcmFkaXVzID0gcmFkaXVzXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwicmFkaXVzXCIsXG4gICAgICAgIHByZXZWYWw6IHByZXYsXG4gICAgICAgIGN1cnJWYWw6IHRoaXMuX3JhZGl1c1xuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcmFkaXVzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW50cmFuc2Zvcm1lZCB3aWR0aC9oZWlnaHQgb2YgdGhlIGNpcmNsZVxuICAgKiBAcmV0dXJuIHtWZWMyZH0gV2lkdGgvaGVpZ2h0IG9mIHRoZSBjaXJjbGUsIHVudHJhbnNmb3JtZWRcbiAgICovXG4gIGdldERpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgZGlhbWV0ZXIgPSB0aGlzLnJhZGl1cyAqIDJcbiAgICByZXR1cm4gW2RpYW1ldGVyLCBkaWFtZXRlcl1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bnRyYW5zZm9ybWVkIHdpZHRoIG9mIHRoZSBjaXJjbGVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLnJhZGl1cyAqIDJcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB1bnRyYW5zZm9ybWVkIGhlaWdodCBvZiB0aGUgY2lyY2xlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmFkaXVzICogMlxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBib3VuZGluZyBib3ggcmVxdWlyZXMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfdXBkYXRlQUFCb3goKSB7XG4gICAgaWYgKHRoaXMuX2dlb21EaXJ0eSB8fCB0aGlzLl9ib3VuZHNPdXRPZkRhdGUpIHtcbiAgICAgIGNvbnN0IHBvcyA9IHRoaXMuX3Bvc1xuICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9zY2FsZVxuICAgICAgY29uc3Qgcm90ID0gTWF0aC5ERUdfVE9fUkFEICogdGhpcy5fcm90RGVnXG4gICAgICBjb25zdCBjb3NzcXIgPSBNYXRoLnBvdyhNYXRoLmNvcyhyb3QpLCAyKVxuICAgICAgY29uc3Qgc2luc3FyID0gTWF0aC5wb3coTWF0aC5zaW4ocm90KSwgMilcbiAgICAgIGNvbnN0IGFzcXIgPSBNYXRoLnBvdyhzY2FsZVswXSAqIHRoaXMuX3JhZGl1cywgMilcbiAgICAgIGNvbnN0IGJzcXIgPSBNYXRoLnBvdyhzY2FsZVsxXSAqIHRoaXMuX3JhZGl1cywgMilcbiAgICAgIGNvbnN0IEEgPSBNYXRoLnNxcnQoYnNxciAqIHNpbnNxciArIGFzcXIgKiBjb3NzcXIpXG4gICAgICBjb25zdCBCID0gTWF0aC5zcXJ0KGFzcXIgKiBzaW5zcXIgKyBic3FyICogY29zc3FyKVxuICAgICAgQUFCb3gyZC5pbml0Q2VudGVyRXh0ZW50cyh0aGlzLl9hYWJveCwgcG9zLCBbQSwgQl0pXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSBmYWxzZVxuICAgICAgdGhpcy5fYm91bmRzT3V0T2ZEYXRlID0gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRHJhd3MgdGhlIGNpcmNsZSB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5hcmMoMCwgMCwgdGhpcy5fcmFkaXVzLCAwLCBNYXRoLlRXT19QSSwgZmFsc2UpXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHRvIGNvbnZlcnQgdGhlIHNoYXBlIHRvIGEgc2VyaWFsaXphYmxlIEpTT04gb2JqZWN0XG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe1xuICAgICAgdHlwZTogXCJDaXJjbGVcIiwgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1c1xuICAgIH0sIHN1cGVyLnRvSlNPTigpKVxuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NoYXBlcy9jaXJjbGUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _mat2d = __webpack_require__(7);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * @typedef {object} PointOptions\n * @property {number} [size=5] Size of the point in pixels\n */\n\n/**\n * @class Point shape class. A point differs from a circle in that\n *        a point's size is defined in screen/pixel space whereas\n *        a circle is defined in world space.\n * @extends {BaseShape}\n */\nvar Point = function (_BaseShape) {\n  _inherits(Point, _BaseShape);\n\n  /**\n   * Creates a new point shape\n   * @param  {PointOptions} [opts]\n   * @return {Point}\n   */\n  function Point(opts) {\n    _classCallCheck(this, Point);\n\n    var _this = _possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).call(this, opts));\n\n    _this._size = 5;\n    if (typeof opts.size !== \"undefined\") {\n      _this.size = opts.size;\n    }\n    AABox2d.initCenterExtents(_this._aabox, [0, 0], [_this._radius, _this._radius]);\n    _this.translate(opts.x || 0, opts.y || 0);\n    return _this;\n  }\n\n  /**\n   * Sets the size of the point\n   * @param  {nuber} size Size of the point in pixels\n   * @return {Pixel}      this\n   * @fires {Shape#geomChanged}\n   * @throws {Error} If size is not a valid number\n   */\n\n\n  _createClass(Point, [{\n    key: \"_updateAABox\",\n\n\n    /**\n     * Called when the bounding box requires updating\n     * @private\n     * @override\n     */\n    value: function _updateAABox() {\n      if (this._geomDirty || this._boundsOutOfDate) {\n        var pos = this._pos;\n        var scale = this._scale;\n        var rot = _math2.default.DEG_TO_RAD * this._rotDeg;\n        var cossqr = _math2.default.pow(_math2.default.cos(rot), 2);\n        var sinsqr = _math2.default.pow(_math2.default.sin(rot), 2);\n        var asqr = _math2.default.pow(scale[0] * this._size, 2);\n        var bsqr = _math2.default.pow(scale[1] * this._size, 2);\n        var A = _math2.default.sqrt(bsqr * sinsqr + asqr * cossqr);\n        var B = _math2.default.sqrt(asqr * sinsqr + bsqr * cossqr);\n        AABox2d.initCenterExtents(this._aabox, pos, [A, B]);\n        this._geomDirty = false;\n        this._boundsOutOfDate = false;\n      }\n    }\n\n    /**\n     * Draws the point using a 2d rendering context. Called by the BaseShape\n     * class\n     * @param  {CanvasRenderingContext2d} ctx 2d rendering context\n     * @override\n     */\n\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      var pos = [0, 0];\n      _mat2d2.default.svd(pos, null, null, this._fullXform);\n      ctx.arc(pos[0], pos[1], this._size, 0, _math2.default.TWO_PI, false);\n    }\n\n    /**\n     * Called to convert the shape to a serializable JSON object\n     * @return {object}\n     * @override\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign({\n        type: \"Point\", // NOTE: this much match the name of the class\n        size: this.size\n      }, _get(Point.prototype.__proto__ || Object.getPrototypeOf(Point.prototype), \"toJSON\", this).call(this));\n    }\n  }, {\n    key: \"size\",\n    set: function set(size) {\n      if (typeof size !== \"number\") {\n        throw new Error(\"Radius must be a number\");\n      }\n\n      if (size !== this._size) {\n        var prev = this._size;\n        this._size = size;\n        this._geomDirty = true; // dirty needs to be set before firing event\n\n        this.fire(\"changed:geom\", {\n          attr: \"size\",\n          prevVal: prev,\n          currVal: this._size\n        });\n      }\n    }\n\n    /**\n     * Gets the current size of the point\n     * @return {number}\n     */\n    ,\n    get: function get() {\n      return this._size;\n    }\n  }]);\n\n  return Point;\n}(_baseShape2.default);\n\nexports.default = Point;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9pbnQuanM/OWY2OSJdLCJuYW1lcyI6WyJBQUJveDJkIiwiUG9pbnQiLCJvcHRzIiwiX3NpemUiLCJzaXplIiwiaW5pdENlbnRlckV4dGVudHMiLCJfYWFib3giLCJfcmFkaXVzIiwidHJhbnNsYXRlIiwieCIsInkiLCJfZ2VvbURpcnR5IiwiX2JvdW5kc091dE9mRGF0ZSIsInBvcyIsIl9wb3MiLCJzY2FsZSIsIl9zY2FsZSIsInJvdCIsIkRFR19UT19SQUQiLCJfcm90RGVnIiwiY29zc3FyIiwicG93IiwiY29zIiwic2luc3FyIiwic2luIiwiYXNxciIsImJzcXIiLCJBIiwic3FydCIsIkIiLCJjdHgiLCJzZXRUcmFuc2Zvcm0iLCJzdmQiLCJfZnVsbFhmb3JtIiwiYXJjIiwiVFdPX1BJIiwiT2JqZWN0IiwiYXNzaWduIiwidHlwZSIsIkVycm9yIiwicHJldiIsImZpcmUiLCJhdHRyIiwicHJldlZhbCIsImN1cnJWYWwiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7OztBQUVBOzs7OztBQUtBOzs7Ozs7SUFNcUJDLEs7OztBQUNuQjs7Ozs7QUFLQSxpQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLDhHQUNWQSxJQURVOztBQUVoQixVQUFLQyxLQUFMLEdBQWEsQ0FBYjtBQUNBLFFBQUksT0FBT0QsS0FBS0UsSUFBWixLQUFxQixXQUF6QixFQUFzQztBQUNwQyxZQUFLQSxJQUFMLEdBQVlGLEtBQUtFLElBQWpCO0FBQ0Q7QUFDREosWUFBUUssaUJBQVIsQ0FBMEIsTUFBS0MsTUFBL0IsRUFBdUMsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUF2QyxFQUErQyxDQUFDLE1BQUtDLE9BQU4sRUFBZSxNQUFLQSxPQUFwQixDQUEvQztBQUNBLFVBQUtDLFNBQUwsQ0FBZU4sS0FBS08sQ0FBTCxJQUFVLENBQXpCLEVBQTRCUCxLQUFLUSxDQUFMLElBQVUsQ0FBdEM7QUFQZ0I7QUFRakI7O0FBRUQ7Ozs7Ozs7Ozs7Ozs7QUFpQ0E7Ozs7O21DQUtlO0FBQ2IsVUFBSSxLQUFLQyxVQUFMLElBQW1CLEtBQUtDLGdCQUE1QixFQUE4QztBQUM1QyxZQUFNQyxNQUFNLEtBQUtDLElBQWpCO0FBQ0EsWUFBTUMsUUFBUSxLQUFLQyxNQUFuQjtBQUNBLFlBQU1DLE1BQU0sZUFBS0MsVUFBTCxHQUFrQixLQUFLQyxPQUFuQztBQUNBLFlBQU1DLFNBQVMsZUFBS0MsR0FBTCxDQUFTLGVBQUtDLEdBQUwsQ0FBU0wsR0FBVCxDQUFULEVBQXdCLENBQXhCLENBQWY7QUFDQSxZQUFNTSxTQUFTLGVBQUtGLEdBQUwsQ0FBUyxlQUFLRyxHQUFMLENBQVNQLEdBQVQsQ0FBVCxFQUF3QixDQUF4QixDQUFmO0FBQ0EsWUFBTVEsT0FBTyxlQUFLSixHQUFMLENBQVNOLE1BQU0sQ0FBTixJQUFXLEtBQUtaLEtBQXpCLEVBQWdDLENBQWhDLENBQWI7QUFDQSxZQUFNdUIsT0FBTyxlQUFLTCxHQUFMLENBQVNOLE1BQU0sQ0FBTixJQUFXLEtBQUtaLEtBQXpCLEVBQWdDLENBQWhDLENBQWI7QUFDQSxZQUFNd0IsSUFBSSxlQUFLQyxJQUFMLENBQVVGLE9BQU9ILE1BQVAsR0FBZ0JFLE9BQU9MLE1BQWpDLENBQVY7QUFDQSxZQUFNUyxJQUFJLGVBQUtELElBQUwsQ0FBVUgsT0FBT0YsTUFBUCxHQUFnQkcsT0FBT04sTUFBakMsQ0FBVjtBQUNBcEIsZ0JBQVFLLGlCQUFSLENBQTBCLEtBQUtDLE1BQS9CLEVBQXVDTyxHQUF2QyxFQUE0QyxDQUFDYyxDQUFELEVBQUlFLENBQUosQ0FBNUM7QUFDQSxhQUFLbEIsVUFBTCxHQUFrQixLQUFsQjtBQUNBLGFBQUtDLGdCQUFMLEdBQXdCLEtBQXhCO0FBQ0Q7QUFDRjs7QUFFRDs7Ozs7Ozs7OzBCQU1Na0IsRyxFQUFLO0FBQ1RBLFVBQUlDLFlBQUosQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsQ0FBN0IsRUFBZ0MsQ0FBaEM7QUFDQSxVQUFNbEIsTUFBTSxDQUFDLENBQUQsRUFBSSxDQUFKLENBQVo7QUFDQSxzQkFBTW1CLEdBQU4sQ0FBVW5CLEdBQVYsRUFBZSxJQUFmLEVBQXFCLElBQXJCLEVBQTJCLEtBQUtvQixVQUFoQztBQUNBSCxVQUFJSSxHQUFKLENBQVFyQixJQUFJLENBQUosQ0FBUixFQUFnQkEsSUFBSSxDQUFKLENBQWhCLEVBQXdCLEtBQUtWLEtBQTdCLEVBQW9DLENBQXBDLEVBQXVDLGVBQUtnQyxNQUE1QyxFQUFvRCxLQUFwRDtBQUNEOztBQUVEOzs7Ozs7Ozs2QkFLUztBQUNQLGFBQU9DLE9BQU9DLE1BQVAsQ0FBYztBQUNuQkMsY0FBTSxPQURhLEVBQ0o7QUFDZmxDLGNBQU0sS0FBS0E7QUFGUSxPQUFkLHVHQUFQO0FBSUQ7OztzQkF2RVFBLEksRUFBTTtBQUNiLFVBQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixjQUFNLElBQUltQyxLQUFKLENBQVUseUJBQVYsQ0FBTjtBQUNEOztBQUVELFVBQUluQyxTQUFTLEtBQUtELEtBQWxCLEVBQXlCO0FBQ3ZCLFlBQU1xQyxPQUFPLEtBQUtyQyxLQUFsQjtBQUNBLGFBQUtBLEtBQUwsR0FBYUMsSUFBYjtBQUNBLGFBQUtPLFVBQUwsR0FBa0IsSUFBbEIsQ0FIdUIsQ0FHQTs7QUFFdkIsYUFBSzhCLElBQUwsQ0FBVSxjQUFWLEVBQTBCO0FBQ3hCQyxnQkFBTSxNQURrQjtBQUV4QkMsbUJBQVNILElBRmU7QUFHeEJJLG1CQUFTLEtBQUt6QztBQUhVLFNBQTFCO0FBS0Q7QUFDRjs7QUFFRDs7Ozs7d0JBSVc7QUFDVCxhQUFPLEtBQUtBLEtBQVo7QUFDRDs7Ozs7O2tCQS9Da0JGLEsiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQgTWF0aCBmcm9tIFwiLi4vbWF0aC9tYXRoXCJcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQb2ludE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZT01XSBTaXplIG9mIHRoZSBwb2ludCBpbiBwaXhlbHNcbiAqL1xuXG4vKipcbiAqIEBjbGFzcyBQb2ludCBzaGFwZSBjbGFzcy4gQSBwb2ludCBkaWZmZXJzIGZyb20gYSBjaXJjbGUgaW4gdGhhdFxuICogICAgICAgIGEgcG9pbnQncyBzaXplIGlzIGRlZmluZWQgaW4gc2NyZWVuL3BpeGVsIHNwYWNlIHdoZXJlYXNcbiAqICAgICAgICBhIGNpcmNsZSBpcyBkZWZpbmVkIGluIHdvcmxkIHNwYWNlLlxuICogQGV4dGVuZHMge0Jhc2VTaGFwZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9pbnQgZXh0ZW5kcyBCYXNlU2hhcGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwb2ludCBzaGFwZVxuICAgKiBAcGFyYW0gIHtQb2ludE9wdGlvbnN9IFtvcHRzXVxuICAgKiBAcmV0dXJuIHtQb2ludH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3NpemUgPSA1XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNpemUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IG9wdHMuc2l6ZVxuICAgIH1cbiAgICBBQUJveDJkLmluaXRDZW50ZXJFeHRlbnRzKHRoaXMuX2FhYm94LCBbMCwgMF0sIFt0aGlzLl9yYWRpdXMsIHRoaXMuX3JhZGl1c10pXG4gICAgdGhpcy50cmFuc2xhdGUob3B0cy54IHx8IDAsIG9wdHMueSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNpemUgb2YgdGhlIHBvaW50XG4gICAqIEBwYXJhbSAge251YmVyfSBzaXplIFNpemUgb2YgdGhlIHBvaW50IGluIHBpeGVsc1xuICAgKiBAcmV0dXJuIHtQaXhlbH0gICAgICB0aGlzXG4gICAqIEBmaXJlcyB7U2hhcGUjZ2VvbUNoYW5nZWR9XG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzaXplIGlzIG5vdCBhIHZhbGlkIG51bWJlclxuICAgKi9cbiAgc2V0IHNpemUoc2l6ZSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFkaXVzIG11c3QgYmUgYSBudW1iZXJcIilcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSAhPT0gdGhpcy5fc2l6ZSkge1xuICAgICAgY29uc3QgcHJldiA9IHRoaXMuX3NpemVcbiAgICAgIHRoaXMuX3NpemUgPSBzaXplXG4gICAgICB0aGlzLl9nZW9tRGlydHkgPSB0cnVlIC8vIGRpcnR5IG5lZWRzIHRvIGJlIHNldCBiZWZvcmUgZmlyaW5nIGV2ZW50XG5cbiAgICAgIHRoaXMuZmlyZShcImNoYW5nZWQ6Z2VvbVwiLCB7XG4gICAgICAgIGF0dHI6IFwic2l6ZVwiLFxuICAgICAgICBwcmV2VmFsOiBwcmV2LFxuICAgICAgICBjdXJyVmFsOiB0aGlzLl9zaXplXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBjdXJyZW50IHNpemUgb2YgdGhlIHBvaW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9zaXplXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGJvdW5kaW5nIGJveCByZXF1aXJlcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF91cGRhdGVBQUJveCgpIHtcbiAgICBpZiAodGhpcy5fZ2VvbURpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSkge1xuICAgICAgY29uc3QgcG9zID0gdGhpcy5fcG9zXG4gICAgICBjb25zdCBzY2FsZSA9IHRoaXMuX3NjYWxlXG4gICAgICBjb25zdCByb3QgPSBNYXRoLkRFR19UT19SQUQgKiB0aGlzLl9yb3REZWdcbiAgICAgIGNvbnN0IGNvc3NxciA9IE1hdGgucG93KE1hdGguY29zKHJvdCksIDIpXG4gICAgICBjb25zdCBzaW5zcXIgPSBNYXRoLnBvdyhNYXRoLnNpbihyb3QpLCAyKVxuICAgICAgY29uc3QgYXNxciA9IE1hdGgucG93KHNjYWxlWzBdICogdGhpcy5fc2l6ZSwgMilcbiAgICAgIGNvbnN0IGJzcXIgPSBNYXRoLnBvdyhzY2FsZVsxXSAqIHRoaXMuX3NpemUsIDIpXG4gICAgICBjb25zdCBBID0gTWF0aC5zcXJ0KGJzcXIgKiBzaW5zcXIgKyBhc3FyICogY29zc3FyKVxuICAgICAgY29uc3QgQiA9IE1hdGguc3FydChhc3FyICogc2luc3FyICsgYnNxciAqIGNvc3NxcilcbiAgICAgIEFBQm94MmQuaW5pdENlbnRlckV4dGVudHModGhpcy5fYWFib3gsIHBvcywgW0EsIEJdKVxuICAgICAgdGhpcy5fZ2VvbURpcnR5ID0gZmFsc2VcbiAgICAgIHRoaXMuX2JvdW5kc091dE9mRGF0ZSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERyYXdzIHRoZSBwb2ludCB1c2luZyBhIDJkIHJlbmRlcmluZyBjb250ZXh0LiBDYWxsZWQgYnkgdGhlIEJhc2VTaGFwZVxuICAgKiBjbGFzc1xuICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MmR9IGN0eCAyZCByZW5kZXJpbmcgY29udGV4dFxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9kcmF3KGN0eCkge1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMClcbiAgICBjb25zdCBwb3MgPSBbMCwgMF1cbiAgICBNYXQyZC5zdmQocG9zLCBudWxsLCBudWxsLCB0aGlzLl9mdWxsWGZvcm0pXG4gICAgY3R4LmFyYyhwb3NbMF0sIHBvc1sxXSwgdGhpcy5fc2l6ZSwgMCwgTWF0aC5UV09fUEksIGZhbHNlKVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB0byBjb252ZXJ0IHRoZSBzaGFwZSB0byBhIHNlcmlhbGl6YWJsZSBKU09OIG9iamVjdFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgIHR5cGU6IFwiUG9pbnRcIiwgLy8gTk9URTogdGhpcyBtdWNoIG1hdGNoIHRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuICAgICAgc2l6ZTogdGhpcy5zaXplXG4gICAgfSwgc3VwZXIudG9KU09OKCkpXG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3BvaW50LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _point2d = __webpack_require__(3);\n\nvar Point2d = _interopRequireWildcard(_point2d);\n\nvar _baseShape = __webpack_require__(6);\n\nvar _baseShape2 = _interopRequireDefault(_baseShape);\n\nvar _glMatrix = __webpack_require__(1);\n\nvar _math = __webpack_require__(5);\n\nvar _math2 = _interopRequireDefault(_math);\n\nvar _convexHull = __webpack_require__(12);\n\nvar _polyLine = __webpack_require__(13);\n\nvar _polyLine2 = _interopRequireDefault(_polyLine);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction isArray(obj) {\n  return Array.isArray(obj) || ArrayBuffer && ArrayBuffer.isView(obj);\n}\n\nvar Poly = function (_PolyLine) {\n  _inherits(Poly, _PolyLine);\n\n  function Poly(opts) {\n    _classCallCheck(this, Poly);\n\n    var _this = _possibleConstructorReturn(this, (Poly.__proto__ || Object.getPrototypeOf(Poly)).call(this, opts));\n\n    if (_this._verts.length < 3) {\n      throw new Error(\"Poly shapes must be initialized with an array of 2d points and contain at least 3 points\");\n    }\n    return _this;\n  }\n\n  _createClass(Poly, [{\n    key: \"removeVert\",\n    value: function removeVert(vertIndex) {\n      if (this._verts.length < 3) {\n        throw new Error(\"Cannot remove vertex \" + vertIndex + \". It would result in a poly with < 3 points. A poly must contain at least 3 points.\");\n      }\n\n      _get(Poly.prototype.__proto__ || Object.getPrototypeOf(Poly.prototype), \"removeVert\", this).call(this, vertIndex);\n    }\n  }, {\n    key: \"_draw\",\n    value: function _draw(ctx) {\n      var rtn = false;\n      if (this._verts.length >= 3) {\n        ctx.moveTo(this._verts[0][0], this._verts[0][1]);\n        for (var i = 1; i < this._verts.length; i += 1) {\n          ctx.lineTo(this._verts[i][0], this._verts[i][1]);\n        }\n        ctx.closePath();\n        rtn = true;\n      }\n      return rtn;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Object.assign(_get(Poly.prototype.__proto__ || Object.getPrototypeOf(Poly.prototype), \"toJSON\", this).call(this), {\n        type: \"Poly\" // NOTE: this much match the name of the class\n        // This is also supplied after the super.toJSON()\n        // so that this type overrides the parent class's\n        // type\n      });\n    }\n  }]);\n\n  return Poly;\n}(_polyLine2.default);\n\nexports.default = Poly;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGFwZXMvcG9seS5qcz8zNmZiIl0sIm5hbWVzIjpbIkFBQm94MmQiLCJQb2ludDJkIiwiaXNBcnJheSIsIm9iaiIsIkFycmF5IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJQb2x5Iiwib3B0cyIsIl92ZXJ0cyIsImxlbmd0aCIsIkVycm9yIiwidmVydEluZGV4IiwiY3R4IiwicnRuIiwibW92ZVRvIiwiaSIsImxpbmVUbyIsImNsb3NlUGF0aCIsIk9iamVjdCIsImFzc2lnbiIsInR5cGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7O0lBQVlDLE87O0FBQ1o7Ozs7QUFDQTs7QUFHQTs7OztBQUNBOztBQUdBOzs7Ozs7Ozs7Ozs7OztBQUVBLFNBQVNDLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCO0FBQ3BCLFNBQU9DLE1BQU1GLE9BQU4sQ0FBY0MsR0FBZCxLQUF1QkUsZUFBZUEsWUFBWUMsTUFBWixDQUFtQkgsR0FBbkIsQ0FBN0M7QUFDRDs7SUFFb0JJLEk7OztBQUNuQixnQkFBWUMsSUFBWixFQUFrQjtBQUFBOztBQUFBLDRHQUNWQSxJQURVOztBQUVoQixRQUFJLE1BQUtDLE1BQUwsQ0FBWUMsTUFBWixHQUFxQixDQUF6QixFQUE0QjtBQUMxQixZQUFNLElBQUlDLEtBQUosQ0FBVSwwRkFBVixDQUFOO0FBQ0Q7QUFKZTtBQUtqQjs7OzsrQkFFVUMsUyxFQUFXO0FBQ3BCLFVBQUksS0FBS0gsTUFBTCxDQUFZQyxNQUFaLEdBQXFCLENBQXpCLEVBQTRCO0FBQzFCLGNBQU0sSUFBSUMsS0FBSiwyQkFBa0NDLFNBQWxDLHlGQUFOO0FBQ0Q7O0FBRUQsNkdBQWlCQSxTQUFqQjtBQUNEOzs7MEJBR0tDLEcsRUFBSztBQUNULFVBQUlDLE1BQU0sS0FBVjtBQUNBLFVBQUksS0FBS0wsTUFBTCxDQUFZQyxNQUFaLElBQXNCLENBQTFCLEVBQTZCO0FBQzNCRyxZQUFJRSxNQUFKLENBQVcsS0FBS04sTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQVgsRUFBOEIsS0FBS0EsTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLENBQTlCO0FBQ0EsYUFBSyxJQUFJTyxJQUFJLENBQWIsRUFBZ0JBLElBQUksS0FBS1AsTUFBTCxDQUFZQyxNQUFoQyxFQUF3Q00sS0FBSyxDQUE3QyxFQUFnRDtBQUM5Q0gsY0FBSUksTUFBSixDQUFXLEtBQUtSLE1BQUwsQ0FBWU8sQ0FBWixFQUFlLENBQWYsQ0FBWCxFQUE4QixLQUFLUCxNQUFMLENBQVlPLENBQVosRUFBZSxDQUFmLENBQTlCO0FBQ0Q7QUFDREgsWUFBSUssU0FBSjtBQUNBSixjQUFNLElBQU47QUFDRDtBQUNELGFBQU9BLEdBQVA7QUFDRDs7OzZCQUVRO0FBQ1AsYUFBT0ssT0FBT0MsTUFBUCxxR0FBOEI7QUFDbkNDLGNBQU0sTUFENkIsQ0FDdEI7QUFDQTtBQUNBO0FBQ0E7QUFKc0IsT0FBOUIsQ0FBUDtBQU1EOzs7Ozs7a0JBckNrQmQsSSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbmltcG9ydCAqIGFzIEFBQm94MmQgZnJvbSBcIi4uL2NvcmUvYWFib3gyZFwiXG5pbXBvcnQgKiBhcyBQb2ludDJkIGZyb20gXCIuLi9jb3JlL3BvaW50MmRcIlxuaW1wb3J0IEJhc2VTaGFwZSBmcm9tIFwiLi9iYXNlLXNoYXBlLmpzXCJcbmltcG9ydCB7XG4gIG1hdDJkIGFzIE1hdDJkXG59IGZyb20gXCJnbC1tYXRyaXhcIlxuaW1wb3J0IE1hdGggZnJvbSBcIi4uL21hdGgvbWF0aFwiXG5pbXBvcnQge1xuICBzaW1wbGVIdWxsXzJEXG59IGZyb20gXCIuLi9tYXRoL2NvbnZleC1odWxsXCJcbmltcG9ydCBQb2x5TGluZSBmcm9tIFwiLi9wb2x5LWxpbmVcIlxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8IChBcnJheUJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seSBleHRlbmRzIFBvbHlMaW5lIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvbHkgc2hhcGVzIG11c3QgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBhcnJheSBvZiAyZCBwb2ludHMgYW5kIGNvbnRhaW4gYXQgbGVhc3QgMyBwb2ludHNcIilcbiAgICB9XG4gIH1cblxuICByZW1vdmVWZXJ0KHZlcnRJbmRleCkge1xuICAgIGlmICh0aGlzLl92ZXJ0cy5sZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZW1vdmUgdmVydGV4ICR7dmVydEluZGV4fS4gSXQgd291bGQgcmVzdWx0IGluIGEgcG9seSB3aXRoIDwgMyBwb2ludHMuIEEgcG9seSBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgMyBwb2ludHMuYClcbiAgICB9XG5cbiAgICBzdXBlci5yZW1vdmVWZXJ0KHZlcnRJbmRleClcbiAgfVxuXG5cbiAgX2RyYXcoY3R4KSB7XG4gICAgbGV0IHJ0biA9IGZhbHNlXG4gICAgaWYgKHRoaXMuX3ZlcnRzLmxlbmd0aCA+PSAzKSB7XG4gICAgICBjdHgubW92ZVRvKHRoaXMuX3ZlcnRzWzBdWzBdLCB0aGlzLl92ZXJ0c1swXVsxXSlcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fdmVydHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY3R4LmxpbmVUbyh0aGlzLl92ZXJ0c1tpXVswXSwgdGhpcy5fdmVydHNbaV1bMV0pXG4gICAgICB9XG4gICAgICBjdHguY2xvc2VQYXRoKClcbiAgICAgIHJ0biA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHJ0blxuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHN1cGVyLnRvSlNPTigpLCB7XG4gICAgICB0eXBlOiBcIlBvbHlcIiAvLyBOT1RFOiB0aGlzIG11Y2ggbWF0Y2ggdGhlIG5hbWUgb2YgdGhlIGNsYXNzXG4gICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbHNvIHN1cHBsaWVkIGFmdGVyIHRoZSBzdXBlci50b0pTT04oKVxuICAgICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhpcyB0eXBlIG92ZXJyaWRlcyB0aGUgcGFyZW50IGNsYXNzJ3NcbiAgICAgICAgICAgICAgICAgICAvLyB0eXBlXG4gICAgfSlcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc2hhcGVzL3BvbHkuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 30 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Gets the pixel ratio of a specific HTML canvas 2d context\n * @param  {CanvasRenderingContext2D} canvasCtx\n * @return {number}           pixel ratio of the canvas 2d context\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPixelRatio = getPixelRatio;\nexports.makeCanvasAutoHighDPI = makeCanvasAutoHighDPI;\nfunction getPixelRatio(canvasCtx) {\n  var backingStore = canvasCtx.backingStorePixelRatio || canvasCtx.webkitBackingStorePixelRatio || canvasCtx.mozBackingStorePixelRatio || canvasCtx.msBackingStorePixelRatio || canvasCtx.oBackingStorePixelRatio || canvasCtx.backingStorePixelRatio || 1;\n\n  return (window.devicePixelRatio || 1) / backingStore;\n}\n\n/**\n * Wraps certain canvas 2d context APIs to handle\n * displays with high per-pixel ratios. This is useful\n * so that the API can be called with screen-space coordinates\n * and the wrappers modify the arguments of those APIs to properly\n * handle displays with high pixel densities\n * @param  {CanvasRenderingContext2D} canvasCtx\n * @return {number}           pixel ratio of the wrapped canvas context\n */\nfunction makeCanvasAutoHighDPI(canvasCtx) {\n  var pixelRatio = getPixelRatio(canvasCtx);\n\n  if (pixelRatio === 1) {\n    return 1;\n  }\n\n  var allRatioArgs = [\"fillRect\", \"clearRect\", \"strokeRect\",\n  // \"moveTo\",\n  // \"lineTo\",\n  // \"arcTo\",\n  // \"bezierCurveTo\",\n  \"isPointInPath\", \"isPointInStroke\"\n  // \"quadraticCurveTo\",\n  // \"rect\",\n  // \"translate\",\n  // \"createRadialGradient\",\n  // \"createLinearGradient\"\n  ];\n\n  allRatioArgs.forEach(function (funcName) {\n    canvasCtx[funcName] = function (_super) {\n      return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        args = args.map(function (a) {\n          return a * pixelRatio;\n        });\n\n        return _super.apply(this, args);\n      };\n    }(canvasCtx[funcName]);\n  });\n\n  // const ratioArgsByIndex = {\n  //   arc: [0, 1, 2]\n  // }\n\n  // Object.getOwnPropertyNames(ratioArgsByIndex).forEach(funcName => {\n  //   const value = ratioArgsByIndex[funcName]\n  //   canvasCtx[funcName] = (function(_super) {\n  //     return function(...args) {\n  //       let i = 0\n  //       let len = 0\n  //       for (i = 0, len = value.length; i < len; i += 1) {\n  //         args[value[i]] *= pixelRatio\n  //       }\n  //       return _super.apply(this, args)\n  //     }\n  //   })(canvasCtx[funcName])\n  // })\n\n  // // Stroke lineWidth adjustment\n  // canvasCtx.stroke = (function(_super) {\n  //   return function(...args) {\n  //     this.lineWidth *= pixelRatio\n  //     _super.apply(this, args)\n  //     this.lineWidth /= pixelRatio\n  //   }\n  // })(canvasCtx.stroke)\n\n  // // Text\n  // //\n  // canvasCtx.fillText = (function(_super) {\n  //   return function(...args) {\n  //     args[1] *= pixelRatio // x\n  //     args[2] *= pixelRatio // y\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m * pixelRatio) + u\n  //       }\n  //     )\n\n  //     _super.apply(this, args)\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m / pixelRatio) + u\n  //       }\n  //     )\n  //   }\n  // })(canvasCtx.fillText)\n\n  // canvasCtx.strokeText = (function(_super) {\n  //   return function(...args) {\n  //     args[1] *= pixelRatio // x\n  //     args[2] *= pixelRatio // y\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m * pixelRatio) + u\n  //       }\n  //     )\n\n  //     _super.apply(this, args)\n\n  //     this.font = this.font.replace(\n  //       /(\\d+)(px|em|rem|pt)/g,\n  //       function(w, m, u) {\n  //         return (m / pixelRatio) + u\n  //       }\n  //     )\n  //   }\n  // })(canvasCtx.strokeText)\n\n\n  var setTransformArgs = [pixelRatio, 0, 0, pixelRatio, 0, 0];\n  canvasCtx.setTransform = function (_super) {\n    return function () {\n      _super.apply(this, setTransformArgs);\n      this.transform.apply(this, arguments);\n    };\n  }(canvasCtx.setTransform);\n\n  return pixelRatio;\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL2NhbnZhcy11dGlscy5qcz84MjExIl0sIm5hbWVzIjpbImdldFBpeGVsUmF0aW8iLCJtYWtlQ2FudmFzQXV0b0hpZ2hEUEkiLCJjYW52YXNDdHgiLCJiYWNraW5nU3RvcmUiLCJiYWNraW5nU3RvcmVQaXhlbFJhdGlvIiwid2Via2l0QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJtc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8iLCJvQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJwaXhlbFJhdGlvIiwiYWxsUmF0aW9BcmdzIiwiZm9yRWFjaCIsImZ1bmNOYW1lIiwiX3N1cGVyIiwiYXJncyIsIm1hcCIsImEiLCJhcHBseSIsInNldFRyYW5zZm9ybUFyZ3MiLCJzZXRUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOzs7Ozs7Ozs7UUFLZ0JBLGEsR0FBQUEsYTtRQW9CQUMscUIsR0FBQUEscUI7QUFwQlQsU0FBU0QsYUFBVCxDQUF1QkUsU0FBdkIsRUFBa0M7QUFDdkMsTUFBTUMsZUFBZUQsVUFBVUUsc0JBQVYsSUFDbkJGLFVBQVVHLDRCQURTLElBRW5CSCxVQUFVSSx5QkFGUyxJQUduQkosVUFBVUssd0JBSFMsSUFJbkJMLFVBQVVNLHVCQUpTLElBS25CTixVQUFVRSxzQkFMUyxJQUtpQixDQUx0Qzs7QUFPQSxTQUFPLENBQUNLLE9BQU9DLGdCQUFQLElBQTJCLENBQTVCLElBQWlDUCxZQUF4QztBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTTyxTQUFTRixxQkFBVCxDQUErQkMsU0FBL0IsRUFBMEM7QUFDL0MsTUFBTVMsYUFBYVgsY0FBY0UsU0FBZCxDQUFuQjs7QUFFQSxNQUFJUyxlQUFlLENBQW5CLEVBQXNCO0FBQ3BCLFdBQU8sQ0FBUDtBQUNEOztBQUVELE1BQU1DLGVBQWUsQ0FDbkIsVUFEbUIsRUFFbkIsV0FGbUIsRUFHbkIsWUFIbUI7QUFJbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFSbUIsRUFTbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZG1CLEdBQXJCOztBQWlCQUEsZUFBYUMsT0FBYixDQUFxQixvQkFBWTtBQUMvQlgsY0FBVVksUUFBVixJQUF1QixVQUFTQyxNQUFULEVBQWlCO0FBQ3RDLGFBQU8sWUFBa0I7QUFBQSwwQ0FBTkMsSUFBTTtBQUFOQSxjQUFNO0FBQUE7O0FBQ3ZCQSxlQUFPQSxLQUFLQyxHQUFMLENBQVMsVUFBU0MsQ0FBVCxFQUFZO0FBQzFCLGlCQUFPQSxJQUFJUCxVQUFYO0FBQ0QsU0FGTSxDQUFQOztBQUlBLGVBQU9JLE9BQU9JLEtBQVAsQ0FBYSxJQUFiLEVBQW1CSCxJQUFuQixDQUFQO0FBQ0QsT0FORDtBQU9ELEtBUnFCLENBUW5CZCxVQUFVWSxRQUFWLENBUm1CLENBQXRCO0FBU0QsR0FWRDs7QUFZQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE1BQU1NLG1CQUFtQixDQUFDVCxVQUFELEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQkEsVUFBbkIsRUFBK0IsQ0FBL0IsRUFBa0MsQ0FBbEMsQ0FBekI7QUFDQVQsWUFBVW1CLFlBQVYsR0FBMEIsVUFBU04sTUFBVCxFQUFpQjtBQUN6QyxXQUFPLFlBQWtCO0FBQ3ZCQSxhQUFPSSxLQUFQLENBQWEsSUFBYixFQUFtQkMsZ0JBQW5CO0FBQ0EsV0FBS0UsU0FBTDtBQUNELEtBSEQ7QUFJRCxHQUx3QixDQUt0QnBCLFVBQVVtQixZQUxZLENBQXpCOztBQU9BLFNBQU9WLFVBQVA7QUFDRCIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbi8qKlxuICogR2V0cyB0aGUgcGl4ZWwgcmF0aW8gb2YgYSBzcGVjaWZpYyBIVE1MIGNhbnZhcyAyZCBjb250ZXh0XG4gKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNhbnZhc0N0eFxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhcyAyZCBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQaXhlbFJhdGlvKGNhbnZhc0N0eCkge1xuICBjb25zdCBiYWNraW5nU3RvcmUgPSBjYW52YXNDdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgIGNhbnZhc0N0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY2FudmFzQ3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjYW52YXNDdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY2FudmFzQ3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY2FudmFzQ3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMVxuXG4gIHJldHVybiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmVcbn1cblxuLyoqXG4gKiBXcmFwcyBjZXJ0YWluIGNhbnZhcyAyZCBjb250ZXh0IEFQSXMgdG8gaGFuZGxlXG4gKiBkaXNwbGF5cyB3aXRoIGhpZ2ggcGVyLXBpeGVsIHJhdGlvcy4gVGhpcyBpcyB1c2VmdWxcbiAqIHNvIHRoYXQgdGhlIEFQSSBjYW4gYmUgY2FsbGVkIHdpdGggc2NyZWVuLXNwYWNlIGNvb3JkaW5hdGVzXG4gKiBhbmQgdGhlIHdyYXBwZXJzIG1vZGlmeSB0aGUgYXJndW1lbnRzIG9mIHRob3NlIEFQSXMgdG8gcHJvcGVybHlcbiAqIGhhbmRsZSBkaXNwbGF5cyB3aXRoIGhpZ2ggcGl4ZWwgZGVuc2l0aWVzXG4gKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGNhbnZhc0N0eFxuICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgcGl4ZWwgcmF0aW8gb2YgdGhlIHdyYXBwZWQgY2FudmFzIGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDYW52YXNBdXRvSGlnaERQSShjYW52YXNDdHgpIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oY2FudmFzQ3R4KVxuXG4gIGlmIChwaXhlbFJhdGlvID09PSAxKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIGNvbnN0IGFsbFJhdGlvQXJncyA9IFtcbiAgICBcImZpbGxSZWN0XCIsXG4gICAgXCJjbGVhclJlY3RcIixcbiAgICBcInN0cm9rZVJlY3RcIixcbiAgICAvLyBcIm1vdmVUb1wiLFxuICAgIC8vIFwibGluZVRvXCIsXG4gICAgLy8gXCJhcmNUb1wiLFxuICAgIC8vIFwiYmV6aWVyQ3VydmVUb1wiLFxuICAgIFwiaXNQb2ludEluUGF0aFwiLFxuICAgIFwiaXNQb2ludEluU3Ryb2tlXCJcbiAgICAvLyBcInF1YWRyYXRpY0N1cnZlVG9cIixcbiAgICAvLyBcInJlY3RcIixcbiAgICAvLyBcInRyYW5zbGF0ZVwiLFxuICAgIC8vIFwiY3JlYXRlUmFkaWFsR3JhZGllbnRcIixcbiAgICAvLyBcImNyZWF0ZUxpbmVhckdyYWRpZW50XCJcbiAgXVxuXG4gIGFsbFJhdGlvQXJncy5mb3JFYWNoKGZ1bmNOYW1lID0+IHtcbiAgICBjYW52YXNDdHhbZnVuY05hbWVdID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICByZXR1cm4gYSAqIHBpeGVsUmF0aW9cbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICB9XG4gICAgfSkoY2FudmFzQ3R4W2Z1bmNOYW1lXSlcbiAgfSlcblxuICAvLyBjb25zdCByYXRpb0FyZ3NCeUluZGV4ID0ge1xuICAvLyAgIGFyYzogWzAsIDEsIDJdXG4gIC8vIH1cblxuICAvLyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyYXRpb0FyZ3NCeUluZGV4KS5mb3JFYWNoKGZ1bmNOYW1lID0+IHtcbiAgLy8gICBjb25zdCB2YWx1ZSA9IHJhdGlvQXJnc0J5SW5kZXhbZnVuY05hbWVdXG4gIC8vICAgY2FudmFzQ3R4W2Z1bmNOYW1lXSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgLy8gICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIC8vICAgICAgIGxldCBpID0gMFxuICAvLyAgICAgICBsZXQgbGVuID0gMFxuICAvLyAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSkge1xuICAvLyAgICAgICAgIGFyZ3NbdmFsdWVbaV1dICo9IHBpeGVsUmF0aW9cbiAgLy8gICAgICAgfVxuICAvLyAgICAgICByZXR1cm4gX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIC8vICAgICB9XG4gIC8vICAgfSkoY2FudmFzQ3R4W2Z1bmNOYW1lXSlcbiAgLy8gfSlcblxuICAvLyAvLyBTdHJva2UgbGluZVdpZHRoIGFkanVzdG1lbnRcbiAgLy8gY2FudmFzQ3R4LnN0cm9rZSA9IChmdW5jdGlvbihfc3VwZXIpIHtcbiAgLy8gICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAvLyAgICAgdGhpcy5saW5lV2lkdGggKj0gcGl4ZWxSYXRpb1xuICAvLyAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIC8vICAgICB0aGlzLmxpbmVXaWR0aCAvPSBwaXhlbFJhdGlvXG4gIC8vICAgfVxuICAvLyB9KShjYW52YXNDdHguc3Ryb2tlKVxuXG4gIC8vIC8vIFRleHRcbiAgLy8gLy9cbiAgLy8gY2FudmFzQ3R4LmZpbGxUZXh0ID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAvLyAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gIC8vICAgICBhcmdzWzFdICo9IHBpeGVsUmF0aW8gLy8geFxuICAvLyAgICAgYXJnc1syXSAqPSBwaXhlbFJhdGlvIC8vIHlcblxuICAvLyAgICAgdGhpcy5mb250ID0gdGhpcy5mb250LnJlcGxhY2UoXG4gIC8vICAgICAgIC8oXFxkKykocHh8ZW18cmVtfHB0KS9nLFxuICAvLyAgICAgICBmdW5jdGlvbih3LCBtLCB1KSB7XG4gIC8vICAgICAgICAgcmV0dXJuIChtICogcGl4ZWxSYXRpbykgKyB1XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIClcblxuICAvLyAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3MpXG5cbiAgLy8gICAgIHRoaXMuZm9udCA9IHRoaXMuZm9udC5yZXBsYWNlKFxuICAvLyAgICAgICAvKFxcZCspKHB4fGVtfHJlbXxwdCkvZyxcbiAgLy8gICAgICAgZnVuY3Rpb24odywgbSwgdSkge1xuICAvLyAgICAgICAgIHJldHVybiAobSAvIHBpeGVsUmF0aW8pICsgdVxuICAvLyAgICAgICB9XG4gIC8vICAgICApXG4gIC8vICAgfVxuICAvLyB9KShjYW52YXNDdHguZmlsbFRleHQpXG5cbiAgLy8gY2FudmFzQ3R4LnN0cm9rZVRleHQgPSAoZnVuY3Rpb24oX3N1cGVyKSB7XG4gIC8vICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgLy8gICAgIGFyZ3NbMV0gKj0gcGl4ZWxSYXRpbyAvLyB4XG4gIC8vICAgICBhcmdzWzJdICo9IHBpeGVsUmF0aW8gLy8geVxuXG4gIC8vICAgICB0aGlzLmZvbnQgPSB0aGlzLmZvbnQucmVwbGFjZShcbiAgLy8gICAgICAgLyhcXGQrKShweHxlbXxyZW18cHQpL2csXG4gIC8vICAgICAgIGZ1bmN0aW9uKHcsIG0sIHUpIHtcbiAgLy8gICAgICAgICByZXR1cm4gKG0gKiBwaXhlbFJhdGlvKSArIHVcbiAgLy8gICAgICAgfVxuICAvLyAgICAgKVxuXG4gIC8vICAgICBfc3VwZXIuYXBwbHkodGhpcywgYXJncylcblxuICAvLyAgICAgdGhpcy5mb250ID0gdGhpcy5mb250LnJlcGxhY2UoXG4gIC8vICAgICAgIC8oXFxkKykocHh8ZW18cmVtfHB0KS9nLFxuICAvLyAgICAgICBmdW5jdGlvbih3LCBtLCB1KSB7XG4gIC8vICAgICAgICAgcmV0dXJuIChtIC8gcGl4ZWxSYXRpbykgKyB1XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIClcbiAgLy8gICB9XG4gIC8vIH0pKGNhbnZhc0N0eC5zdHJva2VUZXh0KVxuXG5cbiAgY29uc3Qgc2V0VHJhbnNmb3JtQXJncyA9IFtwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwXVxuICBjYW52YXNDdHguc2V0VHJhbnNmb3JtID0gKGZ1bmN0aW9uKF9zdXBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICBfc3VwZXIuYXBwbHkodGhpcywgc2V0VHJhbnNmb3JtQXJncylcbiAgICAgIHRoaXMudHJhbnNmb3JtKC4uLmFyZ3MpXG4gICAgfVxuICB9KShjYW52YXNDdHguc2V0VHJhbnNmb3JtKVxuXG4gIHJldHVybiBwaXhlbFJhdGlvXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi91dGlsL2NhbnZhcy11dGlscy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 31 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\n/**\n * Binds a this arg to a list of different function names.\n * This is most widely used to bind a this to member functions\n * that are used as callbacks in some fashion\n * @param  {string[]} funcNames array of member function names that are part of thisArg\n * @param  {Object} thisArg   object to bind\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bindAll = bindAll;\nfunction bindAll(funcNames, thisArg) {\n  funcNames.forEach(function (funcName) {\n    if (!thisArg[funcName]) {\n      return;\n    }\n    thisArg[funcName] = thisArg[funcName].bind(thisArg);\n  });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi91dGlsL3V0aWxzLmpzPzMxMzEiXSwibmFtZXMiOlsiYmluZEFsbCIsImZ1bmNOYW1lcyIsInRoaXNBcmciLCJmb3JFYWNoIiwiZnVuY05hbWUiLCJiaW5kIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7Ozs7Ozs7Ozs7UUFPZ0JBLE8sR0FBQUEsTztBQUFULFNBQVNBLE9BQVQsQ0FBaUJDLFNBQWpCLEVBQTRCQyxPQUE1QixFQUFxQztBQUMxQ0QsWUFBVUUsT0FBVixDQUFrQixvQkFBWTtBQUM1QixRQUFJLENBQUNELFFBQVFFLFFBQVIsQ0FBTCxFQUF3QjtBQUN0QjtBQUNEO0FBQ0RGLFlBQVFFLFFBQVIsSUFBb0JGLFFBQVFFLFFBQVIsRUFBa0JDLElBQWxCLENBQXVCSCxPQUF2QixDQUFwQjtBQUNELEdBTEQ7QUFNRCIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiXG5cbi8qKlxuICogQmluZHMgYSB0aGlzIGFyZyB0byBhIGxpc3Qgb2YgZGlmZmVyZW50IGZ1bmN0aW9uIG5hbWVzLlxuICogVGhpcyBpcyBtb3N0IHdpZGVseSB1c2VkIHRvIGJpbmQgYSB0aGlzIHRvIG1lbWJlciBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIHVzZWQgYXMgY2FsbGJhY2tzIGluIHNvbWUgZmFzaGlvblxuICogQHBhcmFtICB7c3RyaW5nW119IGZ1bmNOYW1lcyBhcnJheSBvZiBtZW1iZXIgZnVuY3Rpb24gbmFtZXMgdGhhdCBhcmUgcGFydCBvZiB0aGlzQXJnXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRoaXNBcmcgICBvYmplY3QgdG8gYmluZFxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluZEFsbChmdW5jTmFtZXMsIHRoaXNBcmcpIHtcbiAgZnVuY05hbWVzLmZvckVhY2goZnVuY05hbWUgPT4ge1xuICAgIGlmICghdGhpc0FyZ1tmdW5jTmFtZV0pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzQXJnW2Z1bmNOYW1lXSA9IHRoaXNBcmdbZnVuY05hbWVdLmJpbmQodGhpc0FyZylcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3V0aWwvdXRpbHMuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _aabox2d = __webpack_require__(2);\n\nvar AABox2d = _interopRequireWildcard(_aabox2d);\n\nvar _aggregation2 = __webpack_require__(8);\n\nvar _aggregation3 = _interopRequireDefault(_aggregation2);\n\nvar _transform2d = __webpack_require__(14);\n\nvar _eventHandler = __webpack_require__(15);\n\nvar _eventHandler2 = _interopRequireDefault(_eventHandler);\n\nvar _mat2d = __webpack_require__(7);\n\nvar _mat2d2 = _interopRequireDefault(_mat2d);\n\nvar _glMatrix = __webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Camera modification event\n * @event EventedCamera#changed\n * @type {object}\n * @property {string} attr Name of the attribute modified\n * @property {} prevVal Previous value of the attribute prior to modification\n * @property {} currVal Value of the attribute post modification\n */\n\n/**\n * @class Base camera class for 2d screen projections\n *        The base class is used only for the NDC to screen space trasform\n * @extends {EventHandler}\n */\nvar BaseCamera2d = function (_EventHandler) {\n  _inherits(BaseCamera2d, _EventHandler);\n\n  /**\n   * Constructs a new 2d camera\n   * @param  {AABox2d}  viewport           Initial camera viewport boundary, in pixels\n   * @param  {Vec2d}  projectionDimensions The width and height of the viewport in world coordinates\n   * @param  {Boolean} [flipY=false]       Whether world y coordinates are flipped, if false\n   *                                       the top of the viewport window is smaller in y, and the bottom\n   *                                       is larger. If true, the bottom has smaller y coords, and the top\n   *                                       larger\n   * @return {BaseCamera2d}\n   */\n  function BaseCamera2d(viewport, projectionDimensions) {\n    var flipY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, BaseCamera2d);\n\n    var _this = _possibleConstructorReturn(this, (BaseCamera2d.__proto__ || Object.getPrototypeOf(BaseCamera2d)).call(this, [\"changed\", \"changed:xform\"]));\n    // initialize modify events\n\n\n    _this._viewport = AABox2d.clone(viewport);\n    _this._projectionDimensions = _glMatrix.vec2.clone(projectionDimensions);\n    _this._yflip = flipY;\n\n    // stores the NDC space to screen space matrix\n    // NDC (normalized device coordinates) is the space\n    // where the left edge of the window is -1, the right edge is 1\n    // the top edge is -1, and the bottom edge is 1.\n    _this._screenMatrix = _mat2d2.default.create();\n\n    // this flag is dirty whenever the attributes for the\n    // ndc-to-screen projection are modified\n    _this._screenDirty = true;\n    return _this;\n  }\n\n  /**\n   * Returns true if the world Y coordinates go from negative to positive\n   * in a bottom to top fashion in screen space, false otherwise.\n   * @return {Boolean}\n   */\n\n\n  _createClass(BaseCamera2d, [{\n    key: \"isYFlipped\",\n    value: function isYFlipped() {\n      return this._yflip;\n    }\n\n    /**\n     * Sets the camera's screen-space viewport bounds\n     * @param  {AABox2d} viewport\n     * @fires  EventedCamera#changed\n     * @return {BaseCamera2d}\n     */\n\n  }, {\n    key: \"viewport\",\n    set: function set(viewport) {\n      if (!AABox2d.equals(viewport, this._viewport)) {\n        var prev = AABox2d.clone(this._viewport);\n        AABox2d.copy(this._viewport, viewport);\n        this._screenDirty = true;\n        this._worldToScreenOutdated = true;\n        this.fire(\"changed\", {\n          attr: \"viewport\",\n          prevVal: prev,\n          currVal: viewport\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets a copy of the camera's current viewport\n     * @return {AABox2d}\n     */\n    ,\n    get: function get() {\n      return AABox2d.clone(this._viewport);\n    }\n\n    /**\n     * Gets a reference to the camera's current viewport\n     * @return {AABox2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"viewportRef\",\n    get: function get() {\n      return this._viewport;\n    }\n\n    /**\n     * Gets the current NDC to screen space transform matrix\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"screenMatrix\",\n    get: function get() {\n      if (this._screenDirty) {\n        var center = [0, 0];\n        var extents = [0, 0];\n        AABox2d.getCenter(center, this._viewport);\n        AABox2d.getExtents(extents, this._viewport);\n        _mat2d2.default.set(this._screenMatrix, extents[0], 0, 0, extents[1], center[0], center[1]);\n        this._worldToScreenOutdated = true;\n        this._screenDirty = false;\n      }\n      return this._screenMatrix;\n    }\n  }]);\n\n  return BaseCamera2d;\n}(_eventHandler2.default);\n\n/**\n * @class Main 2d camera class to manage othographic 2d projections\n * @extends {BaseCamera2d}\n * @mixin {EventedTransform2d}\n */\n\n\nvar Camera2d = function (_aggregation) {\n  _inherits(Camera2d, _aggregation);\n\n  /**\n   * Creates a new Camera2d object\n   * @param  {AABox2d} viewport             The camera's viewport bounds in pixel space\n   * @param  {Vec2d} projectionDimensions The width/height of the camera's viewport in world coordinates\n   * @param  {Boolean} flipY              True if the direction from negative to positive Y coordinates\n   *                                      go from the bottom to top of the window. False means Y coords\n   *                                      from negative to positive values go from the top to the bottom\n   * @return {Camera2d}\n   */\n  function Camera2d(viewport, projectionDimensions, flipY) {\n    _classCallCheck(this, Camera2d);\n\n    var _this2 = _possibleConstructorReturn(this, (Camera2d.__proto__ || Object.getPrototypeOf(Camera2d)).call(this, viewport, projectionDimensions, flipY));\n\n    _this2._viewMatrix = _mat2d2.default.create();\n    _this2._viewDirty = true;\n    _this2._projMatrix = _mat2d2.default.create();\n    _this2._projDirty = true;\n    return _this2;\n  }\n\n  /**\n   * Sets the projection dimensions of the camera's view. This is the width/height\n   * in world space coordiantes of the camera's view.\n   * @param  {Vec2d} projectionDimensions\n   * @return {Camera2d} this\n   */\n\n\n  _createClass(Camera2d, [{\n    key: \"_localXformUpdated\",\n\n\n    /**\n     * Called when the local transform (does not include parent transforms) of the Transform2d\n     * mixin is modified. Used to be notified internally that the view-to-screen space\n     * transformation needs updating\n     * @private\n     */\n    value: function _localXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Called when the global matrix (includes parent transforms) of the\n     * Transform2d mixin is modified. Used to be notified internally that\n     * the view-to-screen space transformation needs updating\n     * @private\n     */\n\n  }, {\n    key: \"_globalXformUpdated\",\n    value: function _globalXformUpdated() {\n      this._boundsOutOfDate = true;\n    }\n\n    /**\n     * Gets the transformation matrix from world space to view/camera space\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"_matricesDirty\",\n\n\n    /**\n     * Returns true if any of the dirty flags are active\n     * @return {Boolean}\n     * @private\n     */\n    value: function _matricesDirty() {\n      return this._boundsOutOfDate || this._lxformDirty || this._xformDirty || this._viewDirty || this._projDirty || this._screenDirty;\n    }\n\n    /**\n     * Gets the transformation matrix from world space to screen space.\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"projectionDimensions\",\n    set: function set(projectionDimensions) {\n      if (!_glMatrix.vec2.equals(projectionDimensions, this._projectionDimensions)) {\n        var prev = _glMatrix.vec2.clone(this._projectionDimensions);\n        AABox2d.copy(this._projectionDimensions, projectionDimensions);\n        this._viewDirty = true;\n        this._projDirty = true;\n        // this._yflip = this._projectionDimensions[3] < this._projectionDimensions[1]\n        this.fire(\"changed\", {\n          attr: \"projectionDimensions\",\n          prevVal: prev,\n          currVal: projectionDimensions\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Gets a copy of the camera's current projection dimensions\n     * @return {Vec2d}\n     */\n    ,\n    get: function get() {\n      return _glMatrix.vec2.clone(this._projectionDimensions);\n    }\n\n    /**\n     * Gets a reference to the camera's current projection dimensions\n     * @return {Vec2d}\n     * @readOnly\n     */\n\n  }, {\n    key: \"projectionDimensionsRef\",\n    get: function get() {\n      return this._projectionDimensions;\n    }\n  }, {\n    key: \"viewMatrix\",\n    get: function get() {\n      if (this._viewDirty || this._boundsOutOfDate || this._xformDirty || this._lxformDirty) {\n        // the matrix has been marked dirty, so recalculate\n        var pos = [0, 0];\n        var scale = [0, 0];\n        var rot = [0, 0];\n        var xform = this.globalXform;\n        _mat2d2.default.svd(pos, scale, rot, xform);\n        _mat2d2.default.fromTranslation(this._viewMatrix, _glMatrix.vec2.negate(pos, pos));\n        _mat2d2.default.rotate(this._viewMatrix, this._viewMatrix, -rot[0]);\n        _mat2d2.default.scale(this._viewMatrix, this._viewMatrix, scale);\n        _mat2d2.default.rotate(this._viewMatrix, this._viewMatrix, -rot[1]);\n        this._worldToScreenOutdated = true;\n        this._viewDirty = false;\n      }\n      return this._viewMatrix;\n    }\n\n    /**\n     * Gets the orthographic projection transformation matrix from\n     * view to NDC (normalized device coordinates) space\n     * @return {Mat2d}\n     */\n\n  }, {\n    key: \"projMatrix\",\n    get: function get() {\n      if (this._projDirty) {\n        var flip = this._yflip ? -1 : 1;\n        _mat2d2.default.set(this._projMatrix, 2.0 / this._projectionDimensions[0], 0, 0, flip * 2.0 / this._projectionDimensions[1], 0, 0);\n        this._worldToScreenOutdated = true;\n        this._projDirty = false;\n      }\n      return this._projMatrix;\n    }\n  }, {\n    key: \"worldToScreenMatrix\",\n    get: function get() {\n      if (!this._worldToScreenMatrix || this._worldToScreenOutdated || this._matricesDirty()) {\n        if (!this._worldToScreenMatrix) {\n          this._worldToScreenMatrix = _mat2d2.default.create();\n        }\n        _mat2d2.default.copy(this._worldToScreenMatrix, this.viewMatrix);\n        _mat2d2.default.multiply(this._worldToScreenMatrix, this.projMatrix, this._worldToScreenMatrix);\n        _mat2d2.default.multiply(this._worldToScreenMatrix, this.screenMatrix, this._worldToScreenMatrix);\n        this._worldToScreenOutdated = false;\n        this._screenToWorldOutdated = true;\n      }\n      return this._worldToScreenMatrix;\n    }\n\n    /**\n     * Gets teh transform matrix from screen space to world space.\n     * @return {[type]} [description]\n     */\n\n  }, {\n    key: \"screenToWorldMatrix\",\n    get: function get() {\n      if (!this._screenToWorld || this._screenToWorldOutdated || this._matricesDirty()) {\n        if (!this._screenToWorld) {\n          this._screenToWorld = _mat2d2.default.create();\n        }\n        _mat2d2.default.copy(this._screenToWorld, this.worldToScreenMatrix);\n        _mat2d2.default.invert(this._screenToWorld, this._screenToWorld);\n        this._screenToWorldOutdated = false;\n      }\n      return this._screenToWorld;\n    }\n  }]);\n\n  return Camera2d;\n}((0, _aggregation3.default)(BaseCamera2d, (0, _transform2d.createEventedTransform2dMixin)(\"changed:xform\")));\n\nexports.default = Camera2d;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92aWV3L2NhbWVyYTJkLmpzP2YyYWUiXSwibmFtZXMiOlsiQUFCb3gyZCIsIkJhc2VDYW1lcmEyZCIsInZpZXdwb3J0IiwicHJvamVjdGlvbkRpbWVuc2lvbnMiLCJmbGlwWSIsIl92aWV3cG9ydCIsImNsb25lIiwiX3Byb2plY3Rpb25EaW1lbnNpb25zIiwiX3lmbGlwIiwiX3NjcmVlbk1hdHJpeCIsImNyZWF0ZSIsIl9zY3JlZW5EaXJ0eSIsImVxdWFscyIsInByZXYiLCJjb3B5IiwiX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCIsImZpcmUiLCJhdHRyIiwicHJldlZhbCIsImN1cnJWYWwiLCJjZW50ZXIiLCJleHRlbnRzIiwiZ2V0Q2VudGVyIiwiZ2V0RXh0ZW50cyIsInNldCIsIkNhbWVyYTJkIiwiX3ZpZXdNYXRyaXgiLCJfdmlld0RpcnR5IiwiX3Byb2pNYXRyaXgiLCJfcHJvakRpcnR5IiwiX2JvdW5kc091dE9mRGF0ZSIsIl9seGZvcm1EaXJ0eSIsIl94Zm9ybURpcnR5IiwicG9zIiwic2NhbGUiLCJyb3QiLCJ4Zm9ybSIsImdsb2JhbFhmb3JtIiwic3ZkIiwiZnJvbVRyYW5zbGF0aW9uIiwibmVnYXRlIiwicm90YXRlIiwiZmxpcCIsIl93b3JsZFRvU2NyZWVuTWF0cml4IiwiX21hdHJpY2VzRGlydHkiLCJ2aWV3TWF0cml4IiwibXVsdGlwbHkiLCJwcm9qTWF0cml4Iiwic2NyZWVuTWF0cml4IiwiX3NjcmVlblRvV29ybGRPdXRkYXRlZCIsIl9zY3JlZW5Ub1dvcmxkIiwid29ybGRUb1NjcmVlbk1hdHJpeCIsImludmVydCJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FBRUE7O0lBQVlBLE87O0FBQ1o7Ozs7QUFDQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBOzs7Ozs7Ozs7QUFTQTs7Ozs7SUFLTUMsWTs7O0FBQ0o7Ozs7Ozs7Ozs7QUFVQSx3QkFBWUMsUUFBWixFQUFzQkMsb0JBQXRCLEVBQTJE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QzlCLGVBQUtBLG9CQUFMLEdBQTRCLGdCQUFNakMsTUFBTixFQUE1QjtBQUNEO0FBQ0Qsd0JBQU1JLElBQU4sQ0FBVyxLQUFLNkIsb0JBQWhCLEVBQXNDLEtBQUtFLFVBQTNDO0FBQ0Esd0JBQU1DLFFBQU4sQ0FBZSxLQUFLSCxvQkFBcEIsRUFBMEMsS0FBS0ksVUFBL0MsRUFBMkQsS0FBS0osb0JBQWhFO0FBQ0Esd0JBQU1HLFFBQU4sQ0FBZSxLQUFLSCxvQkFBcEIsRUFBMEMsS0FBS0ssWUFBL0MsRUFBNkQsS0FBS0wsb0JBQWxFO0FBQ0EsYUFBSzVCLHNCQUFMLEdBQThCLEtBQTlCO0FBQ0EsYUFBS2tDLHNCQUFMLEdBQThCLElBQTlCO0FBQ0Q7QUFDRCxhQUFPLEtBQUtOLG9CQUFaO0FBQ0Q7O0FBRUQ7Ozs7Ozs7d0JBSTBCO0FBQ3hCLFVBQUksQ0FBQyxLQUFLTyxjQUFOLElBQXdCLEtBQUtELHNCQUE3QixJQUF1RCxLQUFLTCxjQUFMLEVBQTNELEVBQWtGO0FBQ2hGLFlBQUksQ0FBQyxLQUFLTSxjQUFWLEVBQTBCO0FBQ3hCLGVBQUtBLGNBQUwsR0FBc0IsZ0JBQU14QyxNQUFOLEVBQXRCO0FBQ0Q7QUFDRCx3QkFBTUksSUFBTixDQUFXLEtBQUtvQyxjQUFoQixFQUFnQyxLQUFLQyxtQkFBckM7QUFDQSx3QkFBTUMsTUFBTixDQUFhLEtBQUtGLGNBQWxCLEVBQWtDLEtBQUtBLGNBQXZDO0FBQ0EsYUFBS0Qsc0JBQUwsR0FBOEIsS0FBOUI7QUFDRDtBQUNELGFBQU8sS0FBS0MsY0FBWjtBQUNEOzs7O0VBOUptQywyQkFBWWpELFlBQVosRUFDcEMsZ0RBQThCLGVBQTlCLENBRG9DLEM7O2tCQUFqQndCLFEiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIlxuXG5pbXBvcnQgKiBhcyBBQUJveDJkIGZyb20gXCIuLi9jb3JlL2FhYm94MmRcIlxuaW1wb3J0IGFnZ3JlZ2F0aW9uIGZyb20gXCIuLi91dGlsL2FnZ3JlZ2F0aW9uXCJcbmltcG9ydCB7Y3JlYXRlRXZlbnRlZFRyYW5zZm9ybTJkTWl4aW59IGZyb20gXCIuLi9zaGFwZXMvdHJhbnNmb3JtMmRcIlxuaW1wb3J0IEV2ZW50SGFuZGxlciBmcm9tIFwiLi4vdXRpbC9ldmVudC1oYW5kbGVyXCJcbmltcG9ydCBNYXQyZCBmcm9tIFwiLi4vY29yZS9tYXQyZFwiXG5pbXBvcnQge3ZlYzIgYXMgVmVjMmR9IGZyb20gXCJnbC1tYXRyaXhcIlxuXG4vKipcbiAqIENhbWVyYSBtb2RpZmljYXRpb24gZXZlbnRcbiAqIEBldmVudCBFdmVudGVkQ2FtZXJhI2NoYW5nZWRcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXR0ciBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUgbW9kaWZpZWRcbiAqIEBwcm9wZXJ0eSB7fSBwcmV2VmFsIFByZXZpb3VzIHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUgcHJpb3IgdG8gbW9kaWZpY2F0aW9uXG4gKiBAcHJvcGVydHkge30gY3VyclZhbCBWYWx1ZSBvZiB0aGUgYXR0cmlidXRlIHBvc3QgbW9kaWZpY2F0aW9uXG4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQmFzZSBjYW1lcmEgY2xhc3MgZm9yIDJkIHNjcmVlbiBwcm9qZWN0aW9uc1xuICogICAgICAgIFRoZSBiYXNlIGNsYXNzIGlzIHVzZWQgb25seSBmb3IgdGhlIE5EQyB0byBzY3JlZW4gc3BhY2UgdHJhc2Zvcm1cbiAqIEBleHRlbmRzIHtFdmVudEhhbmRsZXJ9XG4gKi9cbmNsYXNzIEJhc2VDYW1lcmEyZCBleHRlbmRzIEV2ZW50SGFuZGxlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IDJkIGNhbWVyYVxuICAgKiBAcGFyYW0gIHtBQUJveDJkfSAgdmlld3BvcnQgICAgICAgICAgIEluaXRpYWwgY2FtZXJhIHZpZXdwb3J0IGJvdW5kYXJ5LCBpbiBwaXhlbHNcbiAgICogQHBhcmFtICB7VmVjMmR9ICBwcm9qZWN0aW9uRGltZW5zaW9ucyBUaGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgdmlld3BvcnQgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW2ZsaXBZPWZhbHNlXSAgICAgICBXaGV0aGVyIHdvcmxkIHkgY29vcmRpbmF0ZXMgYXJlIGZsaXBwZWQsIGlmIGZhbHNlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRvcCBvZiB0aGUgdmlld3BvcnQgd2luZG93IGlzIHNtYWxsZXIgaW4geSwgYW5kIHRoZSBib3R0b21cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBsYXJnZXIuIElmIHRydWUsIHRoZSBib3R0b20gaGFzIHNtYWxsZXIgeSBjb29yZHMsIGFuZCB0aGUgdG9wXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFyZ2VyXG4gICAqIEByZXR1cm4ge0Jhc2VDYW1lcmEyZH1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHZpZXdwb3J0LCBwcm9qZWN0aW9uRGltZW5zaW9ucywgZmxpcFkgPSBmYWxzZSkge1xuICAgIC8vIGluaXRpYWxpemUgbW9kaWZ5IGV2ZW50c1xuICAgIHN1cGVyKFtcImNoYW5nZWRcIiwgXCJjaGFuZ2VkOnhmb3JtXCJdKVxuXG4gICAgdGhpcy5fdmlld3BvcnQgPSBBQUJveDJkLmNsb25lKHZpZXdwb3J0KVxuICAgIHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zID0gVmVjMmQuY2xvbmUocHJvamVjdGlvbkRpbWVuc2lvbnMpXG4gICAgdGhpcy5feWZsaXAgPSBmbGlwWVxuXG4gICAgLy8gc3RvcmVzIHRoZSBOREMgc3BhY2UgdG8gc2NyZWVuIHNwYWNlIG1hdHJpeFxuICAgIC8vIE5EQyAobm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMpIGlzIHRoZSBzcGFjZVxuICAgIC8vIHdoZXJlIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHdpbmRvdyBpcyAtMSwgdGhlIHJpZ2h0IGVkZ2UgaXMgMVxuICAgIC8vIHRoZSB0b3AgZWRnZSBpcyAtMSwgYW5kIHRoZSBib3R0b20gZWRnZSBpcyAxLlxuICAgIHRoaXMuX3NjcmVlbk1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG5cbiAgICAvLyB0aGlzIGZsYWcgaXMgZGlydHkgd2hlbmV2ZXIgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZVxuICAgIC8vIG5kYy10by1zY3JlZW4gcHJvamVjdGlvbiBhcmUgbW9kaWZpZWRcbiAgICB0aGlzLl9zY3JlZW5EaXJ0eSA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHdvcmxkIFkgY29vcmRpbmF0ZXMgZ28gZnJvbSBuZWdhdGl2ZSB0byBwb3NpdGl2ZVxuICAgKiBpbiBhIGJvdHRvbSB0byB0b3AgZmFzaGlvbiBpbiBzY3JlZW4gc3BhY2UsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzWUZsaXBwZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3lmbGlwXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2FtZXJhJ3Mgc2NyZWVuLXNwYWNlIHZpZXdwb3J0IGJvdW5kc1xuICAgKiBAcGFyYW0gIHtBQUJveDJkfSB2aWV3cG9ydFxuICAgKiBAZmlyZXMgIEV2ZW50ZWRDYW1lcmEjY2hhbmdlZFxuICAgKiBAcmV0dXJuIHtCYXNlQ2FtZXJhMmR9XG4gICAqL1xuICBzZXQgdmlld3BvcnQodmlld3BvcnQpIHtcbiAgICBpZiAoIUFBQm94MmQuZXF1YWxzKHZpZXdwb3J0LCB0aGlzLl92aWV3cG9ydCkpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBBQUJveDJkLmNsb25lKHRoaXMuX3ZpZXdwb3J0KVxuICAgICAgQUFCb3gyZC5jb3B5KHRoaXMuX3ZpZXdwb3J0LCB2aWV3cG9ydClcbiAgICAgIHRoaXMuX3NjcmVlbkRpcnR5ID0gdHJ1ZVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZFwiLCB7XG4gICAgICAgIGF0dHI6IFwidmlld3BvcnRcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogdmlld3BvcnRcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvcHkgb2YgdGhlIGNhbWVyYSdzIGN1cnJlbnQgdmlld3BvcnRcbiAgICogQHJldHVybiB7QUFCb3gyZH1cbiAgICovXG4gIGdldCB2aWV3cG9ydCgpIHtcbiAgICByZXR1cm4gQUFCb3gyZC5jbG9uZSh0aGlzLl92aWV3cG9ydClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjYW1lcmEncyBjdXJyZW50IHZpZXdwb3J0XG4gICAqIEByZXR1cm4ge0FBQm94MmR9XG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgZ2V0IHZpZXdwb3J0UmVmKCkge1xuICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgTkRDIHRvIHNjcmVlbiBzcGFjZSB0cmFuc2Zvcm0gbWF0cml4XG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IHNjcmVlbk1hdHJpeCgpIHtcbiAgICBpZiAodGhpcy5fc2NyZWVuRGlydHkpIHtcbiAgICAgIGNvbnN0IGNlbnRlciA9IFswLCAwXVxuICAgICAgY29uc3QgZXh0ZW50cyA9IFswLCAwXVxuICAgICAgQUFCb3gyZC5nZXRDZW50ZXIoY2VudGVyLCB0aGlzLl92aWV3cG9ydClcbiAgICAgIEFBQm94MmQuZ2V0RXh0ZW50cyhleHRlbnRzLCB0aGlzLl92aWV3cG9ydClcbiAgICAgIE1hdDJkLnNldCh0aGlzLl9zY3JlZW5NYXRyaXgsIGV4dGVudHNbMF0sIDAsIDAsIGV4dGVudHNbMV0sIGNlbnRlclswXSwgY2VudGVyWzFdKVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fc2NyZWVuRGlydHkgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2NyZWVuTWF0cml4XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgTWFpbiAyZCBjYW1lcmEgY2xhc3MgdG8gbWFuYWdlIG90aG9ncmFwaGljIDJkIHByb2plY3Rpb25zXG4gKiBAZXh0ZW5kcyB7QmFzZUNhbWVyYTJkfVxuICogQG1peGluIHtFdmVudGVkVHJhbnNmb3JtMmR9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhbWVyYTJkIGV4dGVuZHMgYWdncmVnYXRpb24oQmFzZUNhbWVyYTJkLFxuICBjcmVhdGVFdmVudGVkVHJhbnNmb3JtMmRNaXhpbihcImNoYW5nZWQ6eGZvcm1cIikpIHtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDYW1lcmEyZCBvYmplY3RcbiAgICogQHBhcmFtICB7QUFCb3gyZH0gdmlld3BvcnQgICAgICAgICAgICAgVGhlIGNhbWVyYSdzIHZpZXdwb3J0IGJvdW5kcyBpbiBwaXhlbCBzcGFjZVxuICAgKiBAcGFyYW0gIHtWZWMyZH0gcHJvamVjdGlvbkRpbWVuc2lvbnMgVGhlIHdpZHRoL2hlaWdodCBvZiB0aGUgY2FtZXJhJ3Mgdmlld3BvcnQgaW4gd29ybGQgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gZmxpcFkgICAgICAgICAgICAgIFRydWUgaWYgdGhlIGRpcmVjdGlvbiBmcm9tIG5lZ2F0aXZlIHRvIHBvc2l0aXZlIFkgY29vcmRpbmF0ZXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdvIGZyb20gdGhlIGJvdHRvbSB0byB0b3Agb2YgdGhlIHdpbmRvdy4gRmFsc2UgbWVhbnMgWSBjb29yZHNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gbmVnYXRpdmUgdG8gcG9zaXRpdmUgdmFsdWVzIGdvIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tXG4gICAqIEByZXR1cm4ge0NhbWVyYTJkfVxuICAgKi9cbiAgY29uc3RydWN0b3Iodmlld3BvcnQsIHByb2plY3Rpb25EaW1lbnNpb25zLCBmbGlwWSkge1xuICAgIHN1cGVyKHZpZXdwb3J0LCBwcm9qZWN0aW9uRGltZW5zaW9ucywgZmxpcFkpXG5cbiAgICB0aGlzLl92aWV3TWF0cml4ID0gTWF0MmQuY3JlYXRlKClcbiAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlXG4gICAgdGhpcy5fcHJvak1hdHJpeCA9IE1hdDJkLmNyZWF0ZSgpXG4gICAgdGhpcy5fcHJvakRpcnR5ID0gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb2plY3Rpb24gZGltZW5zaW9ucyBvZiB0aGUgY2FtZXJhJ3Mgdmlldy4gVGhpcyBpcyB0aGUgd2lkdGgvaGVpZ2h0XG4gICAqIGluIHdvcmxkIHNwYWNlIGNvb3JkaWFudGVzIG9mIHRoZSBjYW1lcmEncyB2aWV3LlxuICAgKiBAcGFyYW0gIHtWZWMyZH0gcHJvamVjdGlvbkRpbWVuc2lvbnNcbiAgICogQHJldHVybiB7Q2FtZXJhMmR9IHRoaXNcbiAgICovXG4gIHNldCBwcm9qZWN0aW9uRGltZW5zaW9ucyhwcm9qZWN0aW9uRGltZW5zaW9ucykge1xuICAgIGlmICghVmVjMmQuZXF1YWxzKHByb2plY3Rpb25EaW1lbnNpb25zLCB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucykpIHtcbiAgICAgIGNvbnN0IHByZXYgPSBWZWMyZC5jbG9uZSh0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucylcbiAgICAgIEFBQm94MmQuY29weSh0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucywgcHJvamVjdGlvbkRpbWVuc2lvbnMpXG4gICAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlXG4gICAgICB0aGlzLl9wcm9qRGlydHkgPSB0cnVlXG4gICAgICAgIC8vIHRoaXMuX3lmbGlwID0gdGhpcy5fcHJvamVjdGlvbkRpbWVuc2lvbnNbM10gPCB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9uc1sxXVxuICAgICAgdGhpcy5maXJlKFwiY2hhbmdlZFwiLCB7XG4gICAgICAgIGF0dHI6IFwicHJvamVjdGlvbkRpbWVuc2lvbnNcIixcbiAgICAgICAgcHJldlZhbDogcHJldixcbiAgICAgICAgY3VyclZhbDogcHJvamVjdGlvbkRpbWVuc2lvbnNcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIGNvcHkgb2YgdGhlIGNhbWVyYSdzIGN1cnJlbnQgcHJvamVjdGlvbiBkaW1lbnNpb25zXG4gICAqIEByZXR1cm4ge1ZlYzJkfVxuICAgKi9cbiAgZ2V0IHByb2plY3Rpb25EaW1lbnNpb25zKCkge1xuICAgIHJldHVybiBWZWMyZC5jbG9uZSh0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGEgcmVmZXJlbmNlIHRvIHRoZSBjYW1lcmEncyBjdXJyZW50IHByb2plY3Rpb24gZGltZW5zaW9uc1xuICAgKiBAcmV0dXJuIHtWZWMyZH1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICBnZXQgcHJvamVjdGlvbkRpbWVuc2lvbnNSZWYoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGxvY2FsIHRyYW5zZm9ybSAoZG9lcyBub3QgaW5jbHVkZSBwYXJlbnQgdHJhbnNmb3Jtcykgb2YgdGhlIFRyYW5zZm9ybTJkXG4gICAqIG1peGluIGlzIG1vZGlmaWVkLiBVc2VkIHRvIGJlIG5vdGlmaWVkIGludGVybmFsbHkgdGhhdCB0aGUgdmlldy10by1zY3JlZW4gc3BhY2VcbiAgICogdHJhbnNmb3JtYXRpb24gbmVlZHMgdXBkYXRpbmdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9sb2NhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIGdsb2JhbCBtYXRyaXggKGluY2x1ZGVzIHBhcmVudCB0cmFuc2Zvcm1zKSBvZiB0aGVcbiAgICogVHJhbnNmb3JtMmQgbWl4aW4gaXMgbW9kaWZpZWQuIFVzZWQgdG8gYmUgbm90aWZpZWQgaW50ZXJuYWxseSB0aGF0XG4gICAqIHRoZSB2aWV3LXRvLXNjcmVlbiBzcGFjZSB0cmFuc2Zvcm1hdGlvbiBuZWVkcyB1cGRhdGluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dsb2JhbFhmb3JtVXBkYXRlZCgpIHtcbiAgICB0aGlzLl9ib3VuZHNPdXRPZkRhdGUgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gd29ybGQgc3BhY2UgdG8gdmlldy9jYW1lcmEgc3BhY2VcbiAgICogQHJldHVybiB7TWF0MmR9XG4gICAqL1xuICBnZXQgdmlld01hdHJpeCgpIHtcbiAgICBpZiAodGhpcy5fdmlld0RpcnR5IHx8IHRoaXMuX2JvdW5kc091dE9mRGF0ZSB8fCB0aGlzLl94Zm9ybURpcnR5IHx8IHRoaXMuX2x4Zm9ybURpcnR5KSB7XG4gICAgICAvLyB0aGUgbWF0cml4IGhhcyBiZWVuIG1hcmtlZCBkaXJ0eSwgc28gcmVjYWxjdWxhdGVcbiAgICAgIGNvbnN0IHBvcyA9IFswLCAwXVxuICAgICAgY29uc3Qgc2NhbGUgPSBbMCwgMF1cbiAgICAgIGNvbnN0IHJvdCA9IFswLCAwXVxuICAgICAgY29uc3QgeGZvcm0gPSB0aGlzLmdsb2JhbFhmb3JtXG4gICAgICBNYXQyZC5zdmQocG9zLCBzY2FsZSwgcm90LCB4Zm9ybSlcbiAgICAgIE1hdDJkLmZyb21UcmFuc2xhdGlvbih0aGlzLl92aWV3TWF0cml4LCBWZWMyZC5uZWdhdGUocG9zLCBwb3MpKVxuICAgICAgTWF0MmQucm90YXRlKHRoaXMuX3ZpZXdNYXRyaXgsIHRoaXMuX3ZpZXdNYXRyaXgsIC1yb3RbMF0pXG4gICAgICBNYXQyZC5zY2FsZSh0aGlzLl92aWV3TWF0cml4LCB0aGlzLl92aWV3TWF0cml4LCBzY2FsZSlcbiAgICAgIE1hdDJkLnJvdGF0ZSh0aGlzLl92aWV3TWF0cml4LCB0aGlzLl92aWV3TWF0cml4LCAtcm90WzFdKVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdNYXRyaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvbiB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZnJvbVxuICAgKiB2aWV3IHRvIE5EQyAobm9ybWFsaXplZCBkZXZpY2UgY29vcmRpbmF0ZXMpIHNwYWNlXG4gICAqIEByZXR1cm4ge01hdDJkfVxuICAgKi9cbiAgZ2V0IHByb2pNYXRyaXgoKSB7XG4gICAgaWYgKHRoaXMuX3Byb2pEaXJ0eSkge1xuICAgICAgY29uc3QgZmxpcCA9ICh0aGlzLl95ZmxpcCA/IC0xIDogMSlcbiAgICAgIE1hdDJkLnNldCh0aGlzLl9wcm9qTWF0cml4LCAyLjAgLyB0aGlzLl9wcm9qZWN0aW9uRGltZW5zaW9uc1swXSwgMCwgMCwgZmxpcCAqIDIuMCAvIHRoaXMuX3Byb2plY3Rpb25EaW1lbnNpb25zWzFdLCAwLCAwKVxuICAgICAgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkID0gdHJ1ZVxuICAgICAgdGhpcy5fcHJvakRpcnR5ID0gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3Byb2pNYXRyaXhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBkaXJ0eSBmbGFncyBhcmUgYWN0aXZlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWF0cmljZXNEaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYm91bmRzT3V0T2ZEYXRlIHx8IHRoaXMuX2x4Zm9ybURpcnR5IHx8IHRoaXMuX3hmb3JtRGlydHkgfHwgdGhpcy5fdmlld0RpcnR5IHx8IHRoaXMuX3Byb2pEaXJ0eSB8fCB0aGlzLl9zY3JlZW5EaXJ0eVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBmcm9tIHdvcmxkIHNwYWNlIHRvIHNjcmVlbiBzcGFjZS5cbiAgICogQHJldHVybiB7TWF0MmR9XG4gICAqL1xuICBnZXQgd29ybGRUb1NjcmVlbk1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXggfHwgdGhpcy5fd29ybGRUb1NjcmVlbk91dGRhdGVkIHx8IHRoaXMuX21hdHJpY2VzRGlydHkoKSkge1xuICAgICAgaWYgKCF0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4KSB7XG4gICAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXggPSBNYXQyZC5jcmVhdGUoKVxuICAgICAgfVxuICAgICAgTWF0MmQuY29weSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLnZpZXdNYXRyaXgpXG4gICAgICBNYXQyZC5tdWx0aXBseSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLnByb2pNYXRyaXgsIHRoaXMuX3dvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICBNYXQyZC5tdWx0aXBseSh0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4LCB0aGlzLnNjcmVlbk1hdHJpeCwgdGhpcy5fd29ybGRUb1NjcmVlbk1hdHJpeClcbiAgICAgIHRoaXMuX3dvcmxkVG9TY3JlZW5PdXRkYXRlZCA9IGZhbHNlXG4gICAgICB0aGlzLl9zY3JlZW5Ub1dvcmxkT3V0ZGF0ZWQgPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93b3JsZFRvU2NyZWVuTWF0cml4XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0ZWggdHJhbnNmb3JtIG1hdHJpeCBmcm9tIHNjcmVlbiBzcGFjZSB0byB3b3JsZCBzcGFjZS5cbiAgICogQHJldHVybiB7W3R5cGVdfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBnZXQgc2NyZWVuVG9Xb3JsZE1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuX3NjcmVlblRvV29ybGQgfHwgdGhpcy5fc2NyZWVuVG9Xb3JsZE91dGRhdGVkIHx8IHRoaXMuX21hdHJpY2VzRGlydHkoKSkge1xuICAgICAgaWYgKCF0aGlzLl9zY3JlZW5Ub1dvcmxkKSB7XG4gICAgICAgIHRoaXMuX3NjcmVlblRvV29ybGQgPSBNYXQyZC5jcmVhdGUoKVxuICAgICAgfVxuICAgICAgTWF0MmQuY29weSh0aGlzLl9zY3JlZW5Ub1dvcmxkLCB0aGlzLndvcmxkVG9TY3JlZW5NYXRyaXgpXG4gICAgICBNYXQyZC5pbnZlcnQodGhpcy5fc2NyZWVuVG9Xb3JsZCwgdGhpcy5fc2NyZWVuVG9Xb3JsZClcbiAgICAgIHRoaXMuX3NjcmVlblRvV29ybGRPdXRkYXRlZCA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zY3JlZW5Ub1dvcmxkXG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3ZpZXcvY2FtZXJhMmQuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * Copyright Marc J. Schmidt. See the LICENSE file at the top-level\n * directory of this distribution and at\n * https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n */\n;\n(function (root, factory) {\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === \"object\") {\n        module.exports = factory();\n    } else {\n        root.ResizeSensor = factory();\n    }\n}(this, function () {\n\n    //Make sure it does not throw in a SSR (Server Side Rendering) situation\n    if (typeof window === \"undefined\") {\n        return null;\n    }\n    // Only used for the dirty checking, so the event callback count is limted to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time, because the sensor is too fast and\n    // would generate too many unnecessary events.\n    var requestAnimationFrame = window.requestAnimationFrame ||\n        window.mozRequestAnimationFrame ||\n        window.webkitRequestAnimationFrame ||\n        function (fn) {\n            return window.setTimeout(fn, 20);\n        };\n\n    /**\n     * Iterate over each of the provided element(s).\n     *\n     * @param {HTMLElement|HTMLElement[]} elements\n     * @param {Function}                  callback\n     */\n    function forEachElement(elements, callback){\n        var elementsType = Object.prototype.toString.call(elements);\n        var isCollectionTyped = ('[object Array]' === elementsType\n            || ('[object NodeList]' === elementsType)\n            || ('[object HTMLCollection]' === elementsType)\n            || ('[object Object]' === elementsType)\n            || ('undefined' !== typeof jQuery && elements instanceof jQuery) //jquery\n            || ('undefined' !== typeof Elements && elements instanceof Elements) //mootools\n        );\n        var i = 0, j = elements.length;\n        if (isCollectionTyped) {\n            for (; i < j; i++) {\n                callback(elements[i]);\n            }\n        } else {\n            callback(elements);\n        }\n    }\n\n    /**\n     * Class for dimension change detection.\n     *\n     * @param {Element|Element[]|Elements|jQuery} element\n     * @param {Function} callback\n     *\n     * @constructor\n     */\n    var ResizeSensor = function(element, callback) {\n        /**\n         *\n         * @constructor\n         */\n        function EventQueue() {\n            var q = [];\n            this.add = function(ev) {\n                q.push(ev);\n            };\n\n            var i, j;\n            this.call = function() {\n                for (i = 0, j = q.length; i < j; i++) {\n                    q[i].call();\n                }\n            };\n\n            this.remove = function(ev) {\n                var newQueue = [];\n                for(i = 0, j = q.length; i < j; i++) {\n                    if(q[i] !== ev) newQueue.push(q[i]);\n                }\n                q = newQueue;\n            }\n\n            this.length = function() {\n                return q.length;\n            }\n        }\n\n        /**\n         * @param {HTMLElement} element\n         * @param {String}      prop\n         * @returns {String|Number}\n         */\n        function getComputedStyle(element, prop) {\n            if (element.currentStyle) {\n                return element.currentStyle[prop];\n            } else if (window.getComputedStyle) {\n                return window.getComputedStyle(element, null).getPropertyValue(prop);\n            } else {\n                return element.style[prop];\n            }\n        }\n\n        /**\n         *\n         * @param {HTMLElement} element\n         * @param {Function}    resized\n         */\n        function attachResizeEvent(element, resized) {\n            if (!element.resizedAttached) {\n                element.resizedAttached = new EventQueue();\n                element.resizedAttached.add(resized);\n            } else if (element.resizedAttached) {\n                element.resizedAttached.add(resized);\n                return;\n            }\n\n            element.resizeSensor = document.createElement('div');\n            element.resizeSensor.className = 'resize-sensor';\n            var style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\n            var styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n            element.resizeSensor.style.cssText = style;\n            element.resizeSensor.innerHTML =\n                '<div class=\"resize-sensor-expand\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + '\"></div>' +\n                '</div>' +\n                '<div class=\"resize-sensor-shrink\" style=\"' + style + '\">' +\n                    '<div style=\"' + styleChild + ' width: 200%; height: 200%\"></div>' +\n                '</div>';\n            element.appendChild(element.resizeSensor);\n\n            if (getComputedStyle(element, 'position') == 'static') {\n                element.style.position = 'relative';\n            }\n\n            var expand = element.resizeSensor.childNodes[0];\n            var expandChild = expand.childNodes[0];\n            var shrink = element.resizeSensor.childNodes[1];\n            var dirty, rafId, newWidth, newHeight;\n            var lastWidth = element.offsetWidth;\n            var lastHeight = element.offsetHeight;\n\n            var reset = function() {\n                expandChild.style.width = '100000px';\n                expandChild.style.height = '100000px';\n\n                expand.scrollLeft = 100000;\n                expand.scrollTop = 100000;\n\n                shrink.scrollLeft = 100000;\n                shrink.scrollTop = 100000;\n            };\n\n            reset();\n\n            var onResized = function() {\n                rafId = 0;\n\n                if (!dirty) return;\n\n                lastWidth = newWidth;\n                lastHeight = newHeight;\n\n                if (element.resizedAttached) {\n                    element.resizedAttached.call();\n                }\n            };\n\n            var onScroll = function() {\n                newWidth = element.offsetWidth;\n                newHeight = element.offsetHeight;\n                dirty = newWidth != lastWidth || newHeight != lastHeight;\n\n                if (dirty && !rafId) {\n                    rafId = requestAnimationFrame(onResized);\n                }\n\n                reset();\n            };\n\n            var addEvent = function(el, name, cb) {\n                if (el.attachEvent) {\n                    el.attachEvent('on' + name, cb);\n                } else {\n                    el.addEventListener(name, cb);\n                }\n            };\n\n            addEvent(expand, 'scroll', onScroll);\n            addEvent(shrink, 'scroll', onScroll);\n        }\n\n        forEachElement(element, function(elem){\n            attachResizeEvent(elem, callback);\n        });\n\n        this.detach = function(ev) {\n            ResizeSensor.detach(element, ev);\n        };\n    };\n\n    ResizeSensor.detach = function(element, ev) {\n        forEachElement(element, function(elem){\n            if(elem.resizedAttached && typeof ev == \"function\"){\n                elem.resizedAttached.remove(ev);\n                if(elem.resizedAttached.length()) return;\n            }\n            if (elem.resizeSensor) {\n                if (elem.contains(elem.resizeSensor)) {\n                    elem.removeChild(elem.resizeSensor);\n                }\n                delete elem.resizeSensor;\n                delete elem.resizedAttached;\n            }\n        });\n    };\n\n    return ResizeSensor;\n\n}));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9jc3MtZWxlbWVudC1xdWVyaWVzL3NyYy9SZXNpemVTZW5zb3IuanM/MTljOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0NBQWtDO0FBQ2pELGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU87QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixPQUFPO0FBQzFCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUyxRQUFRLFVBQVUsV0FBVyxrQkFBa0IsYUFBYSxvQkFBb0I7QUFDckksaURBQWlELFNBQVMsUUFBUSxnQkFBZ0I7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQSxDQUFDIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgTWFyYyBKLiBTY2htaWR0LiBTZWUgdGhlIExJQ0VOU0UgZmlsZSBhdCB0aGUgdG9wLWxldmVsXG4gKiBkaXJlY3Rvcnkgb2YgdGhpcyBkaXN0cmlidXRpb24gYW5kIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllcy9ibG9iL21hc3Rlci9MSUNFTlNFLlxuICovXG47XG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5SZXNpemVTZW5zb3IgPSBmYWN0b3J5KCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAvL01ha2Ugc3VyZSBpdCBkb2VzIG5vdCB0aHJvdyBpbiBhIFNTUiAoU2VydmVyIFNpZGUgUmVuZGVyaW5nKSBzaXR1YXRpb25cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gT25seSB1c2VkIGZvciB0aGUgZGlydHkgY2hlY2tpbmcsIHNvIHRoZSBldmVudCBjYWxsYmFjayBjb3VudCBpcyBsaW10ZWQgdG8gbWF4IDEgY2FsbCBwZXIgZnBzIHBlciBzZW5zb3IuXG4gICAgLy8gSW4gY29tYmluYXRpb24gd2l0aCB0aGUgZXZlbnQgYmFzZWQgcmVzaXplIHNlbnNvciB0aGlzIHNhdmVzIGNwdSB0aW1lLCBiZWNhdXNlIHRoZSBzZW5zb3IgaXMgdG9vIGZhc3QgYW5kXG4gICAgLy8gd291bGQgZ2VuZXJhdGUgdG9vIG1hbnkgdW5uZWNlc3NhcnkgZXZlbnRzLlxuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuc2V0VGltZW91dChmbiwgMjApO1xuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZSBvdmVyIGVhY2ggb2YgdGhlIHByb3ZpZGVkIGVsZW1lbnQocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEhUTUxFbGVtZW50W119IGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gICAgICAgICAgICAgICAgICBjYWxsYmFja1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2hFbGVtZW50KGVsZW1lbnRzLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBlbGVtZW50c1R5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWxlbWVudHMpO1xuICAgICAgICB2YXIgaXNDb2xsZWN0aW9uVHlwZWQgPSAoJ1tvYmplY3QgQXJyYXldJyA9PT0gZWxlbWVudHNUeXBlXG4gICAgICAgICAgICB8fCAoJ1tvYmplY3QgTm9kZUxpc3RdJyA9PT0gZWxlbWVudHNUeXBlKVxuICAgICAgICAgICAgfHwgKCdbb2JqZWN0IEhUTUxDb2xsZWN0aW9uXScgPT09IGVsZW1lbnRzVHlwZSlcbiAgICAgICAgICAgIHx8ICgnW29iamVjdCBPYmplY3RdJyA9PT0gZWxlbWVudHNUeXBlKVxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgalF1ZXJ5ICYmIGVsZW1lbnRzIGluc3RhbmNlb2YgalF1ZXJ5KSAvL2pxdWVyeVxuICAgICAgICAgICAgfHwgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgRWxlbWVudHMgJiYgZWxlbWVudHMgaW5zdGFuY2VvZiBFbGVtZW50cykgLy9tb290b29sc1xuICAgICAgICApO1xuICAgICAgICB2YXIgaSA9IDAsIGogPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb25UeXBlZCkge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50c1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyBmb3IgZGltZW5zaW9uIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8RWxlbWVudFtdfEVsZW1lbnRzfGpRdWVyeX0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgUmVzaXplU2Vuc29yID0gZnVuY3Rpb24oZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gRXZlbnRRdWV1ZSgpIHtcbiAgICAgICAgICAgIHZhciBxID0gW107XG4gICAgICAgICAgICB0aGlzLmFkZCA9IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgcS5wdXNoKGV2KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBpLCBqO1xuICAgICAgICAgICAgdGhpcy5jYWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaiA9IHEubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHFbaV0uY2FsbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3UXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoaSA9IDAsIGogPSBxLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZihxW2ldICE9PSBldikgbmV3UXVldWUucHVzaChxW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcSA9IG5ld1F1ZXVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBxLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSAgICAgIHByb3BcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ3xOdW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIHByb3ApIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmN1cnJlbnRTdHlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmN1cnJlbnRTdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICByZXNpemVkXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhdHRhY2hSZXNpemVFdmVudChlbGVtZW50LCByZXNpemVkKSB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQucmVzaXplZEF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemVkQXR0YWNoZWQgPSBuZXcgRXZlbnRRdWV1ZSgpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQucmVzaXplZEF0dGFjaGVkLmFkZChyZXNpemVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5yZXNpemVkQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5hZGQocmVzaXplZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbGVtZW50LnJlc2l6ZVNlbnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuY2xhc3NOYW1lID0gJ3Jlc2l6ZS1zZW5zb3InO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyc7XG4gICAgICAgICAgICB2YXIgc3R5bGVDaGlsZCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsgdHJhbnNpdGlvbjogMHM7JztcblxuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3Iuc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgICAgICAgICAgZWxlbWVudC5yZXNpemVTZW5zb3IuaW5uZXJIVE1MID1cbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInJlc2l6ZS1zZW5zb3ItZXhwYW5kXCIgc3R5bGU9XCInICsgc3R5bGUgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IHN0eWxlPVwiJyArIHN0eWxlQ2hpbGQgKyAnXCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICAgJzwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicmVzaXplLXNlbnNvci1zaHJpbmtcIiBzdHlsZT1cIicgKyBzdHlsZSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgc3R5bGU9XCInICsgc3R5bGVDaGlsZCArICcgd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJVwiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICc8L2Rpdj4nO1xuICAgICAgICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbGVtZW50LnJlc2l6ZVNlbnNvcik7XG5cbiAgICAgICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsICdwb3NpdGlvbicpID09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleHBhbmQgPSBlbGVtZW50LnJlc2l6ZVNlbnNvci5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgdmFyIGV4cGFuZENoaWxkID0gZXhwYW5kLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICB2YXIgc2hyaW5rID0gZWxlbWVudC5yZXNpemVTZW5zb3IuY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgICAgIHZhciBkaXJ0eSwgcmFmSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgbGFzdFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBsYXN0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZENoaWxkLnN0eWxlLndpZHRoID0gJzEwMDAwMHB4JztcbiAgICAgICAgICAgICAgICBleHBhbmRDaGlsZC5zdHlsZS5oZWlnaHQgPSAnMTAwMDAwcHgnO1xuXG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbExlZnQgPSAxMDAwMDA7XG4gICAgICAgICAgICAgICAgZXhwYW5kLnNjcm9sbFRvcCA9IDEwMDAwMDtcblxuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xuICAgICAgICAgICAgICAgIHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXNldCgpO1xuXG4gICAgICAgICAgICB2YXIgb25SZXNpemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmFmSWQgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFkaXJ0eSkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgbGFzdFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgICAgICAgbGFzdEhlaWdodCA9IG5ld0hlaWdodDtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlc2l6ZWRBdHRhY2hlZC5jYWxsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG9uU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbmV3V2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIG5ld0hlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGRpcnR5ID0gbmV3V2lkdGggIT0gbGFzdFdpZHRoIHx8IG5ld0hlaWdodCAhPSBsYXN0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpcnR5ICYmICFyYWZJZCkge1xuICAgICAgICAgICAgICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShvblJlc2l6ZWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkRXZlbnQgPSBmdW5jdGlvbihlbCwgbmFtZSwgY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhZGRFdmVudChleHBhbmQsICdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgICAgICBhZGRFdmVudChzaHJpbmssICdzY3JvbGwnLCBvblNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGF0dGFjaFJlc2l6ZUV2ZW50KGVsZW0sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kZXRhY2ggPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgUmVzaXplU2Vuc29yLmRldGFjaChlbGVtZW50LCBldik7XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIFJlc2l6ZVNlbnNvci5kZXRhY2ggPSBmdW5jdGlvbihlbGVtZW50LCBldikge1xuICAgICAgICBmb3JFYWNoRWxlbWVudChlbGVtZW50LCBmdW5jdGlvbihlbGVtKXtcbiAgICAgICAgICAgIGlmKGVsZW0ucmVzaXplZEF0dGFjaGVkICYmIHR5cGVvZiBldiA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICAgICAgICAgIGVsZW0ucmVzaXplZEF0dGFjaGVkLnJlbW92ZShldik7XG4gICAgICAgICAgICAgICAgaWYoZWxlbS5yZXNpemVkQXR0YWNoZWQubGVuZ3RoKCkpIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLnJlc2l6ZVNlbnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtLmNvbnRhaW5zKGVsZW0ucmVzaXplU2Vuc29yKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNoaWxkKGVsZW0ucmVzaXplU2Vuc29yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIGVsZW0ucmVzaXplU2Vuc29yO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtLnJlc2l6ZWRBdHRhY2hlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBSZXNpemVTZW5zb3I7XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vY3NzLWVsZW1lbnQtcXVlcmllcy9zcmMvUmVzaXplU2Vuc29yLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 2x2 Matrix\n * @name mat2\n */\nvar mat2 = {};\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nmat2.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Create a new mat2 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out A new 2x2 matrix\n */\nmat2.fromValues = function(m00, m01, m10, m11) {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m10;\n    out[3] = m11;\n    return out;\n};\n\n/**\n * Set the components of a mat2 to the given values\n *\n * @param {mat2} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\n * @returns {mat2} out\n */\nmat2.set = function(out, m00, m01, m10, m11) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m10;\n    out[3] = m11;\n    return out;\n};\n\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a1 = a[1];\n        out[1] = a[2];\n        out[2] = a1;\n    } else {\n        out[0] = a[0];\n        out[1] = a[2];\n        out[2] = a[1];\n        out[3] = a[3];\n    }\n    \n    return out;\n};\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.invert = function(out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n\n        // Calculate the determinant\n        det = a0 * a3 - a2 * a1;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n    \n    out[0] =  a3 * det;\n    out[1] = -a1 * det;\n    out[2] = -a2 * det;\n    out[3] =  a0 * det;\n\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.adjoint = function(out, a) {\n    // Caching this value is nessecary if out == a\n    var a0 = a[0];\n    out[0] =  a[3];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] =  a0;\n\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2.determinant = function (a) {\n    return a[0] * a[3] - a[2] * a[1];\n};\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    return out;\n};\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nmat2.mul = mat2.multiply;\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 *  c + a2 * s;\n    out[1] = a1 *  c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    return out;\n};\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nmat2.scale = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    return out;\n};\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.rotate(dest, dest, rad);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.fromRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = c;\n    out[1] = s;\n    out[2] = -s;\n    out[3] = c;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2.identity(dest);\n *     mat2.scale(dest, dest, vec);\n *\n * @param {mat2} out mat2 receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2} out\n */\nmat2.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = v[1];\n    return out;\n}\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2.str = function (a) {\n    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))\n};\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix \n * @param {mat2} D the diagonal matrix \n * @param {mat2} U the upper triangular matrix \n * @param {mat2} a the input matrix to factorize\n */\n\nmat2.LDU = function (L, D, U, a) { \n    L[2] = a[2]/a[0]; \n    U[0] = a[0]; \n    U[1] = a[1]; \n    U[3] = a[3] - L[2] * U[1]; \n    return [L, D, U];       \n}; \n\n/**\n * Adds two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link mat2.subtract}\n * @function\n */\nmat2.sub = mat2.subtract;\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2} a The first matrix.\n * @param {mat2} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));\n};\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2} out\n */\nmat2.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2} out the receiving vector\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2} out\n */\nmat2.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\nmodule.exports = mat2;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyLmpzP2FkNWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDIpXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDMpXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTEwO1xuICAgIG91dFszXSA9IG0xMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnNldCA9IGZ1bmN0aW9uKG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gICAgb3V0WzBdID0gbTAwO1xuICAgIG91dFsxXSA9IG0wMTtcbiAgICBvdXRbMl0gPSBtMTA7XG4gICAgb3V0WzNdID0gbTExO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdO1xuICAgIHZhciBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG4gICAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gICAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gICAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gICAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDIubXVsID0gbWF0Mi5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MiBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKiovXG5tYXQyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDIuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0Mi5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgbWF0MiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0Mi5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpKSlcbn07XG5cbi8qKlxuICogUmV0dXJucyBMLCBEIGFuZCBVIG1hdHJpY2VzIChMb3dlciB0cmlhbmd1bGFyLCBEaWFnb25hbCBhbmQgVXBwZXIgdHJpYW5ndWxhcikgYnkgZmFjdG9yaXppbmcgdGhlIGlucHV0IG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeCBcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxuICovXG5cbm1hdDIuTERVID0gZnVuY3Rpb24gKEwsIEQsIFUsIGEpIHsgXG4gICAgTFsyXSA9IGFbMl0vYVswXTsgXG4gICAgVVswXSA9IGFbMF07IFxuICAgIFVbMV0gPSBhWzFdOyBcbiAgICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdOyBcbiAgICByZXR1cm4gW0wsIEQsIFVdOyAgICAgICBcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyLnN1YiA9IG1hdDIuc3VidHJhY3Q7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmV4YWN0RXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyLmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5U2NhbGFyID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgb3V0WzJdID0gYVsyXSAqIGI7XG4gICAgb3V0WzNdID0gYVszXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0MidzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWx0aXBseVNjYWxhckFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0MjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0Mi5qc1xuLy8gbW9kdWxlIGlkID0gMzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 2x3 Matrix\n * @name mat2d\n * \n * @description \n * A mat2d contains six elements defined as:\n * <pre>\n * [a, c, tx,\n *  b, d, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, c, tx,\n *  b, d, ty,\n *  0, 0, 1]\n * </pre>\n * The last row is ignored so the array is shorter and operations are faster.\n */\nvar mat2d = {};\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nmat2d.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Create a new mat2d with the given values\n *\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} A new mat2d\n */\nmat2d.fromValues = function(a, b, c, d, tx, ty) {\n    var out = new glMatrix.ARRAY_TYPE(6);\n    out[0] = a;\n    out[1] = b;\n    out[2] = c;\n    out[3] = d;\n    out[4] = tx;\n    out[5] = ty;\n    return out;\n};\n\n/**\n * Set the components of a mat2d to the given values\n *\n * @param {mat2d} out the receiving matrix\n * @param {Number} a Component A (index 0)\n * @param {Number} b Component B (index 1)\n * @param {Number} c Component C (index 2)\n * @param {Number} d Component D (index 3)\n * @param {Number} tx Component TX (index 4)\n * @param {Number} ty Component TY (index 5)\n * @returns {mat2d} out\n */\nmat2d.set = function(out, a, b, c, d, tx, ty) {\n    out[0] = a;\n    out[1] = b;\n    out[2] = c;\n    out[3] = d;\n    out[4] = tx;\n    out[5] = ty;\n    return out;\n};\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.invert = function(out, a) {\n    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],\n        atx = a[4], aty = a[5];\n\n    var det = aa * ad - ab * ac;\n    if(!det){\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = ad * det;\n    out[1] = -ab * det;\n    out[2] = -ac * det;\n    out[3] = aa * det;\n    out[4] = (ac * aty - ad * atx) * det;\n    out[5] = (ab * atx - aa * aty) * det;\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2d.determinant = function (a) {\n    return a[0] * a[3] - a[1] * a[2];\n};\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    out[4] = a0 * b4 + a2 * b5 + a4;\n    out[5] = a1 * b4 + a3 * b5 + a5;\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nmat2d.mul = mat2d.multiply;\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 *  c + a2 * s;\n    out[1] = a1 *  c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nmat2d.scale = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nmat2d.translate = function(out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = a0 * v0 + a2 * v1 + a4;\n    out[5] = a1 * v0 + a3 * v1 + a5;\n    return out;\n};\n\n/**\n * Creates a matrix from a given angle\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.rotate(dest, dest, rad);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.fromRotation = function(out, rad) {\n    var s = Math.sin(rad), c = Math.cos(rad);\n    out[0] = c;\n    out[1] = s;\n    out[2] = -s;\n    out[3] = c;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.scale(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Scaling vector\n * @returns {mat2d} out\n */\nmat2d.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = v[1];\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat2d.identity(dest);\n *     mat2d.translate(dest, dest, vec);\n *\n * @param {mat2d} out mat2d receiving operation result\n * @param {vec2} v Translation vector\n * @returns {mat2d} out\n */\nmat2d.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = v[0];\n    out[5] = v[1];\n    return out;\n}\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2d.str = function (a) {\n    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + \n                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2d.frob = function (a) { \n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))\n}; \n\n/**\n * Adds two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.subtract}\n * @function\n */\nmat2d.sub = mat2d.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat2d} out\n */\nmat2d.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    return out;\n};\n\n/**\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat2d} out the receiving vector\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat2d} out\n */\nmat2d.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    return out;\n};\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2d.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat2d} a The first matrix.\n * @param {mat2d} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat2d.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)));\n};\n\nmodule.exports = mat2d;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQyZC5qcz9lNTljIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcs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QTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMngzIE1hdHJpeFxuICogQG5hbWUgbWF0MmRcbiAqIFxuICogQGRlc2NyaXB0aW9uIFxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHldXG4gKiA8L3ByZT5cbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcbiAqIDxwcmU+XG4gKiBbYSwgYywgdHgsXG4gKiAgYiwgZCwgdHksXG4gKiAgMCwgMCwgMV1cbiAqIDwvcHJlPlxuICogVGhlIGxhc3Qgcm93IGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cbiAqL1xudmFyIG1hdDJkID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxuICpcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyZCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcbiAqL1xubWF0MmQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MmQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWF0MmQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXG4gKiBAcGFyYW0ge051bWJlcn0gYiBDb21wb25lbnQgQiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXG4gKiBAcGFyYW0ge051bWJlcn0gdHggQ29tcG9uZW50IFRYIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcbiAqL1xubWF0MmQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSBhO1xuICAgIG91dFsxXSA9IGI7XG4gICAgb3V0WzJdID0gYztcbiAgICBvdXRbM10gPSBkO1xuICAgIG91dFs0XSA9IHR4O1xuICAgIG91dFs1XSA9IHR5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDJkIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIENvbXBvbmVudCBBIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBkIENvbXBvbmVudCBEIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5zZXQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICAgIG91dFswXSA9IGE7XG4gICAgb3V0WzFdID0gYjtcbiAgICBvdXRbMl0gPSBjO1xuICAgIG91dFszXSA9IGQ7XG4gICAgb3V0WzRdID0gdHg7XG4gICAgb3V0WzVdID0gdHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYWEgPSBhWzBdLCBhYiA9IGFbMV0sIGFjID0gYVsyXSwgYWQgPSBhWzNdLFxuICAgICAgICBhdHggPSBhWzRdLCBhdHkgPSBhWzVdO1xuXG4gICAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuICAgIGlmKCFkZXQpe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWFiICogZGV0O1xuICAgIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgICBvdXRbM10gPSBhYSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDJkLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MmQnc1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sIGI0ID0gYls0XSwgYjUgPSBiWzVdO1xuICAgIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICAgIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICAgIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICAgIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDJkLm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDJkLm11bCA9IG1hdDJkLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyZCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgb3V0WzRdID0gYTQ7XG4gICAgb3V0WzVdID0gYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sIGE0ID0gYVs0XSwgYTUgPSBhWzVdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gdHJhbnNsYXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKiovXG5tYXQyZC50cmFuc2xhdGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTA7XG4gICAgb3V0WzFdID0gYTE7XG4gICAgb3V0WzJdID0gYTI7XG4gICAgb3V0WzNdID0gYTM7XG4gICAgb3V0WzRdID0gYTAgKiB2MCArIGEyICogdjEgKyBhNDtcbiAgICBvdXRbNV0gPSBhMSAqIHYwICsgYTMgKiB2MSArIGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0MmQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSB2WzFdO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICBvdXRbNF0gPSB2WzBdO1xuICAgIG91dFs1XSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDJkLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyZCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyZC5mcm9iID0gZnVuY3Rpb24gKGEpIHsgXG4gICAgcmV0dXJuKE1hdGguc3FydChNYXRoLnBvdyhhWzBdLCAyKSArIE1hdGgucG93KGFbMV0sIDIpICsgTWF0aC5wb3coYVsyXSwgMikgKyBNYXRoLnBvdyhhWzNdLCAyKSArIE1hdGgucG93KGFbNF0sIDIpICsgTWF0aC5wb3coYVs1XSwgMikgKyAxKSlcbn07IFxuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5zdWIgPSBtYXQyZC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQubXVsdGlwbHlTY2FsYXIgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICBvdXRbNF0gPSBhWzRdICogYjtcbiAgICBvdXRbNV0gPSBhWzVdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLm11bHRpcGx5U2NhbGFyQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIG91dFszXSA9IGFbM10gKyAoYlszXSAqIHNjYWxlKTtcbiAgICBvdXRbNF0gPSBhWzRdICsgKGJbNF0gKiBzY2FsZSk7XG4gICAgb3V0WzVdID0gYVs1XSArIChiWzVdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQyZC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgYVs0XSA9PT0gYls0XSAmJiBhWzVdID09PSBiWzVdO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQyZH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0MmQuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XTtcbiAgICB2YXIgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtYXQyZDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL34vZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 4x4 Matrix\n * @name mat4\n */\nvar mat4 = {\n  scalar: {},\n  SIMD: {},\n};\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Create a new mat4 with the given values\n *\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} A new mat4\n */\nmat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    var out = new glMatrix.ARRAY_TYPE(16);\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n};\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\n * @returns {mat4} out\n */\nmat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n};\n\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nmat4.identity = function(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.transpose = function(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a03 = a[3],\n            a12 = a[6], a13 = a[7],\n            a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n};\n\n/**\n * Transpose the values of a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.transpose = function(out, a) {\n    var a0, a1, a2, a3,\n        tmp01, tmp23,\n        out0, out1, out2, out3;\n\n    a0 = SIMD.Float32x4.load(a, 0);\n    a1 = SIMD.Float32x4.load(a, 4);\n    a2 = SIMD.Float32x4.load(a, 8);\n    a3 = SIMD.Float32x4.load(a, 12);\n\n    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n    out0  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n    out1  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n    SIMD.Float32x4.store(out, 0,  out0);\n    SIMD.Float32x4.store(out, 4,  out1);\n\n    tmp01 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n    tmp23 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n    out2  = SIMD.Float32x4.shuffle(tmp01, tmp23, 0, 2, 4, 6);\n    out3  = SIMD.Float32x4.shuffle(tmp01, tmp23, 1, 3, 5, 7);\n    SIMD.Float32x4.store(out, 8,  out2);\n    SIMD.Float32x4.store(out, 12, out3);\n\n    return out;\n};\n\n/**\n * Transpse a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.transpose = glMatrix.USE_SIMD ? mat4.SIMD.transpose : mat4.scalar.transpose;\n\n/**\n * Inverts a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.invert = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n};\n\n/**\n * Inverts a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.invert = function(out, a) {\n  var row0, row1, row2, row3,\n      tmp1,\n      minor0, minor1, minor2, minor3,\n      det,\n      a0 = SIMD.Float32x4.load(a, 0),\n      a1 = SIMD.Float32x4.load(a, 4),\n      a2 = SIMD.Float32x4.load(a, 8),\n      a3 = SIMD.Float32x4.load(a, 12);\n\n  // Compute matrix adjugate\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n\n  tmp1   = SIMD.Float32x4.mul(row2, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.mul(row1, tmp1);\n  minor1 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row1, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n  minor3 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n  minor2 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row0, row1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n\n  // Compute matrix determinant\n  det   = SIMD.Float32x4.mul(row0, minor0);\n  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 2, 3, 0, 1), det);\n  det   = SIMD.Float32x4.add(SIMD.Float32x4.swizzle(det, 1, 0, 3, 2), det);\n  tmp1  = SIMD.Float32x4.reciprocalApproximation(det);\n  det   = SIMD.Float32x4.sub(\n               SIMD.Float32x4.add(tmp1, tmp1),\n               SIMD.Float32x4.mul(det, SIMD.Float32x4.mul(tmp1, tmp1)));\n  det   = SIMD.Float32x4.swizzle(det, 0, 0, 0, 0);\n  if (!det) {\n      return null;\n  }\n\n  // Compute matrix inverse\n  SIMD.Float32x4.store(out, 0,  SIMD.Float32x4.mul(det, minor0));\n  SIMD.Float32x4.store(out, 4,  SIMD.Float32x4.mul(det, minor1));\n  SIMD.Float32x4.store(out, 8,  SIMD.Float32x4.mul(det, minor2));\n  SIMD.Float32x4.store(out, 12, SIMD.Float32x4.mul(det, minor3));\n  return out;\n}\n\n/**\n * Inverts a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.invert = glMatrix.USE_SIMD ? mat4.SIMD.invert : mat4.scalar.invert;\n\n/**\n * Calculates the adjugate of a mat4 not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.scalar.adjoint = function(out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat4 using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.SIMD.adjoint = function(out, a) {\n  var a0, a1, a2, a3;\n  var row0, row1, row2, row3;\n  var tmp1;\n  var minor0, minor1, minor2, minor3;\n\n  var a0 = SIMD.Float32x4.load(a, 0);\n  var a1 = SIMD.Float32x4.load(a, 4);\n  var a2 = SIMD.Float32x4.load(a, 8);\n  var a3 = SIMD.Float32x4.load(a, 12);\n\n  // Transpose the source matrix.  Sort of.  Not a true transpose operation\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 0, 1, 4, 5);\n  row1 = SIMD.Float32x4.shuffle(a2, a3, 0, 1, 4, 5);\n  row0 = SIMD.Float32x4.shuffle(tmp1, row1, 0, 2, 4, 6);\n  row1 = SIMD.Float32x4.shuffle(row1, tmp1, 1, 3, 5, 7);\n\n  tmp1 = SIMD.Float32x4.shuffle(a0, a1, 2, 3, 6, 7);\n  row3 = SIMD.Float32x4.shuffle(a2, a3, 2, 3, 6, 7);\n  row2 = SIMD.Float32x4.shuffle(tmp1, row3, 0, 2, 4, 6);\n  row3 = SIMD.Float32x4.shuffle(row3, tmp1, 1, 3, 5, 7);\n\n  tmp1   = SIMD.Float32x4.mul(row2, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.mul(row1, tmp1);\n  minor1 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row1, tmp1), minor0);\n  minor1 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor1);\n  minor1 = SIMD.Float32x4.swizzle(minor1, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row1, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor0);\n  minor3 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor3);\n  minor3 = SIMD.Float32x4.swizzle(minor3, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(row1, 2, 3, 0, 1), row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  row2   = SIMD.Float32x4.swizzle(row2, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor0);\n  minor2 = SIMD.Float32x4.mul(row0, tmp1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor0 = SIMD.Float32x4.sub(minor0, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row0, tmp1), minor2);\n  minor2 = SIMD.Float32x4.swizzle(minor2, 2, 3, 0, 1);\n\n  tmp1   = SIMD.Float32x4.mul(row0, row1);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row2, tmp1), minor3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor2 = SIMD.Float32x4.sub(SIMD.Float32x4.mul(row3, tmp1), minor2);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row2, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row3);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row2, tmp1));\n  minor2 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row2, tmp1), minor1);\n  minor2 = SIMD.Float32x4.sub(minor2, SIMD.Float32x4.mul(row1, tmp1));\n\n  tmp1   = SIMD.Float32x4.mul(row0, row2);\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 1, 0, 3, 2);\n  minor1 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row3, tmp1), minor1);\n  minor3 = SIMD.Float32x4.sub(minor3, SIMD.Float32x4.mul(row1, tmp1));\n  tmp1   = SIMD.Float32x4.swizzle(tmp1, 2, 3, 0, 1);\n  minor1 = SIMD.Float32x4.sub(minor1, SIMD.Float32x4.mul(row3, tmp1));\n  minor3 = SIMD.Float32x4.add(SIMD.Float32x4.mul(row1, tmp1), minor3);\n\n  SIMD.Float32x4.store(out, 0,  minor0);\n  SIMD.Float32x4.store(out, 4,  minor1);\n  SIMD.Float32x4.store(out, 8,  minor2);\n  SIMD.Float32x4.store(out, 12, minor3);\n  return out;\n};\n\n/**\n * Calculates the adjugate of a mat4 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\n mat4.adjoint = glMatrix.USE_SIMD ? mat4.SIMD.adjoint : mat4.scalar.adjoint;\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nmat4.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n};\n\n/**\n * Multiplies two mat4's explicitly using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand, must be a Float32Array\n * @param {mat4} b the second operand, must be a Float32Array\n * @returns {mat4} out\n */\nmat4.SIMD.multiply = function (out, a, b) {\n    var a0 = SIMD.Float32x4.load(a, 0);\n    var a1 = SIMD.Float32x4.load(a, 4);\n    var a2 = SIMD.Float32x4.load(a, 8);\n    var a3 = SIMD.Float32x4.load(a, 12);\n\n    var b0 = SIMD.Float32x4.load(b, 0);\n    var out0 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 2, 2, 2, 2), a2),\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b0, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 0, out0);\n\n    var b1 = SIMD.Float32x4.load(b, 4);\n    var out1 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 2, 2, 2, 2), a2),\n                           SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b1, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 4, out1);\n\n    var b2 = SIMD.Float32x4.load(b, 8);\n    var out2 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                       SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 1, 1, 1, 1), a1),\n                       SIMD.Float32x4.add(\n                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 2, 2, 2, 2), a2),\n                               SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b2, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 8, out2);\n\n    var b3 = SIMD.Float32x4.load(b, 12);\n    var out3 = SIMD.Float32x4.add(\n                   SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 0, 0, 0, 0), a0),\n                   SIMD.Float32x4.add(\n                        SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 1, 1, 1, 1), a1),\n                        SIMD.Float32x4.add(\n                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 2, 2, 2, 2), a2),\n                            SIMD.Float32x4.mul(SIMD.Float32x4.swizzle(b3, 3, 3, 3, 3), a3))));\n    SIMD.Float32x4.store(out, 12, out3);\n\n    return out;\n};\n\n/**\n * Multiplies two mat4's explicitly not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.scalar.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];\n    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];\n    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n\n    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];\n    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;\n    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;\n    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;\n    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;\n    return out;\n};\n\n/**\n * Multiplies two mat4's using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.multiply = glMatrix.USE_SIMD ? mat4.SIMD.multiply : mat4.scalar.multiply;\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nmat4.mul = mat4.multiply;\n\n/**\n * Translate a mat4 by the given vector not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.scalar.translate = function (out, a, v) {\n    var x = v[0], y = v[1], z = v[2],\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;\n        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;\n        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n};\n\n/**\n * Translates a mat4 by the given vector using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.SIMD.translate = function (out, a, v) {\n    var a0 = SIMD.Float32x4.load(a, 0),\n        a1 = SIMD.Float32x4.load(a, 4),\n        a2 = SIMD.Float32x4.load(a, 8),\n        a3 = SIMD.Float32x4.load(a, 12),\n        vec = SIMD.Float32x4(v[0], v[1], v[2] , 0);\n\n    if (a !== out) {\n        out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];\n        out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];\n        out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];\n    }\n\n    a0 = SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0));\n    a1 = SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1));\n    a2 = SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2));\n\n    var t0 = SIMD.Float32x4.add(a0, SIMD.Float32x4.add(a1, SIMD.Float32x4.add(a2, a3)));\n    SIMD.Float32x4.store(out, 12, t0);\n\n    return out;\n};\n\n/**\n * Translates a mat4 by the given vector using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.translate = glMatrix.USE_SIMD ? mat4.SIMD.translate : mat4.scalar.translate;\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.scalar.scale = function(out, a, v) {\n    var x = v[0], y = v[1], z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.SIMD.scale = function(out, a, v) {\n    var a0, a1, a2;\n    var vec = SIMD.Float32x4(v[0], v[1], v[2], 0);\n\n    a0 = SIMD.Float32x4.load(a, 0);\n    SIMD.Float32x4.store(\n        out, 0, SIMD.Float32x4.mul(a0, SIMD.Float32x4.swizzle(vec, 0, 0, 0, 0)));\n\n    a1 = SIMD.Float32x4.load(a, 4);\n    SIMD.Float32x4.store(\n        out, 4, SIMD.Float32x4.mul(a1, SIMD.Float32x4.swizzle(vec, 1, 1, 1, 1)));\n\n    a2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(\n        out, 8, SIMD.Float32x4.mul(a2, SIMD.Float32x4.swizzle(vec, 2, 2, 2, 2)));\n\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 using SIMD if available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n */\nmat4.scale = glMatrix.USE_SIMD ? mat4.SIMD.scale : mat4.scalar.scale;\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.rotate = function (out, a, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t,\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23,\n        b00, b01, b02,\n        b10, b11, b12,\n        b20, b21, b22;\n\n    if (Math.abs(len) < glMatrix.EPSILON) { return null; }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];\n    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];\n    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateX = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[0]  = a[0];\n        out[1]  = a[1];\n        out[2]  = a[2];\n        out[3]  = a[3];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[4] = a10 * c + a20 * s;\n    out[5] = a11 * c + a21 * s;\n    out[6] = a12 * c + a22 * s;\n    out[7] = a13 * c + a23 * s;\n    out[8] = a20 * c - a10 * s;\n    out[9] = a21 * c - a11 * s;\n    out[10] = a22 * c - a12 * s;\n    out[11] = a23 * c - a13 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateX = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n      out[0]  = a[0];\n      out[1]  = a[1];\n      out[2]  = a[2];\n      out[3]  = a[3];\n      out[12] = a[12];\n      out[13] = a[13];\n      out[14] = a[14];\n      out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_1 = SIMD.Float32x4.load(a, 4);\n    var a_2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(out, 4,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_2, s)));\n    SIMD.Float32x4.store(out, 8,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_2, c), SIMD.Float32x4.mul(a_1, s)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis using SIMD if availabe and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.rotateX = glMatrix.USE_SIMD ? mat4.SIMD.rotateX : mat4.scalar.rotateX;\n\n/**\n * Rotates a matrix by the given angle around the Y axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateY = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4]  = a[4];\n        out[5]  = a[5];\n        out[6]  = a[6];\n        out[7]  = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c - a20 * s;\n    out[1] = a01 * c - a21 * s;\n    out[2] = a02 * c - a22 * s;\n    out[3] = a03 * c - a23 * s;\n    out[8] = a00 * s + a20 * c;\n    out[9] = a01 * s + a21 * c;\n    out[10] = a02 * s + a22 * c;\n    out[11] = a03 * s + a23 * c;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateY = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4]  = a[4];\n        out[5]  = a[5];\n        out[6]  = a[6];\n        out[7]  = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_0 = SIMD.Float32x4.load(a, 0);\n    var a_2 = SIMD.Float32x4.load(a, 8);\n    SIMD.Float32x4.store(out, 0,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_2, s)));\n    SIMD.Float32x4.store(out, 8,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, s), SIMD.Float32x4.mul(a_2, c)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis if SIMD available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n mat4.rotateY = glMatrix.USE_SIMD ? mat4.SIMD.rotateY : mat4.scalar.rotateY;\n\n/**\n * Rotates a matrix by the given angle around the Z axis not using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.scalar.rotateZ = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8]  = a[8];\n        out[9]  = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c + a10 * s;\n    out[1] = a01 * c + a11 * s;\n    out[2] = a02 * c + a12 * s;\n    out[3] = a03 * c + a13 * s;\n    out[4] = a10 * c - a00 * s;\n    out[5] = a11 * c - a01 * s;\n    out[6] = a12 * c - a02 * s;\n    out[7] = a13 * c - a03 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis using SIMD\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.SIMD.rotateZ = function (out, a, rad) {\n    var s = SIMD.Float32x4.splat(Math.sin(rad)),\n        c = SIMD.Float32x4.splat(Math.cos(rad));\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8]  = a[8];\n        out[9]  = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    var a_0 = SIMD.Float32x4.load(a, 0);\n    var a_1 = SIMD.Float32x4.load(a, 4);\n    SIMD.Float32x4.store(out, 0,\n                         SIMD.Float32x4.add(SIMD.Float32x4.mul(a_0, c), SIMD.Float32x4.mul(a_1, s)));\n    SIMD.Float32x4.store(out, 4,\n                         SIMD.Float32x4.sub(SIMD.Float32x4.mul(a_1, c), SIMD.Float32x4.mul(a_0, s)));\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis if SIMD available and enabled\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\n mat4.rotateZ = glMatrix.USE_SIMD ? mat4.SIMD.rotateZ : mat4.scalar.rotateZ;\n\n/**\n * Creates a matrix from a vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromTranslation = function(out, v) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a vector scaling\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.scale(dest, dest, vec);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {vec3} v Scaling vector\n * @returns {mat4} out\n */\nmat4.fromScaling = function(out, v) {\n    out[0] = v[0];\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = v[1];\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = v[2];\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a given angle around a given axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotate(dest, dest, rad, axis);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.fromRotation = function(out, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t;\n\n    if (Math.abs(len) < glMatrix.EPSILON) { return null; }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = x * x * t + c;\n    out[1] = y * x * t + z * s;\n    out[2] = z * x * t - y * s;\n    out[3] = 0;\n    out[4] = x * y * t - z * s;\n    out[5] = y * y * t + c;\n    out[6] = z * y * t + x * s;\n    out[7] = 0;\n    out[8] = x * z * t + y * s;\n    out[9] = y * z * t - x * s;\n    out[10] = z * z * t + c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the X axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateX(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromXRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = 1;\n    out[1]  = 0;\n    out[2]  = 0;\n    out[3]  = 0;\n    out[4] = 0;\n    out[5] = c;\n    out[6] = s;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = -s;\n    out[10] = c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Y axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateY(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromYRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = c;\n    out[1]  = 0;\n    out[2]  = -s;\n    out[3]  = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = s;\n    out[9] = 0;\n    out[10] = c;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from the given angle around the Z axis\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.rotateZ(dest, dest, rad);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.fromZRotation = function(out, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    // Perform axis-specific matrix multiplication\n    out[0]  = c;\n    out[1]  = s;\n    out[2]  = 0;\n    out[3]  = 0;\n    out[4] = -s;\n    out[5] = c;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslation = function (out, q, v) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - (yy + zz);\n    out[1] = xy + wz;\n    out[2] = xz - wy;\n    out[3] = 0;\n    out[4] = xy - wz;\n    out[5] = 1 - (xx + zz);\n    out[6] = yz + wx;\n    out[7] = 0;\n    out[8] = xz + wy;\n    out[9] = yz - wx;\n    out[10] = 1 - (xx + yy);\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nmat4.getTranslation = function (out, mat) {\n  out[0] = mat[12];\n  out[1] = mat[13];\n  out[2] = mat[14];\n\n  return out;\n};\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nmat4.getRotation = function (out, mat) {\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n  var trace = mat[0] + mat[5] + mat[10];\n  var S = 0;\n\n  if (trace > 0) { \n    S = Math.sqrt(trace + 1.0) * 2;\n    out[3] = 0.25 * S;\n    out[0] = (mat[6] - mat[9]) / S;\n    out[1] = (mat[8] - mat[2]) / S; \n    out[2] = (mat[1] - mat[4]) / S; \n  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { \n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\n    out[3] = (mat[6] - mat[9]) / S;\n    out[0] = 0.25 * S;\n    out[1] = (mat[1] + mat[4]) / S; \n    out[2] = (mat[8] + mat[2]) / S; \n  } else if (mat[5] > mat[10]) { \n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\n    out[3] = (mat[8] - mat[2]) / S;\n    out[0] = (mat[1] + mat[4]) / S; \n    out[1] = 0.25 * S;\n    out[2] = (mat[6] + mat[9]) / S; \n  } else { \n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\n    out[3] = (mat[1] - mat[4]) / S;\n    out[0] = (mat[8] + mat[2]) / S;\n    out[1] = (mat[6] + mat[9]) / S;\n    out[2] = 0.25 * S;\n  }\n\n  return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslationScale = function (out, q, v, s) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2,\n        sx = s[0],\n        sy = s[1],\n        sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     mat4.translate(dest, origin);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *     mat4.translate(dest, negativeOrigin);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @param {vec3} o The origin vector around which to scale and rotate\n * @returns {mat4} out\n */\nmat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {\n  // Quaternion math\n  var x = q[0], y = q[1], z = q[2], w = q[3],\n      x2 = x + x,\n      y2 = y + y,\n      z2 = z + z,\n\n      xx = x * x2,\n      xy = x * y2,\n      xz = x * z2,\n      yy = y * y2,\n      yz = y * z2,\n      zz = z * z2,\n      wx = w * x2,\n      wy = w * y2,\n      wz = w * z2,\n\n      sx = s[0],\n      sy = s[1],\n      sz = s[2],\n\n      ox = o[0],\n      oy = o[1],\n      oz = o[2];\n\n  out[0] = (1 - (yy + zz)) * sx;\n  out[1] = (xy + wz) * sx;\n  out[2] = (xz - wy) * sx;\n  out[3] = 0;\n  out[4] = (xy - wz) * sy;\n  out[5] = (1 - (xx + zz)) * sy;\n  out[6] = (yz + wx) * sy;\n  out[7] = 0;\n  out[8] = (xz + wy) * sz;\n  out[9] = (yz - wx) * sz;\n  out[10] = (1 - (xx + yy)) * sz;\n  out[11] = 0;\n  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);\n  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);\n  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);\n  out[15] = 1;\n\n  return out;\n};\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nmat4.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.frustum = function (out, left, right, bottom, top, near, far) {\n    var rl = 1 / (right - left),\n        tb = 1 / (top - bottom),\n        nf = 1 / (near - far);\n    out[0] = (near * 2) * rl;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = (near * 2) * tb;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = (right + left) * rl;\n    out[9] = (top + bottom) * tb;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (far * near * 2) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspective = function (out, fovy, aspect, near, far) {\n    var f = 1.0 / Math.tan(fovy / 2),\n        nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (2 * far * near) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given field of view.\n * This is primarily useful for generating projection matrices to be used\n * with the still experiemental WebVR API.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspectiveFromFieldOfView = function (out, fov, near, far) {\n    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),\n        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),\n        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),\n        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),\n        xScale = 2.0 / (leftTan + rightTan),\n        yScale = 2.0 / (upTan + downTan);\n\n    out[0] = xScale;\n    out[1] = 0.0;\n    out[2] = 0.0;\n    out[3] = 0.0;\n    out[4] = 0.0;\n    out[5] = yScale;\n    out[6] = 0.0;\n    out[7] = 0.0;\n    out[8] = -((leftTan - rightTan) * xScale * 0.5);\n    out[9] = ((upTan - downTan) * yScale * 0.5);\n    out[10] = far / (near - far);\n    out[11] = -1.0;\n    out[12] = 0.0;\n    out[13] = 0.0;\n    out[14] = (far * near) / (near - far);\n    out[15] = 0.0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.ortho = function (out, left, right, bottom, top, near, far) {\n    var lr = 1 / (left - right),\n        bt = 1 / (bottom - top),\n        nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nmat4.lookAt = function (out, eye, center, up) {\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,\n        eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2],\n        centerx = center[0],\n        centery = center[1],\n        centerz = center[2];\n\n    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&\n        Math.abs(eyey - centery) < glMatrix.EPSILON &&\n        Math.abs(eyez - centerz) < glMatrix.EPSILON) {\n        return mat4.identity(out);\n    }\n\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n\n    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    } else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n\n    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    } else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n\n    out[0] = x0;\n    out[1] = y0;\n    out[2] = z0;\n    out[3] = 0;\n    out[4] = x1;\n    out[5] = y1;\n    out[6] = z1;\n    out[7] = 0;\n    out[8] = x2;\n    out[9] = y2;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat4.str = function (a) {\n    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +\n                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +\n                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat4.frob = function (a) {\n    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))\n};\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n};\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n};\n\n/**\n * Alias for {@link mat4.subtract}\n * @function\n */\nmat4.sub = mat4.subtract;\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nmat4.multiplyScalar = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n};\n\n/**\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\n *\n * @param {mat4} out the receiving vector\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @param {Number} scale the amount to scale b's elements by before adding\n * @returns {mat4} out\n */\nmat4.multiplyScalarAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    out[4] = a[4] + (b[4] * scale);\n    out[5] = a[5] + (b[5] * scale);\n    out[6] = a[6] + (b[6] * scale);\n    out[7] = a[7] + (b[7] * scale);\n    out[8] = a[8] + (b[8] * scale);\n    out[9] = a[9] + (b[9] * scale);\n    out[10] = a[10] + (b[10] * scale);\n    out[11] = a[11] + (b[11] * scale);\n    out[12] = a[12] + (b[12] * scale);\n    out[13] = a[13] + (b[13] * scale);\n    out[14] = a[14] + (b[14] * scale);\n    out[15] = a[15] + (b[15] * scale);\n    return out;\n};\n\n/**\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat4.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && \n           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && \n           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&\n           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n};\n\n/**\n * Returns whether or not the matrices have approximately the same elements in the same position.\n *\n * @param {mat4} a The first matrix.\n * @param {mat4} b The second matrix.\n * @returns {Boolean} True if the matrices are equal, false otherwise.\n */\nmat4.equals = function (a, b) {\n    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],\n        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], \n        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], \n        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];\n\n    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],\n        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], \n        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], \n        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];\n\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&\n            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&\n            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&\n            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&\n            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&\n            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&\n            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&\n            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&\n            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&\n            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&\n            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&\n            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&\n            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&\n            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));\n};\n\n\n\nmodule.exports = mat4;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzPzg5OWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQSIsImZpbGUiOiIzNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG52YXIgbWF0NCA9IHtcbiAgc2NhbGFyOiB7fSxcbiAgU0lNRDoge30sXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQ0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA1KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA4KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjMgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMTEpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzIgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTQpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcbiAqL1xubWF0NC5mcm9tVmFsdWVzID0gZnVuY3Rpb24obTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcbiAgICBvdXRbMF0gPSBtMDA7XG4gICAgb3V0WzFdID0gbTAxO1xuICAgIG91dFsyXSA9IG0wMjtcbiAgICBvdXRbM10gPSBtMDM7XG4gICAgb3V0WzRdID0gbTEwO1xuICAgIG91dFs1XSA9IG0xMTtcbiAgICBvdXRbNl0gPSBtMTI7XG4gICAgb3V0WzddID0gbTEzO1xuICAgIG91dFs4XSA9IG0yMDtcbiAgICBvdXRbOV0gPSBtMjE7XG4gICAgb3V0WzEwXSA9IG0yMjtcbiAgICBvdXRbMTFdID0gbTIzO1xuICAgIG91dFsxMl0gPSBtMzA7XG4gICAgb3V0WzEzXSA9IG0zMTtcbiAgICBvdXRbMTRdID0gbTMyO1xuICAgIG91dFsxNV0gPSBtMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggNClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTMgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggNylcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMTApXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMzEgQ29tcG9uZW50IGluIGNvbHVtbiAzLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMTMpXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zZXQgPSBmdW5jdGlvbihvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICAgIG91dFswXSA9IG0wMDtcbiAgICBvdXRbMV0gPSBtMDE7XG4gICAgb3V0WzJdID0gbTAyO1xuICAgIG91dFszXSA9IG0wMztcbiAgICBvdXRbNF0gPSBtMTA7XG4gICAgb3V0WzVdID0gbTExO1xuICAgIG91dFs2XSA9IG0xMjtcbiAgICBvdXRbN10gPSBtMTM7XG4gICAgb3V0WzhdID0gbTIwO1xuICAgIG91dFs5XSA9IG0yMTtcbiAgICBvdXRbMTBdID0gbTIyO1xuICAgIG91dFsxMV0gPSBtMjM7XG4gICAgb3V0WzEyXSA9IG0zMDtcbiAgICBvdXRbMTNdID0gbTMxO1xuICAgIG91dFsxNF0gPSBtMzI7XG4gICAgb3V0WzE1XSA9IG0zMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NCBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDQgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCwgYTEsIGEyLCBhMyxcbiAgICAgICAgdG1wMDEsIHRtcDIzLFxuICAgICAgICBvdXQwLCBvdXQxLCBvdXQyLCBvdXQzO1xuXG4gICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCk7XG4gICAgYTMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDEyKTtcblxuICAgIHRtcDAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDAsIDEsIDQsIDUpO1xuICAgIHRtcDIzID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDAsIDEsIDQsIDUpO1xuICAgIG91dDAgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDAsIDIsIDQsIDYpO1xuICAgIG91dDEgID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAwMSwgdG1wMjMsIDEsIDMsIDUsIDcpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgIG91dDApO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgIG91dDEpO1xuXG4gICAgdG1wMDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMiwgMywgNiwgNyk7XG4gICAgdG1wMjMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMiwgMywgNiwgNyk7XG4gICAgb3V0MiAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMCwgMiwgNCwgNik7XG4gICAgb3V0MyAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDAxLCB0bXAyMywgMSwgMywgNSwgNyk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCAgb3V0Mik7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgb3V0Myk7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3BzZSBhIG1hdDQgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNwb3NlID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQudHJhbnNwb3NlIDogbWF0NC5zY2FsYXIudHJhbnNwb3NlO1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDQgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICB2YXIgcm93MCwgcm93MSwgcm93Miwgcm93MyxcbiAgICAgIHRtcDEsXG4gICAgICBtaW5vcjAsIG1pbm9yMSwgbWlub3IyLCBtaW5vcjMsXG4gICAgICBkZXQsXG4gICAgICBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCksXG4gICAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCksXG4gICAgICBhMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgOCksXG4gICAgICBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gIC8vIENvbXB1dGUgbWF0cml4IGFkanVnYXRlXG4gIHRtcDEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEwLCBhMSwgMCwgMSwgNCwgNSk7XG4gIHJvdzEgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKGEyLCBhMywgMCwgMSwgNCwgNSk7XG4gIHJvdzAgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHRtcDEsIHJvdzEsIDAsIDIsIDQsIDYpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShyb3cxLCB0bXAxLCAxLCAzLCA1LCA3KTtcbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAyLCAzLCA2LCA3KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAyLCAzLCA2LCA3KTtcbiAgcm93MiA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MywgMCwgMiwgNCwgNik7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzMsIHRtcDEsIDEsIDMsIDUsIDcpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IxLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IzKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjMsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzEsIDIsIDMsIDAsIDEpLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgcm93MiAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cyLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMiwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMiwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMyk7XG5cbiAgLy8gQ29tcHV0ZSBtYXRyaXggZGV0ZXJtaW5hbnRcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgbWlub3IwKTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShkZXQsIDIsIDMsIDAsIDEpLCBkZXQpO1xuICBkZXQgICA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGRldCwgMSwgMCwgMywgMiksIGRldCk7XG4gIHRtcDEgID0gU0lNRC5GbG9hdDMyeDQucmVjaXByb2NhbEFwcHJveGltYXRpb24oZGV0KTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoXG4gICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQodG1wMSwgdG1wMSksXG4gICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBTSU1ELkZsb2F0MzJ4NC5tdWwodG1wMSwgdG1wMSkpKTtcbiAgZGV0ICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGRldCwgMCwgMCwgMCwgMCk7XG4gIGlmICghZGV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgbWF0cml4IGludmVyc2VcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCAgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IwKSk7XG4gIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgNCwgIFNJTUQuRmxvYXQzMng0Lm11bChkZXQsIG1pbm9yMSkpO1xuICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDgsICBTSU1ELkZsb2F0MzJ4NC5tdWwoZGV0LCBtaW5vcjIpKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgU0lNRC5GbG9hdDMyeDQubXVsKGRldCwgbWlub3IzKSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDQgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaW52ZXJ0ID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQuaW52ZXJ0IDogbWF0NC5zY2FsYXIuaW52ZXJ0O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0NCBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDQgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgdmFyIGEwLCBhMSwgYTIsIGEzO1xuICB2YXIgcm93MCwgcm93MSwgcm93Miwgcm93MztcbiAgdmFyIHRtcDE7XG4gIHZhciBtaW5vcjAsIG1pbm9yMSwgbWlub3IyLCBtaW5vcjM7XG5cbiAgdmFyIGEwID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgdmFyIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgdmFyIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgdmFyIGEzID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAxMik7XG5cbiAgLy8gVHJhbnNwb3NlIHRoZSBzb3VyY2UgbWF0cml4LiAgU29ydCBvZi4gIE5vdCBhIHRydWUgdHJhbnNwb3NlIG9wZXJhdGlvblxuICB0bXAxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMCwgYTEsIDAsIDEsIDQsIDUpO1xuICByb3cxID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZShhMiwgYTMsIDAsIDEsIDQsIDUpO1xuICByb3cwID0gU0lNRC5GbG9hdDMyeDQuc2h1ZmZsZSh0bXAxLCByb3cxLCAwLCAyLCA0LCA2KTtcbiAgcm93MSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUocm93MSwgdG1wMSwgMSwgMywgNSwgNyk7XG5cbiAgdG1wMSA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTAsIGExLCAyLCAzLCA2LCA3KTtcbiAgcm93MyA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUoYTIsIGEzLCAyLCAzLCA2LCA3KTtcbiAgcm93MiA9IFNJTUQuRmxvYXQzMng0LnNodWZmbGUodG1wMSwgcm93MywgMCwgMiwgNCwgNik7XG4gIHJvdzMgPSBTSU1ELkZsb2F0MzJ4NC5zaHVmZmxlKHJvdzMsIHRtcDEsIDEsIDMsIDUsIDcpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpO1xuICBtaW5vcjEgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUobWlub3IxLCAyLCAzLCAwLCAxKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMCA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMCk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMCwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCB0bXAxKSwgbWlub3IzKTtcbiAgbWlub3IzID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShtaW5vcjMsIDIsIDMsIDAsIDEpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHJvdzEsIDIsIDMsIDAsIDEpLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgcm93MiAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZShyb3cyLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IwID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IwKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjAgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IwLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKG1pbm9yMiwgMiwgMywgMCwgMSk7XG5cbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQubXVsKHJvdzAsIHJvdzEpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDEsIDAsIDMsIDIpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpLCBtaW5vcjMpO1xuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHRtcDEsIDIsIDMsIDAsIDEpO1xuICBtaW5vcjIgPSBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKHJvdzMsIHRtcDEpLCBtaW5vcjIpO1xuICBtaW5vcjMgPSBTSU1ELkZsb2F0MzJ4NC5zdWIobWlub3IzLCBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MiwgdG1wMSkpO1xuXG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0Lm11bChyb3cwLCByb3czKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAxLCAwLCAzLCAyKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMSwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzIsIHRtcDEpKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSwgbWlub3IyKTtcbiAgdG1wMSAgID0gU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh0bXAxLCAyLCAzLCAwLCAxKTtcbiAgbWlub3IxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChyb3cyLCB0bXAxKSwgbWlub3IxKTtcbiAgbWlub3IyID0gU0lNRC5GbG9hdDMyeDQuc3ViKG1pbm9yMiwgU0lNRC5GbG9hdDMyeDQubXVsKHJvdzEsIHRtcDEpKTtcblxuICB0bXAxICAgPSBTSU1ELkZsb2F0MzJ4NC5tdWwocm93MCwgcm93Mik7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMSwgMCwgMywgMik7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MywgdG1wMSksIG1pbm9yMSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjMsIFNJTUQuRmxvYXQzMng0Lm11bChyb3cxLCB0bXAxKSk7XG4gIHRtcDEgICA9IFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodG1wMSwgMiwgMywgMCwgMSk7XG4gIG1pbm9yMSA9IFNJTUQuRmxvYXQzMng0LnN1YihtaW5vcjEsIFNJTUQuRmxvYXQzMng0Lm11bChyb3czLCB0bXAxKSk7XG4gIG1pbm9yMyA9IFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwocm93MSwgdG1wMSksIG1pbm9yMyk7XG5cbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLCAgbWlub3IwKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCAgbWlub3IxKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA4LCAgbWlub3IyKTtcbiAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgbWlub3IzKTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0IHVzaW5nIFNJTUQgaWYgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG4gbWF0NC5hZGpvaW50ID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQuYWRqb2ludCA6IG1hdDQuc2NhbGFyLmFkam9pbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzIGV4cGxpY2l0bHkgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmQsIG11c3QgYmUgYSBGbG9hdDMyQXJyYXlcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmQsIG11c3QgYmUgYSBGbG9hdDMyQXJyYXlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgdmFyIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICB2YXIgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpO1xuICAgIHZhciBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpO1xuXG4gICAgdmFyIGIwID0gU0lNRC5GbG9hdDMyeDQubG9hZChiLCAwKTtcbiAgICB2YXIgb3V0MCA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAxLCAxLCAxLCAxKSwgYTEpLFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMCwgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIwLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgMCwgb3V0MCk7XG5cbiAgICB2YXIgYjEgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDQpO1xuICAgIHZhciBvdXQxID0gU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAwLCAwLCAwLCAwKSwgYTApLFxuICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDEsIDEsIDEsIDEpLCBhMSksXG4gICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIxLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjEsIDMsIDMsIDMsIDMpLCBhMykpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCA0LCBvdXQxKTtcblxuICAgIHZhciBiMiA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYiwgOCk7XG4gICAgdmFyIG91dDIgPSBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQubXVsKFNJTUQuRmxvYXQzMng0LnN3aXp6bGUoYjIsIDAsIDAsIDAsIDApLCBhMCksXG4gICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMiwgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAyLCAyLCAyLCAyKSwgYTIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0Lm11bChTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKGIyLCAzLCAzLCAzLCAzKSwgYTMpKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCwgb3V0Mik7XG5cbiAgICB2YXIgYjMgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGIsIDEyKTtcbiAgICB2YXIgb3V0MyA9IFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMCwgMCwgMCwgMCksIGEwKSxcbiAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoXG4gICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMSwgMSwgMSwgMSksIGExKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMiwgMiwgMiwgMiksIGEyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5tdWwoU0lNRC5GbG9hdDMyeDQuc3dpenpsZShiMywgMywgMywgMywgMyksIGEzKSkpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDEyLCBvdXQzKTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQncyBleHBsaWNpdGx5IG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdO1xuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3MgdXNpbmcgU0lNRCBpZiBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHkgPSBnbE1hdHJpeC5VU0VfU0lNRCA/IG1hdDQuU0lNRC5tdWx0aXBseSA6IG1hdDQuc2NhbGFyLm11bHRpcGx5O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQ0Lm11bCA9IG1hdDQubXVsdGlwbHk7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCksXG4gICAgICAgIGExID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KSxcbiAgICAgICAgYTIgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDgpLFxuICAgICAgICBhMyA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMTIpLFxuICAgICAgICB2ZWMgPSBTSU1ELkZsb2F0MzJ4NCh2WzBdLCB2WzFdLCB2WzJdICwgMCk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07IG91dFsxXSA9IGFbMV07IG91dFsyXSA9IGFbMl07IG91dFszXSA9IGFbM107XG4gICAgICAgIG91dFs0XSA9IGFbNF07IG91dFs1XSA9IGFbNV07IG91dFs2XSA9IGFbNl07IG91dFs3XSA9IGFbN107XG4gICAgICAgIG91dFs4XSA9IGFbOF07IG91dFs5XSA9IGFbOV07IG91dFsxMF0gPSBhWzEwXTsgb3V0WzExXSA9IGFbMTFdO1xuICAgIH1cblxuICAgIGEwID0gU0lNRC5GbG9hdDMyeDQubXVsKGEwLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMCwgMCwgMCwgMCkpO1xuICAgIGExID0gU0lNRC5GbG9hdDMyeDQubXVsKGExLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMSwgMSwgMSwgMSkpO1xuICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubXVsKGEyLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMiwgMiwgMiwgMikpO1xuXG4gICAgdmFyIHQwID0gU0lNRC5GbG9hdDMyeDQuYWRkKGEwLCBTSU1ELkZsb2F0MzJ4NC5hZGQoYTEsIFNJTUQuRmxvYXQzMng0LmFkZChhMiwgYTMpKSk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAxMiwgdDApO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvciB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQudHJhbnNsYXRlIDogbWF0NC5zY2FsYXIudHJhbnNsYXRlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyBub3QgdXNpbmcgdmVjdG9yaXphdGlvblxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbm1hdDQuc2NhbGFyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyB1c2luZyB2ZWN0b3JpemF0aW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5TSU1ELnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwLCBhMSwgYTI7XG4gICAgdmFyIHZlYyA9IFNJTUQuRmxvYXQzMng0KHZbMF0sIHZbMV0sIHZbMl0sIDApO1xuXG4gICAgYTAgPSBTSU1ELkZsb2F0MzJ4NC5sb2FkKGEsIDApO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKFxuICAgICAgICBvdXQsIDAsIFNJTUQuRmxvYXQzMng0Lm11bChhMCwgU0lNRC5GbG9hdDMyeDQuc3dpenpsZSh2ZWMsIDAsIDAsIDAsIDApKSk7XG5cbiAgICBhMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUoXG4gICAgICAgIG91dCwgNCwgU0lNRC5GbG9hdDMyeDQubXVsKGExLCBTSU1ELkZsb2F0MzJ4NC5zd2l6emxlKHZlYywgMSwgMSwgMSwgMSkpKTtcblxuICAgIGEyID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShcbiAgICAgICAgb3V0LCA4LCBTSU1ELkZsb2F0MzJ4NC5tdWwoYTIsIFNJTUQuRmxvYXQzMng0LnN3aXp6bGUodmVjLCAyLCAyLCAyLCAyKSkpO1xuXG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMyB1c2luZyBTSU1EIGlmIGF2YWlsYWJsZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsZSA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnNjYWxlIDogbWF0NC5zY2FsYXIuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyBub3QgdXNpbmcgU0lNRFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuc2NhbGFyLnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpcyB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguc2luKHJhZCkpLFxuICAgICAgICBjID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5jb3MocmFkKSk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB2YXIgYV8xID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA0KTtcbiAgICB2YXIgYV8yID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuYWRkKFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5zdWIoU0lNRC5GbG9hdDMyeDQubXVsKGFfMiwgYyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIHMpKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMgdXNpbmcgU0lNRCBpZiBhdmFpbGFiZSBhbmQgZW5hYmxlZFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWCA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnJvdGF0ZVggOiBtYXQ0LnNjYWxhci5yb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIG5vdCB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5zY2FsYXIucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzIHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LlNJTUQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5zaW4ocmFkKSksXG4gICAgICAgIGMgPSBTSU1ELkZsb2F0MzJ4NC5zcGxhdChNYXRoLmNvcyhyYWQpKTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICB2YXIgYV8wID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCAwKTtcbiAgICB2YXIgYV8yID0gU0lNRC5GbG9hdDMyeDQubG9hZChhLCA4KTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChhXzAsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8yLCBzKSkpO1xuICAgIFNJTUQuRmxvYXQzMng0LnN0b3JlKG91dCwgOCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBTSU1ELkZsb2F0MzJ4NC5hZGQoU0lNRC5GbG9hdDMyeDQubXVsKGFfMCwgcyksIFNJTUQuRmxvYXQzMng0Lm11bChhXzIsIGMpKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXMgaWYgU0lNRCBhdmFpbGFibGUgYW5kIGVuYWJsZWRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG4gbWF0NC5yb3RhdGVZID0gZ2xNYXRyaXguVVNFX1NJTUQgPyBtYXQ0LlNJTUQucm90YXRlWSA6IG1hdDQuc2NhbGFyLnJvdGF0ZVk7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXMgbm90IHVzaW5nIFNJTURcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnNjYWxhci5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpcyB1c2luZyBTSU1EXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5TSU1ELnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IFNJTUQuRmxvYXQzMng0LnNwbGF0KE1hdGguc2luKHJhZCkpLFxuICAgICAgICBjID0gU0lNRC5GbG9hdDMyeDQuc3BsYXQoTWF0aC5jb3MocmFkKSk7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFs4XSAgPSBhWzhdO1xuICAgICAgICBvdXRbOV0gID0gYVs5XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgdmFyIGFfMCA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgMCk7XG4gICAgdmFyIGFfMSA9IFNJTUQuRmxvYXQzMng0LmxvYWQoYSwgNCk7XG4gICAgU0lNRC5GbG9hdDMyeDQuc3RvcmUob3V0LCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgIFNJTUQuRmxvYXQzMng0LmFkZChTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBjKSwgU0lNRC5GbG9hdDMyeDQubXVsKGFfMSwgcykpKTtcbiAgICBTSU1ELkZsb2F0MzJ4NC5zdG9yZShvdXQsIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgU0lNRC5GbG9hdDMyeDQuc3ViKFNJTUQuRmxvYXQzMng0Lm11bChhXzEsIGMpLCBTSU1ELkZsb2F0MzJ4NC5tdWwoYV8wLCBzKSkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzIGlmIFNJTUQgYXZhaWxhYmxlIGFuZCBlbmFibGVkXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuIG1hdDQucm90YXRlWiA9IGdsTWF0cml4LlVTRV9TSU1EID8gbWF0NC5TSU1ELnJvdGF0ZVogOiBtYXQ0LnNjYWxhci5yb3RhdGVaO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gdlsxXTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSB2WzJdO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdDtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgZ2xNYXRyaXguRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgICBvdXRbMV0gPSB5ICogeCAqIHQgKyB6ICogcztcbiAgICBvdXRbMl0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHggKiB5ICogdCAtIHogKiBzO1xuICAgIG91dFs1XSA9IHkgKiB5ICogdCArIGM7XG4gICAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4ICogeiAqIHQgKyB5ICogcztcbiAgICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgICBvdXRbMTBdID0geiAqIHogKiB0ICsgYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVhSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gMTtcbiAgICBvdXRbMV0gID0gMDtcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gcztcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gLXM7XG4gICAgb3V0WzEwXSA9IGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21ZUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IC1zO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gcztcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWlJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSBjO1xuICAgIG91dFsxXSAgPSBzO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IC1zO1xuICAgIG91dFs1XSA9IGM7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24gYW5kIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24gPSBmdW5jdGlvbiAob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yIGNvbXBvbmVudCBvZiBhIHRyYW5zZm9ybWF0aW9uXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXG4gKiAgb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHt2ZWMzfSBvdXRcbiAqL1xubWF0NC5nZXRUcmFuc2xhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIG1hdCkge1xuICBvdXRbMF0gPSBtYXRbMTJdO1xuICBvdXRbMV0gPSBtYXRbMTNdO1xuICBvdXRbMl0gPSBtYXRbMTRdO1xuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcm90YXRpb25hbCBjb21wb25lbnRcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxuICogIHNhbWUgYXMgdGhlIHF1YXRlcm5pb24gb3JpZ2luYWxseSBzdXBwbGllZC5cbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcbiAqL1xubWF0NC5nZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIChvdXQsIG1hdCkge1xuICAvLyBBbGdvcml0aG0gdGFrZW4gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuICB2YXIgdHJhY2UgPSBtYXRbMF0gKyBtYXRbNV0gKyBtYXRbMTBdO1xuICB2YXIgUyA9IDA7XG5cbiAgaWYgKHRyYWNlID4gMCkgeyBcbiAgICBTID0gTWF0aC5zcXJ0KHRyYWNlICsgMS4wKSAqIDI7XG4gICAgb3V0WzNdID0gMC4yNSAqIFM7XG4gICAgb3V0WzBdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFsxXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUzsgXG4gICAgb3V0WzJdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTOyBcbiAgfSBlbHNlIGlmICgobWF0WzBdID4gbWF0WzVdKSYobWF0WzBdID4gbWF0WzEwXSkpIHsgXG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMF0gLSBtYXRbNV0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUzsgXG4gICAgb3V0WzJdID0gKG1hdFs4XSArIG1hdFsyXSkgLyBTOyBcbiAgfSBlbHNlIGlmIChtYXRbNV0gPiBtYXRbMTBdKSB7IFxuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzVdIC0gbWF0WzBdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7IFxuICAgIG91dFsxXSA9IDAuMjUgKiBTO1xuICAgIG91dFsyXSA9IChtYXRbNl0gKyBtYXRbOV0pIC8gUzsgXG4gIH0gZWxzZSB7IFxuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzEwXSAtIG1hdFswXSAtIG1hdFs1XSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlID0gZnVuY3Rpb24gKG91dCwgcSwgdiwgcykge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyLFxuICAgICAgICBzeCA9IHNbMF0sXG4gICAgICAgIHN5ID0gc1sxXSxcbiAgICAgICAgc3ogPSBzWzJdO1xuXG4gICAgb3V0WzBdID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gICAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gICAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgICBvdXRbNl0gPSAoeXogKyB3eCkgKiBzeTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICAgIG91dFs5XSA9ICh5eiAtIHd4KSAqIHN6O1xuICAgIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG5lZ2F0aXZlT3JpZ2luKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBvIFRoZSBvcmlnaW4gdmVjdG9yIGFyb3VuZCB3aGljaCB0byBzY2FsZSBhbmQgcm90YXRlXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgIHgyID0geCArIHgsXG4gICAgICB5MiA9IHkgKyB5LFxuICAgICAgejIgPSB6ICsgeixcblxuICAgICAgeHggPSB4ICogeDIsXG4gICAgICB4eSA9IHggKiB5MixcbiAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgeXkgPSB5ICogeTIsXG4gICAgICB5eiA9IHkgKiB6MixcbiAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgd3ggPSB3ICogeDIsXG4gICAgICB3eSA9IHcgKiB5MixcbiAgICAgIHd6ID0gdyAqIHoyLFxuXG4gICAgICBzeCA9IHNbMF0sXG4gICAgICBzeSA9IHNbMV0sXG4gICAgICBzeiA9IHNbMl0sXG5cbiAgICAgIG94ID0gb1swXSxcbiAgICAgIG95ID0gb1sxXSxcbiAgICAgIG96ID0gb1syXTtcblxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0WzBdICogb3ggKyBvdXRbNF0gKiBveSArIG91dFs4XSAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXRbMV0gKiBveCArIG91dFs1XSAqIG95ICsgb3V0WzldICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dFsyXSAqIG94ICsgb3V0WzZdICogb3kgKyBvdXRbMTBdICogb3opO1xuICBvdXRbMTVdID0gMTtcblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBxIFF1YXRlcm5pb24gdG8gY3JlYXRlIG1hdHJpeCBmcm9tXG4gKlxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZydXN0dW0gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gICAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtPYmplY3R9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyA9IGZ1bmN0aW9uIChvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pLFxuICAgICAgICB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcblxuICAgIG91dFswXSA9IHhTY2FsZTtcbiAgICBvdXRbMV0gPSAwLjA7XG4gICAgb3V0WzJdID0gMC4wO1xuICAgIG91dFszXSA9IDAuMDtcbiAgICBvdXRbNF0gPSAwLjA7XG4gICAgb3V0WzVdID0geVNjYWxlO1xuICAgIG91dFs2XSA9IDAuMDtcbiAgICBvdXRbN10gPSAwLjA7XG4gICAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMV0gPSAtMS4wO1xuICAgIG91dFsxMl0gPSAwLjA7XG4gICAgb3V0WzEzXSA9IDAuMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxNV0gPSAwLjA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm9ydGhvID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubG9va0F0ID0gZnVuY3Rpb24gKG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQ0LmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikgKSlcbn07XG5cbi8qKlxuICogQWRkcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICAgIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICAgIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICAgIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICAgIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICAgIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICAgIG91dFs5XSA9IGFbOV0gKyBiWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gICAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gICAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gICAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gICAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gICAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gICAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdIC0gYlsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdIC0gYlsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0LnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQuc3ViID0gbWF0NC5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5tdWx0aXBseVNjYWxhciA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIG91dFszXSA9IGFbM10gKiBiO1xuICAgIG91dFs0XSA9IGFbNF0gKiBiO1xuICAgIG91dFs1XSA9IGFbNV0gKiBiO1xuICAgIG91dFs2XSA9IGFbNl0gKiBiO1xuICAgIG91dFs3XSA9IGFbN10gKiBiO1xuICAgIG91dFs4XSA9IGFbOF0gKiBiO1xuICAgIG91dFs5XSA9IGFbOV0gKiBiO1xuICAgIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gICAgb3V0WzExXSA9IGFbMTFdICogYjtcbiAgICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICAgIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gICAgb3V0WzE0XSA9IGFbMTRdICogYjtcbiAgICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsdGlwbHlTY2FsYXJBbmRBZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIsIHNjYWxlKSB7XG4gICAgb3V0WzBdID0gYVswXSArIChiWzBdICogc2NhbGUpO1xuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKTtcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSk7XG4gICAgb3V0WzNdID0gYVszXSArIChiWzNdICogc2NhbGUpO1xuICAgIG91dFs0XSA9IGFbNF0gKyAoYls0XSAqIHNjYWxlKTtcbiAgICBvdXRbNV0gPSBhWzVdICsgKGJbNV0gKiBzY2FsZSk7XG4gICAgb3V0WzZdID0gYVs2XSArIChiWzZdICogc2NhbGUpO1xuICAgIG91dFs3XSA9IGFbN10gKyAoYls3XSAqIHNjYWxlKTtcbiAgICBvdXRbOF0gPSBhWzhdICsgKGJbOF0gKiBzY2FsZSk7XG4gICAgb3V0WzldID0gYVs5XSArIChiWzldICogc2NhbGUpO1xuICAgIG91dFsxMF0gPSBhWzEwXSArIChiWzEwXSAqIHNjYWxlKTtcbiAgICBvdXRbMTFdID0gYVsxMV0gKyAoYlsxMV0gKiBzY2FsZSk7XG4gICAgb3V0WzEyXSA9IGFbMTJdICsgKGJbMTJdICogc2NhbGUpO1xuICAgIG91dFsxM10gPSBhWzEzXSArIChiWzEzXSAqIHNjYWxlKTtcbiAgICBvdXRbMTRdID0gYVsxNF0gKyAoYlsxNF0gKiBzY2FsZSk7XG4gICAgb3V0WzE1XSA9IGFbMTVdICsgKGJbMTVdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cbiAqIEBwYXJhbSB7bWF0NH0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xubWF0NC5leGFjdEVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM10gJiYgXG4gICAgICAgICAgIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgXG4gICAgICAgICAgIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmXG4gICAgICAgICAgIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5tYXQ0LmVxdWFscyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGEwICA9IGFbMF0sICBhMSAgPSBhWzFdLCAgYTIgID0gYVsyXSwgIGEzICA9IGFbM10sXG4gICAgICAgIGE0ICA9IGFbNF0sICBhNSAgPSBhWzVdLCAgYTYgID0gYVs2XSwgIGE3ICA9IGFbN10sIFxuICAgICAgICBhOCAgPSBhWzhdLCAgYTkgID0gYVs5XSwgIGExMCA9IGFbMTBdLCBhMTEgPSBhWzExXSwgXG4gICAgICAgIGExMiA9IGFbMTJdLCBhMTMgPSBhWzEzXSwgYTE0ID0gYVsxNF0sIGExNSA9IGFbMTVdO1xuXG4gICAgdmFyIGIwICA9IGJbMF0sICBiMSAgPSBiWzFdLCAgYjIgID0gYlsyXSwgIGIzICA9IGJbM10sXG4gICAgICAgIGI0ICA9IGJbNF0sICBiNSAgPSBiWzVdLCAgYjYgID0gYls2XSwgIGI3ICA9IGJbN10sIFxuICAgICAgICBiOCAgPSBiWzhdLCAgYjkgID0gYls5XSwgIGIxMCA9IGJbMTBdLCBiMTEgPSBiWzExXSwgXG4gICAgICAgIGIxMiA9IGJbMTJdLCBiMTMgPSBiWzEzXSwgYjE0ID0gYlsxNF0sIGIxNSA9IGJbMTVdO1xuXG4gICAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhOSAtIGI5KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTApLCBNYXRoLmFicyhiMTApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExMiAtIGIxMikgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmXG4gICAgICAgICAgICBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04qTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTMpLCBNYXRoLmFicyhiMTMpKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OKk1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiZcbiAgICAgICAgICAgIE1hdGguYWJzKGExNSAtIGIxNSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpKTtcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdDQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDQuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\nvar mat3 = __webpack_require__(20);\nvar vec3 = __webpack_require__(21);\nvar vec4 = __webpack_require__(22);\n\n/**\n * @class Quaternion\n * @name quat\n */\nvar quat = {};\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nquat.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nquat.rotationTo = (function() {\n    var tmpvec3 = vec3.create();\n    var xUnitVec3 = vec3.fromValues(1,0,0);\n    var yUnitVec3 = vec3.fromValues(0,1,0);\n\n    return function(out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n            return out;\n        } else if (dot > 0.999999) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            return out;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out[0] = tmpvec3[0];\n            out[1] = tmpvec3[1];\n            out[2] = tmpvec3[2];\n            out[3] = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };\n})();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local \"right\" direction\n * @param {vec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nquat.setAxes = (function() {\n    var matr = mat3.create();\n\n    return function(out, view, right, up) {\n        matr[0] = right[0];\n        matr[3] = right[1];\n        matr[6] = right[2];\n\n        matr[1] = up[0];\n        matr[4] = up[1];\n        matr[7] = up[2];\n\n        matr[2] = -view[0];\n        matr[5] = -view[1];\n        matr[8] = -view[2];\n\n        return quat.normalize(out, quat.fromMat3(out, matr));\n    };\n})();\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nquat.clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nquat.fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nquat.copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nquat.set = vec4.set;\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nquat.identity = function(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nquat.setAxisAngle = function(out, axis, rad) {\n    rad = rad * 0.5;\n    var s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n};\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {quat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nquat.getAxisAngle = function(out_axis, q) {\n    var rad = Math.acos(q[3]) * 2.0;\n    var s = Math.sin(rad / 2.0);\n    if (s != 0.0) {\n        out_axis[0] = q[0] / s;\n        out_axis[1] = q[1] / s;\n        out_axis[2] = q[2] / s;\n    } else {\n        // If s is zero, return any axis (no rotation - axis does not matter)\n        out_axis[0] = 1;\n        out_axis[1] = 0;\n        out_axis[2] = 0;\n    }\n    return rad;\n};\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nquat.add = vec4.add;\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nquat.multiply = function(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n};\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nquat.mul = quat.multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nquat.scale = vec4.scale;\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateX = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateY = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        by = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateZ = function (out, a, rad) {\n    rad *= 0.5; \n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bz = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n};\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nquat.calculateW = function (out, a) {\n    var x = a[0], y = a[1], z = a[2];\n\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n    return out;\n};\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nquat.dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nquat.lerp = vec4.lerp;\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nquat.slerp = function (out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    var        omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if ( cosom < 0.0 ) {\n        cosom = -cosom;\n        bx = - bx;\n        by = - by;\n        bz = - bz;\n        bw = - bw;\n    }\n    // calculate coefficients\n    if ( (1.0 - cosom) > 0.000001 ) {\n        // standard case (slerp)\n        omega  = Math.acos(cosom);\n        sinom  = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {        \n        // \"from\" and \"to\" quaternions are very close \n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n    \n    return out;\n};\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {quat} c the third operand\n * @param {quat} d the fourth operand\n * @param {Number} t interpolation amount\n * @returns {quat} out\n */\nquat.sqlerp = (function () {\n  var temp1 = quat.create();\n  var temp2 = quat.create();\n  \n  return function (out, a, b, c, d, t) {\n    quat.slerp(temp1, a, d, t);\n    quat.slerp(temp2, b, c, t);\n    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));\n    \n    return out;\n  };\n}());\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nquat.invert = function(out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,\n        invDot = dot ? 1.0/dot : 0;\n    \n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0*invDot;\n    out[1] = -a1*invDot;\n    out[2] = -a2*invDot;\n    out[3] = a3*invDot;\n    return out;\n};\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nquat.conjugate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n * @function\n */\nquat.length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nquat.len = quat.length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nquat.squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nquat.sqrLen = quat.squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nquat.normalize = vec4.normalize;\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nquat.fromMat3 = function(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    var fTrace = m[0] + m[4] + m[8];\n    var fRoot;\n\n    if ( fTrace > 0.0 ) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0);  // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5/fRoot;  // 1/(4w)\n        out[0] = (m[5]-m[7])*fRoot;\n        out[1] = (m[6]-m[2])*fRoot;\n        out[2] = (m[1]-m[3])*fRoot;\n    } else {\n        // |w| <= 1/2\n        var i = 0;\n        if ( m[4] > m[0] )\n          i = 1;\n        if ( m[8] > m[i*3+i] )\n          i = 2;\n        var j = (i+1)%3;\n        var k = (i+2)%3;\n        \n        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;\n        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;\n        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;\n    }\n    \n    return out;\n};\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nquat.str = function (a) {\n    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {quat} a The first quaternion.\n * @param {quat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nquat.exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions have approximately the same elements in the same position.\n *\n * @param {quat} a The first vector.\n * @param {quat} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nquat.equals = vec4.equals;\n\nmodule.exports = quat;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9xdWF0LmpzP2QxMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQSxlOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0EsZTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLGU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxPO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcbnZhciBtYXQzID0gcmVxdWlyZShcIi4vbWF0My5qc1wiKTtcbnZhciB2ZWMzID0gcmVxdWlyZShcIi4vdmVjMy5qc1wiKTtcbnZhciB2ZWM0ID0gcmVxdWlyZShcIi4vdmVjNC5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgcm90YXRpb24gYXhpcyBhbmQgYW5nbGUgZm9yIGEgZ2l2ZW5cbiAqICBxdWF0ZXJuaW9uLiBJZiBhIHF1YXRlcm5pb24gaXMgY3JlYXRlZCB3aXRoXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxuICogIHZhbHVlcyBhcyBwcm92aWRpZWQgaW4gdGhlIG9yaWdpbmFsIHBhcmFtZXRlciBsaXN0XG4gKiAgT1IgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdmFsdWVzLlxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxuICogIGFuZ2xlIC05MCBpcyB0aGUgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBmb3JtZWQgYnlcbiAqICBbMCwgMCwgMV0gYW5kIDI3MC4gVGhpcyBtZXRob2QgZmF2b3JzIHRoZSBsYXR0ZXIuXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxuICogQHBhcmFtICB7cXVhdH0gcSAgICAgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXG4gKi9cbnF1YXQuZ2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0X2F4aXMsIHEpIHtcbiAgICB2YXIgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcbiAgICBpZiAocyAhPSAwLjApIHtcbiAgICAgICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMV0gPSBxWzFdIC8gcztcbiAgICAgICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICAgICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgICAgICBvdXRfYXhpc1sxXSA9IDA7XG4gICAgICAgIG91dF9heGlzWzJdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHJhZDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gcXVhdC5jcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gcXVhdC5jcmVhdGUoKTtcbiAgXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgcXVhdC5zbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgcXVhdC5zbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgcXVhdC5zbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bMV0tbVszXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCBxdWF0ZXJuaW9uLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnF1YXQuZXhhY3RFcXVhbHMgPSB2ZWM0LmV4YWN0RXF1YWxzO1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7cXVhdH0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5xdWF0LmVxdWFscyA9IHZlYzQuZXF1YWxzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YXQ7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE. */\n\nvar glMatrix = __webpack_require__(4);\n\n/**\n * @class 2 Dimensional Vector\n * @name vec2\n */\nvar vec2 = {};\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nvec2.create = function() {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nvec2.clone = function(a) {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nvec2.fromValues = function(x, y) {\n    var out = new glMatrix.ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nvec2.copy = function(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nvec2.set = function(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.add = function(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.subtract = function(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.multiply = function(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.divide = function(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nvec2.div = vec2.divide;\n\n/**\n * Math.ceil the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to ceil\n * @returns {vec2} out\n */\nvec2.ceil = function (out, a) {\n    out[0] = Math.ceil(a[0]);\n    out[1] = Math.ceil(a[1]);\n    return out;\n};\n\n/**\n * Math.floor the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to floor\n * @returns {vec2} out\n */\nvec2.floor = function (out, a) {\n    out[0] = Math.floor(a[0]);\n    out[1] = Math.floor(a[1]);\n    return out;\n};\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.min = function(out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.max = function(out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    return out;\n};\n\n/**\n * Math.round the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to round\n * @returns {vec2} out\n */\nvec2.round = function (out, a) {\n    out[0] = Math.round(a[0]);\n    out[1] = Math.round(a[1]);\n    return out;\n};\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nvec2.scale = function(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nvec2.scaleAndAdd = function(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nvec2.distance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec2.squaredDistance = function(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x*x + y*y);\n};\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x*x + y*y;\n};\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nvec2.negate = function(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nvec2.inverse = function(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  return out;\n};\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nvec2.normalize = function(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x*x + y*y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nvec2.cross = function(out, a, b) {\n    var z = a[0] * b[1] - a[1] * b[0];\n    out[0] = out[1] = 0;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nvec2.random = function (out, scale) {\n    scale = scale || 1.0;\n    var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n    out[0] = Math.cos(r) * scale;\n    out[1] = Math.sin(r) * scale;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2d = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat3 = function(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat4 = function(out, a, m) {\n    var x = a[0], \n        y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec2.forEach = (function() {\n    var vec = vec2.create();\n\n    return function(a, stride, offset, count, fn, arg) {\n        var i, l;\n        if(!stride) {\n            stride = 2;\n        }\n\n        if(!offset) {\n            offset = 0;\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i]; vec[1] = a[i+1];\n            fn(vec, vec, arg);\n            a[i] = vec[0]; a[i+1] = vec[1];\n        }\n        \n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec2.exactEquals = function (a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n};\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nvec2.equals = function (a, b) {\n    var a0 = a[0], a1 = a[1];\n    var b0 = b[0], b1 = b[1];\n    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));\n};\n\nmodule.exports = vec2;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vfi9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMyLmpzPzZkZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNB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QUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLE9BQU87QUFDbEIsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTztBQUM5QiwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzJcbiAqL1xudmFyIHZlYzIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXG4gKlxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMiB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNldCA9IGZ1bmN0aW9uKG91dCwgeCwgeSkge1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zdWIgPSB2ZWMyLnN1YnRyYWN0O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLm11bCA9IHZlYzIubXVsdGlwbHk7XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXZpZGV9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZTtcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmNlaWwgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICAgIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIuZmxvb3IgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gTWF0aC5mbG9vcihhWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnJvdW5kID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXhhY3RFcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV07XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbnZlYzIuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV07XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdO1xuICAgIHJldHVybiAoTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgICAgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTipNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9+L2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzIuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 39 */
/***/ function(module, exports) {

	eval("module.exports = {\n\t\"name\": \"@mapd/mapd-draw\",\n\t\"description\": \"A Utility Library for drawing and interacting with shapes using canvas\",\n\t\"version\": \"1.1.0\",\n\t\"homepage\": \"http://mapd.com\",\n\t\"bugs\": \"https://github.com/map-d/mapd-draw.js/issues\",\n\t\"main\": \"dist/mapd-draw.js\",\n\t\"author\": \"MapD Technologies\",\n\t\"license\": \"MIT\",\n\t\"engines\": {\n\t\t\"node\": \">=4.0.0\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/map-d/mapd-draw.js.git\"\n\t},\n\t\"dependencies\": {\n\t\t\"gl-matrix\": \"^2.3.2\",\n\t\t\"css-element-queries\": \"^0.4.0\"\n\t},\n\t\"devDependencies\": {\n\t\t\"babel-core\": \"^6.10.4\",\n\t\t\"babel-loader\": \"^6.2.4\",\n\t\t\"babel-plugin-lodash\": \"^3.1.2\",\n\t\t\"babel-preset-es2015\": \"^6.9.0\",\n\t\t\"babel-preset-stage-0\": \"^6.5.0\",\n\t\t\"eslint\": \"^3.0.1\",\n\t\t\"http-server\": \"^0.9.0\",\n\t\t\"json-loader\": \"0.5.4\",\n\t\t\"webpack\": \"^1.13.1\"\n\t},\n\t\"scripts\": {\n\t\t\"build\": \"npm run build:prod; npm run build:dev\",\n\t\t\"build:prod\": \"npm run webpack\",\n\t\t\"build:dev\": \"npm run webpack:dev\",\n\t\t\"clean\": \"bash scripts/clean.sh\",\n\t\t\"eslint\": \"eslint -c ./.eslintrc.json\",\n\t\t\"lint\": \"eslint $(find src -name \\\"*.js\\\" ! -name '*.spec.js')\",\n\t\t\"start\": \"npm run build; http-server -p 8080 -o;\",\n\t\t\"watch:dev\": \"node node_modules/webpack/bin/webpack.js --progress --colors --watch --config webpack.dev.config.js\",\n\t\t\"webpack\": \"node node_modules/webpack/bin/webpack.js\",\n\t\t\"webpack:dev\": \"node node_modules/webpack/bin/webpack.js --config webpack.dev.config.js\",\n\t\t\"test\": \"node_modules/.bin/mocha ./test --require ./test/config --require ./test/setup\"\n\t},\n\t\"pre-commit\": [\n\t\t\"lint\"\n\t]\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vcGFja2FnZS5qc29uPzBmYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwibmFtZVwiOiBcIkBtYXBkL21hcGQtZHJhd1wiLFxuXHRcImRlc2NyaXB0aW9uXCI6IFwiQSBVdGlsaXR5IExpYnJhcnkgZm9yIGRyYXdpbmcgYW5kIGludGVyYWN0aW5nIHdpdGggc2hhcGVzIHVzaW5nIGNhbnZhc1wiLFxuXHRcInZlcnNpb25cIjogXCIxLjEuMFwiLFxuXHRcImhvbWVwYWdlXCI6IFwiaHR0cDovL21hcGQuY29tXCIsXG5cdFwiYnVnc1wiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9tYXAtZC9tYXBkLWRyYXcuanMvaXNzdWVzXCIsXG5cdFwibWFpblwiOiBcImRpc3QvbWFwZC1kcmF3LmpzXCIsXG5cdFwiYXV0aG9yXCI6IFwiTWFwRCBUZWNobm9sb2dpZXNcIixcblx0XCJsaWNlbnNlXCI6IFwiTUlUXCIsXG5cdFwiZW5naW5lc1wiOiB7XG5cdFx0XCJub2RlXCI6IFwiPj00LjAuMFwiXG5cdH0sXG5cdFwicmVwb3NpdG9yeVwiOiB7XG5cdFx0XCJ0eXBlXCI6IFwiZ2l0XCIsXG5cdFx0XCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL21hcC1kL21hcGQtZHJhdy5qcy5naXRcIlxuXHR9LFxuXHRcImRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJnbC1tYXRyaXhcIjogXCJeMi4zLjJcIixcblx0XHRcImNzcy1lbGVtZW50LXF1ZXJpZXNcIjogXCJeMC40LjBcIlxuXHR9LFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJiYWJlbC1jb3JlXCI6IFwiXjYuMTAuNFwiLFxuXHRcdFwiYmFiZWwtbG9hZGVyXCI6IFwiXjYuMi40XCIsXG5cdFx0XCJiYWJlbC1wbHVnaW4tbG9kYXNoXCI6IFwiXjMuMS4yXCIsXG5cdFx0XCJiYWJlbC1wcmVzZXQtZXMyMDE1XCI6IFwiXjYuOS4wXCIsXG5cdFx0XCJiYWJlbC1wcmVzZXQtc3RhZ2UtMFwiOiBcIl42LjUuMFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiXjMuMC4xXCIsXG5cdFx0XCJodHRwLXNlcnZlclwiOiBcIl4wLjkuMFwiLFxuXHRcdFwianNvbi1sb2FkZXJcIjogXCIwLjUuNFwiLFxuXHRcdFwid2VicGFja1wiOiBcIl4xLjEzLjFcIlxuXHR9LFxuXHRcInNjcmlwdHNcIjoge1xuXHRcdFwiYnVpbGRcIjogXCJucG0gcnVuIGJ1aWxkOnByb2Q7IG5wbSBydW4gYnVpbGQ6ZGV2XCIsXG5cdFx0XCJidWlsZDpwcm9kXCI6IFwibnBtIHJ1biB3ZWJwYWNrXCIsXG5cdFx0XCJidWlsZDpkZXZcIjogXCJucG0gcnVuIHdlYnBhY2s6ZGV2XCIsXG5cdFx0XCJjbGVhblwiOiBcImJhc2ggc2NyaXB0cy9jbGVhbi5zaFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiZXNsaW50IC1jIC4vLmVzbGludHJjLmpzb25cIixcblx0XHRcImxpbnRcIjogXCJlc2xpbnQgJChmaW5kIHNyYyAtbmFtZSBcXFwiKi5qc1xcXCIgISAtbmFtZSAnKi5zcGVjLmpzJylcIixcblx0XHRcInN0YXJ0XCI6IFwibnBtIHJ1biBidWlsZDsgaHR0cC1zZXJ2ZXIgLXAgODA4MCAtbztcIixcblx0XHRcIndhdGNoOmRldlwiOiBcIm5vZGUgbm9kZV9tb2R1bGVzL3dlYnBhY2svYmluL3dlYnBhY2suanMgLS1wcm9ncmVzcyAtLWNvbG9ycyAtLXdhdGNoIC0tY29uZmlnIHdlYnBhY2suZGV2LmNvbmZpZy5qc1wiLFxuXHRcdFwid2VicGFja1wiOiBcIm5vZGUgbm9kZV9tb2R1bGVzL3dlYnBhY2svYmluL3dlYnBhY2suanNcIixcblx0XHRcIndlYnBhY2s6ZGV2XCI6IFwibm9kZSBub2RlX21vZHVsZXMvd2VicGFjay9iaW4vd2VicGFjay5qcyAtLWNvbmZpZyB3ZWJwYWNrLmRldi5jb25maWcuanNcIixcblx0XHRcInRlc3RcIjogXCJub2RlX21vZHVsZXMvLmJpbi9tb2NoYSAuL3Rlc3QgLS1yZXF1aXJlIC4vdGVzdC9jb25maWcgLS1yZXF1aXJlIC4vdGVzdC9zZXR1cFwiXG5cdH0sXG5cdFwicHJlLWNvbW1pdFwiOiBbXG5cdFx0XCJsaW50XCJcblx0XVxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9wYWNrYWdlLmpzb25cbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ])
});
;